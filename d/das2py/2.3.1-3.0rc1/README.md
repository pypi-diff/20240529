# Comparing `tmp/das2py-2.3.1-cp310-cp310-win_amd64.whl.zip` & `tmp/das2py-3.0rc1-cp310-cp310-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,32 +1,32 @@
-Zip file size: 2346815 bytes, number of entries: 30
--rw-rw-rw-  2.0 fat  4867072 b- defN 23-Nov-21 02:57 _das2.cp310-win_amd64.pyd
--rw-rw-rw-  2.0 fat    12977 b- defN 23-Nov-14 20:34 das2/__init__.py
--rw-rw-rw-  2.0 fat     4906 b- defN 22-Sep-22 20:43 das2/auth.py
+Zip file size: 2383624 bytes, number of entries: 30
+-rw-rw-rw-  2.0 fat  4974592 b- defN 24-May-28 21:42 _das2.cp310-win_amd64.pyd
+-rw-rw-rw-  2.0 fat    13230 b- defN 24-May-28 21:40 das2/__init__.py
+-rw-rw-rw-  2.0 fat     4964 b- defN 24-May-28 21:38 das2/auth.py
 -rw-rw-rw-  2.0 fat    13983 b- defN 22-Sep-22 20:43 das2/cdf.py
 -rw-rw-rw-  2.0 fat    42668 b- defN 23-Nov-14 20:34 das2/cli.py
 -rw-rw-rw-  2.0 fat     6596 b- defN 22-Sep-22 20:43 das2/container.py
--rw-rw-rw-  2.0 fat    21313 b- defN 23-Nov-20 23:55 das2/dastime.py
--rw-rw-rw-  2.0 fat    56674 b- defN 23-Nov-14 20:34 das2/dataset.py
+-rw-rw-rw-  2.0 fat    21312 b- defN 24-May-28 21:38 das2/dastime.py
+-rw-rw-rw-  2.0 fat    57795 b- defN 24-May-28 21:38 das2/dataset.py
 -rw-rw-rw-  2.0 fat     7143 b- defN 22-Sep-22 20:43 das2/mpl.py
 -rw-rw-rw-  2.0 fat     5196 b- defN 22-Sep-22 20:43 das2/node.py
 -rw-rw-rw-  2.0 fat     8748 b- defN 22-Sep-22 20:43 das2/pkt.py
--rw-rw-rw-  2.0 fat    26095 b- defN 23-Nov-21 02:24 das2/reader.py
+-rw-rw-rw-  2.0 fat    26287 b- defN 24-May-28 21:38 das2/reader.py
 -rw-rw-rw-  2.0 fat    11488 b- defN 22-Sep-22 20:43 das2/source.py
--rw-rw-rw-  2.0 fat    36638 b- defN 22-Sep-22 20:43 das2/streamsrc.py
+-rw-rw-rw-  2.0 fat    36646 b- defN 24-May-28 21:38 das2/streamsrc.py
 -rw-rw-rw-  2.0 fat    27056 b- defN 22-Sep-22 20:43 das2/toml.py
 -rw-rw-rw-  2.0 fat     1763 b- defN 22-Sep-22 20:43 das2/util.py
--rw-rw-rw-  2.0 fat    10092 b- defN 23-Nov-21 02:03 das2/verify.py
+-rw-rw-rw-  2.0 fat    10135 b- defN 24-May-28 21:38 das2/verify.py
 -rw-rw-rw-  2.0 fat   200850 b- defN 23-Nov-14 20:34 das2/pycdf/__init__.py
 -rw-rw-rw-  2.0 fat    15270 b- defN 22-Sep-22 20:43 das2/pycdf/const.py
--rw-rw-rw-  2.0 fat    20992 b- defN 23-Nov-14 20:34 das2/xsd/das-basic-doc-ns-v3.0.xsd
--rw-rw-rw-  2.0 fat    21375 b- defN 23-Nov-14 20:34 das2/xsd/das-basic-stream-ns-v3.0.xsd
--rw-rw-rw-  2.0 fat     7456 b- defN 23-Nov-14 20:34 das2/xsd/das-basic-stream-v2.2.xsd
--rw-rw-rw-  2.0 fat    21359 b- defN 23-Nov-14 20:34 das2/xsd/das-basic-stream-v3.0.xsd
--rw-rw-rw-  2.0 fat       54 b- defN 23-Nov-21 02:57 das2py-2.3.1.data/scripts/das_verify
--rw-rw-rw-  2.0 fat     1068 b- defN 23-Nov-21 02:57 das2py-2.3.1.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     8796 b- defN 23-Nov-21 02:57 das2py-2.3.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat      102 b- defN 23-Nov-21 02:57 das2py-2.3.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       48 b- defN 23-Nov-21 02:57 das2py-2.3.1.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat       11 b- defN 23-Nov-21 02:57 das2py-2.3.1.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     2316 b- defN 23-Nov-21 02:57 das2py-2.3.1.dist-info/RECORD
-30 files, 5460105 bytes uncompressed, 2343217 bytes compressed:  57.1%
+-rw-rw-rw-  2.0 fat    22743 b- defN 24-May-28 21:38 das2/xsd/das-basic-doc-ns-v3.0.xsd
+-rw-rw-rw-  2.0 fat    23783 b- defN 24-May-28 21:38 das2/xsd/das-basic-stream-ns-v3.0.xsd
+-rw-rw-rw-  2.0 fat     7520 b- defN 24-May-28 21:38 das2/xsd/das-basic-stream-v2.2.xsd
+-rw-rw-rw-  2.0 fat    23873 b- defN 24-May-28 21:38 das2/xsd/das-basic-stream-v3.0.xsd
+-rw-rw-rw-  2.0 fat       54 b- defN 24-May-28 21:42 das2py-3.0rc1.data/scripts/das_verify
+-rw-rw-rw-  2.0 fat     1068 b- defN 24-May-28 21:42 das2py-3.0rc1.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     8797 b- defN 24-May-28 21:42 das2py-3.0rc1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      102 b- defN 24-May-28 21:42 das2py-3.0rc1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       48 b- defN 24-May-28 21:41 das2py-3.0rc1.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat       11 b- defN 24-May-28 21:41 das2py-3.0rc1.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     2323 b- defN 24-May-28 21:42 das2py-3.0rc1.dist-info/RECORD
+30 files, 5576044 bytes uncompressed, 2380012 bytes compressed:  57.3%
```

## zipnote {}

```diff
@@ -63,29 +63,29 @@
 
 Filename: das2/xsd/das-basic-stream-v2.2.xsd
 Comment: 
 
 Filename: das2/xsd/das-basic-stream-v3.0.xsd
 Comment: 
 
-Filename: das2py-2.3.1.data/scripts/das_verify
+Filename: das2py-3.0rc1.data/scripts/das_verify
 Comment: 
 
-Filename: das2py-2.3.1.dist-info/LICENSE
+Filename: das2py-3.0rc1.dist-info/LICENSE
 Comment: 
 
-Filename: das2py-2.3.1.dist-info/METADATA
+Filename: das2py-3.0rc1.dist-info/METADATA
 Comment: 
 
-Filename: das2py-2.3.1.dist-info/WHEEL
+Filename: das2py-3.0rc1.dist-info/WHEEL
 Comment: 
 
-Filename: das2py-2.3.1.dist-info/entry_points.txt
+Filename: das2py-3.0rc1.dist-info/entry_points.txt
 Comment: 
 
-Filename: das2py-2.3.1.dist-info/top_level.txt
+Filename: das2py-3.0rc1.dist-info/top_level.txt
 Comment: 
 
-Filename: das2py-2.3.1.dist-info/RECORD
+Filename: das2py-3.0rc1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## das2/__init__.py

```diff
@@ -19,17 +19,18 @@
 # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 # SOFTWARE.
 
 
 FILL = -1.0e+31
 
-__version__ = '2.3.1'
+__version__ = '3.0-pre1'
 
 import sys
+from typing import Tuple
 import _das2
 from _das2 import Psd as PSD
 from das2.dastime   import *
 from das2.source    import *
 from das2.streamsrc import * 
 from das2.container import *
 from das2.dataset   import *
@@ -46,74 +47,73 @@
 import das2.toml as toml
 import das2.pkt as pkt
 import das2.cli as cli
 
 # ########################################################################### #
 # The basic data reading functions
 
-def read_cmd(sCmd):
+def read_cmd(sCmd) -> Tuple[dict, list]:
 	"""Run a das2 reader command line and output a list of das2 datasets
 
 	Args:
 		sCmd (str) : The command line to run in a subshell, may contain
 			pipes and other borne shell (posix) or cmd shell (windows)
 			constructs.  It is the callers responsibility to check for dangerous
 			shell escapes.
 
-	Returns: list
-		A list of Dataset objects created from the message body, or None if
-		in error occured.  The return datasets may or may not have data depending
-		on if data packetes were part of the response.
-
+	Returns: (dict, list)
+		A stream header followed by a list of dataset objects created from the
+		message body, or None if an error occured.  The return datasets may or
+		may not have data depending on if data packetes were part of the response.
 	"""
 
 	try:
-		lDs = _das2.read_cmd(sCmd)
+		(dHdr, lDs) = _das2.read_cmd(sCmd)
 	except Exception as e:
 		sys.stderr.write("Error running '%s': %s\n"%(sCmd, str(e)))
 		return None
 
 	if lDs != None:
 		lOut = []
 		for ds in lDs:
 			lOut.append(ds_from_raw(ds))
-		return lOut
+		return (dHdr, lOut)
 
 	raise _das2.Error("Unable to retrieve data using %s"%sUrl)
 
 
 
-def read_file(sFileName):
+def read_file(sFileName) -> Tuple[dict, list]:
 	"""Read datasets from a file
 
 	Args:
 		sFileName (str) : the name of the file to read
 
-	Returns: list
-		A list of Dataset objects created from the message body, or None if
-		in error occured.  The return datasets may or may not have data depending
-		on if data packetes were part of the response.
+	Returns: (dict, list)
+		A stream header followed by a list of dataset objects created from the
+		message body, or None if an error occured.  The return datasets may or
+		may not have data depending on if data packetes were part of the response.
 	"""
 
 	try:
-		lDs = _das2.read_file(sFileName)
+		(dHdr, lDs) = _das2.read_file(sFileName)
 	except Exception as e:
-		sys.stderr.write("Error running '%s': %s\n"%(sFileName, str(e)))
+		sys.stderr.write("Error reading '%s': %s\n"%(sFileName, str(e)))
 		return None
 
 	if lDs != None:
 		lOut = []
 		for ds in lDs:
 			lOut.append(ds_from_raw(ds))
-		return lOut
+		return (dHdr, lOut)
 
 	raise _das2.Error("Unable to retrieve data using %s"%sUrl)
 
 
-def read_http(sUrl, rTimeOut=3.0, sAgent=None):
+def read_http(sUrl, rTimeOut=3.0, sAgent=None) -> Tuple[dict, list]:
 	"""Issue an HTTP GET command to a remote server and output a list of
 	datasets.
 
 	To prevent this function from prompting for authentication on the standard
 	input terminal, you can use the das2.set_auth() or das2.load_auth()
 	functions before calling das2.read_http().
 
@@ -126,38 +126,37 @@
 			the operating system itself gives up, typically over five minutes.
 			This value only specifies a maximum wait for the initial connection,
 			actual data download times are not limited by this library.
 
 		sAgent (str, options) : The user-agent string to set in the HTTP/HTTPs
 			header.  If not specified a default string will be sent.
 
-	Returns: list
-		A list of Dataset objects created from the message body, or None if
-		in error occured.  The return datasets may or may not have data depending
-		on if data packetes were part of the response.
+	Returns: (dict, list)
+		A stream header followed by a list of dataset objects created from the
+		message body, or None if an error occured.  The return datasets may or
+		may not have data depending on if data packetes were part of the response.
 	"""
 
 	try:
 		if sAgent:
-			lDs = _das2.read_server(sUrl, rTimeOut, sAgent)
+			(dHdr, lDs) = _das2.read_server(sUrl, rTimeOut, sAgent)
 		else:
-			lDs = _das2.read_server(sUrl, rTimeOut)
+			(dHdr, lDs) = _das2.read_server(sUrl, rTimeOut)
 	except Exception as e:
 		sys.stderr.write("Error retrieving '%s': %s\n"%(sUrl, str(e)))
 		return None
 
 	if lDs != None:
 		lOut = []
 		for ds in lDs:
 			lOut.append(ds_from_raw(ds))
-		return lOut
+		return (dHdr, lOut)
 
 	raise _das2.Error("Unable to retrieve data using %s"%sUrl)
 
-
 g_sDefDas2SrcTag = 'tag:das2.org,2012:'
 
 # ########################################################################### #
 #
 # Catalog Classes:
 #                     Node
 #                      |
```

## das2/auth.py

```diff
@@ -90,16 +90,18 @@
 	
 	:rtype: The number of authentication hashes loaded.
 	"""
 	
 	if sFile is None:
 		import os
 		sHome = os.getenv('HOME')
-		if sHome is None:
-			raise EnvironmentError("Can't find account home directory")
+		if sHome == None:
+			sHome = os.getenv('USERPROFILE')
+			if sHome == None:
+				raise EnvironmentError("Can't find account home directory")
 			
 		sFile = "%s/.das2_auth"%sHome
 	
 	if not os.path.isfile(sFile):
 		sys.stderr.write("Can't open %s\n"%sFile)
 		return 0
```

## das2/dastime.py

```diff
@@ -140,15 +140,15 @@
 		
 		# Assume years less than 100 but greater than 57 are old 2 digit years
 		# that need to be incremented.  I don't like this but what can
 		# you do when reading old data.
 			
 		if isinstance(nYear, (tuple, list)):
 			self.t = [0, 0, 0, 0, 0, 0, 0.0]
-			for i in xrange(0, len(nYear)):
+			for i in range(0, len(nYear)):
 				j = i
 				if i >= 3:
 					j = i+1
 				self.t[j] = nYear[i]
 				
 			if self.t[0] < 100 and self.t[0] > 57:
 				self.t[0] = self.t[0] + 1900
```

## das2/dataset.py

```diff
@@ -51,15 +51,14 @@
 g_bNumpy10Hacks = ((lVer[0] == 1) and (lVer[1] < 11))
 
 if g_bNumpy10Hacks:
 	import os, time
 	os.environ['TZ'] = 'UTC'
 	time.tzset()
 
-
 # ########################################################################### #
 # Numpy timedelta64 and datetime64 are probably more trouble than they are
 # worth.  Common operations such as 1 / ns = GHz are outside the scope of
 # numpy.  I probably shouldn't have used either datetime64 or timedelta64,
 # they just don't play well with other quantities.  Also das2 and astropy
 # have thier own unit handling.  Why scipy didn't take care of units is a
 # mystery.  Adding unit support should have been step 1 for SciPy, because
@@ -455,17 +454,15 @@
 
 	  - .array - The underlying ndarray object
 	  - .units - The units as a string
 	  - .name  - A name for this variable, defaults to it's role in the dimension
 	  - .unique - A list of indicies in which these values are (potentially)
 	        unique.
 
-	Variables are very similar to Quantities in AstroPy.  Users of both das2py
-	and astropy are encouraged to use the astrohelp.py to generate Quantity
-	objects from das2py Variables.
+	Variables are very similar to Quantities in AstroPy.
 	"""
 	def __init__(self, dim, role, values, units, axis=None, fill=None):
 		"""Create a new Variable.
 
 		Args:
 			dim (Dimension) : Parent Dimension for this Variable
 
@@ -1492,125 +1489,150 @@
 					self.shape = tuple(self.shape)
 					bSet = False
 
 		self._check_shape()
 
 
 # ########################################################################### #
-# libdas2 wrapper to high level interface conversion functions
+# das2C wrapper to high level interface conversion functions
 
 def _mk_prop_from_raw(tProp):
 	"""Make a property dictionary value given a :mod:_das2 property string
 
-	Convertions are as follows:
-		- 'string' -> str
-		- 'boolean' -> True | False
-		- 'double' -> float
-		- 'datum' -> Quantity (float, units)
-		- 'int' -> int
-		- 'time' -> DasTime
-		- 'datumrange' -> Quantity (2 elements) (float, float, units)
-		- 'timerange' -> Quantity (2 elements) (DasTime, DasTime, 'UTC')
+	Low level properties are the tuples:
+
+	 (sType, sValue, sUnits, sSep, nMultiFlag)
 
+	Conversions are as follows, anything with units becomes a quantity:
+		- 'string'          -> str,  Quantity(str, units)
+		- 'stringArray'     -> [str] Quantity([str], units)
+		- 'bool'            -> True | False
+		- 'boolArray'       -> [bool]
+		- 'int'             -> int,  Quantity(int, units)
+		- 'intrange,array'  -> [int], Quantity([int], units)
+		- 'realrange,array' -> [float], Quantity([float], units)
+		- 'datetime'        -> datetime64(ns), Quantity(datetime64(ns), units)
+		- 'dt range, array' -> [datetime64(ns)], Quantity([datetime64(ns)], units)
+		
+		- 'datumrange' -> Quantity (2 elements) ([float, float], units)
+		
 	Args:
 		tProp (str, str): The first string is the data type as used in libdas2,
 			the second string is the value.  The first string must be one of those
 			listed above in Conversions.
 
 	Returns: Object
 		A python object representation of the given type an value stirings.
 	"""
 
 	#print("Checking: tProp[%s] = '%s'"%(key, prop))
 
-	sType = tProp[0].lower()
+	sType  = tProp[0].lower()
+	sValue = tProp[1];
+	sUnits = tProp[2];
+	sSep   = tProp[3];
+	nMulti = tProp[4];
 
 	if sType == 'string':
-		return tProp[1]
+		if sUnits == "": return sValue
+		else:            return Quantity(sValue, sUnits);
 
 	if sType == 'boolean':
 		return tProp[1].lower() in ('true','1','yes')
 
-	if sType == 'double':
-		return float(tProp[1])
-
-	if sType == 'datum':
-		lDatum = tProp[1].split()
-
-		if len(lDatum) > 1:
-			sUnits = ' '.join(lDatum[1:])
-
-			# Special exception here.  UTC has been used to tag time values
-			# so if you see those units, return a datetime
-			if sUnits.lower() == 'utc':
-				val = numpy.datetime64(str(dastime.DasTime(lDatum[0])), 'ns')
-				return Quantity(val, 'UTC')
-
-			if len(sUnits) == 0: sUnits = None
-
-			return Quantity( float(lDatum[0]), sUnits)
-		else:
-			return Quantity( float(tProp[1]), None)
-
 	if sType == 'int':
-		return int(tProp[1])
+		if sUnits == "": return int(tProp[1]);
+		else:            return Quantity(int(tProp[1]), sUnits);
 
-	if sType == 'time':
-		return numpy.datetime64( dastime.DasTime(tProp[1]), 'ns')
+	if sType == 'datetime':
 
-	# We could make this work if the 'to' is missing
-	if sType == 'datumrange':
-		l = tProp[1].split()
-		if len(l) < 3:
-			raise ValueError("Can't parse DatumRange: %s"%tProp[1])
-
-		sBeg = l[0]
-		sEnd = l[2]
-		sUnits = ' '.join(l[3:])
-
-		# Add UTC exception here as well
-		if sUnits.lower() == 'utc':
-			beg = numpy.datetime64(str(dastime.DasTime(sBeg)), 'ns')
-			end = numpy.datetime64(str(dastime.DasTime(sEnd)), 'ns')
-			return Quantity([beg, end], 'UTC')
+		# Special exception here.  UTC has been used to tag time values
+		# so if you see those units, return a datetime
+		if sUnits in ("", "UTC", "utc"):
+			val = numpy.datetime64(dastime.DasTime(sValue).isoc(9), 'ns')
+			return Quantity(val, 'UTC')
+
+		# Careful to preserve resolution here
+		if sUnits in ("TT2000"):
+			t = _das2.tt2k_utc(int(sValue))
+			val = numpy.datetime64(dastime.DasTime(t).isoc(9), 'ns')
+			return Quantity( val, sUnits)
 		else:
-			if len(sUnits) == 0:
-				return Quantity([float(sBeg), float(sEnd)], None)
-			else:
-				return Quantity([float(sBeg), float(sEnd)], sUnits)
-
-	# Same as above but force time usage and ignore the units
-	if sType == 'timerange':
-		l = tProp[1].split()
-		if len(l) < 3:
-			raise ValueError("Can't parse TimeRange: %s"%tProp[1])
-
-		sBeg = l[0]
-		sEnd = l[2]
-		sUnits = ' '.join(l[3:])
-
-		# Add UTC exception here as well
-		beg = numpy.datetime64(str(dastime.DasTime(l[0])), 'ns')
-		end = numpy.datetime64(str(dastime.DasTime(l[2])), 'ns')
-		return Quantity([beg, end], 'UTC')
+			return Quantity( float(sValue), sUnits)
 
+	if sType == 'real':
+		if sUnits == "": return float(tProp[1]);
+		else:            return Quantity(float(tProp[1]), sUnits);
+
+
+	if nMulti == 1:
+		raise ValueError("Unknown property type %s of multiplicity 1"%sType)
+
+
+	# Split the items up, the multiplicity 2 items are ranges
+	if nMulti == 2:
+		lItems = [s.strip() for s in sValue.split(' to ') ]
+	elif nMulti == 3:
+		if sSep == "": lItems = sValue.split()
+		else:  lItems = sValue.split()
+	else:
+		raise ValueError("Unexpected property tuple from _das2, multiplicity = %d"%nMulti)
+
+	# Now for the range & set types
+	if sType == "stringarray":
+		if sUnits == "": return lItems
+		else:            return Quantity(lItems, sUnits);
+
+	if sType == "boolArray":
+		return [ s.lower() in ('true','1','yes') for s in lItems]
+
+	if sType in ("intarray","intrange"):
+		lInts = [int(s) for s in lItems ]
+		if sUnits == "": return lInts
+		else:            return Quantity(lInts, sUnits);
+
+	if sType in ("realarray","realrange"):
+		lFloats = [float(s) for s in lItems ]
+		if sUnits == "": return lFloats
+		else:            return Quantity(lFloats, sUnits);
+
+	if sType in ("datetimerange","datetimearray"):
+
+		# Conversions depend on units.  Shouldn't be the case, but is traditional
+		# at this point.
+		if sUnits in ("", "UTC", "utc"):
+			lDt = [ 
+				numpy.datetime64( dastime.DasTime(s).isoc(9), 'ns' ) 
+				for s in lItems
+			]
+			return Quantity(lDt, 'UTC')
+
+		if sUnits in ("TT2000"):
+			# TODO: Implement a flat lookup table similar to dastelem for 
+			#       this conversion.  It will be *MUCH* faster.
+			return Quantity( [
+				numpy.datetime64(dastime.DasTime(_das2.tt2k_utc(int(s))).isoc(9), 'ns')
+				for s in lItems
+			], sUnits)
+		else:
+			return Quantity( [float(s) for s in lItems], sUnits)
 
 
-	raise ValueError("Unknown property data type: %s"%sType)
+	raise ValueError("Unknown property data type: %s in %s"%(sType, str(tProp)))
 
 # #########################
 
 def _mk_var_from_raw(dim, dRawDs, sRole, sExp, sUnits, bMask=False):
 
 	# TODO: Make a real expression parser, this is just for testing
 	#       Right now in das2 we only have straight array lookups and
 	#       waveforms which are of type a[i] + b[j].
 	#
 	#       This code will need to be significantly reworked to handle
-	#       das 2.3 streams.
+	#       das 3 streams.
 
 	# Expression parts: array_lookup units "|" index_range
 	#
 	# array_lookup ends with ] unless array_lookup starts with (,
 	#              then it ends with )
 
 	perr = sys.stderr.write
```

## das2/reader.py

```diff
@@ -361,16 +361,17 @@
 	Properties:
 		sver - The version of the stream that produced the packet, should be
 		   one of: 2.2, 2.3/basic or qstream
 
 	   tag - The 2-character content tag, see g_lValidTags for a list of
 	   	valid tags
 			  
-	   id - The packet integer ID.  Stream and pure dataset packets
-		     are always ID 0.  Otherwise the ID is 1 or greater.
+	   id - The packet integer ID.  Stream and pure dataset packets are are
+		     always ID 0. Data and headers are 1 or greater.  Out of band data 
+		     such as comment and exceptions are -1
 			
 		length - The original length of the packet before decoding UTF-8
 		     strings.
 			
 		content - Exther a bytestr (data packets) or a string (header 
 		     packets.  If the packet is a header then the bytes are 
 			  decode as utf-8. If the packet contains data the a raw
@@ -646,23 +647,28 @@
 	
 
 	def _nextStaticTag(self, x4):
 		"""Return a das2.2 packet, this is complicated by the fact that pre das3
 		data packets don't have length value, parsing the associated header is required.
 		"""
 		
-		try:
-			nPktId = int(x4[1:3].decode('utf-8'), 10)
-		except ValueError:
-			raise ValueError("Invalid packet ID '%s'"%x4[1:3].decode('utf-8'))
-			
-		if (nPktId < 0) or (nPktId > 99):
-			raise ValueError("Invalid packet ID %s at byte offset %s"%(
-				x4[1:3].decode('utf-8'), self.nOffset
-			))
+		# Use -1 for comment packets
+		sPktId = x4[1:3].decode('utf-8')
+		nPktId = -1
+
+		if sPktId not in ('xx','XX'):
+			try:
+				nPktId = int(sPktId, 10)
+			except ValueError:
+				raise ValueError("Invalid packet ID '%s'"%x4[1:3].decode('utf-8'))
+			
+			if (nPktId < 0) or (nPktId > 99):
+				raise ValueError("Invalid packet ID %s at byte offset %s"%(
+					x4[1:3].decode('utf-8'), self.nOffset
+				))
 			
 		if self.nOffset == 4 and (x4 != b'[00]'):
 			raise ValueError("Input does not start with '[00]' does not appear to be a das2 stream")
 		
 		if x4[0:1] == b'[' and x4[3:4] == b']':
 		
 			x6 = self._read(6)	
@@ -691,15 +697,16 @@
 			try:
 				sDoc = xDoc.decode("utf-8")
 			except UnicodeDecodeError:
 				ValueError("Header %s (length %d bytes) is not valid UTF-8 text"%(
 					x4.decode('utf-8'), nLen
 				))
 			
-			self.lPktDef[nPktId] = True
+			if nPktId > -1:
+				self.lPktDef[nPktId] = True
 			
 			# Higher level parser will have to give us the length.  This is an
 			# oversight in the das2 stream format that has been around for a while.
 			# self.lPktSize = ? 
 			
 			# Also comment and exception packets are not differentiated, in das2.2
 			# so we have to read ahead to get the content tag
```

## das2/streamsrc.py

```diff
@@ -389,15 +389,15 @@
 
 			sGet = "&".join(lParams)
 			sUrl = "%s%s%s"%(sBaseUrl, sJoin, sGet)
 
 			try:
 				#print("Reading %s"%sUrl)
 				if verbose: perr("Requesting: %s\n"%sUrl)
-				lDs = _das2.read_server(sUrl)
+				(dHdr, lDs) = _das2.read_server(sUrl)
 			except Exception as e:
 				sys.stderr.write("Couldn't read URL '%s', %s\n"%(sUrl, str(e)))
 				# put this URL on the naughty list
 				self.lBadBase.append(sBaseUrl)
 
 		if lDs != None:
 			lOut = []
```

## das2/verify.py

```diff
@@ -123,15 +123,17 @@
 						pkt.tag, pkt.id, sCurType
 					))
 				else:
 					pout("|%s| ID %s %s header [OKAY] (data size %d bytes)"%(
 						pkt.tag, pkt.id, sCurType, pkt.dataLen()
 					))
 			else:
-				pout("|%s| ID %s %s header [OKAY]"%(pkt.tag, pkt.id, sCurType))
+				sId = pkt.id
+				if pkt.id < 0: sId = '-'
+				pout("|%s| ID %s %s header [OKAY]"%(pkt.tag, sId, sCurType))
 				
 			curPkt = None
 			sCurType = None
 			
 	except (
 		das2.HeaderError, etree.XMLSyntaxError, etree.DocumentInvalid, 
 		xml.parsers.expat.ExpatError
```

## das2/xsd/das-basic-doc-ns-v3.0.xsd

### das2/xsd/das-basic-doc-ns-v3.0.xsd

```diff
@@ -19,14 +19,16 @@
        no longer required
 
     5. The elements <comment> and <exception> are not included since
        these are ment for real-time information.
 
   See the file das-basic-stream-v3.0.xsd for a multi-root schema definition
   suitable for validating packetized streams.
+
+version 3.0, release candiate 2, 2024-05-27
 -->
 <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="das-basic-doc" version="3.0" targetNamespace="das-basic-doc" elementFormDefault="qualified" attributeFormDefault="unqualified">
   <!-- General Fields -->
   <!-- The names for things that could be variables in most languages -->
   <xs:simpleType name="VarName">
     <xs:restriction base="xs:string">
       <xs:pattern value="[a-zA-Z][a-zA-Z0-9_]*"/>
@@ -49,21 +51,14 @@
     <xs:restriction base="xs:string">
       <xs:pattern value="[*]{0}|[a-zA-Z][a-zA-Z0-9_\.]*"/>
       <xs:maxLength value="63"/>
       <!-- leave rooom for null char -->
     </xs:restriction>
   </xs:simpleType>
   <!-- Properties ========================================================== -->
-  <xs:simpleType name="PropName">
-    <xs:restriction base="xs:string">
-      <xs:pattern value="[a-zA-Z][a-zA-Z0-9_\.\-,:]*"/>
-      <xs:maxLength value="63"/>
-      <!-- leave rooom for null char -->
-    </xs:restriction>
-  </xs:simpleType>
   <!-- Alt prop by language -->
   <xs:simpleType name="ISO639_1">
     <xs:restriction base="xs:string">
       <xs:pattern value="[a-zA-Z][a-zA-Z0-9_\-]+"/>
       <xs:maxLength value="8"/>
       <!-- leave rooom for null char -->
     </xs:restriction>
@@ -71,42 +66,80 @@
   <xs:complexType name="AltProp">
     <xs:simpleContent>
       <xs:extension base="xs:string">
         <xs:attribute name="lang" type="ISO639_1" use="required"/>
       </xs:extension>
     </xs:simpleContent>
   </xs:complexType>
-  <!-- The data types for properties. Same as ValueType below with ranges -->
+  <!-- The data types for properties. Same as "Semantic" but with ranges -->
   <xs:simpleType name="PropType">
     <xs:restriction base="xs:string">
-      <xs:enumeration value="boolean"/>
+      <xs:enumeration value="bool"/>
+      <xs:enumeration value="boolArray"/>
       <xs:enumeration value="datetime"/>
       <xs:enumeration value="datetimeRange"/>
+      <xs:enumeration value="datetimeArray"/>
       <xs:enumeration value="integer"/>
       <xs:enumeration value="integerRange"/>
+      <xs:enumeration value="integerArray"/>
       <xs:enumeration value="real"/>
       <xs:enumeration value="realRange"/>
+      <xs:enumeration value="realArray"/>
       <xs:enumeration value="string"/>
+      <xs:enumeration value="stringArray"/>
+    </xs:restriction>
+  </xs:simpleType>
+  <xs:simpleType name="Bool">
+    <xs:restriction base="xs:string">
+      <xs:pattern value="[tTfF01]|true|false"/>
+    </xs:restriction>
+  </xs:simpleType>
+  <xs:simpleType name="Terminator">
+    <xs:restriction base="xs:string">
+      <!-- Anything but a pipe, higher level parsing may disqualify many patterns -->
+      <xs:pattern value="([ -{]|[}~];)+"/>
     </xs:restriction>
   </xs:simpleType>
   <!-- Single property -->
   <xs:complexType name="Property" mixed="true">
     <xs:sequence>
       <xs:element name="alt" type="AltProp" minOccurs="0" maxOccurs="unbounded"/>
     </xs:sequence>
-    <xs:attribute name="name" type="PropName" use="required"/>
-    <xs:attribute name="valType" type="PropType" default="string"/>
+    <xs:attribute name="name" type="StructName" use="required"/>
+    <xs:attribute name="type" type="PropType" default="string"/>
     <xs:attribute name="units" type="xs:token"/>
+    <xs:attribute name="sep" type="Terminator" default=" "/>
   </xs:complexType>
   <!-- Properties grouping -->
   <xs:complexType name="Properties">
     <xs:sequence>
       <xs:element name="p" type="Property" minOccurs="0" maxOccurs="unbounded"/>
     </xs:sequence>
   </xs:complexType>
+  <!-- Coordinate Frames =================================================== -->
+  <!-- These are independent of any particular values and assign DIRECTIONALTY
+     ONLY!  Frame components have no units.  These are not to be confused with
+     the "axis" values from <coord>.  The attribute "axis" is a graphical display
+     directive and refers to a display axis, not a physical axis.  
+
+     The two can be made to coincide by using the optional "frame" and "component"
+     attributes of <coord>
+-->
+  <xs:complexType name="FrameDirection">
+    <xs:attribute name="name" type="VarName" use="required"/>
+  </xs:complexType>
+  <xs:complexType name="Frame">
+    <xs:sequence>
+      <xs:element name="properties" type="Properties" minOccurs="0" maxOccurs="1"/>
+      <xs:element name="dir" type="FrameDirection" minOccurs="1" maxOccurs="9"/>
+    </xs:sequence>
+    <xs:attribute name="name" type="StructName" use="required"/>
+    <xs:attribute name="type" type="VarName" use="required"/>
+    <xs:attribute name="inertial" type="Bool"/>
+  </xs:complexType>
   <!-- Extensions ========================================================== -->
   <!-- Extension tags can hold anything except for elements defined in this
   namespace.  They can also have any attributes.  Client stream processors
   should pass stream-level extension elements unchanged dataset level 
   extension element handling is undefined 
 -->
   <xs:complexType name="Extension" mixed="true">
@@ -118,15 +151,15 @@
     </xs:sequence>
     <xs:attribute name="scheme" type="xs:string" use="required"/>
     <xs:attribute name="content" type="xs:string" use="required"/>
     <!-- Can extend with other attributes, will be skipped by schema -->
     <xs:anyAttribute processContents="skip"/>
   </xs:complexType>
   <!-- Datasets ============================================================ -->
-  <!-- Each packet header defines a das dataset and how it appears in the data
+  <!-- Each dataset header defines a das dataset and how it appears in the data
      stream.  The object containment hirearchy is depected in the middle of
      the reference poster, 
      
         https://das2.org/das2_AGU2019.pdf 
          
      and summarized below:
      
@@ -147,29 +180,26 @@
 -->
   <!-- The understood plot type strings -->
   <xs:simpleType name="PlotType">
     <xs:restriction base="xs:string">
       <xs:pattern value="(cartesian2d|cartesian3d|polar|cylindrical|spherical)(:movie)?"/>
     </xs:restriction>
   </xs:simpleType>
-  <xs:simpleType name="Direction">
+  <!-- This has to be multi-valued because breaking natural vector coordinates
+     into individual scalars makes parsing and plotting code more convoluted.
+     See description of each plot axis name in "Dataset" type definition below.
+-->
+  <xs:simpleType name="PlotDirection">
     <xs:restriction base="xs:string">
-      <xs:enumeration value="x"/>
-      <xs:enumeration value="y"/>
-      <xs:enumeration value="z"/>
-      <xs:enumeration value="ρ"/>
-      <!-- radius cylindrical -->
-      <xs:enumeration value="r"/>
-      <!-- radius spherical & polar -->
-      <xs:enumeration value="θ"/>
-      <!-- polar angle -->
-      <xs:enumeration value="φ"/>
-      <!-- azimuthal angle in x-y plane -->
-      <xs:enumeration value="t"/>
-      <!-- for movies, not time on a space axis -->
+      <xs:pattern value="[xyzρrθφt](;[xyzρrθφt])*"/>
+      <!-- ρ: radius cylindrical -->
+      <!-- r: radius spherical & polar -->
+      <!-- θ: polar angle -->
+      <!-- φ: azimuthal angle in x-y plane -->
+      <!-- t: for movies, not time on a space axis -->
     </xs:restriction>
   </xs:simpleType>
   <!-- The Index space definition for this dataset.
 
   Just as the plot type can define the graphical space for a dataset,
   this defines the value lookup space.
 
@@ -239,83 +269,78 @@
       <xs:minInclusive value="2"/>
       <xs:maxInclusive value="2147483647"/>
     </xs:restriction>
   </xs:simpleType>
   <xs:simpleType name="EmptyPosInt">
     <xs:union memberTypes="IntTwoOrMore Empty"/>
   </xs:simpleType>
-  <!-- The data types for values, does not support ranges -->
-  <xs:simpleType name="ValueType">
+  <!-- The understanding of what kind of value this is, is it a countable (int), 
+     a state (bool), a floating point number (real), a calendar date (datetime),
+     or just some information (string) -->
+  <xs:simpleType name="Semantic">
     <xs:restriction base="xs:string">
       <xs:pattern value="bool|datetime|int|real|string"/>
     </xs:restriction>
   </xs:simpleType>
+  <!-- What kind of arrays and values in memory should be used for this item
+     Since some languages don't support unsigned types and can use the next
+     largger signed type
+-->
+  <xs:simpleType name="Storage">
+    <xs:restriction base="xs:string">
+      <xs:pattern value="byte|ubyte|short|ushort|int|uint|long|ulong|float|double|string|struct"/>
+    </xs:restriction>
+  </xs:simpleType>
   <!-- Encoding type missing since only utf8 is allowed -->
   <xs:simpleType name="ValuesContent">
     <!-- The regex for scientific notation is looooong, just make sure
        illegal characters are not present -->
     <xs:restriction base="xs:string">
       <xs:pattern value="[0-9\+\-;\.eE\s]*"/>
       <xs:whiteSpace value="collapse"/>
     </xs:restriction>
   </xs:simpleType>
   <xs:simpleType name="ValRepeat">
     <xs:restriction base="xs:string">
       <xs:pattern value="none|whole|each"/>
     </xs:restriction>
   </xs:simpleType>
-  <!-- Variable length data values
-
-  By default no terminators are defined and an app must rely on itemBytes in
-  <packet> is used to determine where fields end.  Alternatively fexible width
-  fields may be used in one of two ways:
-
-     1. Provide a length tag before each value, ex: "|17|Some event string"
-
-     2. Provide a value terminator.  Unlike separators in most languages, 
-        terminators MUST follow each value, even the last value.
-
-  In either case, specify that values are variable length using itemsBytes="*"
-  and if terminators are in use, give the terminator character which must be 
-  from the set | \ ? : ; ~ # ^ @ $.
-
-  The suggested value terminator is ";" though no default is given.
--->
-  <xs:simpleType name="Terminator">
+  <!-- Ragged arrays of variable length items need different types of terminators
+     for different array indexes.  This item allows for one terminator character
+     per array dimension -->
+  <xs:simpleType name="TermList">
     <xs:restriction base="xs:string">
-      <xs:pattern value="[\|/\\\?:;~#\^@$]"/>
-      <xs:pattern value="\\n"/>
-      <!-- <xs:pattern value="[\|\\/\?:;~\^$#@]" /> -->
+      <xs:pattern value="([; -{]|[}~])+(\|([ -{]|[}~])+)*"/>
     </xs:restriction>
   </xs:simpleType>
   <!-- An array variable in the header -->
   <xs:complexType name="Values">
     <xs:simpleContent>
       <xs:extension base="ValuesContent">
         <xs:attribute name="repeat" type="ValRepeat" default="none"/>
         <xs:attribute name="repetitions" type="xs:positiveInteger"/>
         <!-- Since values elements have a natural end point, no terminator
-        is needed for the last value, so they are called separators here -->
+        is needed for the last value -->
         <xs:attribute name="valSep" type="Terminator" default=";"/>
       </xs:extension>
     </xs:simpleContent>
   </xs:complexType>
   <xs:complexType name="Sequence">
-    <xs:attribute name="use" type="VarRole" default="center"/>
     <xs:attribute name="minval" type="xs:double" use="required"/>
     <xs:attribute name="interval" type="xs:double" use="required"/>
     <xs:attribute name="repeat" type="ValRepeat" default="none"/>
     <xs:attribute name="repetitions" type="xs:positiveInteger"/>
   </xs:complexType>
   <xs:complexType name="Packet">
-    <xs:attribute name="numItems" use="required"/>
+    <xs:attribute name="numItems" type="NonZeroStar" use="required"/>
     <xs:attribute name="itemBytes" type="NonZeroStar"/>
     <!-- encoding is always text -->
-    <xs:attribute name="valTerm" type="Terminator"/>
     <xs:attribute name="fill" type="xs:string"/>
+    <xs:attribute name="valTerm" type="Terminator"/>
+    <xs:attribute name="itemsTerm" type="TermList"/>
   </xs:complexType>
   <!-- The purposes for values of a variable -->
   <xs:simpleType name="VarRole">
     <xs:restriction base="xs:string">
       <xs:enumeration value="center"/>
       <xs:enumeration value="offset"/>
       <xs:enumeration value="average"/>
@@ -334,57 +359,61 @@
     <xs:choice>
       <xs:element name="values" type="Values"/>
       <xs:element name="sequence" type="Sequence"/>
       <xs:element name="packet" type="Packet"/>
     </xs:choice>
     <xs:attribute name="use" type="VarRole" default="center"/>
     <xs:attribute name="units" type="xs:token" use="required"/>
-    <xs:attribute name="valType" type="ValueType" use="required"/>
+    <xs:attribute name="storage" type="Storage"/>
+    <xs:attribute name="semantic" type="Semantic" use="required"/>
     <xs:attribute name="index" type="VarIndexShape" use="required"/>
   </xs:complexType>
   <!-- Vectors, Inherit from scalars and add elements ======== -->
-  <xs:complexType name="Component">
-    <xs:attribute name="name" type="VarName" use="required"/>
+  <xs:complexType name="VecComponent">
+    <xs:attribute name="dir" type="VarName" use="required"/>
     <xs:attribute name="units" type="xs:token"/>
   </xs:complexType>
   <xs:simpleType name="VectorClass">
     <xs:restriction base="xs:string">
       <xs:enumeration value="cartesian"/>
       <xs:enumeration value="polar"/>
       <xs:enumeration value="spherical"/>
       <!-- More?? -->
     </xs:restriction>
   </xs:simpleType>
   <xs:complexType name="VectorVar">
     <xs:sequence>
-      <xs:element name="component" type="Component" minOccurs="2" maxOccurs="3"/>
+      <xs:element name="component" type="VecComponent" minOccurs="1" maxOccurs="3"/>
       <xs:choice>
         <xs:element name="values" type="Values"/>
         <xs:element name="sequence" type="Sequence"/>
         <xs:element name="packet" type="Packet"/>
       </xs:choice>
     </xs:sequence>
     <xs:attribute name="use" type="VarRole" default="center"/>
     <xs:attribute name="units" type="xs:token" use="required"/>
-    <xs:attribute name="valType" type="ValueType" use="required"/>
+    <xs:attribute name="semantic" type="Semantic" use="required"/>
+    <xs:attribute name="storage" type="Storage"/>
     <xs:attribute name="index" type="VarIndexShape" use="required"/>
-    <xs:attribute name="vecClass" type="VectorClass" use="required"/>
+    <!-- deprecated -->
+    <xs:attribute name="vecClass" type="VectorClass"/>
   </xs:complexType>
   <!-- Physical Dimensions ================================================= -->
   <xs:complexType name="CoordDim">
     <xs:sequence>
       <xs:element name="properties" type="Properties" minOccurs="0"/>
-      <!-- For v3.0/basic only allow scalar types in coordinates -->
-      <!-- <xs:choice minOccurs="1" maxOccurs="unbounded">  -->
-      <xs:element name="scalar" type="ScalarVar" minOccurs="1" maxOccurs="unbounded"/>
-      <!-- <xs:element name="vector" type="VectorVar" /> -->
-      <!-- </xs:choice> -->
+      <xs:choice minOccurs="1" maxOccurs="unbounded">
+        <xs:element name="scalar" type="ScalarVar" minOccurs="1" maxOccurs="unbounded"/>
+        <xs:element name="vector" type="VectorVar"/>
+      </xs:choice>
     </xs:sequence>
     <xs:attribute name="physDim" type="PhysDimName" use="required"/>
-    <xs:attribute name="axis" type="Direction" use="required"/>
+    <xs:attribute name="axis" type="PlotDirection" use="required"/>
+    <xs:attribute name="frame" type="StructName"/>
+    <!-- <xs:attribute name="dir" type="VarName"  /> -->
   </xs:complexType>
   <xs:complexType name="DataDim">
     <xs:sequence>
       <xs:element name="properties" type="Properties" minOccurs="0"/>
       <xs:choice minOccurs="1" maxOccurs="unbounded">
         <xs:element name="scalar" type="ScalarVar"/>
         <xs:element name="vector" type="VectorVar"/>
@@ -393,14 +422,15 @@
     <xs:attribute name="physDim" type="PhysDimName" use="required"/>
     <!-- 
   Data items must have unique names, however the name inherits from the overall
   dataset name.  So if you only have one <data> or <extData> element, the name
   isn't needed
   -->
     <xs:attribute name="name" type="StructName"/>
+    <xs:attribute name="frame" type="StructName"/>
   </xs:complexType>
   <!-- Extended data objects in an extended data section -->
   <xs:complexType name="DataObject">
     <xs:sequence>
       <xs:element name="packet" type="Packet" minOccurs="1" maxOccurs="unbounded"/>
     </xs:sequence>
     <xs:attribute name="scheme" type="xs:string" use="required"/>
@@ -493,14 +523,15 @@
     <xs:restriction base="xs:string">
       <xs:enumeration value="das-basic-doc"/>
     </xs:restriction>
   </xs:simpleType>
   <xs:complexType name="Stream">
     <xs:sequence>
       <xs:element name="properties" type="Properties" minOccurs="0"/>
+      <xs:element name="frame" type="Frame" minOccurs="0" maxOccurs="unbounded"/>
       <xs:element name="extension" type="Extension" minOccurs="0" maxOccurs="unbounded"/>
       <xs:element name="dataset" type="Dataset" minOccurs="1"/>
       <xs:choice minOccurs="0" maxOccurs="unbounded">
         <xs:element name="dataset" type="Dataset"/>
         <xs:element name="d" type="PacketData"/>
       </xs:choice>
     </xs:sequence>
```

## das2/xsd/das-basic-stream-ns-v3.0.xsd

### das2/xsd/das-basic-stream-ns-v3.0.xsd

```diff
@@ -8,15 +8,15 @@
 
   See the file das2-basic-stream-v3.0.xsd for a multi-root schema 
   definition for files using un-declared namespaces
 
   See the file das2-basic-doc-v3.0.xsd for a single-root schema definition
   suitable for validating standard (i.e. non-packitized) documents.
 
-  version 3.0, release candidate 1, 2023-07-16.
+  version 3.0, release candidate 2, 2024-05-27.
 -->
 <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="das-basic-stream" version="3.0" elementFormDefault="qualified" attributeFormDefault="unqualified" targetNamespace="das-basic-stream">
   <!-- General Fields -->
   <!-- The names for things that could be variables in most languages -->
   <xs:simpleType name="VarName">
     <xs:restriction base="xs:string">
       <xs:pattern value="[a-zA-Z][a-zA-Z0-9_]*"/>
@@ -54,42 +54,81 @@
   <xs:complexType name="AltProp">
     <xs:simpleContent>
       <xs:extension base="xs:string">
         <xs:attribute name="lang" type="ISO639_1" use="required"/>
       </xs:extension>
     </xs:simpleContent>
   </xs:complexType>
-  <!-- The data types for properties. Same as ValueType below with ranges -->
+  <!-- The data types for properties. Same as "Semantic" but with ranges -->
   <xs:simpleType name="PropType">
     <xs:restriction base="xs:string">
       <xs:enumeration value="bool"/>
+      <xs:enumeration value="boolArray"/>
       <xs:enumeration value="datetime"/>
       <xs:enumeration value="datetimeRange"/>
-      <xs:enumeration value="int"/>
-      <xs:enumeration value="intRange"/>
+      <xs:enumeration value="datetimeArray"/>
+      <xs:enumeration value="integer"/>
+      <xs:enumeration value="integerRange"/>
+      <xs:enumeration value="integerArray"/>
       <xs:enumeration value="real"/>
       <xs:enumeration value="realRange"/>
+      <xs:enumeration value="realArray"/>
       <xs:enumeration value="string"/>
+      <xs:enumeration value="stringArray"/>
+    </xs:restriction>
+  </xs:simpleType>
+  <xs:simpleType name="Bool">
+    <xs:restriction base="xs:string">
+      <xs:pattern value="[tTfF01]|true|false"/>
+    </xs:restriction>
+  </xs:simpleType>
+  <xs:simpleType name="Terminator">
+    <xs:restriction base="xs:string">
+      <!-- Anything but a pipe, higher level parsing may disqualify many patterns -->
+      <xs:pattern value="([ -{]|[}~];)+"/>
+      <xs:pattern value="\\n"/>
     </xs:restriction>
   </xs:simpleType>
   <!-- Single property -->
   <xs:complexType name="Property" mixed="true">
     <xs:sequence>
       <xs:element name="alt" type="AltProp" minOccurs="0" maxOccurs="unbounded"/>
     </xs:sequence>
     <xs:attribute name="name" type="StructName" use="required"/>
     <xs:attribute name="type" type="PropType" default="string"/>
     <xs:attribute name="units" type="xs:token"/>
+    <xs:attribute name="sep" type="Terminator" default=" "/>
   </xs:complexType>
   <!-- Properties grouping -->
   <xs:complexType name="Properties">
     <xs:sequence>
       <xs:element name="p" type="Property" minOccurs="0" maxOccurs="unbounded"/>
     </xs:sequence>
   </xs:complexType>
+  <!-- Coordinate Frames =================================================== -->
+  <!-- These are independent of any particular values and assign DIRECTIONALTY
+     ONLY!  Frame components have no units.  These are not to be confused with
+     the "axis" values from <coord>.  The attribute "axis" is a graphical display
+     directive and refers to a display axis, not a physical axis.  
+
+     The two can be made to coincide by using the optional "frame" and "component"
+     attributes of <coord>
+-->
+  <xs:complexType name="FrameDirection">
+    <xs:attribute name="name" type="VarName" use="required"/>
+  </xs:complexType>
+  <xs:complexType name="Frame">
+    <xs:sequence>
+      <xs:element name="properties" type="Properties" minOccurs="0" maxOccurs="1"/>
+      <xs:element name="dir" type="FrameDirection" minOccurs="1" maxOccurs="9"/>
+    </xs:sequence>
+    <xs:attribute name="name" type="StructName" use="required"/>
+    <xs:attribute name="type" type="VarName" use="required"/>
+    <xs:attribute name="inertial" type="Bool"/>
+  </xs:complexType>
   <!-- Extensions ========================================================== -->
   <!-- Extension tags can hold anything except for elements defined in this
   namespace.  They can also have any attributes.  Client stream processors
   should pass stream-level extension elements unchanged dataset level 
   extension element handling is undefined 
 -->
   <xs:complexType name="Extension" mixed="true">
@@ -130,29 +169,26 @@
 -->
   <!-- The understood plot type strings -->
   <xs:simpleType name="PlotType">
     <xs:restriction base="xs:string">
       <xs:pattern value="(cartesian2d|cartesian3d|polar|cylindrical|spherical)(:movie)?"/>
     </xs:restriction>
   </xs:simpleType>
-  <xs:simpleType name="Direction">
+  <!-- This has to be multi-valued because breaking natural vector coordinates
+     into individual scalars makes parsing and plotting code more convoluted.
+     See description of each plot axis name in "Dataset" type definition below.
+-->
+  <xs:simpleType name="PlotDirection">
     <xs:restriction base="xs:string">
-      <xs:enumeration value="x"/>
-      <xs:enumeration value="y"/>
-      <xs:enumeration value="z"/>
-      <xs:enumeration value="ρ"/>
-      <!-- radius cylindrical -->
-      <xs:enumeration value="r"/>
-      <!-- radius spherical & polar -->
-      <xs:enumeration value="θ"/>
-      <!-- polar angle -->
-      <xs:enumeration value="φ"/>
-      <!-- azimuthal angle in x-y plane -->
-      <xs:enumeration value="t"/>
-      <!-- for movies, not time on a space axis -->
+      <xs:pattern value="[xyzρrθφt](;[xyzρrθφt])*"/>
+      <!-- ρ: radius cylindrical -->
+      <!-- r: radius spherical & polar -->
+      <!-- θ: polar angle -->
+      <!-- φ: azimuthal angle in x-y plane -->
+      <!-- t: for movies, not time on a space axis -->
     </xs:restriction>
   </xs:simpleType>
   <!-- The Index space definition for this dataset.
 
   Just as the plot type can define the graphical space for a dataset,
   this defines the value lookup space.
 
@@ -222,24 +258,35 @@
       <xs:minInclusive value="2"/>
       <xs:maxInclusive value="2147483647"/>
     </xs:restriction>
   </xs:simpleType>
   <xs:simpleType name="EmptyPosInt">
     <xs:union memberTypes="IntTwoOrMore Empty"/>
   </xs:simpleType>
-  <!-- The data types for values, does not support ranges -->
-  <xs:simpleType name="ValueType">
+  <!-- The understanding of what kind of value this is, is it a countable (int), 
+     a state (bool), a floating point number (real), a calendar date (datetime),
+     or just some information (string) -->
+  <xs:simpleType name="Semantic">
     <xs:restriction base="xs:string">
       <xs:pattern value="bool|datetime|int|real|string"/>
     </xs:restriction>
   </xs:simpleType>
+  <!-- What kind of arrays and values in memory should be used for this item
+     Since some languages don't support unsigned types and can use the next
+     larger signed type
+-->
+  <xs:simpleType name="Storage">
+    <xs:restriction base="xs:string">
+      <xs:pattern value="byte|ubyte|short|ushort|int|uint|long|ulong|float|double|string|struct"/>
+    </xs:restriction>
+  </xs:simpleType>
   <!-- Data value types in packets, sizes and formats -->
   <xs:simpleType name="EncodingType">
     <xs:restriction base="xs:string">
-      <xs:pattern value="none|byte|ubyte|utf8|BEint|BEuint|BEreal|LEint|LEuint|LEreal"/>
+      <xs:pattern value="byte|ubyte|BEint|BEuint|BEreal|LEint|LEuint|LEreal|utf8|none"/>
     </xs:restriction>
   </xs:simpleType>
   <xs:simpleType name="ValuesContent">
     <!-- The regex for scientific notation is looooong, just make sure
        illegal characters are not present -->
     <xs:restriction base="xs:string">
       <xs:pattern value="[0-9\+\-;\.eE\s]*"/>
@@ -250,60 +297,57 @@
     <xs:restriction base="xs:string">
       <xs:pattern value="none|whole|each"/>
     </xs:restriction>
   </xs:simpleType>
   <!-- Variable length data values
 
   By default no terminators are defined and an app must rely on itemBytes in
-  <packet> is used to determine where fields end.  Alternatively fexible width
-  fields may be used in one of two ways:
+  <packet> is used to determine where fields end. 
 
-     1. Provide a length tag before each value, ex: "|17|Some event string"
+  The terminator is interpreted according to the valType.  So for a real item
+  a terminator of:
 
-     2. Provide a value terminator.  Unlike separators in most languages, 
-        terminators MUST follow each value, even the last value.
+     0
 
-  In either case, specify that values are variable length using itemsBytes="*"
-  and if terminators are in use, give the terminator character which must be 
-  from the set | \ ? : ; ~ # ^ @ $.
+  is taken to be the floating point value 0.0.  For text encoding the terminator
+  is taken to be a single byte.
 
-  The suggested value terminator is ";" though no default is given.
+  The special values \n, and NaN are understood.  Note that for ragged arrays
+  in more then one index a DIFFERENT terminator is needed for each array dimension.
 -->
-  <xs:simpleType name="Terminator">
+  <xs:simpleType name="TermList">
     <xs:restriction base="xs:string">
-      <xs:pattern value="[\|/\\\?:;~#\^@$]"/>
-      <xs:pattern value="\\n"/>
-      <!-- <xs:pattern value="[\|\\/\?:;~\^$#@]" /> -->
+      <xs:pattern value="([; -{]|[}~])+(\|([ -{]|[}~])+)*"/>
     </xs:restriction>
   </xs:simpleType>
   <!-- An array variable in the header -->
   <xs:complexType name="Values">
     <xs:simpleContent>
       <xs:extension base="ValuesContent">
         <xs:attribute name="repeat" type="ValRepeat" default="none"/>
         <xs:attribute name="repetitions" type="xs:positiveInteger"/>
         <!-- Since values elements have a natural end point, no terminator
-        is needed for the last value, so they are called separators here -->
+        is needed for the last value -->
         <xs:attribute name="valSep" type="Terminator" default=";"/>
       </xs:extension>
     </xs:simpleContent>
   </xs:complexType>
   <xs:complexType name="Sequence">
-    <xs:attribute name="use" type="VarRole" default="center"/>
     <xs:attribute name="minval" type="xs:double" use="required"/>
     <xs:attribute name="interval" type="xs:double" use="required"/>
     <xs:attribute name="repeat" type="ValRepeat" default="none"/>
     <xs:attribute name="repetitions" type="xs:positiveInteger"/>
   </xs:complexType>
   <xs:complexType name="Packet">
     <xs:attribute name="numItems" type="NonZeroStar" use="required"/>
     <xs:attribute name="itemBytes" type="NonZeroStar" use="required"/>
     <xs:attribute name="encoding" type="EncodingType" use="required"/>
-    <xs:attribute name="valTerm" type="Terminator"/>
     <xs:attribute name="fill" type="xs:string"/>
+    <xs:attribute name="valTerm" type="Terminator"/>
+    <xs:attribute name="itemsTerm" type="TermList"/>
   </xs:complexType>
   <!-- The purposes for values of a variable -->
   <xs:simpleType name="VarRole">
     <xs:restriction base="xs:string">
       <xs:enumeration value="center"/>
       <xs:enumeration value="offset"/>
       <xs:enumeration value="average"/>
@@ -322,57 +366,62 @@
     <xs:choice>
       <xs:element name="values" type="Values"/>
       <xs:element name="sequence" type="Sequence"/>
       <xs:element name="packet" type="Packet"/>
     </xs:choice>
     <xs:attribute name="use" type="VarRole" default="center"/>
     <xs:attribute name="units" type="xs:token" use="required"/>
-    <xs:attribute name="valType" type="ValueType" use="required"/>
+    <xs:attribute name="storage" type="Storage"/>
+    <xs:attribute name="semantic" type="Semantic" use="required"/>
     <xs:attribute name="index" type="VarIndexShape" use="required"/>
   </xs:complexType>
   <!-- Vectors, Inherit from scalars and add elements ======== -->
-  <xs:complexType name="Component">
-    <xs:attribute name="name" type="VarName" use="required"/>
+  <xs:complexType name="VecComponent">
+    <xs:attribute name="dir" type="VarName" use="required"/>
     <xs:attribute name="units" type="xs:token"/>
   </xs:complexType>
   <xs:simpleType name="VectorClass">
     <xs:restriction base="xs:string">
       <xs:enumeration value="cartesian"/>
       <xs:enumeration value="polar"/>
       <xs:enumeration value="spherical"/>
       <!-- More?? -->
     </xs:restriction>
   </xs:simpleType>
   <xs:complexType name="VectorVar">
     <xs:sequence>
-      <xs:element name="component" type="Component" minOccurs="2" maxOccurs="3"/>
+      <xs:element name="component" type="VecComponent" minOccurs="1" maxOccurs="3"/>
       <xs:choice>
         <xs:element name="values" type="Values"/>
         <xs:element name="sequence" type="Sequence"/>
         <xs:element name="packet" type="Packet"/>
       </xs:choice>
     </xs:sequence>
     <xs:attribute name="use" type="VarRole" default="center"/>
     <xs:attribute name="units" type="xs:token" use="required"/>
-    <xs:attribute name="valType" type="ValueType" use="required"/>
+    <xs:attribute name="semantic" type="Semantic" use="required"/>
+    <xs:attribute name="storage" type="Storage"/>
     <xs:attribute name="index" type="VarIndexShape" use="required"/>
-    <xs:attribute name="vecClass" type="VectorClass" use="required"/>
+    <!-- deprecated -->
+    <xs:attribute name="vecClass" type="VectorClass"/>
   </xs:complexType>
   <!-- Physical Dimensions ================================================= -->
   <xs:complexType name="CoordDim">
     <xs:sequence>
       <xs:element name="properties" type="Properties" minOccurs="0"/>
       <!-- For v3.0/basic only allow scalar types in coordinates -->
       <!-- <xs:choice minOccurs="1" maxOccurs="unbounded">  -->
       <xs:element name="scalar" type="ScalarVar" minOccurs="1" maxOccurs="unbounded"/>
       <!-- <xs:element name="vector" type="VectorVar" /> -->
       <!-- </xs:choice> -->
     </xs:sequence>
     <xs:attribute name="physDim" type="PhysDimName" use="required"/>
-    <xs:attribute name="axis" type="Direction" use="required"/>
+    <xs:attribute name="axis" type="PlotDirection" use="required"/>
+    <xs:attribute name="frame" type="StructName"/>
+    <!-- <xs:attribute name="dir" type="VarName"  /> -->
   </xs:complexType>
   <xs:complexType name="DataDim">
     <xs:sequence>
       <xs:element name="properties" type="Properties" minOccurs="0"/>
       <xs:choice minOccurs="1" maxOccurs="unbounded">
         <xs:element name="scalar" type="ScalarVar"/>
         <xs:element name="vector" type="VectorVar"/>
@@ -381,14 +430,15 @@
     <xs:attribute name="physDim" type="PhysDimName" use="required"/>
     <!-- 
   Data items must have unique names, however the name inherits from the overall
   dataset name.  So if you only have one <data> or <extData> element, the name
   isn't needed
   -->
     <xs:attribute name="name" type="StructName"/>
+    <xs:attribute name="frame" type="StructName"/>
   </xs:complexType>
   <!-- Extended data objects in an extended data section -->
   <xs:complexType name="DataObject">
     <xs:sequence>
       <xs:element name="packet" type="Packet" minOccurs="1" maxOccurs="unbounded"/>
     </xs:sequence>
     <xs:attribute name="scheme" type="xs:string" use="required"/>
@@ -472,14 +522,15 @@
     <xs:restriction base="xs:string">
       <xs:enumeration value="das-basic-stream"/>
     </xs:restriction>
   </xs:simpleType>
   <xs:complexType name="Stream">
     <xs:sequence>
       <xs:element name="properties" type="Properties" minOccurs="0"/>
+      <xs:element name="frame" type="Frame" minOccurs="0" maxOccurs="unbounded"/>
       <xs:element name="extension" type="Extension" minOccurs="0" maxOccurs="unbounded"/>
     </xs:sequence>
     <xs:attribute name="type" type="StreamType" use="required"/>
     <xs:attribute name="version" type="StreamVersion" use="required"/>
     <xs:attribute name="lang" type="ISO639_1" default="en"/>
   </xs:complexType>
   <!-- Exceptions =========================================================== -->
```

## das2/xsd/das-basic-stream-v2.2.xsd

### das2/xsd/das-basic-stream-v2.2.xsd

```diff
@@ -20,14 +20,17 @@
   <xs:simpleType name="PropType">
     <xs:restriction base="xs:string">
       <xs:enumeration value="String"/>
       <xs:enumeration value="Datum"/>
       <xs:enumeration value="boolean"/>
       <xs:enumeration value="int"/>
       <xs:enumeration value="double"/>
+      <xs:enumeration value="doubleArray"/>
+      <xs:enumeration value="Time"/>
+      <xs:enumeration value="TimeRange"/>
       <xs:enumeration value="DatumRange"/>
     </xs:restriction>
   </xs:simpleType>
   <xs:simpleType name="CompressVal">
     <xs:restriction base="xs:string">
       <xs:enumeration value="none"/>
       <xs:enumeration value="zlib"/>
@@ -91,15 +94,15 @@
     </xs:sequence>
     <xs:attribute name="name" type="PhysDimNameEmpty"/>
     <xs:attribute name="type" type="StorageType" use="required"/>
     <xs:attribute name="units" type="xs:token" use="required"/>
   </xs:complexType>
   <xs:simpleType name="StorageType">
     <xs:restriction base="xs:string">
-      <xs:pattern value="big_endian_real[48]|little_endian_real[48]|big_endian_int8|little_endian_int8|ascii[1-9][0-9]*|time[1-9][0-9]*|char[1-9][0-9]*"/>
+      <xs:pattern value="sun_real[48]|little_endian_real[48]|ascii[1-9][0-9]*|time[1-9][0-9]*"/>
     </xs:restriction>
   </xs:simpleType>
   <xs:simpleType name="Values">
     <!-- The regex for scientific notation is looooong, just make sure
        illegal characters are not present -->
     <xs:restriction base="xs:string">
       <xs:pattern value="[0-9\+\-,\.eE\s]*"/>
@@ -122,15 +125,15 @@
       <xs:whiteSpace value="collapse"/>
     </xs:restriction>
   </xs:simpleType>
   <xs:complexType name="DataPoint">
     <xs:sequence>
       <xs:element name="properties" type="Properties" minOccurs="0"/>
     </xs:sequence>
-    <xs:attribute name="name" type="PhysDimName"/>
+    <xs:attribute name="name" type="PhysDimName" use="required"/>
     <xs:attribute name="type" type="StorageType" use="required"/>
     <xs:attribute name="units" type="xs:token" use="required"/>
   </xs:complexType>
   <!-- Multi Value per packet physical dimenions, spanning 2 coordinates -->
   <xs:complexType name="DataRow">
     <xs:sequence>
       <xs:element name="properties" type="Properties" minOccurs="0"/>
@@ -154,26 +157,21 @@
     </xs:sequence>
   </xs:complexType>
   <!-- A packet may have one of these as the top level element -->
   <xs:element name="packet" type="Dataset"/>
   <!-- Exceptions =========================================================== -->
   <xs:element name="exception">
     <xs:complexType>
-      <xs:simpleContent>
-        <xs:extension base="xs:string">
-          <xs:attribute name="type" type="xs:token" use="required"/>
-        </xs:extension>
-      </xs:simpleContent>
+      <xs:attribute name="type" type="xs:token" use="required"/>
+      <xs:attribute name="message" type="xs:string" use="required"/>
     </xs:complexType>
   </xs:element>
   <!-- Comments ============================================================= -->
+  <!-- das2.2 comments put the value in an attribute which is odd -->
   <xs:element name="comment">
     <xs:complexType>
-      <xs:simpleContent>
-        <xs:extension base="xs:string">
-          <xs:attribute name="type" type="xs:token" use="required"/>
-          <xs:attribute name="source" type="xs:normalizedString"/>
-        </xs:extension>
-      </xs:simpleContent>
+      <xs:attribute name="type" type="xs:token" use="required"/>
+      <xs:attribute name="source" type="xs:normalizedString" use="required"/>
+      <xs:attribute name="value" type="xs:string" use="required"/>
     </xs:complexType>
   </xs:element>
 </xs:schema>
```

## das2/xsd/das-basic-stream-v3.0.xsd

### das2/xsd/das-basic-stream-v3.0.xsd

```diff
@@ -8,15 +8,15 @@
 
   See the file das2-basic-stream-ns-v3.0.xsd for a multi-root schema 
   definition for files using a declared namespace
 
   See the file das2-basic-doc-v3.0.xsd for a single-root schema definition
   suitable for validating standard (i.e. non-packitized) documents.
 
-  version 3.0, release candidate 1, 2023-07-23.
+  version 3.0, release candidate 2, 2024-05-27.
 -->
 <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" version="3.0" elementFormDefault="qualified" attributeFormDefault="unqualified">
   <!-- targetNamespace="das-basic-stream" xmlns="das-basic-stream" -->
   <!-- General Fields -->
   <!-- The names for things that could be variables in most languages -->
   <xs:simpleType name="VarName">
     <xs:restriction base="xs:string">
@@ -55,42 +55,81 @@
   <xs:complexType name="AltProp">
     <xs:simpleContent>
       <xs:extension base="xs:string">
         <xs:attribute name="lang" type="ISO639_1" use="required"/>
       </xs:extension>
     </xs:simpleContent>
   </xs:complexType>
-  <!-- The data types for properties. Same as ValueType below with ranges -->
+  <!-- The data types for properties. Same as "Semantic" but with ranges -->
   <xs:simpleType name="PropType">
     <xs:restriction base="xs:string">
       <xs:enumeration value="bool"/>
+      <xs:enumeration value="boolArray"/>
       <xs:enumeration value="datetime"/>
       <xs:enumeration value="datetimeRange"/>
-      <xs:enumeration value="int"/>
-      <xs:enumeration value="intRange"/>
+      <xs:enumeration value="datetimeArray"/>
+      <xs:enumeration value="integer"/>
+      <xs:enumeration value="integerRange"/>
+      <xs:enumeration value="integerArray"/>
       <xs:enumeration value="real"/>
       <xs:enumeration value="realRange"/>
+      <xs:enumeration value="realArray"/>
       <xs:enumeration value="string"/>
+      <xs:enumeration value="stringArray"/>
+    </xs:restriction>
+  </xs:simpleType>
+  <xs:simpleType name="Bool">
+    <xs:restriction base="xs:string">
+      <xs:pattern value="[tTfF01]|true|false"/>
+    </xs:restriction>
+  </xs:simpleType>
+  <xs:simpleType name="Terminator">
+    <xs:restriction base="xs:string">
+      <!-- Anything but a pipe, higher level parsing may disqualify many patterns -->
+      <xs:pattern value="([ -{]|[}~];)+"/>
+      <xs:pattern value="\\n"/>
     </xs:restriction>
   </xs:simpleType>
   <!-- Single property -->
   <xs:complexType name="Property" mixed="true">
     <xs:sequence>
       <xs:element name="alt" type="AltProp" minOccurs="0" maxOccurs="unbounded"/>
     </xs:sequence>
     <xs:attribute name="name" type="StructName" use="required"/>
     <xs:attribute name="type" type="PropType" default="string"/>
     <xs:attribute name="units" type="xs:token"/>
+    <xs:attribute name="sep" type="Terminator" default=" "/>
   </xs:complexType>
   <!-- Properties grouping -->
   <xs:complexType name="Properties">
     <xs:sequence>
       <xs:element name="p" type="Property" minOccurs="0" maxOccurs="unbounded"/>
     </xs:sequence>
   </xs:complexType>
+  <!-- Coordinate Frames =================================================== -->
+  <!-- These are independent of any particular values and assign DIRECTIONALTY
+     ONLY!  Frame components have no units.  These are not to be confused with
+     the "axis" values from <coord>.  The attribute "axis" is a graphical display
+     directive and refers to a display axis, not a physical axis.  
+
+     The two can be made to coincide by using the optional "frame" and "component"
+     attributes of <coord>
+-->
+  <xs:complexType name="FrameDirection">
+    <xs:attribute name="name" type="VarName" use="required"/>
+  </xs:complexType>
+  <xs:complexType name="Frame">
+    <xs:sequence>
+      <xs:element name="properties" type="Properties" minOccurs="0" maxOccurs="1"/>
+      <xs:element name="dir" type="FrameDirection" minOccurs="1" maxOccurs="9"/>
+    </xs:sequence>
+    <xs:attribute name="name" type="StructName" use="required"/>
+    <xs:attribute name="type" type="VarName" use="required"/>
+    <xs:attribute name="inertial" type="Bool"/>
+  </xs:complexType>
   <!-- Extensions ========================================================== -->
   <!-- Extension tags can hold anything except for elements defined in this
   namespace.  They can also have any attributes.  Client stream processors
   should pass stream-level extension elements unchanged dataset level 
   extension element handling is undefined 
 -->
   <xs:complexType name="Extension" mixed="true">
@@ -131,29 +170,26 @@
 -->
   <!-- The understood plot type strings -->
   <xs:simpleType name="PlotType">
     <xs:restriction base="xs:string">
       <xs:pattern value="(cartesian2d|cartesian3d|polar|cylindrical|spherical)(:movie)?"/>
     </xs:restriction>
   </xs:simpleType>
-  <xs:simpleType name="Direction">
+  <!-- This has to be multi-valued because breaking natural vector coordinates
+     into individual scalars makes parsing and plotting code more convoluted.
+     See description of each plot axis name in "Dataset" type definition below.
+-->
+  <xs:simpleType name="PlotDirection">
     <xs:restriction base="xs:string">
-      <xs:enumeration value="x"/>
-      <xs:enumeration value="y"/>
-      <xs:enumeration value="z"/>
-      <xs:enumeration value="ρ"/>
-      <!-- radius cylindrical -->
-      <xs:enumeration value="r"/>
-      <!-- radius spherical & polar -->
-      <xs:enumeration value="θ"/>
-      <!-- polar angle -->
-      <xs:enumeration value="φ"/>
-      <!-- azimuthal angle in x-y plane -->
-      <xs:enumeration value="t"/>
-      <!-- for movies, not time on a space axis -->
+      <xs:pattern value="[xyzρrθφt](;[xyzρrθφt])*"/>
+      <!-- ρ: radius cylindrical -->
+      <!-- r: radius spherical & polar -->
+      <!-- θ: polar angle -->
+      <!-- φ: azimuthal angle in x-y plane -->
+      <!-- t: for movies, not time on a space axis -->
     </xs:restriction>
   </xs:simpleType>
   <!-- The Index space definition for this dataset.
 
   Just as the plot type can define the graphical space for a dataset,
   this defines the value lookup space.
 
@@ -223,24 +259,35 @@
       <xs:minInclusive value="2"/>
       <xs:maxInclusive value="2147483647"/>
     </xs:restriction>
   </xs:simpleType>
   <xs:simpleType name="EmptyPosInt">
     <xs:union memberTypes="IntTwoOrMore Empty"/>
   </xs:simpleType>
-  <!-- The data types for values, does not support ranges -->
-  <xs:simpleType name="ValueType">
+  <!-- The understanding of what kind of value this is, is it a countable (int), 
+     a state (bool), a floating point number (real), a calendar date (datetime),
+     or just some information (string) -->
+  <xs:simpleType name="Semantic">
     <xs:restriction base="xs:string">
       <xs:pattern value="bool|datetime|int|real|string"/>
     </xs:restriction>
   </xs:simpleType>
+  <!-- What kind of arrays and values in memory should be used for this item
+     Since some languages don't support unsigned types and can use the next
+     larger signed type
+-->
+  <xs:simpleType name="Storage">
+    <xs:restriction base="xs:string">
+      <xs:pattern value="byte|ubyte|short|ushort|int|uint|long|ulong|float|double|string|struct"/>
+    </xs:restriction>
+  </xs:simpleType>
   <!-- Data value types in packets, sizes and formats -->
   <xs:simpleType name="EncodingType">
     <xs:restriction base="xs:string">
-      <xs:pattern value="none|byte|ubyte|utf8|BEint|BEuint|BEreal|LEint|LEuint|LEreal"/>
+      <xs:pattern value="byte|ubyte|BEint|BEuint|BEreal|LEint|LEuint|LEreal|utf8|none"/>
     </xs:restriction>
   </xs:simpleType>
   <xs:simpleType name="ValuesContent">
     <!-- The regex for scientific notation is looooong, just make sure
        illegal characters are not present -->
     <xs:restriction base="xs:string">
       <xs:pattern value="[0-9\+\-;\.eE\s]*"/>
@@ -251,60 +298,57 @@
     <xs:restriction base="xs:string">
       <xs:pattern value="none|whole|each"/>
     </xs:restriction>
   </xs:simpleType>
   <!-- Variable length data values
 
   By default no terminators are defined and an app must rely on itemBytes in
-  <packet> is used to determine where fields end.  Alternatively fexible width
-  fields may be used in one of two ways:
+  <packet> is used to determine where fields end. 
 
-     1. Provide a length tag before each value, ex: "|17|Some event string"
+  The terminator is interpreted according to the valType.  So for a real item
+  a terminator of:
 
-     2. Provide a value terminator.  Unlike separators in most languages, 
-        terminators MUST follow each value, even the last value.
+     0
 
-  In either case, specify that values are variable length using itemsBytes="*"
-  and if terminators are in use, give the terminator character which must be 
-  from the set | \ ? : ; ~ # ^ @ $.
+  is taken to be the floating point value 0.0.  For text encoding the terminator
+  is taken to be a single byte.
 
-  The suggested value terminator is ";" though no default is given.
+  The special values \n, and NaN are understood.  Note that for ragged arrays
+  in more then one index a DIFFERENT terminator is needed for each array dimension.
 -->
-  <xs:simpleType name="Terminator">
+  <xs:simpleType name="TermList">
     <xs:restriction base="xs:string">
-      <xs:pattern value="[\|/\\\?:;~#\^@$]"/>
-      <xs:pattern value="\\n"/>
-      <!-- <xs:pattern value="[\|\\/\?:;~\^$#@]" /> -->
+      <xs:pattern value="([; -{]|[}~])+(\|([ -{]|[}~])+)*"/>
     </xs:restriction>
   </xs:simpleType>
   <!-- An array variable in the header -->
   <xs:complexType name="Values">
     <xs:simpleContent>
       <xs:extension base="ValuesContent">
         <xs:attribute name="repeat" type="ValRepeat" default="none"/>
         <xs:attribute name="repetitions" type="xs:positiveInteger"/>
         <!-- Since values elements have a natural end point, no terminator
-        is needed for the last value, so they are called separators here -->
-        <xs:attribute name="valSep" type="Terminator" default=";"/>
+        is needed for the last value -->
+        <xs:attribute name="valTerm" type="Terminator" default=" "/>
       </xs:extension>
     </xs:simpleContent>
   </xs:complexType>
   <xs:complexType name="Sequence">
-    <xs:attribute name="use" type="VarRole" default="center"/>
     <xs:attribute name="minval" type="xs:double" use="required"/>
     <xs:attribute name="interval" type="xs:double" use="required"/>
     <xs:attribute name="repeat" type="ValRepeat" default="none"/>
     <xs:attribute name="repetitions" type="xs:positiveInteger"/>
   </xs:complexType>
   <xs:complexType name="Packet">
     <xs:attribute name="numItems" type="NonZeroStar" use="required"/>
     <xs:attribute name="itemBytes" type="NonZeroStar" use="required"/>
     <xs:attribute name="encoding" type="EncodingType" use="required"/>
     <xs:attribute name="fill" type="xs:string"/>
     <xs:attribute name="valTerm" type="Terminator"/>
+    <xs:attribute name="itemsTerm" type="TermList"/>
   </xs:complexType>
   <!-- The purposes for values of a variable -->
   <xs:simpleType name="VarRole">
     <xs:restriction base="xs:string">
       <xs:enumeration value="center"/>
       <xs:enumeration value="offset"/>
       <xs:enumeration value="average"/>
@@ -323,57 +367,64 @@
     <xs:choice>
       <xs:element name="values" type="Values"/>
       <xs:element name="sequence" type="Sequence"/>
       <xs:element name="packet" type="Packet"/>
     </xs:choice>
     <xs:attribute name="use" type="VarRole" default="center"/>
     <xs:attribute name="units" type="xs:token" use="required"/>
-    <xs:attribute name="valType" type="ValueType" use="required"/>
+    <xs:attribute name="storage" type="Storage"/>
+    <xs:attribute name="semantic" type="Semantic" use="required"/>
     <xs:attribute name="index" type="VarIndexShape" use="required"/>
   </xs:complexType>
   <!-- Vectors, Inherit from scalars and add elements ======== -->
-  <xs:complexType name="Component">
-    <xs:attribute name="name" type="VarName" use="required"/>
+  <xs:complexType name="VecComponent">
+    <xs:attribute name="dir" type="VarName" use="required"/>
     <xs:attribute name="units" type="xs:token"/>
   </xs:complexType>
   <xs:simpleType name="VectorClass">
     <xs:restriction base="xs:string">
       <xs:enumeration value="cartesian"/>
       <xs:enumeration value="polar"/>
       <xs:enumeration value="spherical"/>
       <!-- More?? -->
     </xs:restriction>
   </xs:simpleType>
   <xs:complexType name="VectorVar">
     <xs:sequence>
-      <xs:element name="component" type="Component" minOccurs="2" maxOccurs="3"/>
+      <xs:element name="component" type="VecComponent" minOccurs="1" maxOccurs="3"/>
       <xs:choice>
         <xs:element name="values" type="Values"/>
         <xs:element name="sequence" type="Sequence"/>
         <xs:element name="packet" type="Packet"/>
       </xs:choice>
     </xs:sequence>
     <xs:attribute name="use" type="VarRole" default="center"/>
     <xs:attribute name="units" type="xs:token" use="required"/>
-    <xs:attribute name="valType" type="ValueType" use="required"/>
+    <xs:attribute name="semantic" type="Semantic" use="required"/>
+    <xs:attribute name="storage" type="Storage"/>
     <xs:attribute name="index" type="VarIndexShape" use="required"/>
-    <xs:attribute name="vecClass" type="VectorClass" use="required"/>
+    <!-- deprecated -->
+    <xs:attribute name="vecClass" type="VectorClass"/>
   </xs:complexType>
   <!-- Physical Dimensions ================================================= -->
   <xs:complexType name="CoordDim">
     <xs:sequence>
       <xs:element name="properties" type="Properties" minOccurs="0"/>
-      <!-- For v3.0/basic only allow scalar types in coordinates -->
-      <!-- <xs:choice minOccurs="1" maxOccurs="unbounded">  -->
-      <xs:element name="scalar" type="ScalarVar" minOccurs="1" maxOccurs="unbounded"/>
-      <!-- <xs:element name="vector" type="VectorVar" /> -->
-      <!-- </xs:choice> -->
+      <xs:choice minOccurs="1" maxOccurs="unbounded">
+        <xs:element name="scalar" type="ScalarVar" minOccurs="1" maxOccurs="unbounded"/>
+        <xs:element name="vector" type="VectorVar"/>
+      </xs:choice>
     </xs:sequence>
     <xs:attribute name="physDim" type="PhysDimName" use="required"/>
-    <xs:attribute name="axis" type="Direction" use="required"/>
+    <xs:attribute name="axis" type="PlotDirection" use="required"/>
+    <xs:attribute name="frame" type="StructName"/>
+    <!-- No need to provide for single component coordinates, if they are
+       vectors, put them together as a vector so that they can be transform
+       as a vector, using things like SPICE -->
+    <!-- <xs:attribute name="dir" type="VarName"  /> -->
   </xs:complexType>
   <xs:complexType name="DataDim">
     <xs:sequence>
       <xs:element name="properties" type="Properties" minOccurs="0"/>
       <xs:choice minOccurs="1" maxOccurs="unbounded">
         <xs:element name="scalar" type="ScalarVar"/>
         <xs:element name="vector" type="VectorVar"/>
@@ -382,14 +433,15 @@
     <xs:attribute name="physDim" type="PhysDimName" use="required"/>
     <!-- 
   Data items must have unique names, however the name inherits from the overall
   dataset name.  So if you only have one <data> or <extData> element, the name
   isn't needed
   -->
     <xs:attribute name="name" type="StructName"/>
+    <xs:attribute name="frame" type="StructName"/>
   </xs:complexType>
   <!-- Extended data objects in an extended data section -->
   <xs:complexType name="DataObject">
     <xs:sequence>
       <xs:element name="packet" type="Packet" minOccurs="1" maxOccurs="unbounded"/>
     </xs:sequence>
     <xs:attribute name="scheme" type="xs:string" use="required"/>
@@ -473,14 +525,15 @@
     <xs:restriction base="xs:string">
       <xs:enumeration value="das-basic-stream"/>
     </xs:restriction>
   </xs:simpleType>
   <xs:complexType name="Stream">
     <xs:sequence>
       <xs:element name="properties" type="Properties" minOccurs="0"/>
+      <xs:element name="frame" type="Frame" minOccurs="0" maxOccurs="unbounded"/>
       <xs:element name="extension" type="Extension" minOccurs="0" maxOccurs="unbounded"/>
     </xs:sequence>
     <xs:attribute name="type" type="StreamType" use="required"/>
     <xs:attribute name="version" type="StreamVersion" use="required"/>
     <xs:attribute name="lang" type="ISO639_1" default="en"/>
   </xs:complexType>
   <!-- Exceptions =========================================================== -->
```

## Comparing `das2py-2.3.1.dist-info/LICENSE` & `das2py-3.0rc1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `das2py-2.3.1.dist-info/METADATA` & `das2py-3.0rc1.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: das2py
-Version: 2.3.1
+Version: 3.0rc1
 Summary: An efficient space physics data client for python
 Home-page: https://das2.org/das2py
 Author: C Piker
 Author-email: C Piker <cpiker@users.noreply.github.com>
 Maintainer-email: K Steele <KaiwenS7@users.noreply.github.com>
 License: MIT License
         
@@ -27,15 +27,15 @@
         LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
         OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
         SOFTWARE.
         
 Project-URL: Homepage, https://das2.org/das2py
 Project-URL: Repository, https://github.com/das-developers/das2py
 Keywords: space-physics,magneosphere,das2
-Requires-Python: >=2.7
+Requires-Python: >=3.5
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: numpy
 Requires-Dist: lxml
 
 # das2py
 Das2 servers typically provide data relevant to space plasma and magnetospheric
```

## Comparing `das2py-2.3.1.dist-info/RECORD` & `das2py-3.0rc1.dist-info/RECORD`

 * *Files 26% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-_das2.cp310-win_amd64.pyd,sha256=6BFC8fLnv1UfHK0wqpfvZls2dgL6UgzbR4zOOFvs_Yw,4867072
-das2/__init__.py,sha256=wedmGdwyP2QoBX6JJyxxpf_oUHdllI0SpSEVgvvPJ6A,12977
-das2/auth.py,sha256=vzJ2QYfwrIgz-MsHQ-JcJakmawRFIdPVqetDTmWs7js,4906
+_das2.cp310-win_amd64.pyd,sha256=nKbXVByf18Q3ByE8m3RquhWVkwIKFOwLAGvpUwn2hAw,4974592
+das2/__init__.py,sha256=cJZ-mvI2J4xHeTFh_rFTAGF6yiL5G0f4FtuZCpiPojk,13230
+das2/auth.py,sha256=Nse2IOc3EHWie9P0yjDszJIv8VOcU3MF6vUbAQsnBio,4964
 das2/cdf.py,sha256=IbiTB3o0_CUN_5VJLB1LfhwRB_SOWQ7ntW8uIfyt-MQ,13983
 das2/cli.py,sha256=lz7wj-C0fOhP8OqBVJzeHviFpqbvsbMOfQflbGPmDWs,42668
 das2/container.py,sha256=WWt6B68Tx8DqcTapbTafdcH09pBf8L8elbJpsT1ZzTo,6596
-das2/dastime.py,sha256=s-vE8AVY6ZNlyh1f0O8Dk3VL_bqehYwAq1J-9c_DzMc,21313
-das2/dataset.py,sha256=LoD3RVU5Q_6zdNr8lNyQKolry-j2nR1O8qBv3ZGQXIc,56674
+das2/dastime.py,sha256=9x3SNYUkTxrWvG83tcr5APaSb70651Rmid36kbOdvEk,21312
+das2/dataset.py,sha256=Snb38NTi4-gtSc5maETORR6gYdVDKizsBIzPFfOBbkg,57795
 das2/mpl.py,sha256=0d2nIA9CasbArJQ41pXtjZFkzMI_69TiYti2kOJzLH0,7143
 das2/node.py,sha256=uEj07kpSILPZHOPlnOoNERoW9IEEZtynTXQ2Q1SxYgE,5196
 das2/pkt.py,sha256=ft2uPKXSu5UpvZRDa45pIKtvyA2wyRe8v5aCdzrHKKA,8748
-das2/reader.py,sha256=0v834KWKh7IqU3P9enmBgDDm6EDh7pfc4yYoiT7O8mM,26095
+das2/reader.py,sha256=DZI6a3EOm0FZLYQGSgKgrBMD9zTVTYORb7KVf-QYuYg,26287
 das2/source.py,sha256=TOghGA871P9gU8D8OEMZDccEA1jUfW1WB4vB1u_ONMQ,11488
-das2/streamsrc.py,sha256=mFe7LVt27e4nxQIXI9z-qc67Ef2QMgYq53ojniuqeuk,36638
+das2/streamsrc.py,sha256=wg__hJ_qf63y4jdduMp6gSljQXc9teG5C-8nVxM1vLM,36646
 das2/toml.py,sha256=srGUOC0sh9tfyLu6trV58s6SnwuF-CsYVHrIoJq6Dgw,27056
 das2/util.py,sha256=5FIgv9pbteh1oZp3ekYr3TNVwF-iWPxAtue4mu7knWc,1763
-das2/verify.py,sha256=S9uisKe6nBC1zznuGUntQe6vvNQcOcvtEXKrBf_pk3E,10092
+das2/verify.py,sha256=rMyCFN1-2ePWbIALRZHbvwqfbfxMNRsG3EL8_ci_Ecc,10135
 das2/pycdf/__init__.py,sha256=m88z07PZSKE48aNK0ESWpwfikiu2eFV2loldqEIVZYY,200850
 das2/pycdf/const.py,sha256=hOHO_LqrvjGIkTs_GFe7gKfoylQ4AoP3f29yMsfpDDY,15270
-das2/xsd/das-basic-doc-ns-v3.0.xsd,sha256=Ubq_4Uq_oAmkIATfgS_ReA_1Ct624cqfEJYdDPPY-PU,20992
-das2/xsd/das-basic-stream-ns-v3.0.xsd,sha256=VBfmBkGs0ZFmtKIeaBUj_uIcRAsGezHjrP9AklvG87M,21375
-das2/xsd/das-basic-stream-v2.2.xsd,sha256=NRaW8kYWkk9gBzhy9YvV68NS7few4f2bPAWDqs40XSM,7456
-das2/xsd/das-basic-stream-v3.0.xsd,sha256=kwxlG5u0c5DvttZd_k5bkmSdvq0VVdxHSfi8csZvkas,21359
-das2py-2.3.1.data/scripts/das_verify,sha256=LHssMtM98Fyk257V49wKQpPn0pOQJFA7j6udT9xT8xk,54
-das2py-2.3.1.dist-info/LICENSE,sha256=-59SN-PluCIeBckyTm06vHW0fCywuS1_-fuxu3paesg,1068
-das2py-2.3.1.dist-info/METADATA,sha256=B-ymnnYtKE53h3M6scU3rv1_Q6sR5xrF7ndLPhZGqQA,8796
-das2py-2.3.1.dist-info/WHEEL,sha256=QZRFZfINHXboTe9fmBqbFIViCGEqzQrgdxTyahla7mM,102
-das2py-2.3.1.dist-info/entry_points.txt,sha256=5moWxnD9vnLdBmz8AB7p51flLRgOHaSIVJ3wm-qhP5s,48
-das2py-2.3.1.dist-info/top_level.txt,sha256=hgRRjqKutoatfhBRcAWUPz8MXaRi74CzSMABkVH4baA,11
-das2py-2.3.1.dist-info/RECORD,,
+das2/xsd/das-basic-doc-ns-v3.0.xsd,sha256=JXIr81nOgbOba14oEbxCkZ9AmwzOeh_N0jRAq40T0dM,22743
+das2/xsd/das-basic-stream-ns-v3.0.xsd,sha256=dhO1J22Q9SvdoWLSnG5BrbLDqV33c3s7lu_HwoPgtu0,23783
+das2/xsd/das-basic-stream-v2.2.xsd,sha256=ICyV246jhhiNAsR8a0vV6nvo7U5l2ox8JfzTmZFJiYk,7520
+das2/xsd/das-basic-stream-v3.0.xsd,sha256=ak2ZUMGAOzcKiPpDT-ptXsR8DvzWdtO2CIyNprIcSeY,23873
+das2py-3.0rc1.data/scripts/das_verify,sha256=LHssMtM98Fyk257V49wKQpPn0pOQJFA7j6udT9xT8xk,54
+das2py-3.0rc1.dist-info/LICENSE,sha256=-59SN-PluCIeBckyTm06vHW0fCywuS1_-fuxu3paesg,1068
+das2py-3.0rc1.dist-info/METADATA,sha256=XZIBOxSmWb1xwdtPzajYzAQgX3FB2T7YM5isaq0lROQ,8797
+das2py-3.0rc1.dist-info/WHEEL,sha256=lO6CqtLHCAi38X3Es1a4R1lAjZFvN010IMRCFo2S7Mc,102
+das2py-3.0rc1.dist-info/entry_points.txt,sha256=5moWxnD9vnLdBmz8AB7p51flLRgOHaSIVJ3wm-qhP5s,48
+das2py-3.0rc1.dist-info/top_level.txt,sha256=hgRRjqKutoatfhBRcAWUPz8MXaRi74CzSMABkVH4baA,11
+das2py-3.0rc1.dist-info/RECORD,,
```

