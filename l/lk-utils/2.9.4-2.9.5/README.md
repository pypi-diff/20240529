# Comparing `tmp/lk_utils-2.9.4-py3-none-any.whl.zip` & `tmp/lk_utils-2.9.5-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,28 +1,26 @@
-Zip file size: 25181 bytes, number of entries: 26
--rw-r--r--  2.0 unx     1750 b- defN 80-Jan-01 00:00 lk_utils/__init__.py
--rw-r--r--  2.0 unx      847 b- defN 80-Jan-01 00:00 lk_utils/__main__.py
--rw-r--r--  2.0 unx      185 b- defN 80-Jan-01 00:00 lk_utils/binding/__init__.py
--rw-r--r--  2.0 unx     2016 b- defN 80-Jan-01 00:00 lk_utils/binding/binding.py
--rw-r--r--  2.0 unx      696 b- defN 80-Jan-01 00:00 lk_utils/binding/defer.py
--rw-r--r--  2.0 unx     6350 b- defN 80-Jan-01 00:00 lk_utils/binding/signal.py
--rw-r--r--  2.0 unx      410 b- defN 80-Jan-01 00:00 lk_utils/common_typing.py
--rw-r--r--  2.0 unx      141 b- defN 80-Jan-01 00:00 lk_utils/filesniff/__init__.py
--rw-r--r--  2.0 unx     9735 b- defN 80-Jan-01 00:00 lk_utils/filesniff/finder.py
--rw-r--r--  2.0 unx     6772 b- defN 80-Jan-01 00:00 lk_utils/filesniff/main.py
--rw-r--r--  2.0 unx     3753 b- defN 80-Jan-01 00:00 lk_utils/filesniff/shutil.py
--rw-r--r--  2.0 unx      582 b- defN 80-Jan-01 00:00 lk_utils/filesniff/traceback.py
--rw-r--r--  2.0 unx     1056 b- defN 80-Jan-01 00:00 lk_utils/importer.py
--rw-r--r--  2.0 unx     6455 b- defN 80-Jan-01 00:00 lk_utils/read_and_write.py
--rw-r--r--  2.0 unx      495 b- defN 80-Jan-01 00:00 lk_utils/subproc/__init__.py
--rw-r--r--  2.0 unx      606 b- defN 80-Jan-01 00:00 lk_utils/subproc/multiprocess.py
--rw-r--r--  2.0 unx     1816 b- defN 80-Jan-01 00:00 lk_utils/subproc/promise.py
--rw-r--r--  2.0 unx     5381 b- defN 80-Jan-01 00:00 lk_utils/subproc/subprocess.py
--rw-r--r--  2.0 unx     8592 b- defN 80-Jan-01 00:00 lk_utils/subproc/threading.py
--rw-r--r--  2.0 unx     1018 b- defN 80-Jan-01 00:00 lk_utils/textwrap.py
--rw-r--r--  2.0 unx      203 b- defN 80-Jan-01 00:00 lk_utils/time_utils/__init__.py
--rw-r--r--  2.0 unx     1533 b- defN 80-Jan-01 00:00 lk_utils/time_utils/time.py
--rw-r--r--  2.0 unx     5207 b- defN 80-Jan-01 00:00 lk_utils/time_utils/timeit.py
--rw-r--r--  2.0 unx     3897 b- defN 80-Jan-01 00:00 lk_utils-2.9.4.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 lk_utils-2.9.4.dist-info/WHEEL
-?rw-r--r--  2.0 unx     2124 b- defN 16-Jan-01 00:00 lk_utils-2.9.4.dist-info/RECORD
-26 files, 71708 bytes uncompressed, 21769 bytes compressed:  69.6%
+Zip file size: 24320 bytes, number of entries: 24
+-rw-r--r--  2.0 fat     1802 b- defN 80-Jan-01 00:00 lk_utils/__init__.py
+-rw-r--r--  2.0 fat      847 b- defN 80-Jan-01 00:00 lk_utils/__main__.py
+-rw-r--r--  2.0 fat      191 b- defN 80-Jan-01 00:00 lk_utils/binding/__init__.py
+-rw-r--r--  2.0 fat     2090 b- defN 80-Jan-01 00:00 lk_utils/binding/binding.py
+-rw-r--r--  2.0 fat     6566 b- defN 80-Jan-01 00:00 lk_utils/binding/signal.py
+-rw-r--r--  2.0 fat      426 b- defN 80-Jan-01 00:00 lk_utils/common_typing.py
+-rw-r--r--  2.0 fat      141 b- defN 80-Jan-01 00:00 lk_utils/filesniff/__init__.py
+-rw-r--r--  2.0 fat     9074 b- defN 80-Jan-01 00:00 lk_utils/filesniff/finder.py
+-rw-r--r--  2.0 fat     7036 b- defN 80-Jan-01 00:00 lk_utils/filesniff/main.py
+-rw-r--r--  2.0 fat     3903 b- defN 80-Jan-01 00:00 lk_utils/filesniff/shutil.py
+-rw-r--r--  2.0 fat      582 b- defN 80-Jan-01 00:00 lk_utils/filesniff/traceback.py
+-rw-r--r--  2.0 fat     6680 b- defN 80-Jan-01 00:00 lk_utils/read_and_write.py
+-rw-r--r--  2.0 fat      508 b- defN 80-Jan-01 00:00 lk_utils/subproc/__init__.py
+-rw-r--r--  2.0 fat      630 b- defN 80-Jan-01 00:00 lk_utils/subproc/multiprocess.py
+-rw-r--r--  2.0 fat     1886 b- defN 80-Jan-01 00:00 lk_utils/subproc/promise.py
+-rw-r--r--  2.0 fat     5574 b- defN 80-Jan-01 00:00 lk_utils/subproc/subprocess.py
+-rw-r--r--  2.0 fat     8878 b- defN 80-Jan-01 00:00 lk_utils/subproc/threading.py
+-rw-r--r--  2.0 fat     1059 b- defN 80-Jan-01 00:00 lk_utils/textwrap.py
+-rw-r--r--  2.0 fat      210 b- defN 80-Jan-01 00:00 lk_utils/time_utils/__init__.py
+-rw-r--r--  2.0 fat     1594 b- defN 80-Jan-01 00:00 lk_utils/time_utils/time.py
+-rw-r--r--  2.0 fat     5384 b- defN 80-Jan-01 00:00 lk_utils/time_utils/timeit.py
+-rw-r--r--  2.0 fat     3897 b- defN 80-Jan-01 00:00 lk_utils-2.9.5.dist-info/METADATA
+-rw-r--r--  2.0 fat       88 b- defN 80-Jan-01 00:00 lk_utils-2.9.5.dist-info/WHEEL
+?rw-r--r--  2.0 fat     1966 b- defN 16-Jan-01 00:00 lk_utils-2.9.5.dist-info/RECORD
+24 files, 71012 bytes uncompressed, 21150 bytes compressed:  70.2%
```

## zipnote {}

```diff
@@ -6,17 +6,14 @@
 
 Filename: lk_utils/binding/__init__.py
 Comment: 
 
 Filename: lk_utils/binding/binding.py
 Comment: 
 
-Filename: lk_utils/binding/defer.py
-Comment: 
-
 Filename: lk_utils/binding/signal.py
 Comment: 
 
 Filename: lk_utils/common_typing.py
 Comment: 
 
 Filename: lk_utils/filesniff/__init__.py
@@ -30,17 +27,14 @@
 
 Filename: lk_utils/filesniff/shutil.py
 Comment: 
 
 Filename: lk_utils/filesniff/traceback.py
 Comment: 
 
-Filename: lk_utils/importer.py
-Comment: 
-
 Filename: lk_utils/read_and_write.py
 Comment: 
 
 Filename: lk_utils/subproc/__init__.py
 Comment: 
 
 Filename: lk_utils/subproc/multiprocess.py
@@ -63,17 +57,17 @@
 
 Filename: lk_utils/time_utils/time.py
 Comment: 
 
 Filename: lk_utils/time_utils/timeit.py
 Comment: 
 
-Filename: lk_utils-2.9.4.dist-info/METADATA
+Filename: lk_utils-2.9.5.dist-info/METADATA
 Comment: 
 
-Filename: lk_utils-2.9.4.dist-info/WHEEL
+Filename: lk_utils-2.9.5.dist-info/WHEEL
 Comment: 
 
-Filename: lk_utils-2.9.4.dist-info/RECORD
+Filename: lk_utils-2.9.5.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## lk_utils/__init__.py

```diff
@@ -1,52 +1,52 @@
-if 1:
-    import lk_logger
-    lk_logger.setup(quiet=True, show_funcname=False, show_varnames=True)
-
-from . import binding
-from . import common_typing as t
-from . import common_typing as typing
-from . import filesniff
-from . import filesniff as fs
-from . import read_and_write
-from . import read_and_write as rw
-from . import subproc
-from . import textwrap
-from . import time_utils  # TODO: rename to "time"?
-from .binding import Signal
-from .binding import bind_with
-from .binding import call_once
-from .filesniff import cd_current_dir
-from .filesniff import find_dir_names
-from .filesniff import find_dir_paths
-from .filesniff import find_dirs
-from .filesniff import find_file_names
-from .filesniff import find_file_paths
-from .filesniff import find_files
-from .filesniff import findall_dir_names
-from .filesniff import findall_dir_paths
-from .filesniff import findall_dirs
-from .filesniff import findall_file_names
-from .filesniff import findall_file_paths
-from .filesniff import findall_files
-from .filesniff import get_current_dir
-from .filesniff import make_link as mklink
-from .filesniff import make_links as mklinks
-from .filesniff import normpath
-from .filesniff import xpath
-from .filesniff import xpath as relpath  # backward compatible
-# from .importer import get_module
-# from .importer import get_package
-# from .importer import load_module
-# from .importer import load_package
-from .read_and_write import dumps
-from .read_and_write import loads
-from .read_and_write import ropen
-from .read_and_write import wopen
-from .subproc import new_thread
-from .subproc import run_cmd_args
-from .subproc import run_cmd_line
-from .subproc import run_new_thread
-from .time_utils import timestamp
-from .time_utils import wait
-
-__version__ = '2.9.4'
+if 1:
+    import lk_logger
+    lk_logger.setup(quiet=True, show_funcname=False, show_varnames=True)
+
+from . import binding
+from . import common_typing as t
+from . import common_typing as typing
+from . import filesniff
+from . import filesniff as fs
+from . import read_and_write
+from . import read_and_write as rw
+from . import subproc
+from . import textwrap
+from . import time_utils  # TODO: rename to "time"?
+from .binding import Signal
+from .binding import bind_with
+from .binding import call_once
+from .filesniff import cd_current_dir
+from .filesniff import find_dir_names
+from .filesniff import find_dir_paths
+from .filesniff import find_dirs
+from .filesniff import find_file_names
+from .filesniff import find_file_paths
+from .filesniff import find_files
+from .filesniff import findall_dir_names
+from .filesniff import findall_dir_paths
+from .filesniff import findall_dirs
+from .filesniff import findall_file_names
+from .filesniff import findall_file_paths
+from .filesniff import findall_files
+from .filesniff import get_current_dir
+from .filesniff import make_link as mklink
+from .filesniff import make_links as mklinks
+from .filesniff import normpath
+from .filesniff import xpath
+from .filesniff import xpath as relpath  # backward compatible
+# from .importer import get_module
+# from .importer import get_package
+# from .importer import load_module
+# from .importer import load_package
+from .read_and_write import dumps
+from .read_and_write import loads
+from .read_and_write import ropen
+from .read_and_write import wopen
+from .subproc import new_thread
+from .subproc import run_cmd_args
+from .subproc import run_cmd_line
+from .subproc import run_new_thread
+from .time_utils import timestamp
+from .time_utils import wait
+
+__version__ = '2.9.5'
```

## lk_utils/binding/__init__.py

 * *Ordering differences only*

```diff
@@ -1,6 +1,6 @@
-from .binding import bind_with
-from .binding import call_once
-# from .defer import define_later
-# from .defer import iterate_later
-from .signal import Signal
-from .signal import config
+from .binding import bind_with
+from .binding import call_once
+# from .defer import define_later
+# from .defer import iterate_later
+from .signal import Signal
+from .signal import config
```

## lk_utils/binding/binding.py

 * *Ordering differences only*

```diff
@@ -1,74 +1,74 @@
-import typing as t
-
-from .signal import get_func_id
-
-
-class T:
-    Func = t.TypeVar('Func', bound=t.Callable[[], t.Any])
-    FuncWrapper = t.Callable[[Func], Func]
-    Trigger = t.Callable  # callable[[func, *args, **kwargs], any]
-
-
-class TARGET:
-    pass
-
-
-_bound_funcs = set()
-
-
-def call_once(*_args, **_kwargs) -> T.FuncWrapper:
-    def wrapper(func: T.Func) -> T.Func:
-        func(*_args, **_kwargs)
-        return func
-    return wrapper
-
-
-def bind_with(trigger: T.Trigger) -> T.FuncWrapper:
-    def decorator(func: T.Func) -> T.Func:
-        if (x := (id(trigger), get_func_id(func))) not in _bound_funcs:
-            _bound_funcs.add(x)
-            trigger(func)
-        return func
-    return decorator
-
-
-# -----------------------------------------------------------------------------
-
-
-# def call_once(*_args, **_kwargs) -> T.FuncWrapper:
-#     def decorator(func: T.Func) -> T.Func:
-#         func(*_args, **_kwargs)
-#         return func
-#     return decorator
-#
-#
-# def bind(
-#     trigger: t.Callable,
-#     *_args,
-#     **_kwargs,
-#     # args: tuple = (TARGET,),
-#     # kwargs: dict = None,
-#     # *,
-#     # args0: t.Optional[tuple] = None,
-#     # kwargs0: t.Optional[dict] = None,
-#     # args1: t.Optional[tuple] = None,
-#     # kwargs1: t.Optional[dict] = None,
-# ) -> t.Callable[[T.Func], T.Func]:
-#     _is_func_in_params = bool(
-#         TARGET in _args or
-#         any(x is TARGET for x in _kwargs.values())
-#     )
-#
-#     def decorator(func: T.Func) -> T.Func:
-#         bound_id = (id(trigger), get_func_id(func))
-#         if bound_id not in _bound_funcs:
-#             _bound_funcs.add(bound_id)
-#             # if class `TARGET` in `_args` or in `_kwargs`, replace it \
-#             # with `func`.
-#             if _is_func_in_params:
-#                 args = (func if x is TARGET else x for x in _args)
-#                 kwargs = {k: (func if v is TARGET else v) for k, v in _kwargs.items()}
-#             trigger(*args, **kwargs)
-#         return func
-#
-#     return decorator
+import typing as t
+
+from .signal import get_func_id
+
+
+class T:
+    Func = t.TypeVar('Func', bound=t.Callable[[], t.Any])
+    FuncWrapper = t.Callable[[Func], Func]
+    Trigger = t.Callable  # callable[[func, *args, **kwargs], any]
+
+
+class TARGET:
+    pass
+
+
+_bound_funcs = set()
+
+
+def call_once(*_args, **_kwargs) -> T.FuncWrapper:
+    def wrapper(func: T.Func) -> T.Func:
+        func(*_args, **_kwargs)
+        return func
+    return wrapper
+
+
+def bind_with(trigger: T.Trigger) -> T.FuncWrapper:
+    def decorator(func: T.Func) -> T.Func:
+        if (x := (id(trigger), get_func_id(func))) not in _bound_funcs:
+            _bound_funcs.add(x)
+            trigger(func)
+        return func
+    return decorator
+
+
+# -----------------------------------------------------------------------------
+
+
+# def call_once(*_args, **_kwargs) -> T.FuncWrapper:
+#     def decorator(func: T.Func) -> T.Func:
+#         func(*_args, **_kwargs)
+#         return func
+#     return decorator
+#
+#
+# def bind(
+#     trigger: t.Callable,
+#     *_args,
+#     **_kwargs,
+#     # args: tuple = (TARGET,),
+#     # kwargs: dict = None,
+#     # *,
+#     # args0: t.Optional[tuple] = None,
+#     # kwargs0: t.Optional[dict] = None,
+#     # args1: t.Optional[tuple] = None,
+#     # kwargs1: t.Optional[dict] = None,
+# ) -> t.Callable[[T.Func], T.Func]:
+#     _is_func_in_params = bool(
+#         TARGET in _args or
+#         any(x is TARGET for x in _kwargs.values())
+#     )
+#
+#     def decorator(func: T.Func) -> T.Func:
+#         bound_id = (id(trigger), get_func_id(func))
+#         if bound_id not in _bound_funcs:
+#             _bound_funcs.add(bound_id)
+#             # if class `TARGET` in `_args` or in `_kwargs`, replace it \
+#             # with `func`.
+#             if _is_func_in_params:
+#                 args = (func if x is TARGET else x for x in _args)
+#                 kwargs = {k: (func if v is TARGET else v) for k, v in _kwargs.items()}
+#             trigger(*args, **kwargs)
+#         return func
+#
+#     return decorator
```

## lk_utils/binding/signal.py

 * *Ordering differences only*

```diff
@@ -1,216 +1,216 @@
-import re
-import textwrap
-import typing as t
-from contextlib import contextmanager
-from functools import partial
-from types import FunctionType
-
-
-class T:
-    DuplicateLocalsScheme = t.Literal['exclusive', 'ignore', 'override']
-    Func = t.Union[FunctionType, t.Callable]
-    # Func = FunctionType
-    # Func = t.Callable
-    FuncId = str
-    Funcs = t.Dict[FuncId, Func]
-
-
-class _Config:  # DELETE
-    duplicate_locals_scheme: T.DuplicateLocalsScheme = 'override'
-    # use_thread_pool: bool = False
-
-
-config = _Config()
-
-
-class Signal:
-    _funcs: T.Funcs
-
-    def __class_getitem__(cls, *_: t.Any) -> t.Type['Signal']:
-        """
-        use square brackets to annotate a signal type.
-        https://stackoverflow.com/a/68982326
-        usage:
-            some_signal: Signal[int, str]
-        """
-        return cls
-    
-    def __init__(self, *_) -> None:
-        self._funcs = {}
-    
-    def __bool__(self) -> bool:
-        return bool(self._funcs)
-    
-    def __len__(self) -> int:
-        return len(self._funcs)
-    
-    # decorator
-    def __call__(self, func: T.Func) -> T.Func:
-        self.bind(func)
-        return func
-    
-    def emit(self, *_args, error_level: int = 1, **_kwargs) -> None:
-        """
-        error_level: see `_PropagationChain._error_level:comment`
-        """
-        if not self._funcs: return
-
-        # print(self._funcs, ':l')
-        with _prop_chain.locking(self, error_level):
-            f: T.Func
-            for f in tuple(self._funcs.values()):
-                if _prop_chain.check(f):
-                    try:
-                        f(*_args, **_kwargs)
-                    except Exception as e:
-                        print(':e', e)
-                # else:  # TODO: should we break here or use `config` to decide?
-                #     break
-    
-    # DELETE: param `name` may be removed in future.
-    def bind(self, func: T.Func, name: str = None) -> T.FuncId:
-        id = name or get_func_id(func)
-        if (
-            id in self._funcs and
-            config.duplicate_locals_scheme == 'ignore'
-        ):
-            return id
-        self._funcs[id] = func
-        return id
-    
-    def unbind(self, func_or_id: t.Union[T.Func, T.FuncId]) -> None:
-        id = (
-            func_or_id if isinstance(func_or_id, str)
-            else get_func_id(func_or_id)
-        )
-        self._funcs.pop(id, None)
-    
-    def unbind_all(self) -> None:
-        self._funcs.clear()
-    
-    clear = unbind_all
-
-
-class _PropagationChain:
-    """
-    a chain to check and avoid infinite loop, which may be caused by mutual -
-    signal binding.
-    """
-    
-    _chain: t.List[T.FuncId]
-    _error_level: int
-    #   0: no error print
-    #   1: brief error print
-    #   2: detailed error print
-    #   3: detailed error print and raise error
-    _is_locked: bool
-    _lock_owner: t.Optional[Signal]
-    
-    def __init__(self) -> None:
-        self._chain = []
-        self._error_level = 0
-        self._is_locked = False
-        self._lock_owner = None
-    
-    # @property
-    # def chain(self) -> t.List[T.FuncId]:
-    #     return self._chain
-
-    @property
-    def lock_owner(self) -> t.Optional[Signal]:
-        return self._lock_owner
-    
-    @contextmanager
-    def locking(self, owner: Signal, error_level: int = 1) -> t.Iterator[None]:
-        self.lock(owner, error_level)
-        yield
-        self.unlock(owner)
-    
-    def check(self, func: T.Func) -> bool:
-        """
-        check if function already triggered in this propagation chain.
-        """
-        if (id := get_func_id(func)) not in self._chain:
-            self._chain.append(id)
-            return True
-        
-        def print_error_details() -> None:
-            chain = tuple(map(_pretty_id, self._chain))
-            if len(chain) == 1:
-                diagram = (
-                    '╭─▶ 1. {}'.format(chain[0]),
-                    '╰─x 2. {}'.format(chain[0]),
-                )
-            else:
-                diagram = (
-                    '╭─▶ 1. {}'.format(chain[0]),
-                    *(
-                        '│   {}. {}'.format(i, x) 
-                        for i, x in enumerate(chain[1:], 2)
-                    ),
-                    '╰─x {}. {}'.format(len(chain) + 1, chain[0]),
-                )
-
-            print(textwrap.dedent('''
-                signal prevented because of circular emissions:
-                    {}
-            ''').format(
-                textwrap.indent('\n'.join(diagram), '    ').lstrip()
-            ), ':p3v4s')
-
-        def _pretty_id(func_id: T.FuncId) -> str:
-            a, b, c = re.fullmatch(r'(.+)\((.+):(.+)\)', func_id).groups()
-            b = re.split(r'[/\\]', b)[-1]
-            return f'{a} ({b}:{c})'
-
-        if self._error_level == 1:
-            print('signal prevented because of circular emissions', ':p2vs')
-        elif self._error_level == 2:
-            print_error_details()
-        elif self._error_level == 3:
-            print_error_details()
-            raise RecursionError('circular signal emissions')
-        return False
-    
-    def lock(self, owner: Signal, error_level: int = 1) -> bool:
-        if self._lock_owner:
-            return False
-        # assert not self._chain
-        self._error_level = error_level
-        self._is_locked = True
-        self._lock_owner = owner
-        return True
-    
-    def unlock(self, controller: Signal) -> bool:
-        if controller is not self._lock_owner:
-            return False
-        self._chain.clear()
-        self._error_level = 0
-        self._is_locked = False
-        self._lock_owner = None
-        return True
-
-
-# def get_func_args_count(func: FunctionType) -> int:
-#     cnt = func.__code__.co_argcount - len(func.__defaults__ or ())
-#     if 'method' in str(func.__class__): cnt -= 1
-#     return cnt
-
-
-def get_func_id(func: T.Func) -> T.FuncId:
-    # related test: tests/duplicate_locals.py
-    if config.duplicate_locals_scheme == 'exclusive':
-        return str(id(func))
-    else:
-        # https://stackoverflow.com/a/46479810
-        if isinstance(func, partial):
-            func = func.func
-        # # return func.__qualname__
-        return '{}({}:{})'.format(
-            func.__qualname__,
-            func.__code__.co_filename, 
-            func.__code__.co_firstlineno,
-        )
-
-
-_prop_chain = _PropagationChain()
+import re
+import textwrap
+import typing as t
+from contextlib import contextmanager
+from functools import partial
+from types import FunctionType
+
+
+class T:
+    DuplicateLocalsScheme = t.Literal['exclusive', 'ignore', 'override']
+    Func = t.Union[FunctionType, t.Callable]
+    # Func = FunctionType
+    # Func = t.Callable
+    FuncId = str
+    Funcs = t.Dict[FuncId, Func]
+
+
+class _Config:  # DELETE
+    duplicate_locals_scheme: T.DuplicateLocalsScheme = 'override'
+    # use_thread_pool: bool = False
+
+
+config = _Config()
+
+
+class Signal:
+    _funcs: T.Funcs
+
+    def __class_getitem__(cls, *_: t.Any) -> t.Type['Signal']:
+        """
+        use square brackets to annotate a signal type.
+        https://stackoverflow.com/a/68982326
+        usage:
+            some_signal: Signal[int, str]
+        """
+        return cls
+    
+    def __init__(self, *_) -> None:
+        self._funcs = {}
+    
+    def __bool__(self) -> bool:
+        return bool(self._funcs)
+    
+    def __len__(self) -> int:
+        return len(self._funcs)
+    
+    # decorator
+    def __call__(self, func: T.Func) -> T.Func:
+        self.bind(func)
+        return func
+    
+    def emit(self, *_args, error_level: int = 1, **_kwargs) -> None:
+        """
+        error_level: see `_PropagationChain._error_level:comment`
+        """
+        if not self._funcs: return
+
+        # print(self._funcs, ':l')
+        with _prop_chain.locking(self, error_level):
+            f: T.Func
+            for f in tuple(self._funcs.values()):
+                if _prop_chain.check(f):
+                    try:
+                        f(*_args, **_kwargs)
+                    except Exception as e:
+                        print(':e', e)
+                # else:  # TODO: should we break here or use `config` to decide?
+                #     break
+    
+    # DELETE: param `name` may be removed in future.
+    def bind(self, func: T.Func, name: str = None) -> T.FuncId:
+        id = name or get_func_id(func)
+        if (
+            id in self._funcs and
+            config.duplicate_locals_scheme == 'ignore'
+        ):
+            return id
+        self._funcs[id] = func
+        return id
+    
+    def unbind(self, func_or_id: t.Union[T.Func, T.FuncId]) -> None:
+        id = (
+            func_or_id if isinstance(func_or_id, str)
+            else get_func_id(func_or_id)
+        )
+        self._funcs.pop(id, None)
+    
+    def unbind_all(self) -> None:
+        self._funcs.clear()
+    
+    clear = unbind_all
+
+
+class _PropagationChain:
+    """
+    a chain to check and avoid infinite loop, which may be caused by mutual -
+    signal binding.
+    """
+    
+    _chain: t.List[T.FuncId]
+    _error_level: int
+    #   0: no error print
+    #   1: brief error print
+    #   2: detailed error print
+    #   3: detailed error print and raise error
+    _is_locked: bool
+    _lock_owner: t.Optional[Signal]
+    
+    def __init__(self) -> None:
+        self._chain = []
+        self._error_level = 0
+        self._is_locked = False
+        self._lock_owner = None
+    
+    # @property
+    # def chain(self) -> t.List[T.FuncId]:
+    #     return self._chain
+
+    @property
+    def lock_owner(self) -> t.Optional[Signal]:
+        return self._lock_owner
+    
+    @contextmanager
+    def locking(self, owner: Signal, error_level: int = 1) -> t.Iterator[None]:
+        self.lock(owner, error_level)
+        yield
+        self.unlock(owner)
+    
+    def check(self, func: T.Func) -> bool:
+        """
+        check if function already triggered in this propagation chain.
+        """
+        if (id := get_func_id(func)) not in self._chain:
+            self._chain.append(id)
+            return True
+        
+        def print_error_details() -> None:
+            chain = tuple(map(_pretty_id, self._chain))
+            if len(chain) == 1:
+                diagram = (
+                    '╭─▶ 1. {}'.format(chain[0]),
+                    '╰─x 2. {}'.format(chain[0]),
+                )
+            else:
+                diagram = (
+                    '╭─▶ 1. {}'.format(chain[0]),
+                    *(
+                        '│   {}. {}'.format(i, x) 
+                        for i, x in enumerate(chain[1:], 2)
+                    ),
+                    '╰─x {}. {}'.format(len(chain) + 1, chain[0]),
+                )
+
+            print(textwrap.dedent('''
+                signal prevented because of circular emissions:
+                    {}
+            ''').format(
+                textwrap.indent('\n'.join(diagram), '    ').lstrip()
+            ), ':p3v4s')
+
+        def _pretty_id(func_id: T.FuncId) -> str:
+            a, b, c = re.fullmatch(r'(.+)\((.+):(.+)\)', func_id).groups()
+            b = re.split(r'[/\\]', b)[-1]
+            return f'{a} ({b}:{c})'
+
+        if self._error_level == 1:
+            print('signal prevented because of circular emissions', ':p2vs')
+        elif self._error_level == 2:
+            print_error_details()
+        elif self._error_level == 3:
+            print_error_details()
+            raise RecursionError('circular signal emissions')
+        return False
+    
+    def lock(self, owner: Signal, error_level: int = 1) -> bool:
+        if self._lock_owner:
+            return False
+        # assert not self._chain
+        self._error_level = error_level
+        self._is_locked = True
+        self._lock_owner = owner
+        return True
+    
+    def unlock(self, controller: Signal) -> bool:
+        if controller is not self._lock_owner:
+            return False
+        self._chain.clear()
+        self._error_level = 0
+        self._is_locked = False
+        self._lock_owner = None
+        return True
+
+
+# def get_func_args_count(func: FunctionType) -> int:
+#     cnt = func.__code__.co_argcount - len(func.__defaults__ or ())
+#     if 'method' in str(func.__class__): cnt -= 1
+#     return cnt
+
+
+def get_func_id(func: T.Func) -> T.FuncId:
+    # related test: tests/duplicate_locals.py
+    if config.duplicate_locals_scheme == 'exclusive':
+        return str(id(func))
+    else:
+        # https://stackoverflow.com/a/46479810
+        if isinstance(func, partial):
+            func = func.func
+        # # return func.__qualname__
+        return '{}({}:{})'.format(
+            func.__qualname__,
+            func.__code__.co_filename, 
+            func.__code__.co_firstlineno,
+        )
+
+
+_prop_chain = _PropagationChain()
```

## lk_utils/common_typing.py

 * *Ordering differences only*

```diff
@@ -1,16 +1,16 @@
-if 1:
-    import types  # noqa
-    from types import *  # noqa
-    from typing import *  # noqa
-    from typing_extensions import *  # noqa
-
-if 2:
-    import sys
-    if sys.version_info[:2] < (3, 11):
-        # fix the missing `Self` type in `typing` module
-        import typing as _typing
-        setattr(_typing, 'Self', _typing.Any)
-
-if 3:
-    if 'TextIO' not in globals():
-        from typing.io import *
+if 1:
+    import types  # noqa
+    from types import *  # noqa
+    from typing import *  # noqa
+    from typing_extensions import *  # noqa
+
+if 2:
+    import sys
+    if sys.version_info[:2] < (3, 11):
+        # fix the missing `Self` type in `typing` module
+        import typing as _typing
+        setattr(_typing, 'Self', _typing.Any)
+
+if 3:
+    if 'TextIO' not in globals():
+        from typing.io import *
```

## lk_utils/filesniff/finder.py

```diff
@@ -1,409 +1,383 @@
-"""
-design guide: docs/filename-extension-form-in-design-thinking.zh.md
-"""
-import os
-from dataclasses import dataclass
-
-from .main import normpath
-from .. import common_typing as t
-
-__all__ = [
-    'Path',
-    'find_dir_names',
-    'find_dir_paths',
-    'find_dirs',
-    'find_file_names',
-    'find_file_paths',
-    'find_files',
-    'findall_dir_names',
-    'findall_dir_paths',
-    'findall_dirs',
-    'findall_file_names',
-    'findall_file_paths',
-    'findall_files',
-]
-
-
-@dataclass
-class Path:
-    dir: str
-    path: str
-    relpath: str
-    name: str
-    type: t.Literal['dir', 'file']
-    
-    @property
-    def abspath(self) -> str:  # alias to 'path'
-        return self.path
-    
-    @property
-    def stem(self) -> str:
-        return os.path.splitext(self.name)[0]
-    
-    @property
-    def ext(self) -> str:
-        return os.path.splitext(self.name)[1][1:].lower()
-    
-    # make it sortable.
-    def __lt__(self, other: 'Path') -> bool:
-        return self.path < other.path
-
-
-class PathType:
-    FILE = 0
-    DIR = 1
-
-
-class T:
-    _Path = Path
-    
-    DirPath = str
-    FinderResult = t.Iterator[_Path]
-    PathFilter = t.Callable[[str, str], bool]
-    #   callable[[abspath, name], bool]
-    #       the abspath could either be a file or a dir.
-    #       the name could either be a file or a dir.
-    PathType = int
-    
-    Prefix = t.Union[str, t.Tuple[str, ...]]
-    Suffix = t.Union[str, t.Tuple[str, ...]]
-    #   DELETE: suffix supported formats:
-    #       'png'
-    #       '.png'
-    #       '*.png'
-    #       'png jpg'
-    #       '.png .jpg'
-    #       '*.png *.jpg'
-    #       ('png', 'jpg', ...)
-    #       ('.png', '.jpg', ...)
-    #       ('*.png', '*.jpg', ...)
-    #   (new) suffix supported formats:
-    #       '.png'
-    #       ('.png', '.jpg')
-    
-    SortBy = t.Literal['name', 'path', 'time']
-
-
-def _find_paths(
-    dirpath: T.DirPath,
-    path_type: T.PathType,
-    recursive: bool = False,
-    prefix: T.Prefix = None,
-    suffix: T.Suffix = None,
-    filter: T.PathFilter = None,
-    sort_by: T.SortBy = None,
-) -> T.FinderResult:
-    """
-    args:
-        path_type: 0: file, 1: dir. see also `[class] PathType`.
-        suffix:
-            1. each item must be string start with '.' ('.jpg', '.txt', etc.)
-            2. case insensitive.
-            3. param type is str or tuple[str], cannot be list[str].
-        filter:
-            None: no filter (everything pass through)
-            callable:
-                return: True means matched, False means dropped.
-    """
-    dirpath = normpath(dirpath, force_abspath=True)
-    
-    def main() -> T.FinderResult:
-        for root, dirs, files in os.walk(dirpath):
-            root = normpath(root)
-            
-            if path_type == PathType.FILE:
-                names = files
-            else:
-                names = dirs
-            
-            for n in names:
-                p = f'{root}/{n}'
-                if filter and filter(p, n) is False:
-                    continue
-                if prefix and not n.startswith(prefix):
-                    continue
-                if suffix and not n.endswith(suffix):
-                    continue
-                
-                yield Path(
-                    dir=root,
-                    path=p,
-                    relpath=p[len(dirpath) + 1 :],
-                    name=n,
-                    type='dir' if path_type == PathType.DIR else 'file',  # noqa
-                )
-            
-            if not recursive:
-                break
-    
-    if sort_by is None:
-        yield from main()
-    elif sort_by == 'name':
-        yield from sorted(main(), key=lambda x: x.name)
-    elif sort_by == 'path':
-        yield from sorted(main(), key=lambda x: x.path)
-    elif sort_by == 'time':
-        yield from sorted(main(), key=lambda x: os.path.getmtime(x.path),
-                          reverse=True)  # fmt:skip
-    else:
-        raise ValueError(sort_by)
-
-
-class _DefaultFilter:
-    def __init__(self):
-        self._whitelist = set()  # DELETE
-        self._blacklist = set()
-    
-    def reset(self) -> None:
-        self._whitelist.clear()
-        self._blacklist.clear()
-    
-    """
-    filter returns:
-        True means accepted, False means rejected. (this is different with \
-        python's built-in `filter` function)
-    """
-    
-    def filter_file(self, filepath: str, filename: str) -> bool:
-        if filepath.endswith('~'):  # e.g. '/path/to/file.py~'
-            return False
-        dirpath = filepath[: -(len(filename) + 1)]
-        dirname = dirpath.rsplit('/', 1)[-1]
-        if self.filter_dir(dirpath, dirname) is False:
-            return False
-        if filename.startswith(('.', '~')):
-            return False
-        return True
-    
-    def filter_dir(self, dirpath: str, dirname: str) -> bool:
-        if dirpath in self._blacklist:
-            return False
-        if dirname.startswith(('.', '~', '__')):
-            self._blacklist.add(dirpath)
-            return False
-        return True
-
-
-_default_filter = _DefaultFilter()
-
-
-# -----------------------------------------------------------------------------
-
-
-def find_files(
-    dirpath: T.DirPath,
-    suffix: T.Suffix = None,
-    filter: T.PathFilter = _default_filter.filter_file,
-    **kwargs,
-) -> T.FinderResult:
-    return _find_paths(
-        dirpath,
-        path_type=PathType.FILE,
-        recursive=False,
-        suffix=suffix,
-        filter=filter,
-        **kwargs,
-    )
-
-
-def find_file_paths(
-    dirpath: T.DirPath,
-    suffix: T.Suffix = None,
-    filter: T.PathFilter = _default_filter.filter_file,
-    **kwargs,
-) -> t.List[str]:
-    return [
-        x.path
-        for x in _find_paths(
-            dirpath,
-            path_type=PathType.FILE,
-            recursive=False,
-            suffix=suffix,
-            filter=filter,
-            **kwargs,
-        )
-    ]
-
-
-def find_file_names(
-    dirpath: T.DirPath,
-    suffix: T.Suffix = None,
-    filter: T.PathFilter = _default_filter.filter_file,
-    **kwargs,
-) -> t.List[str]:
-    return [
-        x.name
-        for x in _find_paths(
-            dirpath,
-            path_type=PathType.FILE,
-            recursive=False,
-            suffix=suffix,
-            filter=filter,
-            **kwargs,
-        )
-    ]
-
-
-def findall_files(
-    dirpath: T.DirPath,
-    suffix: T.Suffix = None,
-    filter: T.PathFilter = _default_filter.filter_file,
-    **kwargs,
-) -> T.FinderResult:
-    return _find_paths(
-        dirpath,
-        path_type=PathType.FILE,
-        recursive=True,
-        suffix=suffix,
-        filter=filter,
-        **kwargs,
-    )
-
-
-def findall_file_paths(
-    dirpath: T.DirPath,
-    suffix: T.Suffix = None,
-    filter: T.PathFilter = _default_filter.filter_file,
-    **kwargs,
-) -> t.List[str]:
-    return [
-        x.path
-        for x in _find_paths(
-            dirpath,
-            path_type=PathType.FILE,
-            recursive=True,
-            suffix=suffix,
-            filter=filter,
-            **kwargs,
-        )
-    ]
-
-
-def findall_file_names(
-    dirpath: T.DirPath,
-    suffix: T.Suffix = None,
-    filter: T.PathFilter = _default_filter.filter_file,
-    **kwargs,
-) -> t.List[str]:
-    return [
-        x.name
-        for x in _find_paths(
-            dirpath,
-            path_type=PathType.FILE,
-            recursive=True,
-            suffix=suffix,
-            filter=filter,
-            **kwargs,
-        )
-    ]
-
-
-# -----------------------------------------------------------------------------
-
-
-def find_dirs(
-    dirpath: T.DirPath,
-    prefix: T.Prefix = None,
-    filter: T.PathFilter = _default_filter.filter_dir,
-    **kwargs,
-) -> T.FinderResult:
-    return _find_paths(
-        dirpath,
-        path_type=PathType.DIR,
-        recursive=False,
-        prefix=prefix,
-        filter=filter,
-        **kwargs,
-    )
-
-
-def find_dir_paths(
-    dirpath: T.DirPath,
-    prefix: T.Prefix = None,
-    filter: T.PathFilter = _default_filter.filter_dir,
-    **kwargs,
-) -> t.List[str]:
-    return [
-        x.path
-        for x in _find_paths(
-            dirpath,
-            path_type=PathType.DIR,
-            recursive=False,
-            prefix=prefix,
-            filter=filter,
-            **kwargs,
-        )
-    ]
-
-
-def find_dir_names(
-    dirpath: T.DirPath,
-    prefix: T.Prefix = None,
-    filter: T.PathFilter = _default_filter.filter_dir,
-    **kwargs,
-) -> t.List[str]:
-    return [
-        x.name
-        for x in _find_paths(
-            dirpath,
-            path_type=PathType.DIR,
-            recursive=False,
-            prefix=prefix,
-            filter=filter,
-            **kwargs,
-        )
-    ]
-
-
-def findall_dirs(
-    dirpath: T.DirPath,
-    prefix: T.Prefix = None,
-    filter: T.PathFilter = _default_filter.filter_dir,
-    **kwargs,
-) -> T.FinderResult:
-    return _find_paths(
-        dirpath,
-        path_type=PathType.DIR,
-        recursive=True,
-        prefix=prefix,
-        filter=filter,
-        **kwargs,
-    )
-
-
-def findall_dir_paths(
-    dirpath: T.DirPath,
-    prefix: T.Prefix = None,
-    filter: T.PathFilter = _default_filter.filter_dir,
-    **kwargs,
-) -> t.List[str]:
-    return [
-        x.path
-        for x in _find_paths(
-            dirpath,
-            path_type=PathType.DIR,
-            recursive=True,
-            prefix=prefix,
-            filter=filter,
-            **kwargs,
-        )
-    ]
-
-
-def findall_dir_names(
-    dirpath: T.DirPath,
-    prefix: T.Prefix = None,
-    filter: T.PathFilter = _default_filter.filter_dir,
-    **kwargs,
-) -> t.List[str]:
-    return [
-        x.name
-        for x in _find_paths(
-            dirpath,
-            path_type=PathType.DIR,
-            recursive=True,
-            prefix=prefix,
-            filter=filter,
-            **kwargs,
-        )
-    ]
+"""
+design guide: docs/filename-extension-form-in-design-thinking.zh.md
+"""
+import os
+from dataclasses import dataclass
+
+from .main import normpath
+from .. import common_typing as t
+
+__all__ = [
+    'Path',
+    'find_dir_names',
+    'find_dir_paths',
+    'find_dirs',
+    'find_file_names',
+    'find_file_paths',
+    'find_files',
+    'findall_dir_names',
+    'findall_dir_paths',
+    'findall_dirs',
+    'findall_file_names',
+    'findall_file_paths',
+    'findall_files',
+]
+
+
+@dataclass
+class Path:
+    dir: str
+    path: str
+    relpath: str
+    name: str
+    type: t.Literal['dir', 'file']
+    
+    @property
+    def abspath(self) -> str:  # alias to 'path'
+        return self.path
+    
+    @property
+    def stem(self) -> str:
+        return os.path.splitext(self.name)[0]
+    
+    @property
+    def ext(self) -> str:
+        return os.path.splitext(self.name)[1][1:].lower()
+    
+    # make it sortable.
+    def __lt__(self, other: 'Path') -> bool:
+        return self.path < other.path
+
+
+class PathType:
+    FILE = 0
+    DIR = 1
+
+
+class T:
+    _Path = Path
+    
+    DirPath = str
+    FinderResult = t.Iterator[_Path]
+    PathType = int
+    
+    Prefix = t.Union[str, t.Tuple[str, ...]]
+    Suffix = t.Union[str, t.Tuple[str, ...]]
+    #   DELETE: suffix supported formats:
+    #       'png'
+    #       '.png'
+    #       '*.png'
+    #       'png jpg'
+    #       '.png .jpg'
+    #       '*.png *.jpg'
+    #       ('png', 'jpg', ...)
+    #       ('.png', '.jpg', ...)
+    #       ('*.png', '*.jpg', ...)
+    #   (new) suffix supported formats:
+    #       '.png'
+    #       ('.png', '.jpg')
+    
+    SortBy = t.Literal['name', 'path', 'time']
+
+
+def _find_paths(
+    dirpath: T.DirPath,
+    path_type: T.PathType,
+    recursive: bool = False,
+    prefix: T.Prefix = None,
+    suffix: T.Suffix = None,
+    sort_by: T.SortBy = None,
+    enable_filter: bool = True,
+) -> T.FinderResult:
+    """
+    args:
+        path_type: 0: file, 1: dir. see also `[class] PathType`.
+        suffix:
+            1. each item must be string start with '.' ('.jpg', '.txt', etc.)
+            2. case insensitive.
+            3. param type is str or tuple[str], cannot be list[str].
+    """
+    dirpath = normpath(dirpath, force_abspath=True)
+    filter = (
+        None if not enable_filter else
+        _default_filter.filter_file if path_type == PathType.FILE else
+        _default_filter.filter_dir
+    )
+    
+    def main() -> T.FinderResult:
+        for root, dirs, files in os.walk(dirpath):
+            root = normpath(root)
+            
+            if path_type == PathType.FILE:
+                names = files
+            else:
+                names = dirs
+            
+            for n in names:
+                p = f'{root}/{n}'
+                # noinspection PyArgumentList
+                if filter and filter(p, n, is_root=(root == dirpath)) is False:
+                    continue
+                if prefix and not n.startswith(prefix):
+                    continue
+                if suffix and not n.endswith(suffix):
+                    continue
+                
+                yield Path(
+                    dir=root,
+                    path=p,
+                    relpath=p[len(dirpath) + 1:],
+                    name=n,
+                    type='dir' if path_type == PathType.DIR else 'file',  # noqa
+                )
+            
+            if not recursive:
+                break
+    
+    if sort_by is None:
+        yield from main()
+    elif sort_by == 'name':
+        yield from sorted(main(), key=lambda x: x.name)
+    elif sort_by == 'path':
+        yield from sorted(main(), key=lambda x: x.path)
+    elif sort_by == 'time':
+        yield from sorted(main(), key=lambda x: os.path.getmtime(x.path),
+                          reverse=True)  # fmt:skip
+    else:
+        raise ValueError(sort_by)
+
+
+class _DefaultFilter:
+    def __init__(self) -> None:
+        self._whitelist = set()  # DELETE
+        self._blacklist = set()
+    
+    def reset(self) -> None:
+        self._whitelist.clear()
+        self._blacklist.clear()
+    
+    """
+    filter returns:
+        True means accepted, False means rejected. (this is different with -
+        python's built-in `filter` function)
+    """
+    
+    def filter_file(self, filepath: str, filename: str, is_root: bool) -> bool:
+        if filename.startswith(('.', '~')) or filepath.endswith('~'):
+            #   e.g. '/path/to/file.py~'
+            return False
+        if not is_root:
+            dirpath = filepath[: -(len(filename) + 1)]
+            dirname = dirpath.rsplit('/', 1)[-1]
+            if self.filter_dir(dirpath, dirname) is False:
+                return False
+        return True
+    
+    def filter_dir(self, dirpath: str, dirname: str, **_) -> bool:
+        if dirpath in self._blacklist:
+            return False
+        if dirname.startswith(('.', '~', '__')):
+            self._blacklist.add(dirpath)
+            return False
+        return True
+
+
+_default_filter = _DefaultFilter()
+
+
+# -----------------------------------------------------------------------------
+
+
+def find_files(
+    dirpath: T.DirPath,
+    suffix: T.Suffix = None,
+    **kwargs,
+) -> T.FinderResult:
+    return _find_paths(
+        dirpath,
+        path_type=PathType.FILE,
+        recursive=False,
+        suffix=suffix,
+        **kwargs,
+    )
+
+
+def find_file_paths(
+    dirpath: T.DirPath,
+    suffix: T.Suffix = None,
+    **kwargs,
+) -> t.List[str]:
+    return [
+        x.path
+        for x in _find_paths(
+            dirpath,
+            path_type=PathType.FILE,
+            recursive=False,
+            suffix=suffix,
+            **kwargs,
+        )
+    ]
+
+
+def find_file_names(
+    dirpath: T.DirPath,
+    suffix: T.Suffix = None,
+    **kwargs,
+) -> t.List[str]:
+    return [
+        x.name
+        for x in _find_paths(
+            dirpath,
+            path_type=PathType.FILE,
+            recursive=False,
+            suffix=suffix,
+            **kwargs,
+        )
+    ]
+
+
+def findall_files(
+    dirpath: T.DirPath,
+    suffix: T.Suffix = None,
+    **kwargs,
+) -> T.FinderResult:
+    return _find_paths(
+        dirpath,
+        path_type=PathType.FILE,
+        recursive=True,
+        suffix=suffix,
+        **kwargs,
+    )
+
+
+def findall_file_paths(
+    dirpath: T.DirPath,
+    suffix: T.Suffix = None,
+    **kwargs,
+) -> t.List[str]:
+    return [
+        x.path
+        for x in _find_paths(
+            dirpath,
+            path_type=PathType.FILE,
+            recursive=True,
+            suffix=suffix,
+            **kwargs,
+        )
+    ]
+
+
+def findall_file_names(
+    dirpath: T.DirPath,
+    suffix: T.Suffix = None,
+    **kwargs,
+) -> t.List[str]:
+    return [
+        x.name
+        for x in _find_paths(
+            dirpath,
+            path_type=PathType.FILE,
+            recursive=True,
+            suffix=suffix,
+            **kwargs,
+        )
+    ]
+
+
+# -----------------------------------------------------------------------------
+
+
+def find_dirs(
+    dirpath: T.DirPath,
+    prefix: T.Prefix = None,
+    **kwargs,
+) -> T.FinderResult:
+    return _find_paths(
+        dirpath,
+        path_type=PathType.DIR,
+        recursive=False,
+        prefix=prefix,
+        **kwargs,
+    )
+
+
+def find_dir_paths(
+    dirpath: T.DirPath,
+    prefix: T.Prefix = None,
+    **kwargs,
+) -> t.List[str]:
+    return [
+        x.path
+        for x in _find_paths(
+            dirpath,
+            path_type=PathType.DIR,
+            recursive=False,
+            prefix=prefix,
+            **kwargs,
+        )
+    ]
+
+
+def find_dir_names(
+    dirpath: T.DirPath,
+    prefix: T.Prefix = None,
+    **kwargs,
+) -> t.List[str]:
+    return [
+        x.name
+        for x in _find_paths(
+            dirpath,
+            path_type=PathType.DIR,
+            recursive=False,
+            prefix=prefix,
+            **kwargs,
+        )
+    ]
+
+
+def findall_dirs(
+    dirpath: T.DirPath,
+    prefix: T.Prefix = None,
+    **kwargs,
+) -> T.FinderResult:
+    return _find_paths(
+        dirpath,
+        path_type=PathType.DIR,
+        recursive=True,
+        prefix=prefix,
+        **kwargs,
+    )
+
+
+def findall_dir_paths(
+    dirpath: T.DirPath,
+    prefix: T.Prefix = None,
+    **kwargs,
+) -> t.List[str]:
+    return [
+        x.path
+        for x in _find_paths(
+            dirpath,
+            path_type=PathType.DIR,
+            recursive=True,
+            prefix=prefix,
+            **kwargs,
+        )
+    ]
+
+
+def findall_dir_names(
+    dirpath: T.DirPath,
+    prefix: T.Prefix = None,
+    **kwargs,
+) -> t.List[str]:
+    return [
+        x.name
+        for x in _find_paths(
+            dirpath,
+            path_type=PathType.DIR,
+            recursive=True,
+            prefix=prefix,
+            **kwargs,
+        )
+    ]
```

## lk_utils/filesniff/main.py

 * *Ordering differences only*

```diff
@@ -1,264 +1,264 @@
-import os
-import os.path as ospath
-from functools import partial
-from inspect import currentframe
-from types import FrameType
-
-from .. import common_typing as t
-
-__all__ = [
-    'abspath',
-    'barename',
-    'basename',
-    'cd_current_dir',
-    'dirname',
-    'dirpath',
-    'exists',
-    'filename',
-    'filepath',
-    'get_current_dir',
-    'isdir',
-    'isdirlike',
-    'isfile',
-    'isfilelike',
-    'islink',
-    'normpath',
-    'not_empty',
-    'parent',
-    'parent_path',
-    'relpath',
-    'replace_ext',
-    'split',
-    'xpath',
-]
-
-exists = ospath.exists
-_IS_WINDOWS = os.name == 'nt'
-
-
-class T:
-    Path = DirPath = FilePath = str
-
-
-def normpath(path: T.Path, force_abspath: bool = False) -> T.Path:
-    if force_abspath:
-        out = ospath.abspath(path)
-    else:
-        out = ospath.normpath(path)
-    if _IS_WINDOWS:
-        out = out.replace('\\', '/')
-    return out
-
-
-abspath = partial(normpath, force_abspath=True)
-
-
-# ------------------------------------------------------------------------------
-
-def parent_path(path: T.Path) -> T.DirPath:
-    return normpath(ospath.dirname(path))
-
-
-parent = parent_path  # alias
-
-
-def relpath(path: T.Path, start: T.Path = None) -> T.Path:
-    if not path: return ''
-    return normpath(ospath.relpath(path, start))
-
-
-def dirpath(path: T.Path) -> T.DirPath:
-    if ospath.isdir(path):
-        return normpath(path)
-    else:
-        return normpath(ospath.dirname(path))
-
-
-def dirname(path: T.Path) -> str:
-    """ Return the directory name of path.
-
-    Examples:
-        path = 'a/b/c/d.txt' -> 'c'
-        path = 'a/b/c' -> 'c'
-    """
-    path = normpath(path, True)
-    if ospath.isfile(path):
-        return ospath.basename(ospath.dirname(path))
-    else:
-        return ospath.basename(path)
-
-
-def filepath(path: T.Path, suffix: bool = True, strict: bool = False) -> T.Path:
-    if strict and isdir(path):
-        raise Exception('Cannot get filepath from a directory!')
-    if suffix:
-        return normpath(path)
-    else:
-        return normpath(ospath.splitext(path)[0])
-
-
-def filename(path: T.Path, suffix: bool = True, strict: bool = False) -> str:
-    """ Return the file name from path.
-
-    Examples:
-        strict  input           output
-        True    'a/b/c.txt'     'c.txt'
-        True    'a/b'            error
-        False   'a/b'           'b'
-    """
-    if strict and isdir(path):
-        raise Exception('Cannot get filename from a directory!')
-    if suffix:
-        return ospath.basename(path)
-    else:
-        return ospath.splitext(ospath.basename(path))[0]
-
-
-basename = filename
-
-
-def barename(path: T.Path, strict: bool = False) -> str:
-    return filename(path, suffix=False, strict=strict)
-
-
-# ------------------------------------------------------------------------------
-
-def isfile(filepath: T.Path) -> bool:
-    """ Unsafe method judging path-like string.
-
-    TLDR: If `filepath` looks like a filepath, will return True; otherwise
-        return False.
-
-    Judgement based:
-        - Does it end with '/'? -> False
-        - Does it really exist on system? -> True
-        - Does it contain a dot ("xxx.xxx")? -> True
-
-    Positive cases:
-        print(isfile('D:/myprj/README.md'))  # -> True (no matter exists or not)
-        print(isfile('D:/myprj/README'))  # -> True (if it really exists)
-        print(isfile('D:/myprj/README'))  # -> False (if it really not exists)
-
-    Negative cases: (the function judges seems not that good)
-        print(isfile('D:/myprj/.idea'))  # -> True (it should be False)
-        print(isfile('D:/!@#$%^&*/README.md'))  # -> True (it should be False)
-    """
-    if filepath == '':
-        return False
-    if filepath.endswith('/'):
-        return False
-    if ospath.isfile(filepath):
-        return True
-    if '.' in filepath.rsplit('/', 1)[-1]:
-        return True
-    else:
-        return False
-
-
-isfilelike = isfile
-
-
-def isdir(dirpath: T.Path) -> bool:
-    """ Unsafe method judging dirpath-like string.
-
-    TLDR: If `dirpath` looks like a dirpath, will return True; otherwise return
-        False.
-
-    Judgement based:
-        - Is it a dot/dot-slash/slash? -> True
-        - Does it really exist on system? -> True
-        - Does it end with '/'? -> False
-    """
-    if dirpath == '':
-        return False
-    if dirpath in ('.', './', '/'):
-        return True
-    if ospath.isdir(dirpath):
-        return True
-    else:
-        return False
-
-
-isdirlike = isdir
-
-islink = ospath.islink
-
-
-def not_empty(file: T.FilePath) -> bool:
-    """
-    References:
-        https://www.imooc.com/wenda/detail/350036?block_id=tuijian_yw
-    """
-    return bool(ospath.exists(file) and ospath.getsize(file))
-
-
-# -----------------------------------------------------------------------------
-
-
-def cd_current_dir() -> T.Path:
-    caller_frame = currentframe().f_back
-    dir = _get_dir_of_frame(caller_frame)
-    os.chdir(dir)
-    return dir
-
-
-def get_current_dir() -> T.Path:
-    caller_frame = currentframe().f_back
-    return _get_dir_of_frame(caller_frame)
-
-
-def replace_ext(path: T.Path, ext: str) -> T.Path:
-    """
-    params:
-        ext:
-            recommend no dot prefiexed, like 'png'.
-            but for compatibility, '.png' is also acceptable.
-    """
-    return ospath.splitext(path)[0] + '.' + ext.lstrip('.')
-
-
-def split(path: T.Path, parts: int = 2) -> t.Tuple[str, ...]:
-    path = abspath(path)
-    if parts == 2:
-        a, b = path.rsplit('/', 1)
-        return a, b
-    elif parts == 3:
-        assert isfile(path)
-        a, b = path.rsplit('/', 1)
-        b, c = b.rsplit('.', 1)
-        return a, b, c
-    else:
-        raise ValueError('Unsupported parts number!')
-
-
-def xpath(path: T.Path, force_abspath: bool = True) -> T.Path:
-    """ Consider relative path always based on caller's.
-
-    References: https://blog.csdn.net/Likianta/article/details/89299937
-    """
-    caller_frame = currentframe().f_back
-    caller_dir = _get_dir_of_frame(caller_frame)
-    
-    if path in ('', '.', './'):
-        out = caller_dir
-    else:
-        out = ospath.abspath(ospath.join(caller_dir, path))
-    
-    if force_abspath:
-        return normpath(out)
-    else:
-        return normpath(ospath.relpath(out, os.getcwd()))
-
-
-def _get_dir_of_frame(frame: FrameType, ignore_error: bool = False) -> T.Path:
-    file = frame.f_globals.get('__file__') \
-           or frame.f_code.co_filename
-    if file.startswith('<') and file.endswith('>'):
-        if ignore_error:
-            print(':v4p2', 'Unable to locate directory from caller frame! '
-                           'Fallback using current working directory instead.')
-            return normpath(os.getcwd())
-        else:
-            raise OSError('Unable to locate directory from caller frame!')
-    else:
-        return normpath(ospath.dirname(file))
+import os
+import os.path as ospath
+from functools import partial
+from inspect import currentframe
+from types import FrameType
+
+from .. import common_typing as t
+
+__all__ = [
+    'abspath',
+    'barename',
+    'basename',
+    'cd_current_dir',
+    'dirname',
+    'dirpath',
+    'exists',
+    'filename',
+    'filepath',
+    'get_current_dir',
+    'isdir',
+    'isdirlike',
+    'isfile',
+    'isfilelike',
+    'islink',
+    'normpath',
+    'not_empty',
+    'parent',
+    'parent_path',
+    'relpath',
+    'replace_ext',
+    'split',
+    'xpath',
+]
+
+exists = ospath.exists
+_IS_WINDOWS = os.name == 'nt'
+
+
+class T:
+    Path = DirPath = FilePath = str
+
+
+def normpath(path: T.Path, force_abspath: bool = False) -> T.Path:
+    if force_abspath:
+        out = ospath.abspath(path)
+    else:
+        out = ospath.normpath(path)
+    if _IS_WINDOWS:
+        out = out.replace('\\', '/')
+    return out
+
+
+abspath = partial(normpath, force_abspath=True)
+
+
+# ------------------------------------------------------------------------------
+
+def parent_path(path: T.Path) -> T.DirPath:
+    return normpath(ospath.dirname(path))
+
+
+parent = parent_path  # alias
+
+
+def relpath(path: T.Path, start: T.Path = None) -> T.Path:
+    if not path: return ''
+    return normpath(ospath.relpath(path, start))
+
+
+def dirpath(path: T.Path) -> T.DirPath:
+    if ospath.isdir(path):
+        return normpath(path)
+    else:
+        return normpath(ospath.dirname(path))
+
+
+def dirname(path: T.Path) -> str:
+    """ Return the directory name of path.
+
+    Examples:
+        path = 'a/b/c/d.txt' -> 'c'
+        path = 'a/b/c' -> 'c'
+    """
+    path = normpath(path, True)
+    if ospath.isfile(path):
+        return ospath.basename(ospath.dirname(path))
+    else:
+        return ospath.basename(path)
+
+
+def filepath(path: T.Path, suffix: bool = True, strict: bool = False) -> T.Path:
+    if strict and isdir(path):
+        raise Exception('Cannot get filepath from a directory!')
+    if suffix:
+        return normpath(path)
+    else:
+        return normpath(ospath.splitext(path)[0])
+
+
+def filename(path: T.Path, suffix: bool = True, strict: bool = False) -> str:
+    """ Return the file name from path.
+
+    Examples:
+        strict  input           output
+        True    'a/b/c.txt'     'c.txt'
+        True    'a/b'            error
+        False   'a/b'           'b'
+    """
+    if strict and isdir(path):
+        raise Exception('Cannot get filename from a directory!')
+    if suffix:
+        return ospath.basename(path)
+    else:
+        return ospath.splitext(ospath.basename(path))[0]
+
+
+basename = filename
+
+
+def barename(path: T.Path, strict: bool = False) -> str:
+    return filename(path, suffix=False, strict=strict)
+
+
+# ------------------------------------------------------------------------------
+
+def isfile(filepath: T.Path) -> bool:
+    """ Unsafe method judging path-like string.
+
+    TLDR: If `filepath` looks like a filepath, will return True; otherwise
+        return False.
+
+    Judgement based:
+        - Does it end with '/'? -> False
+        - Does it really exist on system? -> True
+        - Does it contain a dot ("xxx.xxx")? -> True
+
+    Positive cases:
+        print(isfile('D:/myprj/README.md'))  # -> True (no matter exists or not)
+        print(isfile('D:/myprj/README'))  # -> True (if it really exists)
+        print(isfile('D:/myprj/README'))  # -> False (if it really not exists)
+
+    Negative cases: (the function judges seems not that good)
+        print(isfile('D:/myprj/.idea'))  # -> True (it should be False)
+        print(isfile('D:/!@#$%^&*/README.md'))  # -> True (it should be False)
+    """
+    if filepath == '':
+        return False
+    if filepath.endswith('/'):
+        return False
+    if ospath.isfile(filepath):
+        return True
+    if '.' in filepath.rsplit('/', 1)[-1]:
+        return True
+    else:
+        return False
+
+
+isfilelike = isfile
+
+
+def isdir(dirpath: T.Path) -> bool:
+    """ Unsafe method judging dirpath-like string.
+
+    TLDR: If `dirpath` looks like a dirpath, will return True; otherwise return
+        False.
+
+    Judgement based:
+        - Is it a dot/dot-slash/slash? -> True
+        - Does it really exist on system? -> True
+        - Does it end with '/'? -> False
+    """
+    if dirpath == '':
+        return False
+    if dirpath in ('.', './', '/'):
+        return True
+    if ospath.isdir(dirpath):
+        return True
+    else:
+        return False
+
+
+isdirlike = isdir
+
+islink = ospath.islink
+
+
+def not_empty(file: T.FilePath) -> bool:
+    """
+    References:
+        https://www.imooc.com/wenda/detail/350036?block_id=tuijian_yw
+    """
+    return bool(ospath.exists(file) and ospath.getsize(file))
+
+
+# -----------------------------------------------------------------------------
+
+
+def cd_current_dir() -> T.Path:
+    caller_frame = currentframe().f_back
+    dir = _get_dir_of_frame(caller_frame)
+    os.chdir(dir)
+    return dir
+
+
+def get_current_dir() -> T.Path:
+    caller_frame = currentframe().f_back
+    return _get_dir_of_frame(caller_frame)
+
+
+def replace_ext(path: T.Path, ext: str) -> T.Path:
+    """
+    params:
+        ext:
+            recommend no dot prefiexed, like 'png'.
+            but for compatibility, '.png' is also acceptable.
+    """
+    return ospath.splitext(path)[0] + '.' + ext.lstrip('.')
+
+
+def split(path: T.Path, parts: int = 2) -> t.Tuple[str, ...]:
+    path = abspath(path)
+    if parts == 2:
+        a, b = path.rsplit('/', 1)
+        return a, b
+    elif parts == 3:
+        assert isfile(path)
+        a, b = path.rsplit('/', 1)
+        b, c = b.rsplit('.', 1)
+        return a, b, c
+    else:
+        raise ValueError('Unsupported parts number!')
+
+
+def xpath(path: T.Path, force_abspath: bool = True) -> T.Path:
+    """ Consider relative path always based on caller's.
+
+    References: https://blog.csdn.net/Likianta/article/details/89299937
+    """
+    caller_frame = currentframe().f_back
+    caller_dir = _get_dir_of_frame(caller_frame)
+    
+    if path in ('', '.', './'):
+        out = caller_dir
+    else:
+        out = ospath.abspath(ospath.join(caller_dir, path))
+    
+    if force_abspath:
+        return normpath(out)
+    else:
+        return normpath(ospath.relpath(out, os.getcwd()))
+
+
+def _get_dir_of_frame(frame: FrameType, ignore_error: bool = False) -> T.Path:
+    file = frame.f_globals.get('__file__') \
+           or frame.f_code.co_filename
+    if file.startswith('<') and file.endswith('>'):
+        if ignore_error:
+            print(':v4p2', 'Unable to locate directory from caller frame! '
+                           'Fallback using current working directory instead.')
+            return normpath(os.getcwd())
+        else:
+            raise OSError('Unable to locate directory from caller frame!')
+    else:
+        return normpath(ospath.dirname(file))
```

## lk_utils/filesniff/shutil.py

 * *Ordering differences only*

```diff
@@ -1,150 +1,150 @@
-import os
-import shutil
-from functools import partial
-from os.path import exists
-
-from .finder import findall_dirs
-from .main import _IS_WINDOWS  # noqa
-from .. import common_typing as t
-
-__all__ = [
-    'clone_tree',
-    'copy_file',
-    'copy_tree',
-    'make_dir',
-    'make_dirs',
-    'make_file',
-    'make_link',
-    'make_links',
-    'move',
-    'overwrite',
-    'remove_file',
-    'remove_tree',
-]
-
-
-def clone_tree(src: str, dst: str, overwrite: bool = None) -> None:
-    if exists(dst):
-        if _overwrite(dst, overwrite) is False: return
-    if not exists(dst):
-        os.mkdir(dst)
-    for d in findall_dirs(src):
-        dp_o = f'{dst}/{d.relpath}'
-        if not exists(dp_o):
-            os.mkdir(dp_o)
-
-
-def copy_file(src: str, dst: str, overwrite: bool = None) -> None:
-    if exists(dst):
-        if _overwrite(dst, overwrite) is False: return
-    shutil.copyfile(src, dst)
-
-
-def copy_tree(
-    src: str, dst: str, overwrite: bool = None, symlinks: bool = False
-) -> None:
-    if exists(dst):
-        if _overwrite(dst, overwrite) is False: return
-    shutil.copytree(src, dst, symlinks=symlinks)
-
-
-def make_dir(dst: str) -> None:
-    if not exists(dst):
-        os.mkdir(dst)
-
-
-def make_dirs(dst: str) -> None:
-    os.makedirs(dst, exist_ok=True)
-
-
-def make_file(dst: str) -> None:
-    open(dst, 'w').close()
-
-
-def make_link(src: str, dst: str, overwrite: bool = None) -> str:
-    """
-    args:
-        overwrite:
-            True: if exists, overwrite
-            False: if exists, raise an error
-            None: if exists, skip it
-    
-    ref: https://blog.walterlv.com/post/ntfs-link-comparisons.html
-    """
-    from .main import normpath
-    
-    src = normpath(src, force_abspath=True)
-    dst = normpath(dst, force_abspath=True)
-    
-    assert exists(src), src
-    if exists(dst):
-        if _overwrite(dst, overwrite) is False:
-            return dst
-    
-    if _IS_WINDOWS:
-        os.symlink(src, dst, target_is_directory=os.path.isdir(src))
-    else:
-        os.symlink(src, dst)
-    
-    return dst
-
-
-def make_links(
-    src: str, dst: str, names: t.List[str] = None, overwrite: bool = None
-) -> t.List[str]:
-    out = []
-    for n in names or os.listdir(src):
-        out.append(make_link(f'{src}/{n}', f'{dst}/{n}', overwrite))
-    return out
-
-
-def move(src: str, dst: str, overwrite: bool = None) -> None:
-    if exists(dst):
-        if _overwrite(dst, overwrite) is False: return
-    shutil.move(src, dst)
-
-
-def remove_file(dst: str) -> None:
-    if exists(dst):
-        os.remove(dst)
-
-
-def remove_tree(dst: str) -> None:
-    if exists(dst):
-        if os.path.isdir(dst):
-            shutil.rmtree(dst)
-        elif os.path.islink(dst):
-            os.unlink(dst)
-        else:
-            raise Exception('Unknown file type', dst)
-
-
-def _overwrite(path: str, scheme: t.Union[None, bool]) -> bool:
-    """
-    args:
-        scheme:
-            True: overwrite
-            False: no overwrite, and raise an FileExistsError
-            None: no overwrite, no error (skip)
-    returns: bool
-        the return value reflects what "overwrite" results in, literally.
-        i.e. True means "we DID overwrite", False means "we DID NOT overwrite".
-        the caller should take care of the return value and do the leftovers. \
-        usually, if caller receives True, it can continue its work; if False, \
-        should return at once.
-    """
-    if scheme is None:
-        return False
-    elif scheme is True:
-        if os.path.isfile(path):
-            os.remove(path)
-        elif os.path.islink(path):
-            os.unlink(path)
-        else:
-            shutil.rmtree(path)
-        return True
-    else:  # raise error
-        raise FileExistsError(path)
-
-
-overwrite = partial(_overwrite, scheme=True)
+import os
+import shutil
+from functools import partial
+from os.path import exists
+
+from .finder import findall_dirs
+from .main import _IS_WINDOWS  # noqa
+from .. import common_typing as t
+
+__all__ = [
+    'clone_tree',
+    'copy_file',
+    'copy_tree',
+    'make_dir',
+    'make_dirs',
+    'make_file',
+    'make_link',
+    'make_links',
+    'move',
+    'overwrite',
+    'remove_file',
+    'remove_tree',
+]
+
+
+def clone_tree(src: str, dst: str, overwrite: bool = None) -> None:
+    if exists(dst):
+        if _overwrite(dst, overwrite) is False: return
+    if not exists(dst):
+        os.mkdir(dst)
+    for d in findall_dirs(src):
+        dp_o = f'{dst}/{d.relpath}'
+        if not exists(dp_o):
+            os.mkdir(dp_o)
+
+
+def copy_file(src: str, dst: str, overwrite: bool = None) -> None:
+    if exists(dst):
+        if _overwrite(dst, overwrite) is False: return
+    shutil.copyfile(src, dst)
+
+
+def copy_tree(
+    src: str, dst: str, overwrite: bool = None, symlinks: bool = False
+) -> None:
+    if exists(dst):
+        if _overwrite(dst, overwrite) is False: return
+    shutil.copytree(src, dst, symlinks=symlinks)
+
+
+def make_dir(dst: str) -> None:
+    if not exists(dst):
+        os.mkdir(dst)
+
+
+def make_dirs(dst: str) -> None:
+    os.makedirs(dst, exist_ok=True)
+
+
+def make_file(dst: str) -> None:
+    open(dst, 'w').close()
+
+
+def make_link(src: str, dst: str, overwrite: bool = None) -> str:
+    """
+    args:
+        overwrite:
+            True: if exists, overwrite
+            False: if exists, raise an error
+            None: if exists, skip it
+    
+    ref: https://blog.walterlv.com/post/ntfs-link-comparisons.html
+    """
+    from .main import normpath
+    
+    src = normpath(src, force_abspath=True)
+    dst = normpath(dst, force_abspath=True)
+    
+    assert exists(src), src
+    if exists(dst):
+        if _overwrite(dst, overwrite) is False:
+            return dst
+    
+    if _IS_WINDOWS:
+        os.symlink(src, dst, target_is_directory=os.path.isdir(src))
+    else:
+        os.symlink(src, dst)
+    
+    return dst
+
+
+def make_links(
+    src: str, dst: str, names: t.List[str] = None, overwrite: bool = None
+) -> t.List[str]:
+    out = []
+    for n in names or os.listdir(src):
+        out.append(make_link(f'{src}/{n}', f'{dst}/{n}', overwrite))
+    return out
+
+
+def move(src: str, dst: str, overwrite: bool = None) -> None:
+    if exists(dst):
+        if _overwrite(dst, overwrite) is False: return
+    shutil.move(src, dst)
+
+
+def remove_file(dst: str) -> None:
+    if exists(dst):
+        os.remove(dst)
+
+
+def remove_tree(dst: str) -> None:
+    if exists(dst):
+        if os.path.isdir(dst):
+            shutil.rmtree(dst)
+        elif os.path.islink(dst):
+            os.unlink(dst)
+        else:
+            raise Exception('Unknown file type', dst)
+
+
+def _overwrite(path: str, scheme: t.Union[None, bool]) -> bool:
+    """
+    args:
+        scheme:
+            True: overwrite
+            False: no overwrite, and raise an FileExistsError
+            None: no overwrite, no error (skip)
+    returns: bool
+        the return value reflects what "overwrite" results in, literally.
+        i.e. True means "we DID overwrite", False means "we DID NOT overwrite".
+        the caller should take care of the return value and do the leftovers. \
+        usually, if caller receives True, it can continue its work; if False, \
+        should return at once.
+    """
+    if scheme is None:
+        return False
+    elif scheme is True:
+        if os.path.isfile(path):
+            os.remove(path)
+        elif os.path.islink(path):
+            os.unlink(path)
+        else:
+            shutil.rmtree(path)
+        return True
+    else:  # raise error
+        raise FileExistsError(path)
+
+
+overwrite = partial(_overwrite, scheme=True)
```

## lk_utils/read_and_write.py

 * *Ordering differences only*

```diff
@@ -1,225 +1,225 @@
-from contextlib import contextmanager
-
-from . import common_typing as t
-
-
-class T:
-    Content = t.Union[str, t.Iterable[str]]
-    Data = t.Union[str, bytes, list, dict, t.Any]
-    File = str
-    FileMode = t.Literal['a', 'r', 'rb', 'w', 'wb']
-    FileHandle = t.Union[t.TextIO, t.BinaryIO]
-    FileType = t.Literal['binary', 'json', 'pickle', 'plain', 'toml', 'yaml']
-
-
-@contextmanager
-def ropen(
-    file: T.File, mode: T.FileMode = 'r', encoding: str = 'utf-8', **kwargs
-) -> T.FileHandle:
-    if 'b' in mode:
-        handle = open(file, mode=mode, **kwargs)
-    else:
-        handle = open(file, mode=mode, encoding=encoding, **kwargs)
-    try:
-        yield handle
-    finally:
-        handle.close()
-
-
-@contextmanager
-def wopen(
-    file: T.File, mode: T.FileMode = 'w', encoding: str = 'utf-8'
-) -> T.FileHandle:
-    if 'b' in mode:
-        handle = open(file, mode=mode)
-    else:
-        handle = open(file, mode=mode, encoding=encoding)
-    try:
-        yield handle
-    finally:
-        handle.close()
-
-
-def read_file(file: T.File, **kwargs) -> str:
-    with ropen(file, **kwargs) as f:
-        content = f.read()
-        # https://blog.csdn.net/liu_xzhen/article/details/79563782
-        if content.startswith(u'\ufeff'):
-            # Strip BOM charset at the start of content.
-            content = content.encode('utf-8')[3:].decode('utf-8')
-    return content
-
-
-def read_lines(file: T.File, offset: int = 0, **kwargs) -> t.List[str]:
-    """
-    References:
-        https://blog.csdn.net/qq_40925239/article/details/81486637
-    """
-    with ropen(file, **kwargs) as f:
-        out = [line.rstrip() for line in f]
-    return out[offset:]
-
-
-def write_file(
-    content: T.Content, file: T.File, mode: T.FileMode = 'w', sep: str = '\n'
-):
-    """
-    ref:
-        python 在最后一行追加 https://www.cnblogs.com/zle1992/p/6138125.html
-        python map https://blog.csdn.net/yongh701/article/details/50283689
-    """
-    if not isinstance(content, str):
-        content = sep.join(map(str, content))
-    if not content.endswith('\n'):  # add line feed
-        content += '\n'
-    with wopen(file, mode) as f:
-        f.write(content)
-
-
-# ------------------------------------------------------------------------------
-
-
-def loads(file: T.File, ftype: T.FileType = None, **kwargs) -> T.Data:
-    if ftype is None:
-        ftype = _detect_file_type(file)
-    if ftype == 'plain':
-        return read_file(file, **kwargs)
-    elif ftype == 'binary':
-        with ropen(file, 'rb', **kwargs) as f:
-            return f.read()
-    elif ftype == 'json':
-        from json import load as jload
-        
-        with ropen(file, **kwargs) as f:
-            return jload(f)
-    elif ftype == 'yaml':  # pip install pyyaml
-        from yaml import safe_load as yload  # noqa
-        
-        with ropen(file, **kwargs) as f:
-            return yload(f)
-    elif ftype == 'toml':  # pip install toml
-        from toml import load as tload  # noqa
-        
-        with ropen(file, **kwargs) as f:
-            return tload(f)
-    elif ftype == 'pickle':
-        from pickle import load as pload
-        
-        with ropen(file, 'rb', **kwargs) as f:
-            return pload(f)
-    else:
-        # unregistered file types, like: .js, .css, .py, etc.
-        return read_file(file, **kwargs)
-
-
-def dumps(
-    data: T.Data, file: T.File, ftype: T.FileType = None, **kwargs
-) -> None:
-    if ftype is None:
-        ftype = _detect_file_type(file)
-    
-    if ftype == 'plain':
-        write_file(data, file, sep=kwargs.get('sep', '\n'))
-    
-    elif ftype == 'json':
-        from json import dump as jdump
-        
-        with wopen(file) as f:
-            jdump(
-                data,
-                f,
-                ensure_ascii=False,
-                default=str,
-                indent=kwargs.get('indent', 4),
-            )
-            #   ensure_ascii=False
-            #       https://www.cnblogs.com/zdz8207/p/python_learn_note_26.html
-            #   default=str
-            #       when something is not serializble, callback `__str__`.
-            #       it is useful to resolve `pathlib.PosixPath`.
-    
-    elif ftype == 'yaml':  # pip install pyyaml
-        from yaml import dump as ydump  # noqa
-        
-        with wopen(file) as f:
-            ydump(
-                data,
-                f,
-                **{
-                    'allow_unicode': True,
-                    'sort_keys': False,
-                    **kwargs,
-                }
-            )
-    
-    elif ftype == 'pickle':
-        from pickle import dump as pdump
-        
-        with wopen(file, 'wb') as f:
-            pdump(data, f, **kwargs)
-    
-    elif ftype == 'toml':  # pip install toml
-        from toml import dump as tdump  # noqa
-        
-        with wopen(file) as f:
-            tdump(data, f, **kwargs)
-    
-    elif ftype == 'binary':
-        with wopen(file, 'wb') as f:
-            f.write(data)
-    
-    else:
-        raise Exception(ftype, file, type(data))
-
-
-def _detect_file_type(filename: str) -> T.FileType:
-    if filename.endswith(('.txt', '.htm', '.html', '.md', '.rst')):
-        return 'plain'
-    elif filename.endswith(('.json', '.json5')):
-        return 'json'
-    elif filename.endswith(('.yaml', '.yml')):  # pip install pyyaml
-        return 'yaml'
-    elif filename.endswith(('.toml', '.tml')):  # pip install toml
-        return 'toml'
-    elif filename.endswith(('.pkl',)):
-        return 'pickle'
-    else:
-        return 'plain'
-        # raise Exception(f'Unknown file type: {filename}')
-
-
-# ------------------------------------------------------------------------------
-
-
-@contextmanager
-def read(file: T.File, **kwargs) -> T.Data:
-    """Open file as a read handle.
-    
-    Usage:
-        with read('input.json') as r:
-            print(len(r))
-    """
-    data = loads(file, **kwargs)
-    yield data
-
-
-@contextmanager
-def write(file: T.File, data: T.Data = None, **kwargs):
-    """Create a write handle, file will be generated after the `with` block
-        closed.
-    
-    Args:
-        file: See `dumps`.
-        data (list|dict|set|str): If the data type is incorrect, an Assertion
-            Error will be raised.
-        kwargs: See `dumps`.
-    
-    Usage:
-        with write('output.json', []) as w:
-            for i in range(10):
-                w.append(i)
-        print('See "result.json:1"')
-    """
-    assert isinstance(data, (list, dict, set))
-    yield data
-    dumps(data, file, **kwargs)
+from contextlib import contextmanager
+
+from . import common_typing as t
+
+
+class T:
+    Content = t.Union[str, t.Iterable[str]]
+    Data = t.Union[str, bytes, list, dict, t.Any]
+    File = str
+    FileMode = t.Literal['a', 'r', 'rb', 'w', 'wb']
+    FileHandle = t.Union[t.TextIO, t.BinaryIO]
+    FileType = t.Literal['binary', 'json', 'pickle', 'plain', 'toml', 'yaml']
+
+
+@contextmanager
+def ropen(
+    file: T.File, mode: T.FileMode = 'r', encoding: str = 'utf-8', **kwargs
+) -> T.FileHandle:
+    if 'b' in mode:
+        handle = open(file, mode=mode, **kwargs)
+    else:
+        handle = open(file, mode=mode, encoding=encoding, **kwargs)
+    try:
+        yield handle
+    finally:
+        handle.close()
+
+
+@contextmanager
+def wopen(
+    file: T.File, mode: T.FileMode = 'w', encoding: str = 'utf-8'
+) -> T.FileHandle:
+    if 'b' in mode:
+        handle = open(file, mode=mode)
+    else:
+        handle = open(file, mode=mode, encoding=encoding)
+    try:
+        yield handle
+    finally:
+        handle.close()
+
+
+def read_file(file: T.File, **kwargs) -> str:
+    with ropen(file, **kwargs) as f:
+        content = f.read()
+        # https://blog.csdn.net/liu_xzhen/article/details/79563782
+        if content.startswith(u'\ufeff'):
+            # Strip BOM charset at the start of content.
+            content = content.encode('utf-8')[3:].decode('utf-8')
+    return content
+
+
+def read_lines(file: T.File, offset: int = 0, **kwargs) -> t.List[str]:
+    """
+    References:
+        https://blog.csdn.net/qq_40925239/article/details/81486637
+    """
+    with ropen(file, **kwargs) as f:
+        out = [line.rstrip() for line in f]
+    return out[offset:]
+
+
+def write_file(
+    content: T.Content, file: T.File, mode: T.FileMode = 'w', sep: str = '\n'
+):
+    """
+    ref:
+        python 在最后一行追加 https://www.cnblogs.com/zle1992/p/6138125.html
+        python map https://blog.csdn.net/yongh701/article/details/50283689
+    """
+    if not isinstance(content, str):
+        content = sep.join(map(str, content))
+    if not content.endswith('\n'):  # add line feed
+        content += '\n'
+    with wopen(file, mode) as f:
+        f.write(content)
+
+
+# ------------------------------------------------------------------------------
+
+
+def loads(file: T.File, ftype: T.FileType = None, **kwargs) -> T.Data:
+    if ftype is None:
+        ftype = _detect_file_type(file)
+    if ftype == 'plain':
+        return read_file(file, **kwargs)
+    elif ftype == 'binary':
+        with ropen(file, 'rb', **kwargs) as f:
+            return f.read()
+    elif ftype == 'json':
+        from json import load as jload
+        
+        with ropen(file, **kwargs) as f:
+            return jload(f)
+    elif ftype == 'yaml':  # pip install pyyaml
+        from yaml import safe_load as yload  # noqa
+        
+        with ropen(file, **kwargs) as f:
+            return yload(f)
+    elif ftype == 'toml':  # pip install toml
+        from toml import load as tload  # noqa
+        
+        with ropen(file, **kwargs) as f:
+            return tload(f)
+    elif ftype == 'pickle':
+        from pickle import load as pload
+        
+        with ropen(file, 'rb', **kwargs) as f:
+            return pload(f)
+    else:
+        # unregistered file types, like: .js, .css, .py, etc.
+        return read_file(file, **kwargs)
+
+
+def dumps(
+    data: T.Data, file: T.File, ftype: T.FileType = None, **kwargs
+) -> None:
+    if ftype is None:
+        ftype = _detect_file_type(file)
+    
+    if ftype == 'plain':
+        write_file(data, file, sep=kwargs.get('sep', '\n'))
+    
+    elif ftype == 'json':
+        from json import dump as jdump
+        
+        with wopen(file) as f:
+            jdump(
+                data,
+                f,
+                ensure_ascii=False,
+                default=str,
+                indent=kwargs.get('indent', 4),
+            )
+            #   ensure_ascii=False
+            #       https://www.cnblogs.com/zdz8207/p/python_learn_note_26.html
+            #   default=str
+            #       when something is not serializble, callback `__str__`.
+            #       it is useful to resolve `pathlib.PosixPath`.
+    
+    elif ftype == 'yaml':  # pip install pyyaml
+        from yaml import dump as ydump  # noqa
+        
+        with wopen(file) as f:
+            ydump(
+                data,
+                f,
+                **{
+                    'allow_unicode': True,
+                    'sort_keys': False,
+                    **kwargs,
+                }
+            )
+    
+    elif ftype == 'pickle':
+        from pickle import dump as pdump
+        
+        with wopen(file, 'wb') as f:
+            pdump(data, f, **kwargs)
+    
+    elif ftype == 'toml':  # pip install toml
+        from toml import dump as tdump  # noqa
+        
+        with wopen(file) as f:
+            tdump(data, f, **kwargs)
+    
+    elif ftype == 'binary':
+        with wopen(file, 'wb') as f:
+            f.write(data)
+    
+    else:
+        raise Exception(ftype, file, type(data))
+
+
+def _detect_file_type(filename: str) -> T.FileType:
+    if filename.endswith(('.txt', '.htm', '.html', '.md', '.rst')):
+        return 'plain'
+    elif filename.endswith(('.json', '.json5')):
+        return 'json'
+    elif filename.endswith(('.yaml', '.yml')):  # pip install pyyaml
+        return 'yaml'
+    elif filename.endswith(('.toml', '.tml')):  # pip install toml
+        return 'toml'
+    elif filename.endswith(('.pkl',)):
+        return 'pickle'
+    else:
+        return 'plain'
+        # raise Exception(f'Unknown file type: {filename}')
+
+
+# ------------------------------------------------------------------------------
+
+
+@contextmanager
+def read(file: T.File, **kwargs) -> T.Data:
+    """Open file as a read handle.
+    
+    Usage:
+        with read('input.json') as r:
+            print(len(r))
+    """
+    data = loads(file, **kwargs)
+    yield data
+
+
+@contextmanager
+def write(file: T.File, data: T.Data = None, **kwargs):
+    """Create a write handle, file will be generated after the `with` block
+        closed.
+    
+    Args:
+        file: See `dumps`.
+        data (list|dict|set|str): If the data type is incorrect, an Assertion
+            Error will be raised.
+        kwargs: See `dumps`.
+    
+    Usage:
+        with write('output.json', []) as w:
+            for i in range(10):
+                w.append(i)
+        print('See "result.json:1"')
+    """
+    assert isinstance(data, (list, dict, set))
+    yield data
+    dumps(data, file, **kwargs)
```

## lk_utils/subproc/__init__.py

 * *Ordering differences only*

```diff
@@ -1,13 +1,13 @@
-from . import subprocess
-# from .multi_process import new_process
-from .promise import Promise
-from .promise import defer
-from .subprocess import compose_cmd
-from .subprocess import run_cmd_args
-from .subprocess import run_cmd_line
-from .threading import ThreadBroker
-from .threading import ThreadBroker as ThreadWorker  # backward compatibility
-from .threading import new_thread
-from .threading import retrieve_thread
-from .threading import run_new_thread
-from .threading import thread_manager
+from . import subprocess
+# from .multi_process import new_process
+from .promise import Promise
+from .promise import defer
+from .subprocess import compose_cmd
+from .subprocess import run_cmd_args
+from .subprocess import run_cmd_line
+from .threading import ThreadBroker
+from .threading import ThreadBroker as ThreadWorker  # backward compatibility
+from .threading import new_thread
+from .threading import retrieve_thread
+from .threading import run_new_thread
+from .threading import thread_manager
```

## lk_utils/subproc/multiprocess.py

 * *Ordering differences only*

```diff
@@ -1,24 +1,24 @@
-from functools import wraps
-from multiprocessing import Process
-from types import FunctionType
-
-from .. import common_typing as t
-
-
-class T:
-    Target = FunctionType
-    Wrapper = t.Callable[[...], Process]
-    Decorator = t.Callable[[Target], Wrapper]
-
-
-def new_process(daemon: bool = True) -> T.Decorator:
-    def decorator(func: T.Target) -> T.Wrapper:
-        @wraps(func)
-        def wrapper(*args, **kwargs) -> Process:
-            p = Process(target=func, args=args, kwargs=kwargs, daemon=daemon)
-            p.start()
-            return p
-        
-        return wrapper
-    
-    return decorator
+from functools import wraps
+from multiprocessing import Process
+from types import FunctionType
+
+from .. import common_typing as t
+
+
+class T:
+    Target = FunctionType
+    Wrapper = t.Callable[[...], Process]
+    Decorator = t.Callable[[Target], Wrapper]
+
+
+def new_process(daemon: bool = True) -> T.Decorator:
+    def decorator(func: T.Target) -> T.Wrapper:
+        @wraps(func)
+        def wrapper(*args, **kwargs) -> Process:
+            p = Process(target=func, args=args, kwargs=kwargs, daemon=daemon)
+            p.start()
+            return p
+        
+        return wrapper
+    
+    return decorator
```

## lk_utils/subproc/promise.py

 * *Ordering differences only*

```diff
@@ -1,70 +1,70 @@
-from .threading import ThreadBroker as Thread
-from .. import common_typing as t
-
-
-def defer(func: t.Callable, *args, **kwargs) -> 'Promise':
-    """
-    args:
-        kwargs:
-            self used keys:
-                __instant_starting__: bool, default True.
-                __daemon__: bool, default True.
-            other keys will be passed to `func`.
-
-    usage:
-        def add(a: int, b: int) -> int:
-            return a + b
-        promise = defer(add, 1, 2).then(print)
-        ...
-        promise.join()  # it prints '3'
-    """
-    start_now = kwargs.pop('__instant_starting__', True)
-    daemon = kwargs.pop('__daemon__', True)
-    t = Thread(
-        func, args=args, kwargs=kwargs,
-        daemon=daemon, start_now=start_now
-    )
-    return Promise(t)
-
-
-class Promise:
-    _is_done: bool
-    _thread: Thread
-    _then: t.Optional[t.Callable]
-    _result: t.Any
-    
-    def __init__(self, thread: Thread):
-        self._is_done = False
-        self._thread = thread
-        self._then = None
-        self._result = None
-    
-    def __call__(self) -> t.Any:
-        return self.fulfill()
-    
-    def start(self) -> None:
-        self._thread.start()
-    
-    def then(self, func, args: tuple = None, kwargs: dict = None) -> t.Self:
-        from functools import partial
-        self._then = partial(func, args or (), kwargs or {})
-        return self
-    
-    def fetch(self) -> t.Optional[t.Any]:
-        if self._is_done:
-            return self._result
-        
-        self._result = self._thread.join()
-        del self._thread
-        self._is_done = True
-        
-        if self._then:
-            self._result = self._then(self._result)
-        return self._result
-    
-    # alias
-    fulfill = join = fetch
-    
-    @property
-    def is_done(self) -> bool:
-        return self._is_done
+from .threading import ThreadBroker as Thread
+from .. import common_typing as t
+
+
+def defer(func: t.Callable, *args, **kwargs) -> 'Promise':
+    """
+    args:
+        kwargs:
+            self used keys:
+                __instant_starting__: bool, default True.
+                __daemon__: bool, default True.
+            other keys will be passed to `func`.
+
+    usage:
+        def add(a: int, b: int) -> int:
+            return a + b
+        promise = defer(add, 1, 2).then(print)
+        ...
+        promise.join()  # it prints '3'
+    """
+    start_now = kwargs.pop('__instant_starting__', True)
+    daemon = kwargs.pop('__daemon__', True)
+    t = Thread(
+        func, args=args, kwargs=kwargs,
+        daemon=daemon, start_now=start_now
+    )
+    return Promise(t)
+
+
+class Promise:
+    _is_done: bool
+    _thread: Thread
+    _then: t.Optional[t.Callable]
+    _result: t.Any
+    
+    def __init__(self, thread: Thread):
+        self._is_done = False
+        self._thread = thread
+        self._then = None
+        self._result = None
+    
+    def __call__(self) -> t.Any:
+        return self.fulfill()
+    
+    def start(self) -> None:
+        self._thread.start()
+    
+    def then(self, func, args: tuple = None, kwargs: dict = None) -> t.Self:
+        from functools import partial
+        self._then = partial(func, args or (), kwargs or {})
+        return self
+    
+    def fetch(self) -> t.Optional[t.Any]:
+        if self._is_done:
+            return self._result
+        
+        self._result = self._thread.join()
+        del self._thread
+        self._is_done = True
+        
+        if self._then:
+            self._result = self._then(self._result)
+        return self._result
+    
+    # alias
+    fulfill = join = fetch
+    
+    @property
+    def is_done(self) -> bool:
+        return self._is_done
```

## lk_utils/subproc/subprocess.py

 * *Ordering differences only*

```diff
@@ -1,193 +1,193 @@
-import shlex
-import subprocess as sp
-
-from lk_logger import bprint
-
-from .threading import run_new_thread
-from .. import common_typing as t
-
-__all__ = [
-    'compose',
-    'compose_cmd',
-    'compose_command',
-    'run',
-    'run_cmd_args',
-    'run_command_args',
-    'run_cmd_line',
-    'run_command_line',
-]
-
-
-def compose_command(*args: t.Any, filter: bool = True) -> t.List[str]:
-    """
-    examples:
-        ('pip', 'install', '', 'lk-utils') -> ['pip', 'install', 'lk-utils']
-        ('pip', 'install', 'lk-utils', ('-i', mirror)) ->
-            if mirror is empty, returns ['pip', 'install', 'lk-utils']
-            else returns ['pip', 'install', 'lk-utils', '-i', mirror]
-    """
-    
-    def flatten(seq: t.Sequence) -> t.Iterator:
-        for s in seq:
-            if isinstance(s, (tuple, list)):
-                yield from flatten(s)
-            else:
-                yield s
-    
-    def stringify(x: t.Optional[t.AnyStr]) -> str:
-        return '' if x is None else str(x).strip()
-    
-    out = []
-    for a in args:
-        if isinstance(a, (tuple, list)):
-            a = tuple(stringify(x) for x in flatten(a))
-            if all(a) or not filter:
-                out.extend(a)
-        else:
-            a = stringify(a)
-            if a or not filter:
-                out.append(a)
-    return out
-
-
-def run_command_args(
-    *args: t.Any,
-    verbose: bool = False,
-    shell: bool = False,
-    cwd: str = None,
-    blocking: bool = True,
-    ignore_error: bool = False,
-    ignore_return: bool = False,
-    filter: bool = True,
-    _refmt_args: bool = True,
-) -> t.Union[str, sp.Popen, None]:
-    """
-    https://stackoverflow.com/questions/58302588/how-to-both-capture-shell -
-    -command-output-and-show-it-in-terminal-at-realtime
-    
-    params:
-        _refmt_args: set to False is faster. this is for internal use.
-    
-    returns:
-        if ignore_return:
-            return None
-        else:
-            if blocking:
-                return <string>
-            else:
-                return <Popen object>
-    
-    memo:
-        `sp.run` is blocking, `sp.Popen` is non-blocking.
-    """
-    if _refmt_args:
-        args = compose_command(*args, filter=filter)
-    # else:
-    #     assert all(isinstance(x, str) for x in args)
-    if verbose:
-        print('[magenta dim]{}[/]'.format(' '.join(args)), ':psr')
-    
-    proc = sp.Popen(
-        args, stdout=sp.PIPE, stderr=sp.PIPE, text=True, shell=shell, cwd=cwd
-    )
-    
-    def communicate() -> t.Iterator[t.Tuple[str, int]]:
-        for line in proc.stdout:
-            if verbose:
-                bprint(line.rstrip())
-                # print(
-                #     '[dim]{}[/]'.format(line.rstrip().replace('[', '\\[')),
-                #     ':p2s1r',
-                # )
-            yield line, 0
-        for line in proc.stderr:
-            if verbose:
-                bprint(line.rstrip())
-                # print(
-                #     '[red dim]{}[/]'.format(line.rstrip().replace('[', '\\[')),
-                #     ':p2s1r',
-                # )
-            yield line, 1
-    
-    if blocking:
-        out, err = '', ''
-        for line, code in communicate():
-            if ignore_return:
-                continue
-            if code == 0:
-                out += line
-            else:
-                err += line
-        
-        if (code := proc.wait()) != 0:
-            if not ignore_error:
-                if verbose:  # the error trace info was already printed
-                    exit(code)
-                else:
-                    raise E.SubprocessError(proc.args, err, code)
-        
-        return None if ignore_return else (out or err).lstrip('\n').rstrip()
-    else:
-        if verbose:
-            run_new_thread(lambda: [_ for _ in communicate()])
-        return None if ignore_return else proc
-
-
-def run_command_line(
-    cmd: str,
-    *,
-    verbose: bool = False,
-    shell: bool = False,
-    cwd: str = None,
-    blocking: bool = True,
-    ignore_error: bool = False,
-    ignore_return: bool = False,
-    filter: bool = False,  # notice this differs
-) -> t.Union[str, sp.Popen, None]:
-    return run_command_args(
-        *shlex.split(cmd),
-        verbose=verbose,
-        shell=shell,
-        cwd=cwd,
-        blocking=blocking,
-        ignore_error=ignore_error,
-        ignore_return=ignore_return,
-        filter=filter,
-        _refmt_args=False,
-    )
-
-
-class E:
-    class SubprocessError(Exception):
-        def __init__(
-            self, args: t.Iterable[str], response: str, return_code: int = None
-        ):
-            self._args = ' '.join(args)
-            self._resp = response
-            self._code = str(return_code or 'null')
-        
-        def __str__(self):
-            from textwrap import dedent
-            from textwrap import indent
-            
-            return (
-                dedent('''
-                error happened with exit code {code}:
-                    args:
-                        {args}
-                    response:
-                        {response}
-            ''')
-                .format(
-                    code=self._code,
-                    args=self._args,
-                    response=indent(self._resp, ' ' * 8).lstrip(),
-                )
-                .strip()
-            )
-
-
-# alias
-compose = compose_cmd = compose_command
-run = run_cmd_args = run_command_args
-run_cmd_line = run_command_line
+import shlex
+import subprocess as sp
+
+from lk_logger import bprint
+
+from .threading import run_new_thread
+from .. import common_typing as t
+
+__all__ = [
+    'compose',
+    'compose_cmd',
+    'compose_command',
+    'run',
+    'run_cmd_args',
+    'run_command_args',
+    'run_cmd_line',
+    'run_command_line',
+]
+
+
+def compose_command(*args: t.Any, filter: bool = True) -> t.List[str]:
+    """
+    examples:
+        ('pip', 'install', '', 'lk-utils') -> ['pip', 'install', 'lk-utils']
+        ('pip', 'install', 'lk-utils', ('-i', mirror)) ->
+            if mirror is empty, returns ['pip', 'install', 'lk-utils']
+            else returns ['pip', 'install', 'lk-utils', '-i', mirror]
+    """
+    
+    def flatten(seq: t.Sequence) -> t.Iterator:
+        for s in seq:
+            if isinstance(s, (tuple, list)):
+                yield from flatten(s)
+            else:
+                yield s
+    
+    def stringify(x: t.Optional[t.AnyStr]) -> str:
+        return '' if x is None else str(x).strip()
+    
+    out = []
+    for a in args:
+        if isinstance(a, (tuple, list)):
+            a = tuple(stringify(x) for x in flatten(a))
+            if all(a) or not filter:
+                out.extend(a)
+        else:
+            a = stringify(a)
+            if a or not filter:
+                out.append(a)
+    return out
+
+
+def run_command_args(
+    *args: t.Any,
+    verbose: bool = False,
+    shell: bool = False,
+    cwd: str = None,
+    blocking: bool = True,
+    ignore_error: bool = False,
+    ignore_return: bool = False,
+    filter: bool = True,
+    _refmt_args: bool = True,
+) -> t.Union[str, sp.Popen, None]:
+    """
+    https://stackoverflow.com/questions/58302588/how-to-both-capture-shell -
+    -command-output-and-show-it-in-terminal-at-realtime
+    
+    params:
+        _refmt_args: set to False is faster. this is for internal use.
+    
+    returns:
+        if ignore_return:
+            return None
+        else:
+            if blocking:
+                return <string>
+            else:
+                return <Popen object>
+    
+    memo:
+        `sp.run` is blocking, `sp.Popen` is non-blocking.
+    """
+    if _refmt_args:
+        args = compose_command(*args, filter=filter)
+    # else:
+    #     assert all(isinstance(x, str) for x in args)
+    if verbose:
+        print('[magenta dim]{}[/]'.format(' '.join(args)), ':psr')
+    
+    proc = sp.Popen(
+        args, stdout=sp.PIPE, stderr=sp.PIPE, text=True, shell=shell, cwd=cwd
+    )
+    
+    def communicate() -> t.Iterator[t.Tuple[str, int]]:
+        for line in proc.stdout:
+            if verbose:
+                bprint(line.rstrip())
+                # print(
+                #     '[dim]{}[/]'.format(line.rstrip().replace('[', '\\[')),
+                #     ':p2s1r',
+                # )
+            yield line, 0
+        for line in proc.stderr:
+            if verbose:
+                bprint(line.rstrip())
+                # print(
+                #     '[red dim]{}[/]'.format(line.rstrip().replace('[', '\\[')),
+                #     ':p2s1r',
+                # )
+            yield line, 1
+    
+    if blocking:
+        out, err = '', ''
+        for line, code in communicate():
+            if ignore_return:
+                continue
+            if code == 0:
+                out += line
+            else:
+                err += line
+        
+        if (code := proc.wait()) != 0:
+            if not ignore_error:
+                if verbose:  # the error trace info was already printed
+                    exit(code)
+                else:
+                    raise E.SubprocessError(proc.args, err, code)
+        
+        return None if ignore_return else (out or err).lstrip('\n').rstrip()
+    else:
+        if verbose:
+            run_new_thread(lambda: [_ for _ in communicate()])
+        return None if ignore_return else proc
+
+
+def run_command_line(
+    cmd: str,
+    *,
+    verbose: bool = False,
+    shell: bool = False,
+    cwd: str = None,
+    blocking: bool = True,
+    ignore_error: bool = False,
+    ignore_return: bool = False,
+    filter: bool = False,  # notice this differs
+) -> t.Union[str, sp.Popen, None]:
+    return run_command_args(
+        *shlex.split(cmd),
+        verbose=verbose,
+        shell=shell,
+        cwd=cwd,
+        blocking=blocking,
+        ignore_error=ignore_error,
+        ignore_return=ignore_return,
+        filter=filter,
+        _refmt_args=False,
+    )
+
+
+class E:
+    class SubprocessError(Exception):
+        def __init__(
+            self, args: t.Iterable[str], response: str, return_code: int = None
+        ):
+            self._args = ' '.join(args)
+            self._resp = response
+            self._code = str(return_code or 'null')
+        
+        def __str__(self):
+            from textwrap import dedent
+            from textwrap import indent
+            
+            return (
+                dedent('''
+                error happened with exit code {code}:
+                    args:
+                        {args}
+                    response:
+                        {response}
+            ''')
+                .format(
+                    code=self._code,
+                    args=self._args,
+                    response=indent(self._resp, ' ' * 8).lstrip(),
+                )
+                .strip()
+            )
+
+
+# alias
+compose = compose_cmd = compose_command
+run = run_cmd_args = run_command_args
+run_cmd_line = run_command_line
```

## lk_utils/subproc/threading.py

 * *Ordering differences only*

```diff
@@ -1,286 +1,286 @@
-from collections import defaultdict
-from collections import deque
-from functools import wraps
-from threading import Thread
-from types import GeneratorType
-
-from .. import common_typing as t
-
-
-class T:
-    Group = str  # the default group is 'default'
-    Id = t.Union[str, int]
-    
-    # ThreadBroker
-    Target = t.TypeVar('Target', bound=t.Callable)
-    Args = t.Optional[tuple]
-    KwArgs = t.Optional[dict]
-    _Inherit = bool
-    Task = t.Tuple[Target, Args, KwArgs, _Inherit]
-    
-    # ThreadPool
-    ThreadBroker = t.ForwardRef('ThreadBroker')
-    ThreadPool = t.Dict[Group, t.Dict[Id, ThreadBroker]]
-
-
-class ThreadBroker:
-    _daemon: bool
-    _illed: t.Optional[Exception]
-    _interruptible: bool
-    _is_executed: bool
-    _is_running: bool
-    _result: t.Any
-    _target: T.Target
-    _tasks: t.Deque[T.Task]
-    _thread: Thread
-    
-    class Undefined:
-        pass
-    
-    def __init__(
-        self,
-        target: T.Target,
-        args: T.Args,
-        kwargs: T.KwArgs,
-        daemon: bool,
-        interruptible: bool = False,
-        start_now: bool = True,
-    ):
-        self._tasks = deque()
-        self._tasks.append((target, args, kwargs, False))
-        self._daemon = daemon
-        self._interruptible = interruptible
-        self._is_executed = False
-        self._is_running = False
-        self._result = ThreadBroker.Undefined
-        self._target = target
-        if start_now:
-            self.mainloop()
-    
-    # -------------------------------------------------------------------------
-    
-    @property
-    def illed(self) -> t.Optional[Exception]:
-        return self._illed
-    
-    @property
-    def interruptible(self) -> bool:
-        return self._interruptible
-    
-    @property
-    def is_running(self) -> bool:
-        return self._is_running
-    
-    # @property
-    # def is_alive(self) -> bool:
-    #     return self._thread.is_alive()
-    
-    @property
-    def result(self) -> t.Any:
-        if self._result is ThreadBroker.Undefined:
-            raise RuntimeError('The result is not ready yet.')
-        return self._result
-    
-    # -------------------------------------------------------------------------
-    
-    def start(self) -> None:
-        if self._is_running:
-            print('thread is already running', ':pv3')
-            return
-        self.mainloop()
-    
-    def mainloop(self) -> None:
-        self._is_running = True
-        
-        def loop() -> None:
-            while self._tasks:
-                func, args, kwargs, inherit = self._tasks.popleft()
-                if inherit:
-                    args = (self._result, *(args or ()))
-                try:
-                    self._result = func(*(args or ()), **(kwargs or {}))
-                except Exception as e:
-                    self._illed = e
-                    self._is_running = False
-                    raise e
-                if self._interruptible:
-                    if isinstance(self._result, GeneratorType):
-                        for _ in self._result:
-                            if not self._is_running:
-                                # a safe "break signal" emitted from the outside.
-                                print(
-                                    '[red dim]thread is safely killed[/]',
-                                    func,
-                                    ':r',
-                                )
-                                return
-                    else:
-                        print(
-                            '[yellow dim]thread is marked interruptible but '
-                            'there is no break point in function[/]',
-                            func,
-                            ':r',
-                        )
-            self._is_running = False
-        
-        self._thread = Thread(target=loop)
-        self._thread.daemon = self._daemon
-        self._thread.start()
-        self._is_executed = True
-    
-    def add_task(self, args: tuple = None, kwargs: dict = None) -> int:
-        self._tasks.append((self._target, args, kwargs, False))
-        number = len(self._tasks)
-        if not self._is_running:
-            self.mainloop()
-        return number
-    
-    def then(
-        self,
-        func: T.Target,
-        args: tuple = None,
-        kwargs: dict = None,
-        inherit: bool = True,
-    ) -> t.Self:
-        self._tasks.append((func, args, kwargs, inherit))
-        if not self._is_running:
-            self.mainloop()
-        return self
-    
-    def join(self, timeout: float = None) -> t.Any:
-        if not self._is_executed:
-            raise Exception('thread is never started!')
-        self._thread.join(timeout)
-        return self._result
-    
-    def kill(self) -> bool:
-        """
-        https://stackoverflow.com/questions/6416538/how-to-check-if-an-object-is
-        -a-generator-object-in-python
-        """
-        if self._interruptible:
-            self._is_running = False
-            return True
-        else:
-            # raise RuntimeError('the thread is not interuptable!')
-            print('the thread is not interruptible!', self._thread, ':v4p')
-            return False
-
-
-class ThreadManager:
-    thread_pool: T.ThreadPool
-    
-    def __init__(self):
-        self.thread_pool = defaultdict(dict)
-    
-    def new_thread(
-        self,
-        ident: T.Id = None,
-        group: T.Group = 'default',
-        daemon: bool = True,
-        singleton: bool = False,
-        interruptible: bool = False,
-    ) -> t.Callable[[T.Target], t.Callable[[t.Any], ThreadBroker]]:
-        """a decorator wraps target function in a new thread."""
-        
-        def decorator(func: T.Target) -> t.Callable[[t.Any], ThreadBroker]:
-            nonlocal ident
-            if ident is None:
-                ident = id(func)
-            
-            @wraps(func)
-            def wrapper(*args, **kwargs) -> ThreadBroker:
-                return self._create_thread_broker(
-                    group,
-                    ident,
-                    func,
-                    args,
-                    kwargs,
-                    daemon,
-                    singleton,
-                    interruptible,
-                )
-            
-            return wrapper
-        
-        return decorator
-    
-    def run_new_thread(
-        self,
-        target: T.Target,
-        args: T.Args = None,
-        kwargs: T.KwArgs = None,
-        daemon: bool = True,
-        interruptible: bool = False,
-    ) -> ThreadBroker:
-        """run function in a new thread at once."""
-        # # assert id(target) not in __thread_pool  # should i check it?
-        return self._create_thread_broker(
-            'default',
-            id(target),
-            target,
-            args,
-            kwargs,
-            daemon,
-            False,
-            interruptible,
-        )
-    
-    def _create_thread_broker(
-        self,
-        group: T.Group,
-        ident: T.Id,
-        target: T.Target,
-        args: T.Args = None,
-        kwargs: T.KwArgs = None,
-        daemon: bool = True,
-        singleton: bool = False,
-        interruptible: bool = False,
-    ) -> ThreadBroker:
-        if singleton:
-            if t := self.thread_pool[group].get(ident):
-                t.add_task(args, kwargs)
-                return t
-        broker = self.thread_pool[group][ident] = ThreadBroker(
-            target=target,
-            args=args,
-            kwargs=kwargs,
-            daemon=daemon,
-            interruptible=interruptible,
-        )
-        return broker
-    
-    # -------------------------------------------------------------------------
-    
-    class Delegate:
-        def __init__(self, *threads: ThreadBroker):
-            self.threads = threads
-        
-        def __len__(self) -> int:
-            return len(self.threads)
-        
-        def fetch_one(self, index=0) -> t.Optional[ThreadBroker]:
-            if self.threads:
-                return self.threads[index]
-            else:
-                return None
-        
-        def join_all(self) -> None:
-            for t in self.threads:
-                t.join()
-    
-    def retrieve_thread(
-        self, ident: T.Id, group: T.Group = 'default'
-    ) -> t.Optional[ThreadBroker]:
-        return self.thread_pool[group].get(ident)
-    
-    def retrieve_threads(
-        self, group: T.Group = 'default'
-    ) -> 'ThreadManager.Delegate':
-        return ThreadManager.Delegate(*self.thread_pool[group].values())
-
-
-thread_manager = ThreadManager()
-new_thread = thread_manager.new_thread
-run_new_thread = thread_manager.run_new_thread
-retrieve_thread = thread_manager.retrieve_thread
+from collections import defaultdict
+from collections import deque
+from functools import wraps
+from threading import Thread
+from types import GeneratorType
+
+from .. import common_typing as t
+
+
+class T:
+    Group = str  # the default group is 'default'
+    Id = t.Union[str, int]
+    
+    # ThreadBroker
+    Target = t.TypeVar('Target', bound=t.Callable)
+    Args = t.Optional[tuple]
+    KwArgs = t.Optional[dict]
+    _Inherit = bool
+    Task = t.Tuple[Target, Args, KwArgs, _Inherit]
+    
+    # ThreadPool
+    ThreadBroker = t.ForwardRef('ThreadBroker')
+    ThreadPool = t.Dict[Group, t.Dict[Id, ThreadBroker]]
+
+
+class ThreadBroker:
+    _daemon: bool
+    _illed: t.Optional[Exception]
+    _interruptible: bool
+    _is_executed: bool
+    _is_running: bool
+    _result: t.Any
+    _target: T.Target
+    _tasks: t.Deque[T.Task]
+    _thread: Thread
+    
+    class Undefined:
+        pass
+    
+    def __init__(
+        self,
+        target: T.Target,
+        args: T.Args,
+        kwargs: T.KwArgs,
+        daemon: bool,
+        interruptible: bool = False,
+        start_now: bool = True,
+    ):
+        self._tasks = deque()
+        self._tasks.append((target, args, kwargs, False))
+        self._daemon = daemon
+        self._interruptible = interruptible
+        self._is_executed = False
+        self._is_running = False
+        self._result = ThreadBroker.Undefined
+        self._target = target
+        if start_now:
+            self.mainloop()
+    
+    # -------------------------------------------------------------------------
+    
+    @property
+    def illed(self) -> t.Optional[Exception]:
+        return self._illed
+    
+    @property
+    def interruptible(self) -> bool:
+        return self._interruptible
+    
+    @property
+    def is_running(self) -> bool:
+        return self._is_running
+    
+    # @property
+    # def is_alive(self) -> bool:
+    #     return self._thread.is_alive()
+    
+    @property
+    def result(self) -> t.Any:
+        if self._result is ThreadBroker.Undefined:
+            raise RuntimeError('The result is not ready yet.')
+        return self._result
+    
+    # -------------------------------------------------------------------------
+    
+    def start(self) -> None:
+        if self._is_running:
+            print('thread is already running', ':pv3')
+            return
+        self.mainloop()
+    
+    def mainloop(self) -> None:
+        self._is_running = True
+        
+        def loop() -> None:
+            while self._tasks:
+                func, args, kwargs, inherit = self._tasks.popleft()
+                if inherit:
+                    args = (self._result, *(args or ()))
+                try:
+                    self._result = func(*(args or ()), **(kwargs or {}))
+                except Exception as e:
+                    self._illed = e
+                    self._is_running = False
+                    raise e
+                if self._interruptible:
+                    if isinstance(self._result, GeneratorType):
+                        for _ in self._result:
+                            if not self._is_running:
+                                # a safe "break signal" emitted from the outside.
+                                print(
+                                    '[red dim]thread is safely killed[/]',
+                                    func,
+                                    ':r',
+                                )
+                                return
+                    else:
+                        print(
+                            '[yellow dim]thread is marked interruptible but '
+                            'there is no break point in function[/]',
+                            func,
+                            ':r',
+                        )
+            self._is_running = False
+        
+        self._thread = Thread(target=loop)
+        self._thread.daemon = self._daemon
+        self._thread.start()
+        self._is_executed = True
+    
+    def add_task(self, args: tuple = None, kwargs: dict = None) -> int:
+        self._tasks.append((self._target, args, kwargs, False))
+        number = len(self._tasks)
+        if not self._is_running:
+            self.mainloop()
+        return number
+    
+    def then(
+        self,
+        func: T.Target,
+        args: tuple = None,
+        kwargs: dict = None,
+        inherit: bool = True,
+    ) -> t.Self:
+        self._tasks.append((func, args, kwargs, inherit))
+        if not self._is_running:
+            self.mainloop()
+        return self
+    
+    def join(self, timeout: float = None) -> t.Any:
+        if not self._is_executed:
+            raise Exception('thread is never started!')
+        self._thread.join(timeout)
+        return self._result
+    
+    def kill(self) -> bool:
+        """
+        https://stackoverflow.com/questions/6416538/how-to-check-if-an-object-is
+        -a-generator-object-in-python
+        """
+        if self._interruptible:
+            self._is_running = False
+            return True
+        else:
+            # raise RuntimeError('the thread is not interuptable!')
+            print('the thread is not interruptible!', self._thread, ':v4p')
+            return False
+
+
+class ThreadManager:
+    thread_pool: T.ThreadPool
+    
+    def __init__(self):
+        self.thread_pool = defaultdict(dict)
+    
+    def new_thread(
+        self,
+        ident: T.Id = None,
+        group: T.Group = 'default',
+        daemon: bool = True,
+        singleton: bool = False,
+        interruptible: bool = False,
+    ) -> t.Callable[[T.Target], t.Callable[[t.Any], ThreadBroker]]:
+        """a decorator wraps target function in a new thread."""
+        
+        def decorator(func: T.Target) -> t.Callable[[t.Any], ThreadBroker]:
+            nonlocal ident
+            if ident is None:
+                ident = id(func)
+            
+            @wraps(func)
+            def wrapper(*args, **kwargs) -> ThreadBroker:
+                return self._create_thread_broker(
+                    group,
+                    ident,
+                    func,
+                    args,
+                    kwargs,
+                    daemon,
+                    singleton,
+                    interruptible,
+                )
+            
+            return wrapper
+        
+        return decorator
+    
+    def run_new_thread(
+        self,
+        target: T.Target,
+        args: T.Args = None,
+        kwargs: T.KwArgs = None,
+        daemon: bool = True,
+        interruptible: bool = False,
+    ) -> ThreadBroker:
+        """run function in a new thread at once."""
+        # # assert id(target) not in __thread_pool  # should i check it?
+        return self._create_thread_broker(
+            'default',
+            id(target),
+            target,
+            args,
+            kwargs,
+            daemon,
+            False,
+            interruptible,
+        )
+    
+    def _create_thread_broker(
+        self,
+        group: T.Group,
+        ident: T.Id,
+        target: T.Target,
+        args: T.Args = None,
+        kwargs: T.KwArgs = None,
+        daemon: bool = True,
+        singleton: bool = False,
+        interruptible: bool = False,
+    ) -> ThreadBroker:
+        if singleton:
+            if t := self.thread_pool[group].get(ident):
+                t.add_task(args, kwargs)
+                return t
+        broker = self.thread_pool[group][ident] = ThreadBroker(
+            target=target,
+            args=args,
+            kwargs=kwargs,
+            daemon=daemon,
+            interruptible=interruptible,
+        )
+        return broker
+    
+    # -------------------------------------------------------------------------
+    
+    class Delegate:
+        def __init__(self, *threads: ThreadBroker):
+            self.threads = threads
+        
+        def __len__(self) -> int:
+            return len(self.threads)
+        
+        def fetch_one(self, index=0) -> t.Optional[ThreadBroker]:
+            if self.threads:
+                return self.threads[index]
+            else:
+                return None
+        
+        def join_all(self) -> None:
+            for t in self.threads:
+                t.join()
+    
+    def retrieve_thread(
+        self, ident: T.Id, group: T.Group = 'default'
+    ) -> t.Optional[ThreadBroker]:
+        return self.thread_pool[group].get(ident)
+    
+    def retrieve_threads(
+        self, group: T.Group = 'default'
+    ) -> 'ThreadManager.Delegate':
+        return ThreadManager.Delegate(*self.thread_pool[group].values())
+
+
+thread_manager = ThreadManager()
+new_thread = thread_manager.new_thread
+run_new_thread = thread_manager.run_new_thread
+retrieve_thread = thread_manager.retrieve_thread
```

## lk_utils/textwrap.py

 * *Ordering differences only*

```diff
@@ -1,41 +1,41 @@
-import re
-import textwrap
-
-from . import common_typing as t
-
-
-def dedent(text: str, lstrip: bool = True, join_sep: str = None) -> str:
-    """
-    params:
-        join_sep: suggest: '-', '|' or '\\'.
-    """
-    out = textwrap.dedent(text).rstrip()
-    if join_sep:
-        if '\\' in join_sep:
-            # escape for regular expression
-            join_sep = join_sep.replace('\\', '\\\\')
-        out = re.sub(rf' +{join_sep} *\n *', ' ', out)
-    return out.lstrip() if lstrip else out
-
-
-def indent(text: str, spaces: int = 4, rstrip: bool = True) -> str:
-    out = textwrap.indent(text, ' ' * spaces)
-    return out.rstrip() if rstrip else out
-
-
-def reindent(text: str, spaces: int = 4) -> str:
-    return indent(dedent(text), spaces)
-
-
-def join(
-    parts: t.Iterable[str],
-    indent_: int = 0,
-    sep: str = '\n',
-    lstrip: bool = True
-) -> str:
-    if indent_:
-        out = indent(sep.join(parts), indent_)
-        if lstrip:
-            return out.lstrip()
-        return out
-    return sep.join(parts)
+import re
+import textwrap
+
+from . import common_typing as t
+
+
+def dedent(text: str, lstrip: bool = True, join_sep: str = None) -> str:
+    """
+    params:
+        join_sep: suggest: '-', '|' or '\\'.
+    """
+    out = textwrap.dedent(text).rstrip()
+    if join_sep:
+        if '\\' in join_sep:
+            # escape for regular expression
+            join_sep = join_sep.replace('\\', '\\\\')
+        out = re.sub(rf' +{join_sep} *\n *', ' ', out)
+    return out.lstrip() if lstrip else out
+
+
+def indent(text: str, spaces: int = 4, rstrip: bool = True) -> str:
+    out = textwrap.indent(text, ' ' * spaces)
+    return out.rstrip() if rstrip else out
+
+
+def reindent(text: str, spaces: int = 4) -> str:
+    return indent(dedent(text), spaces)
+
+
+def join(
+    parts: t.Iterable[str],
+    indent_: int = 0,
+    sep: str = '\n',
+    lstrip: bool = True
+) -> str:
+    if indent_:
+        out = indent(sep.join(parts), indent_)
+        if lstrip:
+            return out.lstrip()
+        return out
+    return sep.join(parts)
```

## lk_utils/time_utils/__init__.py

 * *Ordering differences only*

```diff
@@ -1,7 +1,7 @@
-# from . import time
-# from . import timeit
-from .time import get_file_created_time
-from .time import get_file_modified_time
-from .time import timestamp
-from .time import wait
-from .timeit import timeit
+# from . import time
+# from . import timeit
+from .time import get_file_created_time
+from .time import get_file_modified_time
+from .time import timestamp
+from .time import wait
+from .timeit import timeit
```

## lk_utils/time_utils/time.py

 * *Ordering differences only*

```diff
@@ -1,61 +1,61 @@
-import time
-import typing as t
-from os import stat
-
-
-def get_file_created_time(
-    filepath: str, style: str = ''
-) -> t.Union[str, float]:
-    """
-    REF: demos/os_demo#get_file_created_time
-    """
-    time_float = stat(filepath).st_ctime
-    if style:
-        return timestamp(style, time_float)
-    else:
-        return time_float
-
-
-def get_file_modified_time(
-    filepath: str, style: str = ''
-) -> t.Union[str, float]:
-    """
-    REF: demos/os_demo#get_file_created_time
-    """
-    time_float = stat(filepath).st_mtime
-    if style:
-        return timestamp(style, time_float)
-    else:
-        return time_float
-
-
-def seconds_to_hms(second: int) -> str:
-    """
-    REF: https://www.jb51.net/article/147479.htm
-    """
-    m, s = divmod(second, 60)
-    h, m = divmod(m, 60)
-    hms = "%02d%02d%02d" % (h, m, s)
-    return hms
-
-
-def timestamp(style: str = 'y-m-d h:n:s', ctime: float = 0.0) -> str:
-    """
-    generate a timestamp string.
-    e.g. 'y-m-d h:n:s' -> '2018-12-27 15:13:45'
-    """
-    style = style \
-        .replace('y', '%Y').replace('m', '%m').replace('d', '%d') \
-        .replace('h', '%H').replace('n', '%M').replace('s', '%S')
-    if ctime:
-        return time.strftime(style, time.localtime(ctime))
-    else:
-        return time.strftime(style)
-
-
-def wait(timeout: float, interval: float = 1) -> t.Iterator[int]:
-    count = int(timeout / interval)
-    for i in range(count):
-        yield i
-        time.sleep(interval)
-    raise TimeoutError(f'timeout in {timeout} seconds (with {count} loops)')
+import time
+import typing as t
+from os import stat
+
+
+def get_file_created_time(
+    filepath: str, style: str = ''
+) -> t.Union[str, float]:
+    """
+    REF: demos/os_demo#get_file_created_time
+    """
+    time_float = stat(filepath).st_ctime
+    if style:
+        return timestamp(style, time_float)
+    else:
+        return time_float
+
+
+def get_file_modified_time(
+    filepath: str, style: str = ''
+) -> t.Union[str, float]:
+    """
+    REF: demos/os_demo#get_file_created_time
+    """
+    time_float = stat(filepath).st_mtime
+    if style:
+        return timestamp(style, time_float)
+    else:
+        return time_float
+
+
+def seconds_to_hms(second: int) -> str:
+    """
+    REF: https://www.jb51.net/article/147479.htm
+    """
+    m, s = divmod(second, 60)
+    h, m = divmod(m, 60)
+    hms = "%02d%02d%02d" % (h, m, s)
+    return hms
+
+
+def timestamp(style: str = 'y-m-d h:n:s', ctime: float = 0.0) -> str:
+    """
+    generate a timestamp string.
+    e.g. 'y-m-d h:n:s' -> '2018-12-27 15:13:45'
+    """
+    style = style \
+        .replace('y', '%Y').replace('m', '%m').replace('d', '%d') \
+        .replace('h', '%H').replace('n', '%M').replace('s', '%S')
+    if ctime:
+        return time.strftime(style, time.localtime(ctime))
+    else:
+        return time.strftime(style)
+
+
+def wait(timeout: float, interval: float = 1) -> t.Iterator[int]:
+    count = int(timeout / interval)
+    for i in range(count):
+        yield i
+        time.sleep(interval)
+    raise TimeoutError(f'timeout in {timeout} seconds (with {count} loops)')
```

## lk_utils/time_utils/timeit.py

 * *Ordering differences only*

```diff
@@ -1,177 +1,177 @@
-"""
-usages:
-    from lk_utils import timeit
-    @timeit(optional_label)
-    def somefunc():
-        ...
-    with timeit(optional_label):
-        ...
-"""
-import atexit
-import os.path
-import traceback
-import typing as t
-from contextlib import contextmanager
-from functools import partial
-from functools import wraps
-from inspect import currentframe
-from time import time
-from types import FunctionType
-
-import rich
-import rich.table
-
-
-class T:
-    Decorator = t.Callable
-    Function = FunctionType
-
-
-class TimeIt:
-    records: t.Dict[str, dict]
-    # _time: float
-    
-    def __init__(self) -> None:
-        self.records = {}
-        
-        @atexit.register
-        def _on_exit() -> None:
-            if self.records:
-                self.report()
-    
-    def __call__(self, label: str = None) -> t.Union[
-        t.ContextManager, T.Decorator
-    ]:
-        """
-        timeit can either be used as a decorator or a context manager.
-        usage 1:
-            @timeit(some_label)
-            def func():
-                pass
-        usage 2:
-            with timeit(some_label):
-                pass
-        """
-        # get source line of the caller
-        # ref: https://stackoverflow.com/a/72817601
-        stack = traceback.extract_stack(limit=2)
-        line = stack[-2].line.lstrip()
-        if line.startswith('@'):
-            return partial(self._wrap_func_with_timeit, label=label)
-        elif line.startswith('with '):
-            # return partial(self._timing, label=label)
-            # return lambda: self._timing(label)
-            if label is None:
-                caller_frame = currentframe().f_back
-                label = '{}:{}'.format(
-                    os.path.relpath(caller_frame.f_code.co_filename),
-                    caller_frame.f_lineno,
-                )
-            return _delegate(
-                partial(self._start_timing, label),
-                partial(self._end_timing, label)
-            )
-        else:
-            raise Exception('wrong usage', line)
-    
-    @contextmanager
-    def _timing(self, label: str = None) -> t.Iterator[t.Self]:
-        if label is None:
-            caller_frame = currentframe().f_back
-            label = '{}:{}'.format(
-                os.path.relpath(caller_frame.f_code.co_filename),
-                caller_frame.f_lineno,
-            )
-        start = self._start_timing(label)
-        yield self
-        self._end_timing(label, start)
-    
-    def _start_timing(self, label: str) -> float:
-        if label not in self.records:
-            self.records[label] = {
-                'count'    : 0,
-                'accu_time': 0.0,
-                'shortest' : 999,
-                'longest'  : 0.0,
-            }
-        return time()
-    
-    def _end_timing(self, label: str, start_time: float) -> float:
-        end_time = time()
-        duration = end_time - start_time
-        
-        node = self.records[label]
-        node['count'] += 1
-        node['accu_time'] += duration
-        if duration < node['shortest']:
-            node['shortest'] = duration
-        if duration > node['longest']:
-            node['longest'] = duration
-            
-        return end_time
-    
-    # -------------------------------------------------------------------------
-    
-    def _wrap_func_with_timeit(
-        self, func: T.Function, label: str = None
-    ) -> T.Decorator:
-        if label is None:
-            label = func.__qualname__
-        
-        @wraps(func)
-        def wrapper(*args, **kwargs) -> t.Any:
-            with self._timing(label):
-                return func(*args, **kwargs)
-        
-        return wrapper
-    
-    wrap = _wrap_func_with_timeit
-    
-    def report(self) -> None:
-        table = rich.table.Table(
-            'label/id',
-            'accumulative_time',
-            'call_count',
-            'average_call',
-            'shortest',
-            'longest',
-        )
-        table.columns[0].style = 'cyan'
-        table.columns[1].style = 'yellow'
-        table.columns[2].style = 'magenta'
-        table.columns[3].style = 'bold blue'
-        table.columns[4].style = 'green'
-        table.columns[5].style = 'red'
-        for label, data in self.records.items():
-            table.add_row(
-                label,
-                str(round(data['accu_time'], 2)) + 's',
-                str(data['count']),
-                str(round(data['accu_time'] / data['count'] * 1000, 2)) + 'ms',
-                str(round(data['shortest'] * 1000, 2)) + 'ms',
-                str(round(data['longest'] * 1000, 2)) + 'ms',
-            )
-        rich.print(table)
-
-
-class _Delegate:
-    _end: t.Optional[t.Callable[[float], t.Any]]
-    _start: t.Optional[t.Callable[[], float]]
-    _time: t.Optional[float]
-    
-    def __call__(self, start: t.Callable, end: t.Callable) -> t.Self:
-        self._start, self._end = start, end
-        return self
-    
-    def __enter__(self) -> None:
-        self._time = self._start()
-    
-    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
-        self._end(self._time)
-        # del self._start, self._end, self._time
-        self._start, self._end, self._time = None, None, None
-
-
-_delegate = _Delegate()
-timeit = TimeIt()
-report = timeit.report
+"""
+usages:
+    from lk_utils import timeit
+    @timeit(optional_label)
+    def somefunc():
+        ...
+    with timeit(optional_label):
+        ...
+"""
+import atexit
+import os.path
+import traceback
+import typing as t
+from contextlib import contextmanager
+from functools import partial
+from functools import wraps
+from inspect import currentframe
+from time import time
+from types import FunctionType
+
+import rich
+import rich.table
+
+
+class T:
+    Decorator = t.Callable
+    Function = FunctionType
+
+
+class TimeIt:
+    records: t.Dict[str, dict]
+    # _time: float
+    
+    def __init__(self) -> None:
+        self.records = {}
+        
+        @atexit.register
+        def _on_exit() -> None:
+            if self.records:
+                self.report()
+    
+    def __call__(self, label: str = None) -> t.Union[
+        t.ContextManager, T.Decorator
+    ]:
+        """
+        timeit can either be used as a decorator or a context manager.
+        usage 1:
+            @timeit(some_label)
+            def func():
+                pass
+        usage 2:
+            with timeit(some_label):
+                pass
+        """
+        # get source line of the caller
+        # ref: https://stackoverflow.com/a/72817601
+        stack = traceback.extract_stack(limit=2)
+        line = stack[-2].line.lstrip()
+        if line.startswith('@'):
+            return partial(self._wrap_func_with_timeit, label=label)
+        elif line.startswith('with '):
+            # return partial(self._timing, label=label)
+            # return lambda: self._timing(label)
+            if label is None:
+                caller_frame = currentframe().f_back
+                label = '{}:{}'.format(
+                    os.path.relpath(caller_frame.f_code.co_filename),
+                    caller_frame.f_lineno,
+                )
+            return _delegate(
+                partial(self._start_timing, label),
+                partial(self._end_timing, label)
+            )
+        else:
+            raise Exception('wrong usage', line)
+    
+    @contextmanager
+    def _timing(self, label: str = None) -> t.Iterator[t.Self]:
+        if label is None:
+            caller_frame = currentframe().f_back
+            label = '{}:{}'.format(
+                os.path.relpath(caller_frame.f_code.co_filename),
+                caller_frame.f_lineno,
+            )
+        start = self._start_timing(label)
+        yield self
+        self._end_timing(label, start)
+    
+    def _start_timing(self, label: str) -> float:
+        if label not in self.records:
+            self.records[label] = {
+                'count'    : 0,
+                'accu_time': 0.0,
+                'shortest' : 999,
+                'longest'  : 0.0,
+            }
+        return time()
+    
+    def _end_timing(self, label: str, start_time: float) -> float:
+        end_time = time()
+        duration = end_time - start_time
+        
+        node = self.records[label]
+        node['count'] += 1
+        node['accu_time'] += duration
+        if duration < node['shortest']:
+            node['shortest'] = duration
+        if duration > node['longest']:
+            node['longest'] = duration
+            
+        return end_time
+    
+    # -------------------------------------------------------------------------
+    
+    def _wrap_func_with_timeit(
+        self, func: T.Function, label: str = None
+    ) -> T.Decorator:
+        if label is None:
+            label = func.__qualname__
+        
+        @wraps(func)
+        def wrapper(*args, **kwargs) -> t.Any:
+            with self._timing(label):
+                return func(*args, **kwargs)
+        
+        return wrapper
+    
+    wrap = _wrap_func_with_timeit
+    
+    def report(self) -> None:
+        table = rich.table.Table(
+            'label/id',
+            'accumulative_time',
+            'call_count',
+            'average_call',
+            'shortest',
+            'longest',
+        )
+        table.columns[0].style = 'cyan'
+        table.columns[1].style = 'yellow'
+        table.columns[2].style = 'magenta'
+        table.columns[3].style = 'bold blue'
+        table.columns[4].style = 'green'
+        table.columns[5].style = 'red'
+        for label, data in self.records.items():
+            table.add_row(
+                label,
+                str(round(data['accu_time'], 2)) + 's',
+                str(data['count']),
+                str(round(data['accu_time'] / data['count'] * 1000, 2)) + 'ms',
+                str(round(data['shortest'] * 1000, 2)) + 'ms',
+                str(round(data['longest'] * 1000, 2)) + 'ms',
+            )
+        rich.print(table)
+
+
+class _Delegate:
+    _end: t.Optional[t.Callable[[float], t.Any]]
+    _start: t.Optional[t.Callable[[], float]]
+    _time: t.Optional[float]
+    
+    def __call__(self, start: t.Callable, end: t.Callable) -> t.Self:
+        self._start, self._end = start, end
+        return self
+    
+    def __enter__(self) -> None:
+        self._time = self._start()
+    
+    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
+        self._end(self._time)
+        # del self._start, self._end, self._time
+        self._start, self._end, self._time = None, None, None
+
+
+_delegate = _Delegate()
+timeit = TimeIt()
+report = timeit.report
```

## Comparing `lk_utils-2.9.4.dist-info/METADATA` & `lk_utils-2.9.5.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: lk-utils
-Version: 2.9.4
+Version: 2.9.5
 Summary: LK Utils is a set of utility wrappers made for data processing.
 License: MIT
 Author: Likianta
 Author-email: likianta@foxmail.com
 Requires-Python: >=3.8,<4.0
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
```

## Comparing `lk_utils-2.9.4.dist-info/RECORD` & `lk_utils-2.9.5.dist-info/RECORD`

 * *Files 13% similar despite different names*

```diff
@@ -1,26 +1,24 @@
-lk_utils/__init__.py,sha256=CImGoWF30TAjKXTVtcpBkfscEEubGWrViVUr8l7stAY,1750
+lk_utils/__init__.py,sha256=zLrbwc8rwsxJRRBV_OZy0fit2wFz55D-zSoiCH4Srqw,1802
 lk_utils/__main__.py,sha256=KA4dDZb-xAV20iKRTg_YijCSOGepJG_j8h0O6VMYuu8,847
-lk_utils/binding/__init__.py,sha256=Jk4aZkU0EA5dT8r6RUKjKQ1qAdJpHG9c3GwnuWawHww,185
-lk_utils/binding/binding.py,sha256=pATcRkfHMAwWAk7GsYS8xXx4B1w004mj1GG8PTCg2Vc,2016
-lk_utils/binding/defer.py,sha256=tskWv8YveJAWNhAjEY1o7ME_L6ubwMcAJ0jNO1eCZOo,696
-lk_utils/binding/signal.py,sha256=cB8hjMW4OOUkCuHKafVlR7SjySDnvrqWyvSvl57R-jE,6350
-lk_utils/common_typing.py,sha256=k-bc-wizItD81mIlTPhzSJmtaoFXKjCP4HrZJhJJUx8,410
+lk_utils/binding/__init__.py,sha256=hwDlYyjeEG3tgoK8PWuDTSXRKALqTQdk_ErNslmK4Xs,191
+lk_utils/binding/binding.py,sha256=t1-I8qTRwxWsM1MK8CT-9aq3iLH7i9TmaDtSZjpy5RI,2090
+lk_utils/binding/signal.py,sha256=QGT78l6r8cuMsdNbKj2sWLyBcvD-gcIgC9PXRHRXEjs,6566
+lk_utils/common_typing.py,sha256=QxfNTuqn0JreLbsEXsSKc5z2kyAuayJfHSthDImwQ60,426
 lk_utils/filesniff/__init__.py,sha256=rtggL_f0-XRZga_t8jWg8sbIwDFsJUIYz-PFcHE0daM,141
-lk_utils/filesniff/finder.py,sha256=6RCryziJqByUPCUBk7ugSeITKaoO_SPBX9z9TObQY-o,9735
-lk_utils/filesniff/main.py,sha256=QK_yxep5KUu9JiDqCnPFAq4ZhGVWiqW_fxIc9Qk_4jo,6772
-lk_utils/filesniff/shutil.py,sha256=qMVWopIGW_TRxGXY_qpEgEMLh9tIyQ2jJeHuYVbT8HU,3753
+lk_utils/filesniff/finder.py,sha256=67YhrGDfzHugRZHm-yp_F-ClD5Y4hj9W7AS-w8d_Gh8,9074
+lk_utils/filesniff/main.py,sha256=kmsim61FY-gYmQUVNe5mLdTqZN9DrhcJK9hn8A3u-NU,7036
+lk_utils/filesniff/shutil.py,sha256=jYmH3IflCjyyJ2kz2n3OqG49_ykeEJshS-fsnphrkrs,3903
 lk_utils/filesniff/traceback.py,sha256=SoJjnT2ArSrgR3NGOtQ_awCyMQga-e7W6ij7jp0zfdA,582
-lk_utils/importer.py,sha256=SoJciwW2pUahqdWn_HtNSV2x9sAkpmkghFeqsMHmXlc,1056
-lk_utils/read_and_write.py,sha256=oLmGlyFCrOogTWXm-_IyMnmidzSA4gRlh1abE5OGSz0,6455
-lk_utils/subproc/__init__.py,sha256=unuknQy_ylsVHNjWexRlBXIqWX4rPSJvQmD1_1WdSWE,495
-lk_utils/subproc/multiprocess.py,sha256=rWLUB9y-_WtVq63E20fQUG4KLGr-I1vhrBopJ5yms0M,606
-lk_utils/subproc/promise.py,sha256=MKH1oUHYxxq-65yyDcJxsI-v_QOVPOIbJJAqVOrS9v0,1816
-lk_utils/subproc/subprocess.py,sha256=DZ8wgwoyae2GLG-KqFASQY_0ZcJZSpfhRT-0JefxlVk,5381
-lk_utils/subproc/threading.py,sha256=m9pWtcMkwlGqL4w5_rPazUVM96tDUEhb5UNB6qQTxMg,8592
-lk_utils/textwrap.py,sha256=LHNz-HcijyLJFjhSwGRnq7SUsSWktiJ-Sp6hRLSMnCA,1018
-lk_utils/time_utils/__init__.py,sha256=IUPhGSeyiDdNfJpEFAhNd0rMb2CaxIqZo8yKfAUmK5g,203
-lk_utils/time_utils/time.py,sha256=orUzrsQ81fvLIQShEeam-2QfF8IRHITZN--KMbmRO4I,1533
-lk_utils/time_utils/timeit.py,sha256=3QtXEelzxWpUG8LKayn6jkITXPSuSdD7hVbyYXvK8dA,5207
-lk_utils-2.9.4.dist-info/METADATA,sha256=My9Y6xCcDRB5m4pxbWSInvSY7ASEueFvfUQsHmuNF-Q,3897
-lk_utils-2.9.4.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
-lk_utils-2.9.4.dist-info/RECORD,,
+lk_utils/read_and_write.py,sha256=5v4VSAvbNyjDkPsaaIdiuguudEM21u5nDCI1FJrEU5k,6680
+lk_utils/subproc/__init__.py,sha256=UdMbfz7vQr1ghGMGS6G6i24c2ZaCGtTSM7kqqQ0_lbg,508
+lk_utils/subproc/multiprocess.py,sha256=bxykxT0qWtmqBBGo1G2dn9PICTumEdyojISpfPzWcxM,630
+lk_utils/subproc/promise.py,sha256=DkUhSaCmId-Tri8T2qT4omaSuEsRNVcq8cTlwiNMzJs,1886
+lk_utils/subproc/subprocess.py,sha256=0AtbQOX7DCl30iP7-ZsuFsQ-RI19i3b3PaChy1FmEls,5574
+lk_utils/subproc/threading.py,sha256=gS4C37Vbboln73sMZupBCbIos0i0edjHDTO2s8RR1sE,8878
+lk_utils/textwrap.py,sha256=GeWyPjlcMsSFS-g4voSbZjVUIfXsuuo16VLGFMnzJO8,1059
+lk_utils/time_utils/__init__.py,sha256=3Zwuh8pFeTlBGpVMVaqucGUT8u21M1OFgu9pWdyg4Ic,210
+lk_utils/time_utils/time.py,sha256=hu2AHlFvIHK9l_pw4BPMzmTMWO6m5jDlrmHojnZRPbo,1594
+lk_utils/time_utils/timeit.py,sha256=3M4sWGyc9WDFzKPi6Kf2AZ7SiGWJkdgXi6Is19YUiL8,5384
+lk_utils-2.9.5.dist-info/METADATA,sha256=0fn_mtx1s19Rm7_cSLsb611sQ-w6DGCkVDqfqbekzMo,3897
+lk_utils-2.9.5.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
+lk_utils-2.9.5.dist-info/RECORD,,
```

