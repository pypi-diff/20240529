# Comparing `tmp/switchboard_hw-0.2.3-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip` & `tmp/switchboard_hw-0.2.4-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,100 +1,100 @@
-Zip file size: 333926 bytes, number of entries: 98
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-24 19:12 switchboard/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-24 19:12 switchboard_hw-0.2.3.dist-info/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-24 19:12 switchboard_hw.libs/
--rwxr-xr-x  2.0 unx   603792 b- defN 24-May-24 19:12 _switchboard.cpython-39-x86_64-linux-gnu.so
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-24 19:12 switchboard/cpp/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-24 19:12 switchboard/verilog/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-24 19:12 switchboard/dpi/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-24 19:12 switchboard/verilator/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-24 19:12 switchboard/vpi/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-24 19:12 switchboard/sc/
--rw-r--r--  2.0 unx      941 b- defN 24-May-24 19:12 switchboard/__init__.py
--rw-r--r--  2.0 unx     1333 b- defN 24-May-24 19:12 switchboard/test_util.py
--rw-r--r--  2.0 unx     5598 b- defN 24-May-24 19:12 switchboard/cmdline.py
--rw-r--r--  2.0 unx      547 b- defN 24-May-24 19:12 switchboard/xyce.py
--rw-r--r--  2.0 unx    12870 b- defN 24-May-24 19:12 switchboard/axil.py
--rw-r--r--  2.0 unx    19799 b- defN 24-May-24 19:12 switchboard/axi.py
--rw-r--r--  2.0 unx    19774 b- defN 24-May-24 19:12 switchboard/autowrap.py
--rw-r--r--  2.0 unx      311 b- defN 24-May-24 19:12 switchboard/warn.py
--rw-r--r--  2.0 unx     8247 b- defN 24-May-24 19:12 switchboard/sbtcp.py
--rw-r--r--  2.0 unx     2341 b- defN 24-May-24 19:12 switchboard/util.py
--rw-r--r--  2.0 unx     2088 b- defN 24-May-24 19:12 switchboard/icarus.py
--rw-r--r--  2.0 unx     1701 b- defN 24-May-24 19:12 switchboard/uart_xactor.py
--rw-r--r--  2.0 unx    26939 b- defN 24-May-24 19:12 switchboard/umi.py
--rw-r--r--  2.0 unx     5246 b- defN 24-May-24 19:12 switchboard/loopback.py
--rw-r--r--  2.0 unx    12327 b- defN 24-May-24 19:12 switchboard/network.py
--rw-r--r--  2.0 unx     1012 b- defN 24-May-24 19:12 switchboard/verilator.py
--rw-r--r--  2.0 unx     1506 b- defN 24-May-24 19:12 switchboard/switchboard.py
--rw-r--r--  2.0 unx     3398 b- defN 24-May-24 19:12 switchboard/bitvector.py
--rw-r--r--  2.0 unx    28459 b- defN 24-May-24 19:12 switchboard/sbdut.py
--rw-r--r--  2.0 unx     2706 b- defN 24-May-24 19:12 switchboard/gpio.py
--rw-r--r--  2.0 unx    18067 b- defN 24-May-24 19:12 switchboard/ams.py
--rw-r--r--  2.0 unx     4047 b- defN 24-May-24 19:12 switchboard/cpp/pciedev.h
--rw-r--r--  2.0 unx     2376 b- defN 24-May-24 19:12 switchboard/cpp/pagemap.h
--rw-r--r--  2.0 unx     2351 b- defN 24-May-24 19:12 switchboard/cpp/xyce.hpp
--rw-r--r--  2.0 unx     6064 b- defN 24-May-24 19:12 switchboard/cpp/switchboard.hpp
--rw-r--r--  2.0 unx     6479 b- defN 24-May-24 19:12 switchboard/cpp/spsc_queue.h
--rw-r--r--  2.0 unx     3809 b- defN 24-May-24 19:12 switchboard/cpp/umilib.hpp
--rw-r--r--  2.0 unx      291 b- defN 24-May-24 19:12 switchboard/cpp/Makefile
--rw-r--r--  2.0 unx      979 b- defN 24-May-24 19:12 switchboard/cpp/bitutil.h
--rw-r--r--  2.0 unx     9987 b- defN 24-May-24 19:12 switchboard/cpp/umisb.hpp
--rw-r--r--  2.0 unx     2786 b- defN 24-May-24 19:12 switchboard/cpp/router.cc
--rw-r--r--  2.0 unx     6188 b- defN 24-May-24 19:12 switchboard/cpp/switchboard_pcie.hpp
--rw-r--r--  2.0 unx     2514 b- defN 24-May-24 19:12 switchboard/cpp/switchboard_tlm.hpp
--rw-r--r--  2.0 unx     4477 b- defN 24-May-24 19:12 switchboard/cpp/umilib.h
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-24 19:12 switchboard/verilog/common/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-24 19:12 switchboard/verilog/sim/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-24 19:12 switchboard/verilog/fpga/
--rw-r--r--  2.0 unx     7372 b- defN 24-May-24 19:12 switchboard/verilog/common/uart_xactor.sv
--rw-r--r--  2.0 unx    31459 b- defN 24-May-24 19:12 switchboard/verilog/common/switchboard.vh
--rw-r--r--  2.0 unx     7590 b- defN 24-May-24 19:12 switchboard/verilog/common/umi_gpio.v
--rw-r--r--  2.0 unx     1423 b- defN 24-May-24 19:12 switchboard/verilog/sim/umi_rx_sim.sv
--rw-r--r--  2.0 unx     6424 b- defN 24-May-24 19:12 switchboard/verilog/sim/sb_to_queue_sim.sv
--rw-r--r--  2.0 unx     5670 b- defN 24-May-24 19:12 switchboard/verilog/sim/sb_axi_m.sv
--rw-r--r--  2.0 unx     1902 b- defN 24-May-24 19:12 switchboard/verilog/sim/xyce_intf.sv
--rw-r--r--  2.0 unx     4556 b- defN 24-May-24 19:12 switchboard/verilog/sim/sb_jtag_rbb_sim.sv
--rw-r--r--  2.0 unx     1283 b- defN 24-May-24 19:12 switchboard/verilog/sim/sb_tx_sim.sv
--rw-r--r--  2.0 unx     4577 b- defN 24-May-24 19:12 switchboard/verilog/sim/sb_axil_s.sv
--rw-r--r--  2.0 unx     5504 b- defN 24-May-24 19:12 switchboard/verilog/sim/queue_to_sb_sim.sv
--rw-r--r--  2.0 unx     3310 b- defN 24-May-24 19:12 switchboard/verilog/sim/perf_meas_sim.sv
--rw-r--r--  2.0 unx     2207 b- defN 24-May-24 19:12 switchboard/verilog/sim/sb_clk_gen.sv
--rw-r--r--  2.0 unx     1535 b- defN 24-May-24 19:12 switchboard/verilog/sim/umi_to_queue_sim.sv
--rw-r--r--  2.0 unx     1419 b- defN 24-May-24 19:12 switchboard/verilog/sim/umi_tx_sim.sv
--rw-r--r--  2.0 unx      468 b- defN 24-May-24 19:12 switchboard/verilog/sim/auto_stop_sim.sv
--rw-r--r--  2.0 unx     1506 b- defN 24-May-24 19:12 switchboard/verilog/sim/queue_to_umi_sim.sv
--rw-r--r--  2.0 unx     4577 b- defN 24-May-24 19:12 switchboard/verilog/sim/sb_axil_m.sv
--rw-r--r--  2.0 unx     1286 b- defN 24-May-24 19:12 switchboard/verilog/sim/sb_rx_sim.sv
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-24 19:12 switchboard/verilog/fpga/include/
--rw-r--r--  2.0 unx     7821 b- defN 24-May-24 19:12 switchboard/verilog/fpga/sb_rx_fpga.sv
--rw-r--r--  2.0 unx     7608 b- defN 24-May-24 19:12 switchboard/verilog/fpga/sb_tx_fpga.sv
--rw-r--r--  2.0 unx     1005 b- defN 24-May-24 19:12 switchboard/verilog/fpga/memory_fault.sv
--rw-r--r--  2.0 unx     4341 b- defN 24-May-24 19:12 switchboard/verilog/fpga/umi_fpga_queues.sv
--rw-r--r--  2.0 unx    13623 b- defN 24-May-24 19:12 switchboard/verilog/fpga/sb_fpga_queues.sv
--rw-r--r--  2.0 unx     8478 b- defN 24-May-24 19:12 switchboard/verilog/fpga/config_registers.sv
--rw-r--r--  2.0 unx     2061 b- defN 24-May-24 19:12 switchboard/verilog/fpga/axi_reader.sv
--rw-r--r--  2.0 unx     3171 b- defN 24-May-24 19:12 switchboard/verilog/fpga/axi_writer.sv
--rw-r--r--  2.0 unx      272 b- defN 24-May-24 19:12 switchboard/verilog/fpga/include/spsc_queue.vh
--rw-r--r--  2.0 unx      789 b- defN 24-May-24 19:12 switchboard/verilog/fpga/include/sb_queue_regmap.vh
--rw-r--r--  2.0 unx     1103 b- defN 24-May-24 19:12 switchboard/dpi/xyce_dpi.cc
--rw-r--r--  2.0 unx     3469 b- defN 24-May-24 19:12 switchboard/dpi/switchboard_dpi.cc
--rw-r--r--  2.0 unx     4571 b- defN 24-May-24 19:12 switchboard/verilator/testbench.cc
--rw-r--r--  2.0 unx      526 b- defN 24-May-24 19:12 switchboard/verilator/config.vlt
--rw-r--r--  2.0 unx    11038 b- defN 24-May-24 19:12 switchboard/vpi/switchboard_vpi.cc
--rw-r--r--  2.0 unx     4954 b- defN 24-May-24 19:12 switchboard/vpi/xyce_vpi.cc
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-24 19:12 switchboard/sc/morty/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-24 19:12 switchboard/sc/sed/
--rw-r--r--  2.0 unx        0 b- defN 24-May-24 19:12 switchboard/sc/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 24-May-24 19:12 switchboard/sc/morty/__init__.py
--rw-r--r--  2.0 unx     1790 b- defN 24-May-24 19:12 switchboard/sc/morty/uniquify.py
--rw-r--r--  2.0 unx      353 b- defN 24-May-24 19:12 switchboard/sc/morty/morty.py
--rw-r--r--  2.0 unx        0 b- defN 24-May-24 19:12 switchboard/sc/sed/__init__.py
--rw-r--r--  2.0 unx     1082 b- defN 24-May-24 19:12 switchboard/sc/sed/remove.py
--rw-r--r--  2.0 unx      238 b- defN 24-May-24 19:12 switchboard/sc/sed/sed.py
--rw-r--r--  2.0 unx      148 b- defN 24-May-24 19:12 switchboard_hw-0.2.3.dist-info/WHEEL
--rw-r--r--  2.0 unx    10766 b- defN 24-May-24 19:12 switchboard_hw-0.2.3.dist-info/LICENSE
--rw-r--r--  2.0 unx       25 b- defN 24-May-24 19:12 switchboard_hw-0.2.3.dist-info/top_level.txt
--rw-r--r--  2.0 unx       92 b- defN 24-May-24 19:12 switchboard_hw-0.2.3.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx     7378 b- defN 24-May-24 19:12 switchboard_hw-0.2.3.dist-info/RECORD
--rw-r--r--  2.0 unx    18115 b- defN 24-May-24 19:12 switchboard_hw-0.2.3.dist-info/METADATA
-98 files, 1040235 bytes uncompressed, 320564 bytes compressed:  69.2%
+Zip file size: 335938 bytes, number of entries: 98
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-29 20:01 switchboard/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-29 20:01 switchboard_hw-0.2.4.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-29 20:01 switchboard_hw.libs/
+-rwxr-xr-x  2.0 unx   603792 b- defN 24-May-29 20:01 _switchboard.cpython-39-x86_64-linux-gnu.so
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-29 20:01 switchboard/cpp/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-29 20:01 switchboard/verilog/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-29 20:01 switchboard/dpi/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-29 20:01 switchboard/verilator/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-29 20:01 switchboard/vpi/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-29 20:01 switchboard/sc/
+-rw-r--r--  2.0 unx      982 b- defN 24-May-29 20:01 switchboard/__init__.py
+-rw-r--r--  2.0 unx     1333 b- defN 24-May-29 20:01 switchboard/test_util.py
+-rw-r--r--  2.0 unx     5598 b- defN 24-May-29 20:01 switchboard/cmdline.py
+-rw-r--r--  2.0 unx      547 b- defN 24-May-29 20:01 switchboard/xyce.py
+-rw-r--r--  2.0 unx    12870 b- defN 24-May-29 20:01 switchboard/axil.py
+-rw-r--r--  2.0 unx    19799 b- defN 24-May-29 20:01 switchboard/axi.py
+-rw-r--r--  2.0 unx    24879 b- defN 24-May-29 20:01 switchboard/autowrap.py
+-rw-r--r--  2.0 unx      311 b- defN 24-May-29 20:01 switchboard/warn.py
+-rw-r--r--  2.0 unx     8247 b- defN 24-May-29 20:01 switchboard/sbtcp.py
+-rw-r--r--  2.0 unx     2341 b- defN 24-May-29 20:01 switchboard/util.py
+-rw-r--r--  2.0 unx     2088 b- defN 24-May-29 20:01 switchboard/icarus.py
+-rw-r--r--  2.0 unx     1701 b- defN 24-May-29 20:01 switchboard/uart_xactor.py
+-rw-r--r--  2.0 unx    26939 b- defN 24-May-29 20:01 switchboard/umi.py
+-rw-r--r--  2.0 unx     5246 b- defN 24-May-29 20:01 switchboard/loopback.py
+-rw-r--r--  2.0 unx    16148 b- defN 24-May-29 20:01 switchboard/network.py
+-rw-r--r--  2.0 unx     1012 b- defN 24-May-29 20:01 switchboard/verilator.py
+-rw-r--r--  2.0 unx     1506 b- defN 24-May-29 20:01 switchboard/switchboard.py
+-rw-r--r--  2.0 unx     3305 b- defN 24-May-29 20:01 switchboard/bitvector.py
+-rw-r--r--  2.0 unx    28459 b- defN 24-May-29 20:01 switchboard/sbdut.py
+-rw-r--r--  2.0 unx     2706 b- defN 24-May-29 20:01 switchboard/gpio.py
+-rw-r--r--  2.0 unx    18067 b- defN 24-May-29 20:01 switchboard/ams.py
+-rw-r--r--  2.0 unx     4047 b- defN 24-May-29 20:01 switchboard/cpp/pciedev.h
+-rw-r--r--  2.0 unx     2376 b- defN 24-May-29 20:01 switchboard/cpp/pagemap.h
+-rw-r--r--  2.0 unx     2351 b- defN 24-May-29 20:01 switchboard/cpp/xyce.hpp
+-rw-r--r--  2.0 unx     6064 b- defN 24-May-29 20:01 switchboard/cpp/switchboard.hpp
+-rw-r--r--  2.0 unx     6479 b- defN 24-May-29 20:01 switchboard/cpp/spsc_queue.h
+-rw-r--r--  2.0 unx     3809 b- defN 24-May-29 20:01 switchboard/cpp/umilib.hpp
+-rw-r--r--  2.0 unx      291 b- defN 24-May-29 20:01 switchboard/cpp/Makefile
+-rw-r--r--  2.0 unx      979 b- defN 24-May-29 20:01 switchboard/cpp/bitutil.h
+-rw-r--r--  2.0 unx     9987 b- defN 24-May-29 20:01 switchboard/cpp/umisb.hpp
+-rw-r--r--  2.0 unx     2786 b- defN 24-May-29 20:01 switchboard/cpp/router.cc
+-rw-r--r--  2.0 unx     6188 b- defN 24-May-29 20:01 switchboard/cpp/switchboard_pcie.hpp
+-rw-r--r--  2.0 unx     2514 b- defN 24-May-29 20:01 switchboard/cpp/switchboard_tlm.hpp
+-rw-r--r--  2.0 unx     4477 b- defN 24-May-29 20:01 switchboard/cpp/umilib.h
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-29 20:01 switchboard/verilog/common/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-29 20:01 switchboard/verilog/sim/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-29 20:01 switchboard/verilog/fpga/
+-rw-r--r--  2.0 unx     7372 b- defN 24-May-29 20:01 switchboard/verilog/common/uart_xactor.sv
+-rw-r--r--  2.0 unx    31459 b- defN 24-May-29 20:01 switchboard/verilog/common/switchboard.vh
+-rw-r--r--  2.0 unx     7590 b- defN 24-May-29 20:01 switchboard/verilog/common/umi_gpio.v
+-rw-r--r--  2.0 unx     1423 b- defN 24-May-29 20:01 switchboard/verilog/sim/umi_rx_sim.sv
+-rw-r--r--  2.0 unx     6424 b- defN 24-May-29 20:01 switchboard/verilog/sim/sb_to_queue_sim.sv
+-rw-r--r--  2.0 unx     5670 b- defN 24-May-29 20:01 switchboard/verilog/sim/sb_axi_m.sv
+-rw-r--r--  2.0 unx     1902 b- defN 24-May-29 20:01 switchboard/verilog/sim/xyce_intf.sv
+-rw-r--r--  2.0 unx     4556 b- defN 24-May-29 20:01 switchboard/verilog/sim/sb_jtag_rbb_sim.sv
+-rw-r--r--  2.0 unx     1283 b- defN 24-May-29 20:01 switchboard/verilog/sim/sb_tx_sim.sv
+-rw-r--r--  2.0 unx     4577 b- defN 24-May-29 20:01 switchboard/verilog/sim/sb_axil_s.sv
+-rw-r--r--  2.0 unx     5504 b- defN 24-May-29 20:01 switchboard/verilog/sim/queue_to_sb_sim.sv
+-rw-r--r--  2.0 unx     3310 b- defN 24-May-29 20:01 switchboard/verilog/sim/perf_meas_sim.sv
+-rw-r--r--  2.0 unx     2207 b- defN 24-May-29 20:01 switchboard/verilog/sim/sb_clk_gen.sv
+-rw-r--r--  2.0 unx     1535 b- defN 24-May-29 20:01 switchboard/verilog/sim/umi_to_queue_sim.sv
+-rw-r--r--  2.0 unx     1419 b- defN 24-May-29 20:01 switchboard/verilog/sim/umi_tx_sim.sv
+-rw-r--r--  2.0 unx      468 b- defN 24-May-29 20:01 switchboard/verilog/sim/auto_stop_sim.sv
+-rw-r--r--  2.0 unx     1506 b- defN 24-May-29 20:01 switchboard/verilog/sim/queue_to_umi_sim.sv
+-rw-r--r--  2.0 unx     4577 b- defN 24-May-29 20:01 switchboard/verilog/sim/sb_axil_m.sv
+-rw-r--r--  2.0 unx     1286 b- defN 24-May-29 20:01 switchboard/verilog/sim/sb_rx_sim.sv
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-29 20:01 switchboard/verilog/fpga/include/
+-rw-r--r--  2.0 unx     7821 b- defN 24-May-29 20:01 switchboard/verilog/fpga/sb_rx_fpga.sv
+-rw-r--r--  2.0 unx     7608 b- defN 24-May-29 20:01 switchboard/verilog/fpga/sb_tx_fpga.sv
+-rw-r--r--  2.0 unx     1005 b- defN 24-May-29 20:01 switchboard/verilog/fpga/memory_fault.sv
+-rw-r--r--  2.0 unx     4341 b- defN 24-May-29 20:01 switchboard/verilog/fpga/umi_fpga_queues.sv
+-rw-r--r--  2.0 unx    13623 b- defN 24-May-29 20:01 switchboard/verilog/fpga/sb_fpga_queues.sv
+-rw-r--r--  2.0 unx     8478 b- defN 24-May-29 20:01 switchboard/verilog/fpga/config_registers.sv
+-rw-r--r--  2.0 unx     2061 b- defN 24-May-29 20:01 switchboard/verilog/fpga/axi_reader.sv
+-rw-r--r--  2.0 unx     3171 b- defN 24-May-29 20:01 switchboard/verilog/fpga/axi_writer.sv
+-rw-r--r--  2.0 unx      272 b- defN 24-May-29 20:01 switchboard/verilog/fpga/include/spsc_queue.vh
+-rw-r--r--  2.0 unx      789 b- defN 24-May-29 20:01 switchboard/verilog/fpga/include/sb_queue_regmap.vh
+-rw-r--r--  2.0 unx     1103 b- defN 24-May-29 20:01 switchboard/dpi/xyce_dpi.cc
+-rw-r--r--  2.0 unx     3469 b- defN 24-May-29 20:01 switchboard/dpi/switchboard_dpi.cc
+-rw-r--r--  2.0 unx     4571 b- defN 24-May-29 20:01 switchboard/verilator/testbench.cc
+-rw-r--r--  2.0 unx      526 b- defN 24-May-29 20:01 switchboard/verilator/config.vlt
+-rw-r--r--  2.0 unx    11038 b- defN 24-May-29 20:01 switchboard/vpi/switchboard_vpi.cc
+-rw-r--r--  2.0 unx     4954 b- defN 24-May-29 20:01 switchboard/vpi/xyce_vpi.cc
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-29 20:01 switchboard/sc/morty/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-29 20:01 switchboard/sc/sed/
+-rw-r--r--  2.0 unx        0 b- defN 24-May-29 20:01 switchboard/sc/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-29 20:01 switchboard/sc/morty/__init__.py
+-rw-r--r--  2.0 unx     1790 b- defN 24-May-29 20:01 switchboard/sc/morty/uniquify.py
+-rw-r--r--  2.0 unx      353 b- defN 24-May-29 20:01 switchboard/sc/morty/morty.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-29 20:01 switchboard/sc/sed/__init__.py
+-rw-r--r--  2.0 unx     1082 b- defN 24-May-29 20:01 switchboard/sc/sed/remove.py
+-rw-r--r--  2.0 unx      238 b- defN 24-May-29 20:01 switchboard/sc/sed/sed.py
+-rw-r--r--  2.0 unx      148 b- defN 24-May-29 20:01 switchboard_hw-0.2.4.dist-info/WHEEL
+-rw-r--r--  2.0 unx    10766 b- defN 24-May-29 20:01 switchboard_hw-0.2.4.dist-info/LICENSE
+-rw-r--r--  2.0 unx       25 b- defN 24-May-29 20:01 switchboard_hw-0.2.4.dist-info/top_level.txt
+-rw-r--r--  2.0 unx       92 b- defN 24-May-29 20:01 switchboard_hw-0.2.4.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx     7378 b- defN 24-May-29 20:01 switchboard_hw-0.2.4.dist-info/RECORD
+-rw-r--r--  2.0 unx    18115 b- defN 24-May-29 20:01 switchboard_hw-0.2.4.dist-info/METADATA
+98 files, 1049109 bytes uncompressed, 322576 bytes compressed:  69.3%
```

## zipnote {}

```diff
@@ -1,11 +1,11 @@
 Filename: switchboard/
 Comment: 
 
-Filename: switchboard_hw-0.2.3.dist-info/
+Filename: switchboard_hw-0.2.4.dist-info/
 Comment: 
 
 Filename: switchboard_hw.libs/
 Comment: 
 
 Filename: _switchboard.cpython-39-x86_64-linux-gnu.so
 Comment: 
@@ -270,26 +270,26 @@
 
 Filename: switchboard/sc/sed/remove.py
 Comment: 
 
 Filename: switchboard/sc/sed/sed.py
 Comment: 
 
-Filename: switchboard_hw-0.2.3.dist-info/WHEEL
+Filename: switchboard_hw-0.2.4.dist-info/WHEEL
 Comment: 
 
-Filename: switchboard_hw-0.2.3.dist-info/LICENSE
+Filename: switchboard_hw-0.2.4.dist-info/LICENSE
 Comment: 
 
-Filename: switchboard_hw-0.2.3.dist-info/top_level.txt
+Filename: switchboard_hw-0.2.4.dist-info/top_level.txt
 Comment: 
 
-Filename: switchboard_hw-0.2.3.dist-info/entry_points.txt
+Filename: switchboard_hw-0.2.4.dist-info/entry_points.txt
 Comment: 
 
-Filename: switchboard_hw-0.2.3.dist-info/RECORD
+Filename: switchboard_hw-0.2.4.dist-info/RECORD
 Comment: 
 
-Filename: switchboard_hw-0.2.3.dist-info/METADATA
+Filename: switchboard_hw-0.2.4.dist-info/METADATA
 Comment: 
 
 Zip file comment:
```

## switchboard/__init__.py

```diff
@@ -17,7 +17,8 @@
 from .loopback import umi_loopback
 from .bitvector import BitVector
 from .uart_xactor import uart_xactor
 from .sbtcp import start_tcp_bridge
 from .axil import AxiLiteTxRx
 from .axi import AxiTxRx
 from .network import SbNetwork
+from .switchboard import path as sb_path
```

## switchboard/autowrap.py

```diff
@@ -5,18 +5,79 @@
 
 from pathlib import Path
 from copy import deepcopy
 
 from .umi import UmiTxRx
 from .axi import AxiTxRx
 from .axil import AxiLiteTxRx
+from .bitvector import slice_to_msb_lsb
 
 from _switchboard import PySbTx, PySbRx
 
 
+class WireExpr:
+    def __init__(self, width):
+        self.width = width
+        self.bindings = []
+
+    def bind(self, slice, wire):
+        # extract msb, lsb
+        msb, lsb = slice_to_msb_lsb(start=slice.start, stop=slice.stop, step=slice.step)
+
+        # make sure that the slice fits in the width
+        assert 0 <= lsb <= self.width - 1
+        assert 0 <= msb <= self.width - 1
+
+        if len(self.bindings) == 0:
+            self.bindings.append(((msb, lsb), wire))
+            return
+
+        for idx in range(len(self.bindings) - 1, -1, -1):
+            (msb_i, lsb_i), _ = self.bindings[idx]
+            if lsb < lsb_i:
+                assert msb < lsb_i, \
+                    f'bit assignments {msb_i}:{lsb_i} and {msb}:{lsb} overlap'
+                self.bindings.insert(idx + 1, ((msb, lsb), wire))
+                break
+        else:
+            (msb_i, lsb_i), _ = self.bindings[0]
+            assert lsb > msb_i, \
+                f'bit assignments {msb_i}:{lsb_i} and {msb}:{lsb} overlap'
+            self.bindings.insert(0, ((msb, lsb), wire))
+
+    def padded(self):
+        retval = []
+
+        for idx, ((msb, lsb), wire) in enumerate(self.bindings):
+            if idx == 0:
+                if msb != self.width - 1:
+                    msb_pad = (self.width - 1) - msb
+                    retval.append(f"{msb_pad}'b0")
+
+            retval.append(wire)
+
+            if idx < len(self.bindings) - 1:
+                lsb_pad = (lsb - 1) - self.bindings[idx + 1][0][0]
+            else:
+                lsb_pad = lsb
+
+            if lsb_pad > 0:
+                retval.append(f"{lsb_pad}'b0")
+
+        return retval
+
+    def __str__(self):
+        padded = self.padded()
+
+        if len(padded) == 1:
+            return padded[0]
+        else:
+            return '{' + ', '.join(padded) + '}'
+
+
 def normalize_interface(name, value):
     # copy before modifying
     value = deepcopy(value)
 
     assert isinstance(value, dict)
 
     if 'type' not in value:
@@ -60,14 +121,17 @@
             value['uri'] = name
 
         if type == 'axi':
             # settings that only apply to AXI, not AXI-Lite
 
             if 'idw' not in value:
                 value['idw'] = 8
+    elif type == 'gpio':
+        if 'width' not in value:
+            value['width'] = 1
     else:
         raise ValueError(f'Unsupported interface type: "{type}"')
 
     return name, value
 
 
 def normalize_interfaces(interfaces):
@@ -150,15 +214,25 @@
         reset = normalize_reset(reset)
         retval.append(reset)
 
     return retval
 
 
 def normalize_tieoff(key, value):
-    # placeholder for doing more interesting things in the future
+    if isinstance(value, dict):
+        value = deepcopy(value)
+    else:
+        value = {'value': value}
+
+    if 'width' not in value:
+        value['width'] = 1
+
+    if 'wire' not in value:
+        value['wire'] = None
+
     return key, value
 
 
 def normalize_tieoffs(tieoffs):
     if tieoffs is None:
         tieoffs = {}
 
@@ -231,24 +305,73 @@
 
     # wire declarations
 
     wires = {}
 
     lines += ['']
 
+    # declare all GPIO output wires (makes things easier when an output is
+    # sent to multiple places or slices of it are used)
+
+    wires['gpio'] = set()
+
     for instance in instances:
         for name, value in interfaces[instance].items():
             type = value['type']
+            direction = value['direction']
+
+            if not ((type == 'gpio') and (direction == 'output')):
+                continue
+
+            wire = value['wire']
+
+            if wire is None:
+                # means that the output is unused
+                continue
+
+            assert wire not in wires['gpio']
+
+            width = value['width']
+
+            lines += [tab + f'wire [{width-1}:0] {wire};']
+
+            wires['gpio'].add(wire)
+
+    lines += ['']
+
+    for instance in instances:
+        # declare wires for tieoffs
+
+        for key, value in tieoffs[instance].items():
+            if value['value'] is None:
+                continue
+
+            if value['wire'] is None:
+                value['wire'] = f'{instance}_tieoff_{key}'
+
+            width = value['width']
+
+            lines += [
+                tab + f'wire [{width-1}:0] {value["wire"]};',
+                tab + f'assign {value["wire"]} = {value["value"]};'
+            ]
+
+        lines += ['']
+
+        # declare wires for interfaces
+
+        for name, value in interfaces[instance].items():
+            type = value['type']
 
             if type not in wires:
                 wires[type] = set()
 
             wire = value['wire']
 
-            if wire not in wires[type]:
+            if (type != 'gpio') and (wire not in wires[type]):
                 decl_wire = True
                 wires[type].add(wire)
             else:
                 decl_wire = False
 
             direction = value['direction']
 
@@ -307,14 +430,25 @@
                 if external:
                     if direction_is_subordinate(direction):
                         lines += [tab + f'`SB_AXIL_M({wire}, {dw}, {aw}, "");']
                     elif direction_is_manager(direction):
                         lines += [tab + f'`SB_AXIL_S({wire}, {dw}, {aw}, "");']
                     else:
                         raise Exception(f'Unsupported AXI-Lite direction: {direction}')
+            elif type == 'gpio':
+                if direction == 'input':
+                    width = value['width']
+                    new_wire = f'{instance}_input_{name}'
+                    lines += [
+                        tab + f'wire [{width-1}:0] {new_wire};',
+                        tab + f'assign {new_wire} = {wire};'
+                    ]
+                    value['wire'] = new_wire
+                else:
+                    pass
             else:
                 raise Exception(f'Unsupported interface type: "{type}"')
 
             lines += ['']
 
     max_rst_dly = None
 
@@ -324,17 +458,14 @@
             inst_max_rst_dly = max(reset['delay'] for reset in inst_resets)
 
             # update the overall max reset delay
             if (max_rst_dly is None) or (inst_max_rst_dly > max_rst_dly):
                 max_rst_dly = inst_max_rst_dly
 
     if max_rst_dly is not None:
-        max_rst_dly = max(max(reset['delay'] for reset in inst_resets)
-            for inst_resets in resets.values())
-
         lines += [
             tab + f"reg [{max_rst_dly}:0] rstvec = '1;"
             '',
             tab + 'always @(posedge clk) begin'
         ]
 
         if max_rst_dly > 0:
@@ -375,14 +506,20 @@
                 connections += [f'`SB_CONNECT({name}, {wire})']
             elif type_is_umi(type):
                 connections += [f'`SB_UMI_CONNECT({name}, {wire})']
             elif type_is_axi(type):
                 connections += [f'`SB_AXI_CONNECT({name}, {wire})']
             elif type_is_axil(type):
                 connections += [f'`SB_AXIL_CONNECT({name}, {wire})']
+            elif type_is_gpio(type):
+                if wire is None:
+                    # unused output
+                    connections += [f'.{name}()']
+                else:
+                    connections += [f'.{name}({wire})']
 
         # clocks
 
         for clock in clocks[instance]:
             connections += [f'.{clock["name"]}(clk)']
 
         # resets
@@ -400,19 +537,20 @@
                 raise ValueError(f'Unsupported reset polarity: "{polarity}"')
 
             connections += [f'.{name}({value})']
 
         # tieoffs
 
         for key, value in tieoffs[instance].items():
-            if value is None:
-                value = ''
-            else:
-                value = str(value)
-            connections += [f'.{key}({value})']
+            wire = value.get('wire')
+
+            if wire is None:
+                wire = ''
+
+            connections += [f'.{key}({wire})']
 
         for n, connection in enumerate(connections):
             if n != len(connections) - 1:
                 connection += ','
             lines += [(2 * tab) + connection]
 
         lines += [tab + ');']
@@ -474,53 +612,80 @@
     return direction.lower() in ['i', 'in', 'input']
 
 
 def direction_is_output(direction):
     return direction.lower() in ['o', 'out', 'output']
 
 
+def direction_is_inout(direction):
+    return direction.lower() in ['inout']
+
+
 def direction_is_manager(direction):
     return direction.lower() in ['m', 'manager', 'master', 'indicator']
 
 
 def direction_is_subordinate(direction):
     return direction.lower() in ['s', 'subordinate', 'slave', 'target']
 
 
 def normalize_direction(type, direction):
-    if type_is_sb(type) or type_is_umi(type):
+    if type_is_const(type):
+        if direction_is_output(direction):
+            return 'output'
+        else:
+            raise Exception(f'Unsupported direction for interface type "{type}": "{direction}"')
+    elif type_is_sb(type) or type_is_umi(type) or type_is_gpio(type):
         if direction_is_input(direction):
             return 'input'
         elif direction_is_output(direction):
             return 'output'
+        elif direction_is_inout(direction):
+            return 'inout'
         else:
             raise Exception(f'Unsupported direction for interface type "{type}": "{direction}"')
     elif type_is_axi(type) or type_is_axil(type):
         if direction_is_manager(direction):
             return 'manager'
         elif direction_is_subordinate(direction):
             return 'subordinate'
         else:
             raise Exception(f'Unsupported direction for interface type "{type}": "{direction}"')
     else:
         raise Exception(f'Unsupported interface type: "{type}"')
 
 
-def directions_are_compatible(type, a, b):
-    a = normalize_direction(type, a)
-    b = normalize_direction(type, b)
-
-    if type_is_sb(type) or type_is_umi(type):
-        return (((a == 'input') and (b == 'output'))
-            or ((a == 'output') and (b == 'input')))
-    elif type_is_axi(type) or type_is_axil(type):
-        return (((a == 'manager') and (b == 'subordinate'))
-            or ((a == 'subordinate') and (b == 'manager')))
+def directions_are_compatible(type_a, a, type_b, b):
+    a = normalize_direction(type_a, a)
+    b = normalize_direction(type_b, b)
+
+    if a == 'input':
+        return b in ['output', 'inout']
+    elif a == 'output':
+        return b in ['input', 'inout']
+    elif a == 'inout':
+        return b in ['input', 'output', 'inout']
+    elif a == 'manager':
+        return b == 'subordinate'
+    elif a == 'subordinate':
+        return b == 'manager'
     else:
-        raise Exception(f'Unsupported interface type: "{type}"')
+        raise Exception(f'Cannot determine if directions are compatible: {a} and {b}')
+
+
+def types_are_compatible(a, b):
+    a = normalize_intf_type(a)
+    b = normalize_intf_type(b)
+
+    if type_is_const(a):
+        return type_is_gpio(b)
+    elif type_is_const(b):
+        return type_is_gpio(a)
+    else:
+        return a == b
 
 
 def polarity_is_positive(polarity):
     return polarity.lower() in ['+', 'p', 'plus', 'positive']
 
 
 def polarity_is_negative(polarity):
@@ -548,23 +713,47 @@
     return type.lower() in ['axi']
 
 
 def type_is_axil(type):
     return type.lower() in ['axil']
 
 
+def type_is_input(type):
+    return type.lower() in ['i', 'in', 'input']
+
+
+def type_is_output(type):
+    return type.lower() in ['o', 'out', 'output']
+
+
+def type_is_gpio(type):
+    return type.lower() in ['gpio']
+
+
+def type_is_const(type):
+    return type.lower() in ['const', 'constant']
+
+
 def normalize_intf_type(type):
     if type_is_sb(type):
         return 'sb'
     elif type_is_umi(type):
         return 'umi'
     elif type_is_axi(type):
         return 'axi'
     elif type_is_axil(type):
         return 'axil'
+    elif type_is_input(type):
+        return 'input'
+    elif type_is_output(type):
+        return 'output'
+    elif type_is_gpio(type):
+        return 'gpio'
+    elif type_is_const(type):
+        return 'const'
     else:
         raise ValueError(f'Unsupported interface type: "{type}"')
 
 
 def create_intf_objs(intf_defs, fresh=True, max_rate=-1):
     intf_objs = {}
```

## switchboard/network.py

```diff
@@ -1,41 +1,108 @@
 # Copyright (c) 2024 Zero ASIC Corporation
 # This code is licensed under Apache License 2.0 (see LICENSE for details)
 
-
 from pathlib import Path
 from copy import deepcopy
 from itertools import count
+from numbers import Integral
 
 from .sbdut import SbDut
 from .axi import axi_uris
 from .autowrap import (directions_are_compatible, normalize_intf_type,
     type_is_umi, type_is_sb, create_intf_objs, type_is_axi, type_is_axil,
-    autowrap)
+    autowrap, normalize_direction, WireExpr, types_are_compatible)
 from .cmdline import get_cmdline_args
 
 from _switchboard import delete_queues
 
 
 class SbIntf:
-    def __init__(self, inst, name):
+    def __init__(self, inst, name, width=None, indices=None):
         self.inst = inst
         self.name = name
+        self.width = width
+
+        if (indices is None) and (width is not None):
+            indices = slice(width - 1, 0, 1)
+
+        self.slice = indices
+
+    @property
+    def intf_def(self):
+        return self.inst.block.intf_defs[self.name]
+
+    @property
+    def wire_name(self):
+        return f'{self.inst.name}_{self.name}'
+
+    def __getitem__(self, key):
+        if not isinstance(key, slice):
+            key = slice(key, key)
+
+        return SbIntf(inst=self.inst, name=self.name, indices=key)
+
+    def slice_as_str(self):
+        if self.slice is None:
+            return ''
+        else:
+            return f'[{self.slice.start}:{self.slice.stop}]'
+
+    def compute_slice_width(self):
+        if self.slice.start is not None:
+            start = self.slice.start
+        else:
+            start = self.width - 1
+
+        if self.slice.stop is not None:
+            stop = self.slice.stop
+        else:
+            stop = 0
+
+        return start - stop + 1
+
+
+class ConstIntf:
+    def __init__(self, value):
+        self.value = value
+
+    @property
+    def intf_def(self):
+        return dict(
+            type='const',
+            direction='output'
+        )
+
+    def value_as_str(self, width=None, format='decimal'):
+        if width is None:
+            width = ''
+        else:
+            width = str(width)
+
+        if format.lower() == 'decimal':
+            return f"{width}'d{self.value}"
+        elif format.lower() == 'hex':
+            return f"{width}'h{hex(self.value)[2:]}"
+        elif format.lower() == 'hex':
+            return f"{width}'b{bin(self.value)[2:]}"
+        else:
+            raise Exception(f'Unsupported format: {format}')
 
 
 class SbInst:
     def __init__(self, name, block):
         self.name = name
         self.block = block
         self.mapping = {}
         self.external = set()
 
         for name, value in block.intf_defs.items():
             self.mapping[name] = dict(uri=None, wire=None)
-            self.__setattr__(name, SbIntf(inst=self, name=name))
+            width = block.intf_defs[name].get('width', None)
+            self.__setattr__(name, SbIntf(inst=self, name=name, width=width))
 
 
 class SbNetwork:
     def __init__(self, cmdline=False, tool: str = 'verilator', trace: bool = False,
         trace_type: str = 'vcd', frequency: float = 100e6, period: float = None,
         max_rate: float = -1, start_delay: float = None, fast: bool = False,
         extra_args: dict = None, cleanup: bool = True, args=None,
@@ -143,49 +210,90 @@
         # create the instance object
         self.insts[name] = SbInst(name=name, block=block)
 
         # return the instance object
         return self.insts[name]
 
     def connect(self, a, b, uri=None, wire=None):
+        # convert integer inputs into constant datatype
+        if isinstance(a, Integral):
+            a = ConstIntf(value=a)
+        if isinstance(b, Integral):
+            b = ConstIntf(value=b)
+
         # retrieve the two interface definitions
-        intf_def_a = a.inst.block.intf_defs[a.name]
-        intf_def_b = b.inst.block.intf_defs[b.name]
+        intf_def_a = a.intf_def
+        intf_def_b = b.intf_def
 
         # make sure that the interfaces are the same
         type_a = normalize_intf_type(intf_def_a['type'])
         type_b = normalize_intf_type(intf_def_b['type'])
-        assert type_a == type_b
+        assert types_are_compatible(type_a, type_b)
 
         # make sure that the directions are compatible
-        assert directions_are_compatible(type=type_a,
-            a=intf_def_a['direction'], b=intf_def_b['direction'])
+        direction_a = normalize_direction(type_a, intf_def_a['direction'])
+        direction_b = normalize_direction(type_b, intf_def_b['direction'])
+        assert directions_are_compatible(
+            type_a=type_a, a=direction_a,
+            type_b=type_b, b=direction_b
+        )
+
+        # indicate which is input vs. output.  we have to look at both type a and
+        # type b since one may be a constant
+        if (type_a == 'gpio') or (type_b == 'gpio'):
+            if (direction_a == 'input') or (direction_b == 'output'):
+                input, output = a, b
+                direction_a, direction_b = 'input', 'output'
+            elif (direction_b == 'input') or (direction_a == 'output'):
+                input, output = b, a
+                direction_b, direction_a = 'input', 'output'
+            else:
+                raise Exception(f'Cannot infer connection direction with direction_a={direction_a}'
+                    f' and direction_b={direction_b}')
+
+            intf_def_a['direction'] = direction_a
+            intf_def_b['direction'] = direction_b
 
         # determine what the queue will be called that connects the two
 
         if wire is None:
-            wire = f'{a.inst.name}_{a.name}_conn_{b.inst.name}_{b.name}'
+            if (type_a != 'gpio') and (type_b != 'gpio'):
+                wire = f'{a.wire_name}_conn_{b.wire_name}'
+            elif not isinstance(output, ConstIntf):
+                wire = f'{output.inst.name}_{output.name}'
 
-        if uri is None:
+        if (uri is None) and (wire is not None):
             uri = wire
 
             if type_is_sb(type_a) or type_is_umi(type_a):
                 uri = uri + '.q'
 
-        if not self.single_netlist:
-            # internal connection, no need to register it for cleanup
+        if (not self.single_netlist) and (type_a != 'gpio') and (type_b != 'gpio'):
             self.register_uri(type=type_a, uri=uri)
 
         # tell both instances what they are connected to
 
-        a.inst.mapping[a.name]['wire'] = wire
-        b.inst.mapping[b.name]['wire'] = wire
+        if (type_a != 'gpio') and (type_b != 'gpio'):
+            a.inst.mapping[a.name]['wire'] = wire
+            b.inst.mapping[b.name]['wire'] = wire
 
-        a.inst.mapping[a.name]['uri'] = uri
-        b.inst.mapping[b.name]['uri'] = uri
+            a.inst.mapping[a.name]['uri'] = uri
+            b.inst.mapping[b.name]['uri'] = uri
+        else:
+            if input.inst.mapping[input.name]['wire'] is None:
+                expr = WireExpr(input.intf_def['width'])
+                input.inst.mapping[input.name]['wire'] = expr
+
+            if isinstance(output, ConstIntf):
+                input.inst.mapping[input.name]['wire'].bind(
+                    input.slice, output.value_as_str(width=input.compute_slice_width()))
+            else:
+                input.inst.mapping[input.name]['wire'].bind(
+                    input.slice, f'{wire}{output.slice_as_str()}')
+                output.inst.mapping[output.name]['wire'] = wire
 
     def build(self):
         unique_blocks = set(inst.block for inst in self.insts.values())
 
         if self.single_netlist:
             passthroughs = [
                 ('tool', 'verilator', 'task', 'compile', 'warningoff')
```

## switchboard/bitvector.py

```diff
@@ -18,17 +18,17 @@
 
     def __setitem__(self, key, value):
         if isinstance(key, slice):
             if (key.start is None) and (key.stop is None) and (key.step is None):
                 self.value = value
                 return
             else:
-                msb, lsb = self.slice_to_msb_lsb(key.start, key.stop, key.step)
+                msb, lsb = slice_to_msb_lsb(key.start, key.stop, key.step)
         else:
-            msb, lsb = self.slice_to_msb_lsb(key, key)
+            msb, lsb = slice_to_msb_lsb(key, key)
 
         # generate mask with the right width
         mask = (1 << (msb - lsb + 1)) - 1
 
         # clear bit field using the mask
         new_value = self.value & (~(mask << lsb))
 
@@ -41,46 +41,24 @@
         self.value = new_value
 
     def __getitem__(self, key):
         if isinstance(key, slice):
             if (key.start is None) and (key.stop is None) and (key.step is None):
                 return self.value
             else:
-                msb, lsb = self.slice_to_msb_lsb(key.start, key.stop, key.step)
+                msb, lsb = slice_to_msb_lsb(key.start, key.stop, key.step)
         else:
-            msb, lsb = self.slice_to_msb_lsb(key, key)
+            msb, lsb = slice_to_msb_lsb(key, key)
 
         # generate mask with the right width
         mask = (1 << (msb - lsb + 1)) - 1
 
         # extract the value
         return (self.value >> lsb) & mask
 
-    def slice_to_msb_lsb(self, start=None, stop=None, step=None):
-        # set defaults
-        if start is None:
-            start = 0
-        if stop is None:
-            stop = 0
-        if step is None:
-            step = 1
-
-        if step != 1:
-            raise ValueError('Only step=1 allowed for slice indexing.')
-
-        msb = start
-        lsb = stop
-
-        if msb < lsb:
-            raise ValueError('MSB must be greater than or equal to LSB')
-        if lsb < 0:
-            raise ValueError('Negative LSB is not allowed.')
-
-        return msb, lsb
-
     def tobytes(self, n=None):
         # convert to a numpy byte array.  if "n" is provided,
         # pad result to be "n" bytes.  will error out if "n"
         # is less than the number of bytes needed to represent
         # the current value.
 
         value = self.value
@@ -105,7 +83,30 @@
 
         for i, elem in enumerate(arr):
             if not (0 <= elem <= 255):
                 raise ValueError(f'Non-byte value detected at index {i}: {elem}')
             value |= (int(elem) & 0xff) << (i * 8)
 
         return BitVector(value)
+
+
+def slice_to_msb_lsb(start=None, stop=None, step=None):
+    # set defaults
+    if start is None:
+        start = 0
+    if stop is None:
+        stop = 0
+    if step is None:
+        step = 1
+
+    if step != 1:
+        raise ValueError('Only step=1 allowed for slice indexing.')
+
+    msb = start
+    lsb = stop
+
+    if msb < lsb:
+        raise ValueError('MSB must be greater than or equal to LSB')
+    if lsb < 0:
+        raise ValueError('Negative LSB is not allowed.')
+
+    return msb, lsb
```

## Comparing `switchboard_hw-0.2.3.dist-info/LICENSE` & `switchboard_hw-0.2.4.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `switchboard_hw-0.2.3.dist-info/RECORD` & `switchboard_hw-0.2.4.dist-info/RECORD`

 * *Files 3% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 _switchboard.cpython-39-x86_64-linux-gnu.so,sha256=HPe7IO3Ag_-bWQ3HHQ7Y1noWB9a3Ty3QK--wqsvfMK8,603792
-switchboard/__init__.py,sha256=934rQoi9b81uBx1cGmM2C6PDTFn8tppRA6B1CNPjA7s,941
+switchboard/__init__.py,sha256=ZjkpyO_bBJrhOeZpN3USAurIy2XIn5Tt0NVABKIbRz8,982
 switchboard/test_util.py,sha256=hIC3p4v6sjanwDSUKEt-IjA2OuAkMf7_sxk6Rsp9aVw,1333
 switchboard/cmdline.py,sha256=oQPL3Zo8RZteQSr5kmYlb_kSd4wOwnFjWQMPEdhW-Sc,5598
 switchboard/xyce.py,sha256=sZ02vJn0PujzuIbxZ4lKaoggmQVrBdQjMzZWUNfayuo,547
 switchboard/axil.py,sha256=KNGbqNKdq0Pybzxt1I8KDvIG-bPnFv6B7A2fDHa_0e8,12870
 switchboard/axi.py,sha256=wH-dI2cCH-A8K1QvbE14diBpbbwP3UjCWYwyukD4pvw,19799
-switchboard/autowrap.py,sha256=z4sDMJxbpy5vh8c-ouhgi259_LYto201kYkbFXqpVZY,19774
+switchboard/autowrap.py,sha256=FQtVEvyR7REcr9tO4UCWbEoVKp4VSFau2AuhnJVipSE,24879
 switchboard/warn.py,sha256=YLI6T_WrB3mPcASvSqrSa6Nkj5X84HofPm0TOZDS4s8,311
 switchboard/sbtcp.py,sha256=aKMF-kdWP33S9C2V8scAaigTK62pmfAXvp7LdPZ3ixc,8247
 switchboard/util.py,sha256=bE6ZcgbvYGU3agXMH3IO1Y2ZYJIBGWt5cb8z-6kYvSc,2341
 switchboard/icarus.py,sha256=jcxwNUN0Kb3OblY_kw_I41wDRcrPA26zACJWT0-CEYo,2088
 switchboard/uart_xactor.py,sha256=5LEA0lVYo4483wOcSwyCIO26LkHJwloA5LkldrpJwjU,1701
 switchboard/umi.py,sha256=6N3yFnvFmN3jXzsaVUFCluNoj2Xd5xjUVMK0W-PMf_0,26939
 switchboard/loopback.py,sha256=Zx1wBDrXYpUdoV04ru4QG5LfDMy59n91PTeE2eoST88,5246
-switchboard/network.py,sha256=JhDaYD5Hdkyrcw9q7GFeiixhBYfK9-fqzZHP0KiavVs,12327
+switchboard/network.py,sha256=nys6MmdVonDXTIqDMNtYQEco1eIR5qtoxEfFwrCcR_w,16148
 switchboard/verilator.py,sha256=apmqm_a49mSqvBN08lRHrDjmxl-ChU3rgYElq5alzTo,1012
 switchboard/switchboard.py,sha256=DZI1pao3WQEAlPyQxSZPcH57NwM4epPfeuch48vsSLI,1506
-switchboard/bitvector.py,sha256=ER5c-SRIebnDYch_CfTyy0b6Uw5SlYlY2CmKatHoH0M,3398
+switchboard/bitvector.py,sha256=esbnyNloyXp42x9-0pOKjE-08GAtfxIqnUWXN5ot4eU,3305
 switchboard/sbdut.py,sha256=rWFk1AgFpORbaRxnfzOUH6LLKmPDby87hvLUn3ZLY_Q,28459
 switchboard/gpio.py,sha256=HReAzzVoiN3MM1Xr7SstkIIr3gdV6n-BZNrdxwdfGrc,2706
 switchboard/ams.py,sha256=6nLQZ2qha5gvaeLHiCxDQCIn2P3lFswnOrYh_HTIOTs,18067
 switchboard/cpp/pciedev.h,sha256=wyLaeCYBjvn8FZi-2JTNqOG2Ko5VR7zBUEmQHJ2_Mrg,4047
 switchboard/cpp/pagemap.h,sha256=AfydFiJNa6buIfOc24bMMhxd_JKL74zwSa8SsY9JIgQ,2376
 switchboard/cpp/xyce.hpp,sha256=pBJ8gEArUoUSL-KoQWYuxCV7y2MrJqozAWxV5g5h2RE,2351
 switchboard/cpp/switchboard.hpp,sha256=Y1fUV7cjRIPgenOe_PWlGLsKGSb4Mr1BZ9-cUKwutKg,6064
@@ -71,13 +71,13 @@
 switchboard/sc/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 switchboard/sc/morty/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 switchboard/sc/morty/uniquify.py,sha256=dXYLQeUn_K5WGbNJ79Vfp8DnEKfDPFSOdPiwr3HYyQk,1790
 switchboard/sc/morty/morty.py,sha256=I4ePKQNqigyOzAQk5SACNctnJf2r1mSWoG2qQwBculM,353
 switchboard/sc/sed/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 switchboard/sc/sed/remove.py,sha256=_k6vPMYFEOEOdQkLHUw0-bYiZTV179oT0xzHCxocGpg,1082
 switchboard/sc/sed/sed.py,sha256=2uouVwTAkur-LTbrON31L8Sai-w_SD_L8Va1qs5rxKI,238
-switchboard_hw-0.2.3.dist-info/WHEEL,sha256=rY0Y6THYM7EImsHfF-zs67o8pQciAsMw9_YuSvftjrQ,148
-switchboard_hw-0.2.3.dist-info/LICENSE,sha256=2dqsbMlc1IxGnBJVsoUb3HtT1N0kAJnAGF9MBTqSjkw,10766
-switchboard_hw-0.2.3.dist-info/top_level.txt,sha256=hDPbMY9dCMf4f2ObR5n7sLpXJwKaln0h0IvIDd_ufK8,25
-switchboard_hw-0.2.3.dist-info/entry_points.txt,sha256=6IqVCv_W_Wiyuzmje1pemxosVG_P2h35JiHyK0r2I7k,92
-switchboard_hw-0.2.3.dist-info/RECORD,,
-switchboard_hw-0.2.3.dist-info/METADATA,sha256=phUzgsGU3NP830wokJhI_RbIFLB_xV9kllAlytq4u3E,18115
+switchboard_hw-0.2.4.dist-info/WHEEL,sha256=rY0Y6THYM7EImsHfF-zs67o8pQciAsMw9_YuSvftjrQ,148
+switchboard_hw-0.2.4.dist-info/LICENSE,sha256=2dqsbMlc1IxGnBJVsoUb3HtT1N0kAJnAGF9MBTqSjkw,10766
+switchboard_hw-0.2.4.dist-info/top_level.txt,sha256=hDPbMY9dCMf4f2ObR5n7sLpXJwKaln0h0IvIDd_ufK8,25
+switchboard_hw-0.2.4.dist-info/entry_points.txt,sha256=6IqVCv_W_Wiyuzmje1pemxosVG_P2h35JiHyK0r2I7k,92
+switchboard_hw-0.2.4.dist-info/RECORD,,
+switchboard_hw-0.2.4.dist-info/METADATA,sha256=FuoITVQY-fKc5dDYBiPRlL9lC7eZUfmqvxVr8rzzLqI,18115
```

## Comparing `switchboard_hw-0.2.3.dist-info/METADATA` & `switchboard_hw-0.2.4.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: switchboard-hw
-Version: 0.2.3
+Version: 0.2.4
 Summary: A low-latency communication library for RTL simulation and emulation.
 Home-page: https://github.com/zeroasiccorp/switchboard
 Author: Zero ASIC
 License: Apache License 2.0
 Project-URL: Documentation, https://zeroasiccorp.github.io/switchboard/
 Project-URL: Bug Tracker, https://github.com/zeroasiccorp/switchboard/issues
 Requires-Python: >=3.7
```

