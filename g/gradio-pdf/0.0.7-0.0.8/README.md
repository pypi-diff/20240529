# Comparing `tmp/gradio_pdf-0.0.7.tar.gz` & `tmp/gradio_pdf-0.0.8.tar.gz`

## Comparing `gradio_pdf-0.0.7.tar` & `gradio_pdf-0.0.8.tar`

### file list

```diff
@@ -1,26 +1,28 @@
--rw-r--r--   0        0        0       41 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/backend/gradio_pdf/__init__.py
--rw-r--r--   0        0        0     1906 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/backend/gradio_pdf/pdf.py
--rw-r--r--   0        0        0    11998 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/backend/gradio_pdf/pdf.pyi
--rw-r--r--   0        0        0   767472 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/backend/gradio_pdf/templates/component/Index-94e506c5.js
--rw-r--r--   0        0        0       73 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/backend/gradio_pdf/templates/component/index.js
--rw-r--r--   0        0        0    14825 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/backend/gradio_pdf/templates/component/style.css
--rw-r--r--   0        0        0    77959 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/backend/gradio_pdf/templates/component/wrapper-98f94c21-d1a5537c.js
--rw-r--r--   0        0        0   560467 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/backend/gradio_pdf/templates/example/index.js
--rw-r--r--   0        0        0       61 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/backend/gradio_pdf/templates/example/style.css
--rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/demo/__init__.py
--rw-r--r--   0        0        0      768 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/demo/app.py
--rw-r--r--   0        0        0   127928 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/demo/contract.pdf
--rw-r--r--   0        0        0     2543 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/demo/css.css
--rw-r--r--   0        0        0   372153 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/demo/invoice_2.pdf
--rw-r--r--   0        0        0       40 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/demo/requirements.txt
--rw-r--r--   0        0        0    34705 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/demo/sample_invoice.pdf
--rw-r--r--   0        0        0     5623 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/demo/space.py
--rw-r--r--   0        0        0     1296 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/frontend/Example.svelte
--rw-r--r--   0        0        0     4348 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/frontend/Index.svelte
--rw-r--r--   0        0        0      798 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/frontend/PdfUploadText.svelte
--rw-r--r--   0        0        0    64861 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/frontend/package-lock.json
--rw-r--r--   0        0        0      644 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/frontend/package.json
--rw-r--r--   0        0        0       79 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/.gitignore
--rw-r--r--   0        0        0     5036 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/README.md
--rw-r--r--   0        0        0     1567 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/pyproject.toml
--rw-r--r--   0        0        0     6134 2020-02-02 00:00:00.000000 gradio_pdf-0.0.7/PKG-INFO
+-rw-r--r--   0        0        0       40 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/backend/gradio_pdf/__init__.py
+-rw-r--r--   0        0        0     1996 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/backend/gradio_pdf/pdf.py
+-rw-r--r--   0        0        0    12279 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/backend/gradio_pdf/pdf.pyi
+-rw-r--r--   0        0        0   688959 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/backend/gradio_pdf/templates/component/Index-BYwJN1i6.js
+-rw-r--r--   0        0        0       73 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/backend/gradio_pdf/templates/component/index.js
+-rw-r--r--   0        0        0    14825 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/backend/gradio_pdf/templates/component/style.css
+-rw-r--r--   0        0        0    77959 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/backend/gradio_pdf/templates/component/wrapper-98f94c21-DqR3tIm1.js
+-rw-r--r--   0        0        0   560970 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/backend/gradio_pdf/templates/example/index.js
+-rw-r--r--   0        0        0       61 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/backend/gradio_pdf/templates/example/style.css
+-rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/demo/__init__.py
+-rw-r--r--   0        0        0      768 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/demo/_app.py
+-rw-r--r--   0        0        0     5656 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/demo/app.py
+-rw-r--r--   0        0        0   127928 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/demo/contract.pdf
+-rw-r--r--   0        0        0     2543 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/demo/css.css
+-rw-r--r--   0        0        0   372153 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/demo/invoice_2.pdf
+-rw-r--r--   0        0        0       40 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/demo/requirements.txt
+-rw-r--r--   0        0        0    34705 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/demo/sample_invoice.pdf
+-rw-r--r--   0        0        0    10938 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/demo/space.py
+-rw-r--r--   0        0        0     1296 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/frontend/Example.svelte
+-rw-r--r--   0        0        0     4400 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/frontend/Index.svelte
+-rw-r--r--   0        0        0      798 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/frontend/PdfUploadText.svelte
+-rw-r--r--   0        0        0   174508 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/frontend/package-lock.json
+-rw-r--r--   0        0        0      676 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/frontend/package.json
+-rw-r--r--   0        0        0       90 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/.gitignore
+-rw-r--r--   0        0        0     1071 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/LICENSE
+-rw-r--r--   0        0        0    10505 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/README.md
+-rw-r--r--   0        0        0     1549 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/pyproject.toml
+-rw-r--r--   0        0        0    11771 2020-02-02 00:00:00.000000 gradio_pdf-0.0.8/PKG-INFO
```

### Comparing `gradio_pdf-0.0.7/backend/gradio_pdf/pdf.py` & `gradio_pdf-0.0.8/backend/gradio_pdf/pdf.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,46 +1,65 @@
 from __future__ import annotations
 from typing import Any, Callable
 
 from gradio.components.base import Component
 from gradio.data_classes import FileData
 from gradio import processing_utils
 
+
 class PDF(Component):
+    """PDF COMPONENT"""
 
     EVENTS = ["change", "upload"]
 
     data_model = FileData
 
-    def __init__(self, value: Any = None, *,
-                 height: int | None = None,
-                 label: str | None = None, info: str | None = None,
-                 show_label: bool | None = None,
-                 container: bool = True,
-                 scale: int | None = None,
-                 min_width: int | None = None,
-                 interactive: bool | None = None,
-                 visible: bool = True,
-                 elem_id: str | None = None,
-                 elem_classes: list[str] | str | None = None,
-                 render: bool = True,
-                 load_fn: Callable[..., Any] | None = None,
-                 every: float | None = None):
-        super().__init__(value, label=label, info=info,
-                         show_label=show_label, container=container,
-                         scale=scale, min_width=min_width,
-                         interactive=interactive, visible=visible,
-                         elem_id=elem_id, elem_classes=elem_classes,
-                         render=render, load_fn=load_fn, every=every)
+    def __init__(
+        self,
+        value: Any = None,
+        *,
+        height: int | None = None,
+        label: str | None = None,
+        info: str | None = None,
+        show_label: bool | None = None,
+        container: bool = True,
+        scale: int | None = None,
+        min_width: int | None = None,
+        interactive: bool | None = None,
+        visible: bool = True,
+        elem_id: str | None = None,
+        elem_classes: list[str] | str | None = None,
+        render: bool = True,
+        load_fn: Callable[..., Any] | None = None,
+        every: float | None = None,
+        starting_page: int | None = 1,
+    ):
+        super().__init__(
+            value,
+            label=label,
+            info=info,
+            show_label=show_label,
+            container=container,
+            scale=scale,
+            min_width=min_width,
+            interactive=interactive,
+            visible=visible,
+            elem_id=elem_id,
+            elem_classes=elem_classes,
+            render=render,
+            load_fn=load_fn,
+            every=every,
+        )
         self.height = height
+        self.starting_page = starting_page
 
     def preprocess(self, payload: FileData) -> str:
         return payload.path
 
-    def postprocess(self, value: str | None) -> FileData:
+    def postprocess(self, value: str | None) -> FileData | None:
         if not value:
             return None
         return FileData(path=value)
 
     def example_inputs(self):
         return "https://gradio-builds.s3.amazonaws.com/assets/pdf-guide/fw9.pdf"
```

### Comparing `gradio_pdf-0.0.7/backend/gradio_pdf/pdf.pyi` & `gradio_pdf-0.0.8/backend/gradio_pdf/pdf.pyi`

 * *Files 4% similar despite different names*

```diff
@@ -1,43 +1,66 @@
+from __future__ import annotations
+from typing import Any, Callable
+
 from gradio.components.base import Component
+from gradio.data_classes import FileData
+from gradio import processing_utils
 
 from gradio.events import Dependency
 
 class PDF(Component):
+    """PDF COMPONENT"""
 
     EVENTS = ["change", "upload"]
 
     data_model = FileData
 
-    def __init__(self, value: Any = None, *,
-                 height: int | None = None,
-                 label: str | None = None, info: str | None = None,
-                 show_label: bool | None = None,
-                 container: bool = True,
-                 scale: int | None = None,
-                 min_width: int | None = None,
-                 interactive: bool | None = None,
-                 visible: bool = True,
-                 elem_id: str | None = None,
-                 elem_classes: list[str] | str | None = None,
-                 render: bool = True,
-                 load_fn: Callable[..., Any] | None = None,
-                 every: float | None = None):
-        super().__init__(value, label=label, info=info,
-                         show_label=show_label, container=container,
-                         scale=scale, min_width=min_width,
-                         interactive=interactive, visible=visible,
-                         elem_id=elem_id, elem_classes=elem_classes,
-                         render=render, load_fn=load_fn, every=every)
+    def __init__(
+        self,
+        value: Any = None,
+        *,
+        height: int | None = None,
+        label: str | None = None,
+        info: str | None = None,
+        show_label: bool | None = None,
+        container: bool = True,
+        scale: int | None = None,
+        min_width: int | None = None,
+        interactive: bool | None = None,
+        visible: bool = True,
+        elem_id: str | None = None,
+        elem_classes: list[str] | str | None = None,
+        render: bool = True,
+        load_fn: Callable[..., Any] | None = None,
+        every: float | None = None,
+        starting_page: int | None = 1,
+    ):
+        super().__init__(
+            value,
+            label=label,
+            info=info,
+            show_label=show_label,
+            container=container,
+            scale=scale,
+            min_width=min_width,
+            interactive=interactive,
+            visible=visible,
+            elem_id=elem_id,
+            elem_classes=elem_classes,
+            render=render,
+            load_fn=load_fn,
+            every=every,
+        )
         self.height = height
+        self.starting_page = starting_page
 
     def preprocess(self, payload: FileData) -> str:
         return payload.path
 
-    def postprocess(self, value: str | None) -> FileData:
+    def postprocess(self, value: str | None) -> FileData | None:
         if not value:
             return None
         return FileData(path=value)
 
     def example_inputs(self):
         return "https://gradio-builds.s3.amazonaws.com/assets/pdf-guide/fw9.pdf"
 
@@ -81,15 +104,15 @@
             postprocess: If False, will not run postprocessing of component data before returning 'fn' output to the browser.
             cancels: A list of other events to cancel when this listener is triggered. For example, setting cancels=[click_event] will cancel the click_event, where click_event is the return value of another components .click method. Functions that have not yet run (or generators that are iterating) will be cancelled, but functions that are currently running will be allowed to finish.
             every: Run this event 'every' number of seconds while the client connection is open. Interpreted in seconds.
             trigger_mode: If "once" (default for all events except `.change()`) would not allow any submissions while an event is pending. If set to "multiple", unlimited submissions are allowed while pending, and "always_last" (default for `.change()` and `.key_up()` events) would allow a second submission after the pending event is complete.
             js: Optional frontend js method to run before running 'fn'. Input arguments for js method are values of 'inputs' and 'outputs', return should be a list of values for output components.
             concurrency_limit: If set, this is the maximum number of this event that can be running simultaneously. Can be set to None to mean no concurrency_limit (any number of this event can be running simultaneously). Set to "default" to use the default concurrency limit (defined by the `default_concurrency_limit` parameter in `Blocks.queue()`, which itself is 1 by default).
             concurrency_id: If set, this is the id of the concurrency group. Events with the same concurrency_id will be limited by the lowest set concurrency_limit.
-            show_api: whether to show this event in the "view API" page of the Gradio app, or in the ".view_api()" method of the Gradio clients. Unlike setting api_name to False, setting show_api to False will still allow downstream apps to use this event. If fn is None, show_api will automatically be set to False.
+            show_api: whether to show this event in the "view API" page of the Gradio app, or in the ".view_api()" method of the Gradio clients. Unlike setting api_name to False, setting show_api to False will still allow downstream apps as well as the Clients to use this event. If fn is None, show_api will automatically be set to False.
         """
         ...
     
     def upload(self,
         fn: Callable | None,
         inputs: Component | Sequence[Component] | set[Component] | None = None,
         outputs: Component | Sequence[Component] | None = None,
@@ -123,10 +146,10 @@
             postprocess: If False, will not run postprocessing of component data before returning 'fn' output to the browser.
             cancels: A list of other events to cancel when this listener is triggered. For example, setting cancels=[click_event] will cancel the click_event, where click_event is the return value of another components .click method. Functions that have not yet run (or generators that are iterating) will be cancelled, but functions that are currently running will be allowed to finish.
             every: Run this event 'every' number of seconds while the client connection is open. Interpreted in seconds.
             trigger_mode: If "once" (default for all events except `.change()`) would not allow any submissions while an event is pending. If set to "multiple", unlimited submissions are allowed while pending, and "always_last" (default for `.change()` and `.key_up()` events) would allow a second submission after the pending event is complete.
             js: Optional frontend js method to run before running 'fn'. Input arguments for js method are values of 'inputs' and 'outputs', return should be a list of values for output components.
             concurrency_limit: If set, this is the maximum number of this event that can be running simultaneously. Can be set to None to mean no concurrency_limit (any number of this event can be running simultaneously). Set to "default" to use the default concurrency limit (defined by the `default_concurrency_limit` parameter in `Blocks.queue()`, which itself is 1 by default).
             concurrency_id: If set, this is the id of the concurrency group. Events with the same concurrency_id will be limited by the lowest set concurrency_limit.
-            show_api: whether to show this event in the "view API" page of the Gradio app, or in the ".view_api()" method of the Gradio clients. Unlike setting api_name to False, setting show_api to False will still allow downstream apps to use this event. If fn is None, show_api will automatically be set to False.
+            show_api: whether to show this event in the "view API" page of the Gradio app, or in the ".view_api()" method of the Gradio clients. Unlike setting api_name to False, setting show_api to False will still allow downstream apps as well as the Clients to use this event. If fn is None, show_api will automatically be set to False.
         """
         ...
```

### Comparing `gradio_pdf-0.0.7/backend/gradio_pdf/templates/component/Index-94e506c5.js` & `gradio_pdf-0.0.8/backend/gradio_pdf/templates/component/Index-BYwJN1i6.js`

 * *Files 4% similar despite different names*

#### js-beautify {}

```diff
@@ -1,568 +1,565 @@
-var ni = Object.defineProperty;
-var ii = (t, e, i) => e in t ? ni(t, e, {
+var ei = Object.defineProperty;
+var ni = (i, t, n) => t in i ? ei(i, t, {
     enumerable: !0,
     configurable: !0,
     writable: !0,
-    value: i
-}) : t[e] = i;
-var nt = (t, e, i) => (ii(t, typeof e != "symbol" ? e + "" : e, i), i),
-    $t = (t, e, i) => {
-        if (!e.has(t))
-            throw TypeError("Cannot " + i);
+    value: n
+}) : i[t] = n;
+var ee = (i, t, n) => (ni(i, typeof t != "symbol" ? t + "" : t, n), n),
+    $e = (i, t, n) => {
+        if (!t.has(i))
+            throw TypeError("Cannot " + n);
     };
-var a = (t, e, i) => ($t(t, e, "read from private field"), i ? i.call(t) : e.get(t)),
-    W = (t, e, i) => {
-        if (e.has(t))
+var r = (i, t, n) => ($e(i, t, "read from private field"), n ? n.call(i) : t.get(i)),
+    W = (i, t, n) => {
+        if (t.has(i))
             throw TypeError("Cannot add the same private member more than once");
-        e instanceof WeakSet ? e.add(t) : e.set(t, i);
+        t instanceof WeakSet ? t.add(i) : t.set(i, n);
     },
-    oe = (t, e, i, n) => ($t(t, e, "write to private field"), n ? n.call(t, i) : e.set(t, i), i);
-var _t = (t, e, i, n) => ({
+    ot = (i, t, n, e) => ($e(i, t, "write to private field"), e ? e.call(i, n) : t.set(i, n), n);
+var ge = (i, t, n, e) => ({
         set _(s) {
-            oe(t, e, s, i);
+            ot(i, t, s, n);
         },
         get _() {
-            return a(t, e, n);
+            return r(i, t, e);
         }
     }),
-    K = (t, e, i) => ($t(t, e, "access private method"), i);
+    J = (i, t, n) => ($e(i, t, "access private method"), n);
 const {
     SvelteComponent: SvelteComponent$e,
     append: append$d,
     attr: attr$d,
     detach: detach$e,
     init: init$e,
     insert: insert$e,
     noop: noop$7,
     safe_not_equal: safe_not_equal$f,
     set_style: set_style$6,
     svg_element: svg_element$5
 } = window.__gradio__svelte__internal;
 
-function create_fragment$e(t) {
-    let e, i, n, s;
+function create_fragment$e(i) {
+    let t, n, e, s;
     return {
         c() {
-            e = svg_element$5("svg"), i = svg_element$5("g"), n = svg_element$5("path"), s = svg_element$5("path"), attr$d(n, "d", "M18,6L6.087,17.913"), set_style$6(n, "fill", "none"), set_style$6(n, "fill-rule", "nonzero"), set_style$6(n, "stroke-width", "2px"), attr$d(i, "transform", "matrix(1.14096,-0.140958,-0.140958,1.14096,-0.0559523,0.0559523)"), attr$d(s, "d", "M4.364,4.364L19.636,19.636"), set_style$6(s, "fill", "none"), set_style$6(s, "fill-rule", "nonzero"), set_style$6(s, "stroke-width", "2px"), attr$d(e, "width", "100%"), attr$d(e, "height", "100%"), attr$d(e, "viewBox", "0 0 24 24"), attr$d(e, "version", "1.1"), attr$d(e, "xmlns", "http://www.w3.org/2000/svg"), attr$d(e, "xmlns:xlink", "http://www.w3.org/1999/xlink"), attr$d(e, "xml:space", "preserve"), attr$d(e, "stroke", "currentColor"), set_style$6(e, "fill-rule", "evenodd"), set_style$6(e, "clip-rule", "evenodd"), set_style$6(e, "stroke-linecap", "round"), set_style$6(e, "stroke-linejoin", "round");
+            t = svg_element$5("svg"), n = svg_element$5("g"), e = svg_element$5("path"), s = svg_element$5("path"), attr$d(e, "d", "M18,6L6.087,17.913"), set_style$6(e, "fill", "none"), set_style$6(e, "fill-rule", "nonzero"), set_style$6(e, "stroke-width", "2px"), attr$d(n, "transform", "matrix(1.14096,-0.140958,-0.140958,1.14096,-0.0559523,0.0559523)"), attr$d(s, "d", "M4.364,4.364L19.636,19.636"), set_style$6(s, "fill", "none"), set_style$6(s, "fill-rule", "nonzero"), set_style$6(s, "stroke-width", "2px"), attr$d(t, "width", "100%"), attr$d(t, "height", "100%"), attr$d(t, "viewBox", "0 0 24 24"), attr$d(t, "version", "1.1"), attr$d(t, "xmlns", "http://www.w3.org/2000/svg"), attr$d(t, "xmlns:xlink", "http://www.w3.org/1999/xlink"), attr$d(t, "xml:space", "preserve"), attr$d(t, "stroke", "currentColor"), set_style$6(t, "fill-rule", "evenodd"), set_style$6(t, "clip-rule", "evenodd"), set_style$6(t, "stroke-linecap", "round"), set_style$6(t, "stroke-linejoin", "round");
         },
-        m(l, h) {
-            insert$e(l, e, h), append$d(e, i), append$d(i, n), append$d(e, s);
+        m(p, f) {
+            insert$e(p, t, f), append$d(t, n), append$d(n, e), append$d(t, s);
         },
         p: noop$7,
         i: noop$7,
         o: noop$7,
-        d(l) {
-            l && detach$e(e);
+        d(p) {
+            p && detach$e(t);
         }
     };
 }
 class Clear extends SvelteComponent$e {
-    constructor(e) {
-        super(), init$e(this, e, null, create_fragment$e, safe_not_equal$f, {});
+    constructor(t) {
+        super(), init$e(this, t, null, create_fragment$e, safe_not_equal$f, {});
     }
 }
-const DropdownArrow_svelte_svelte_type_style_lang = "",
-    {
-        SvelteComponent: SvelteComponent$d,
-        append: append$c,
-        attr: attr$c,
-        detach: detach$d,
-        init: init$d,
-        insert: insert$d,
-        noop: noop$6,
-        safe_not_equal: safe_not_equal$e,
-        svg_element: svg_element$4
-    } = window.__gradio__svelte__internal;
+const {
+    SvelteComponent: SvelteComponent$d,
+    append: append$c,
+    attr: attr$c,
+    detach: detach$d,
+    init: init$d,
+    insert: insert$d,
+    noop: noop$6,
+    safe_not_equal: safe_not_equal$e,
+    svg_element: svg_element$4
+} = window.__gradio__svelte__internal;
 
-function create_fragment$d(t) {
-    let e, i;
+function create_fragment$d(i) {
+    let t, n;
     return {
         c() {
-            e = svg_element$4("svg"), i = svg_element$4("path"), attr$c(i, "d", "M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"), attr$c(e, "xmlns", "http://www.w3.org/2000/svg"), attr$c(e, "width", "100%"), attr$c(e, "height", "100%"), attr$c(e, "viewBox", "0 0 24 24"), attr$c(e, "fill", "none"), attr$c(e, "stroke", "currentColor"), attr$c(e, "stroke-width", "1.5"), attr$c(e, "stroke-linecap", "round"), attr$c(e, "stroke-linejoin", "round"), attr$c(e, "class", "feather feather-edit-2");
+            t = svg_element$4("svg"), n = svg_element$4("path"), attr$c(n, "d", "M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"), attr$c(t, "xmlns", "http://www.w3.org/2000/svg"), attr$c(t, "width", "100%"), attr$c(t, "height", "100%"), attr$c(t, "viewBox", "0 0 24 24"), attr$c(t, "fill", "none"), attr$c(t, "stroke", "currentColor"), attr$c(t, "stroke-width", "1.5"), attr$c(t, "stroke-linecap", "round"), attr$c(t, "stroke-linejoin", "round"), attr$c(t, "class", "feather feather-edit-2");
         },
-        m(n, s) {
-            insert$d(n, e, s), append$c(e, i);
+        m(e, s) {
+            insert$d(e, t, s), append$c(t, n);
         },
         p: noop$6,
         i: noop$6,
         o: noop$6,
-        d(n) {
-            n && detach$d(e);
+        d(e) {
+            e && detach$d(t);
         }
     };
 }
 class Edit extends SvelteComponent$d {
-    constructor(e) {
-        super(), init$d(this, e, null, create_fragment$d, safe_not_equal$e, {});
+    constructor(t) {
+        super(), init$d(this, t, null, create_fragment$d, safe_not_equal$e, {});
     }
 }
 const {
     SvelteComponent: SvelteComponent$c,
     append: append$b,
     attr: attr$b,
     detach: detach$c,
     init: init$c,
     insert: insert$c,
     noop: noop$5,
     safe_not_equal: safe_not_equal$d,
     svg_element: svg_element$3
 } = window.__gradio__svelte__internal;
 
-function create_fragment$c(t) {
-    let e, i, n;
+function create_fragment$c(i) {
+    let t, n, e;
     return {
         c() {
-            e = svg_element$3("svg"), i = svg_element$3("path"), n = svg_element$3("polyline"), attr$b(i, "d", "M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"), attr$b(n, "points", "13 2 13 9 20 9"), attr$b(e, "xmlns", "http://www.w3.org/2000/svg"), attr$b(e, "width", "100%"), attr$b(e, "height", "100%"), attr$b(e, "viewBox", "0 0 24 24"), attr$b(e, "fill", "none"), attr$b(e, "stroke", "currentColor"), attr$b(e, "stroke-width", "1.5"), attr$b(e, "stroke-linecap", "round"), attr$b(e, "stroke-linejoin", "round"), attr$b(e, "class", "feather feather-file");
+            t = svg_element$3("svg"), n = svg_element$3("path"), e = svg_element$3("polyline"), attr$b(n, "d", "M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"), attr$b(e, "points", "13 2 13 9 20 9"), attr$b(t, "xmlns", "http://www.w3.org/2000/svg"), attr$b(t, "width", "100%"), attr$b(t, "height", "100%"), attr$b(t, "viewBox", "0 0 24 24"), attr$b(t, "fill", "none"), attr$b(t, "stroke", "currentColor"), attr$b(t, "stroke-width", "1.5"), attr$b(t, "stroke-linecap", "round"), attr$b(t, "stroke-linejoin", "round"), attr$b(t, "class", "feather feather-file");
         },
-        m(s, l) {
-            insert$c(s, e, l), append$b(e, i), append$b(e, n);
+        m(s, p) {
+            insert$c(s, t, p), append$b(t, n), append$b(t, e);
         },
         p: noop$5,
         i: noop$5,
         o: noop$5,
         d(s) {
-            s && detach$c(e);
+            s && detach$c(t);
         }
     };
 }
 let File$1 = class extends SvelteComponent$c {
-    constructor(e) {
-        super(), init$c(this, e, null, create_fragment$c, safe_not_equal$d, {});
+    constructor(t) {
+        super(), init$c(this, t, null, create_fragment$c, safe_not_equal$d, {});
     }
 };
 const {
     SvelteComponent: SvelteComponent$b,
     append: append$a,
     attr: attr$a,
     detach: detach$b,
     init: init$b,
     insert: insert$b,
     noop: noop$4,
     safe_not_equal: safe_not_equal$c,
     svg_element: svg_element$2
 } = window.__gradio__svelte__internal;
 
-function create_fragment$b(t) {
-    let e, i, n;
+function create_fragment$b(i) {
+    let t, n, e;
     return {
         c() {
-            e = svg_element$2("svg"), i = svg_element$2("polyline"), n = svg_element$2("path"), attr$a(i, "points", "1 4 1 10 7 10"), attr$a(n, "d", "M3.51 15a9 9 0 1 0 2.13-9.36L1 10"), attr$a(e, "xmlns", "http://www.w3.org/2000/svg"), attr$a(e, "width", "100%"), attr$a(e, "height", "100%"), attr$a(e, "viewBox", "0 0 24 24"), attr$a(e, "fill", "none"), attr$a(e, "stroke", "currentColor"), attr$a(e, "stroke-width", "2"), attr$a(e, "stroke-linecap", "round"), attr$a(e, "stroke-linejoin", "round"), attr$a(e, "class", "feather feather-rotate-ccw");
+            t = svg_element$2("svg"), n = svg_element$2("polyline"), e = svg_element$2("path"), attr$a(n, "points", "1 4 1 10 7 10"), attr$a(e, "d", "M3.51 15a9 9 0 1 0 2.13-9.36L1 10"), attr$a(t, "xmlns", "http://www.w3.org/2000/svg"), attr$a(t, "width", "100%"), attr$a(t, "height", "100%"), attr$a(t, "viewBox", "0 0 24 24"), attr$a(t, "fill", "none"), attr$a(t, "stroke", "currentColor"), attr$a(t, "stroke-width", "2"), attr$a(t, "stroke-linecap", "round"), attr$a(t, "stroke-linejoin", "round"), attr$a(t, "class", "feather feather-rotate-ccw");
         },
-        m(s, l) {
-            insert$b(s, e, l), append$a(e, i), append$a(e, n);
+        m(s, p) {
+            insert$b(s, t, p), append$a(t, n), append$a(t, e);
         },
         p: noop$4,
         i: noop$4,
         o: noop$4,
         d(s) {
-            s && detach$b(e);
+            s && detach$b(t);
         }
     };
 }
 class Undo extends SvelteComponent$b {
-    constructor(e) {
-        super(), init$b(this, e, null, create_fragment$b, safe_not_equal$c, {});
+    constructor(t) {
+        super(), init$b(this, t, null, create_fragment$b, safe_not_equal$c, {});
     }
 }
 const {
     SvelteComponent: SvelteComponent$a,
     append: append$9,
     attr: attr$9,
     detach: detach$a,
     init: init$a,
     insert: insert$a,
     noop: noop$3,
     safe_not_equal: safe_not_equal$b,
     svg_element: svg_element$1
 } = window.__gradio__svelte__internal;
 
-function create_fragment$a(t) {
-    let e, i, n, s;
+function create_fragment$a(i) {
+    let t, n, e, s;
     return {
         c() {
-            e = svg_element$1("svg"), i = svg_element$1("path"), n = svg_element$1("polyline"), s = svg_element$1("line"), attr$9(i, "d", "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"), attr$9(n, "points", "17 8 12 3 7 8"), attr$9(s, "x1", "12"), attr$9(s, "y1", "3"), attr$9(s, "x2", "12"), attr$9(s, "y2", "15"), attr$9(e, "xmlns", "http://www.w3.org/2000/svg"), attr$9(e, "width", "90%"), attr$9(e, "height", "90%"), attr$9(e, "viewBox", "0 0 24 24"), attr$9(e, "fill", "none"), attr$9(e, "stroke", "currentColor"), attr$9(e, "stroke-width", "2"), attr$9(e, "stroke-linecap", "round"), attr$9(e, "stroke-linejoin", "round"), attr$9(e, "class", "feather feather-upload");
+            t = svg_element$1("svg"), n = svg_element$1("path"), e = svg_element$1("polyline"), s = svg_element$1("line"), attr$9(n, "d", "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"), attr$9(e, "points", "17 8 12 3 7 8"), attr$9(s, "x1", "12"), attr$9(s, "y1", "3"), attr$9(s, "x2", "12"), attr$9(s, "y2", "15"), attr$9(t, "xmlns", "http://www.w3.org/2000/svg"), attr$9(t, "width", "90%"), attr$9(t, "height", "90%"), attr$9(t, "viewBox", "0 0 24 24"), attr$9(t, "fill", "none"), attr$9(t, "stroke", "currentColor"), attr$9(t, "stroke-width", "2"), attr$9(t, "stroke-linecap", "round"), attr$9(t, "stroke-linejoin", "round"), attr$9(t, "class", "feather feather-upload");
         },
-        m(l, h) {
-            insert$a(l, e, h), append$9(e, i), append$9(e, n), append$9(e, s);
+        m(p, f) {
+            insert$a(p, t, f), append$9(t, n), append$9(t, e), append$9(t, s);
         },
         p: noop$3,
         i: noop$3,
         o: noop$3,
-        d(l) {
-            l && detach$a(e);
+        d(p) {
+            p && detach$a(t);
         }
     };
 }
 let Upload$1 = class extends SvelteComponent$a {
-    constructor(e) {
-        super(), init$a(this, e, null, create_fragment$a, safe_not_equal$b, {});
+    constructor(t) {
+        super(), init$a(this, t, null, create_fragment$a, safe_not_equal$b, {});
     }
 };
-const PdfUploadText_svelte_svelte_type_style_lang = "",
-    {
-        SvelteComponent: SvelteComponent$9,
-        append: append$8,
-        attr: attr$8,
-        create_component: create_component$5,
-        destroy_component: destroy_component$5,
-        detach: detach$9,
-        element: element$9,
-        init: init$9,
-        insert: insert$9,
-        mount_component: mount_component$5,
-        safe_not_equal: safe_not_equal$a,
-        text: text$4,
-        toggle_class: toggle_class$8,
-        transition_in: transition_in$8,
-        transition_out: transition_out$8
-    } = window.__gradio__svelte__internal;
-
-function create_fragment$9(t) {
-    let e, i, n, s, l, h, _;
-    return n = new Upload$1({}), {
+const {
+    SvelteComponent: SvelteComponent$9,
+    append: append$8,
+    attr: attr$8,
+    create_component: create_component$5,
+    destroy_component: destroy_component$5,
+    detach: detach$9,
+    element: element$9,
+    init: init$9,
+    insert: insert$9,
+    mount_component: mount_component$5,
+    safe_not_equal: safe_not_equal$a,
+    text: text$4,
+    toggle_class: toggle_class$8,
+    transition_in: transition_in$8,
+    transition_out: transition_out$8
+} = window.__gradio__svelte__internal;
+
+function create_fragment$9(i) {
+    let t, n, e, s, p, f, A;
+    return e = new Upload$1({}), {
         c() {
-            e = element$9("div"), i = element$9("span"), create_component$5(n.$$.fragment), s = text$4(`
+            t = element$9("div"), n = element$9("span"), create_component$5(e.$$.fragment), s = text$4(`
     Drop PDF
-    `), l = element$9("span"), l.textContent = "- or -", h = text$4(`
-    Click to Upload`), attr$8(i, "class", "icon-wrap svelte-kzcjhc"), toggle_class$8(
-                i,
+    `), p = element$9("span"), p.textContent = "- or -", f = text$4(`
+    Click to Upload`), attr$8(n, "class", "icon-wrap svelte-kzcjhc"), toggle_class$8(
+                n,
                 "hovered",
                 /*hovered*/
-                t[0]
-            ), attr$8(l, "class", "or svelte-kzcjhc"), attr$8(e, "class", "wrap svelte-kzcjhc");
+                i[0]
+            ), attr$8(p, "class", "or svelte-kzcjhc"), attr$8(t, "class", "wrap svelte-kzcjhc");
         },
-        m(c, o) {
-            insert$9(c, e, o), append$8(e, i), mount_component$5(n, i, null), append$8(e, s), append$8(e, l), append$8(e, h), _ = !0;
+        m(a, h) {
+            insert$9(a, t, h), append$8(t, n), mount_component$5(e, n, null), append$8(t, s), append$8(t, p), append$8(t, f), A = !0;
         },
-        p(c, [o]) {
-            (!_ || o & /*hovered*/
+        p(a, [h]) {
+            (!A || h & /*hovered*/
                 1) && toggle_class$8(
-                i,
+                n,
                 "hovered",
                 /*hovered*/
-                c[0]
+                a[0]
             );
         },
-        i(c) {
-            _ || (transition_in$8(n.$$.fragment, c), _ = !0);
+        i(a) {
+            A || (transition_in$8(e.$$.fragment, a), A = !0);
         },
-        o(c) {
-            transition_out$8(n.$$.fragment, c), _ = !1;
+        o(a) {
+            transition_out$8(e.$$.fragment, a), A = !1;
         },
-        d(c) {
-            c && detach$9(e), destroy_component$5(n);
+        d(a) {
+            a && detach$9(t), destroy_component$5(e);
         }
     };
 }
 
-function instance$9(t, e, i) {
+function instance$9(i, t, n) {
     let {
-        hovered: n = !1
-    } = e;
-    return t.$$set = (s) => {
-        "hovered" in s && i(0, n = s.hovered);
-    }, [n];
+        hovered: e = !1
+    } = t;
+    return i.$$set = (s) => {
+        "hovered" in s && n(0, e = s.hovered);
+    }, [e];
 }
 class PdfUploadText extends SvelteComponent$9 {
-    constructor(e) {
-        super(), init$9(this, e, instance$9, create_fragment$9, safe_not_equal$a, {
+    constructor(t) {
+        super(), init$9(this, t, instance$9, create_fragment$9, safe_not_equal$a, {
             hovered: 0
         });
     }
 }
-const Block_svelte_svelte_type_style_lang = "",
-    {
-        SvelteComponent: SvelteComponent$8,
-        assign: assign$1,
-        create_slot: create_slot$3,
-        detach: detach$8,
-        element: element$8,
-        get_all_dirty_from_scope: get_all_dirty_from_scope$3,
-        get_slot_changes: get_slot_changes$3,
-        get_spread_update: get_spread_update$1,
-        init: init$8,
-        insert: insert$8,
-        safe_not_equal: safe_not_equal$9,
-        set_dynamic_element_data,
-        set_style: set_style$5,
-        toggle_class: toggle_class$7,
-        transition_in: transition_in$7,
-        transition_out: transition_out$7,
-        update_slot_base: update_slot_base$3
-    } = window.__gradio__svelte__internal;
+const {
+    SvelteComponent: SvelteComponent$8,
+    assign: assign$1,
+    create_slot: create_slot$3,
+    detach: detach$8,
+    element: element$8,
+    get_all_dirty_from_scope: get_all_dirty_from_scope$3,
+    get_slot_changes: get_slot_changes$3,
+    get_spread_update: get_spread_update$1,
+    init: init$8,
+    insert: insert$8,
+    safe_not_equal: safe_not_equal$9,
+    set_dynamic_element_data,
+    set_style: set_style$5,
+    toggle_class: toggle_class$7,
+    transition_in: transition_in$7,
+    transition_out: transition_out$7,
+    update_slot_base: update_slot_base$3
+} = window.__gradio__svelte__internal;
 
-function create_dynamic_element(t) {
-    let e, i, n;
+function create_dynamic_element(i) {
+    let t, n, e;
     const s = (
             /*#slots*/
-            t[17].default
+            i[17].default
         ),
-        l = create_slot$3(
+        p = create_slot$3(
             s,
-            t,
+            i,
             /*$$scope*/
-            t[16],
+            i[16],
             null
         );
-    let h = [{
+    let f = [{
             "data-testid": (
                 /*test_id*/
-                t[7]
+                i[7]
             )
         }, {
             id: (
                 /*elem_id*/
-                t[2]
+                i[2]
             )
         }, {
-            class: i = "block " + /*elem_classes*/
-                t[3].join(" ") + " svelte-1t38q2d"
+            class: n = "block " + /*elem_classes*/
+                i[3].join(" ") + " svelte-1t38q2d"
         }],
-        _ = {};
-    for (let c = 0; c < h.length; c += 1)
-        _ = assign$1(_, h[c]);
+        A = {};
+    for (let a = 0; a < f.length; a += 1)
+        A = assign$1(A, f[a]);
     return {
         c() {
-            e = element$8(
+            t = element$8(
                 /*tag*/
-                t[14]
-            ), l && l.c(), set_dynamic_element_data(
+                i[14]
+            ), p && p.c(), set_dynamic_element_data(
                 /*tag*/
-                t[14]
-            )(e, _), toggle_class$7(
-                e,
+                i[14]
+            )(t, A), toggle_class$7(
+                t,
                 "hidden",
                 /*visible*/
-                t[10] === !1
+                i[10] === !1
             ), toggle_class$7(
-                e,
+                t,
                 "padded",
                 /*padding*/
-                t[6]
+                i[6]
             ), toggle_class$7(
-                e,
+                t,
                 "border_focus",
                 /*border_mode*/
-                t[5] === "focus"
-            ), toggle_class$7(e, "hide-container", ! /*explicit_call*/
-                t[8] && ! /*container*/
-                t[9]), set_style$5(e, "height", typeof /*height*/ t[0] == "number" ? (
+                i[5] === "focus"
+            ), toggle_class$7(t, "hide-container", ! /*explicit_call*/
+                i[8] && ! /*container*/
+                i[9]), set_style$5(t, "height", typeof /*height*/ i[0] == "number" ? (
                 /*height*/
-                t[0] + "px"
-            ) : void 0), set_style$5(e, "width", typeof /*width*/ t[1] == "number" ? `calc(min(${/*width*/
-      t[1]}px, 100%))` : void 0), set_style$5(
-                e,
+                i[0] + "px"
+            ) : void 0), set_style$5(t, "width", typeof /*width*/ i[1] == "number" ? `calc(min(${/*width*/
+      i[1]}px, 100%))` : void 0), set_style$5(
+                t,
                 "border-style",
                 /*variant*/
-                t[4]
+                i[4]
             ), set_style$5(
-                e,
+                t,
                 "overflow",
                 /*allow_overflow*/
-                t[11] ? "visible" : "hidden"
+                i[11] ? "visible" : "hidden"
             ), set_style$5(
-                e,
+                t,
                 "flex-grow",
                 /*scale*/
-                t[12]
-            ), set_style$5(e, "min-width", `calc(min(${/*min_width*/
-      t[13]}px, 100%))`), set_style$5(e, "border-width", "var(--block-border-width)");
+                i[12]
+            ), set_style$5(t, "min-width", `calc(min(${/*min_width*/
+      i[13]}px, 100%))`), set_style$5(t, "border-width", "var(--block-border-width)");
         },
-        m(c, o) {
-            insert$8(c, e, o), l && l.m(e, null), n = !0;
+        m(a, h) {
+            insert$8(a, t, h), p && p.m(t, null), e = !0;
         },
-        p(c, o) {
-            l && l.p && (!n || o & /*$$scope*/
+        p(a, h) {
+            p && p.p && (!e || h & /*$$scope*/
                     65536) && update_slot_base$3(
-                    l,
+                    p,
                     s,
-                    c,
+                    a,
                     /*$$scope*/
-                    c[16],
-                    n ? get_slot_changes$3(
+                    a[16],
+                    e ? get_slot_changes$3(
                         s,
                         /*$$scope*/
-                        c[16],
-                        o,
+                        a[16],
+                        h,
                         null
                     ) : get_all_dirty_from_scope$3(
                         /*$$scope*/
-                        c[16]
+                        a[16]
                     ),
                     null
                 ), set_dynamic_element_data(
                     /*tag*/
-                    c[14]
-                )(e, _ = get_spread_update$1(h, [
-                    (!n || o & /*test_id*/
+                    a[14]
+                )(t, A = get_spread_update$1(f, [
+                    (!e || h & /*test_id*/
                         128) && {
                         "data-testid": (
                             /*test_id*/
-                            c[7]
+                            a[7]
                         )
                     },
-                    (!n || o & /*elem_id*/
+                    (!e || h & /*elem_id*/
                         4) && {
                         id: (
                             /*elem_id*/
-                            c[2]
+                            a[2]
                         )
                     },
-                    (!n || o & /*elem_classes*/
-                        8 && i !== (i = "block " + /*elem_classes*/
-                            c[3].join(" ") + " svelte-1t38q2d")) && {
-                        class: i
+                    (!e || h & /*elem_classes*/
+                        8 && n !== (n = "block " + /*elem_classes*/
+                            a[3].join(" ") + " svelte-1t38q2d")) && {
+                        class: n
                     }
                 ])), toggle_class$7(
-                    e,
+                    t,
                     "hidden",
                     /*visible*/
-                    c[10] === !1
+                    a[10] === !1
                 ), toggle_class$7(
-                    e,
+                    t,
                     "padded",
                     /*padding*/
-                    c[6]
+                    a[6]
                 ), toggle_class$7(
-                    e,
+                    t,
                     "border_focus",
                     /*border_mode*/
-                    c[5] === "focus"
-                ), toggle_class$7(e, "hide-container", ! /*explicit_call*/
-                    c[8] && ! /*container*/
-                    c[9]), o & /*height*/
-                1 && set_style$5(e, "height", typeof /*height*/ c[0] == "number" ? (
+                    a[5] === "focus"
+                ), toggle_class$7(t, "hide-container", ! /*explicit_call*/
+                    a[8] && ! /*container*/
+                    a[9]), h & /*height*/
+                1 && set_style$5(t, "height", typeof /*height*/ a[0] == "number" ? (
                     /*height*/
-                    c[0] + "px"
-                ) : void 0), o & /*width*/
-                2 && set_style$5(e, "width", typeof /*width*/ c[1] == "number" ? `calc(min(${/*width*/
-      c[1]}px, 100%))` : void 0), o & /*variant*/
+                    a[0] + "px"
+                ) : void 0), h & /*width*/
+                2 && set_style$5(t, "width", typeof /*width*/ a[1] == "number" ? `calc(min(${/*width*/
+      a[1]}px, 100%))` : void 0), h & /*variant*/
                 16 && set_style$5(
-                    e,
+                    t,
                     "border-style",
                     /*variant*/
-                    c[4]
-                ), o & /*allow_overflow*/
+                    a[4]
+                ), h & /*allow_overflow*/
                 2048 && set_style$5(
-                    e,
+                    t,
                     "overflow",
                     /*allow_overflow*/
-                    c[11] ? "visible" : "hidden"
-                ), o & /*scale*/
+                    a[11] ? "visible" : "hidden"
+                ), h & /*scale*/
                 4096 && set_style$5(
-                    e,
+                    t,
                     "flex-grow",
                     /*scale*/
-                    c[12]
-                ), o & /*min_width*/
-                8192 && set_style$5(e, "min-width", `calc(min(${/*min_width*/
-      c[13]}px, 100%))`);
+                    a[12]
+                ), h & /*min_width*/
+                8192 && set_style$5(t, "min-width", `calc(min(${/*min_width*/
+      a[13]}px, 100%))`);
         },
-        i(c) {
-            n || (transition_in$7(l, c), n = !0);
+        i(a) {
+            e || (transition_in$7(p, a), e = !0);
         },
-        o(c) {
-            transition_out$7(l, c), n = !1;
+        o(a) {
+            transition_out$7(p, a), e = !1;
         },
-        d(c) {
-            c && detach$8(e), l && l.d(c);
+        d(a) {
+            a && detach$8(t), p && p.d(a);
         }
     };
 }
 
-function create_fragment$8(t) {
-    let e, i = (
+function create_fragment$8(i) {
+    let t, n = (
         /*tag*/
-        t[14] && create_dynamic_element(t)
+        i[14] && create_dynamic_element(i)
     );
     return {
         c() {
-            i && i.c();
+            n && n.c();
         },
-        m(n, s) {
-            i && i.m(n, s), e = !0;
+        m(e, s) {
+            n && n.m(e, s), t = !0;
         },
-        p(n, [s]) {
+        p(e, [s]) {
             /*tag*/
-            n[14] && i.p(n, s);
+            e[14] && n.p(e, s);
         },
-        i(n) {
-            e || (transition_in$7(i, n), e = !0);
+        i(e) {
+            t || (transition_in$7(n, e), t = !0);
         },
-        o(n) {
-            transition_out$7(i, n), e = !1;
+        o(e) {
+            transition_out$7(n, e), t = !1;
         },
-        d(n) {
-            i && i.d(n);
+        d(e) {
+            n && n.d(e);
         }
     };
 }
 
-function instance$8(t, e, i) {
+function instance$8(i, t, n) {
     let {
-        $$slots: n = {},
+        $$slots: e = {},
         $$scope: s
-    } = e, {
-        height: l = void 0
-    } = e, {
-        width: h = void 0
-    } = e, {
-        elem_id: _ = ""
-    } = e, {
-        elem_classes: c = []
-    } = e, {
-        variant: o = "solid"
-    } = e, {
-        border_mode: r = "base"
-    } = e, {
-        padding: T = !0
-    } = e, {
-        type: S = "normal"
-    } = e, {
+    } = t, {
+        height: p = void 0
+    } = t, {
+        width: f = void 0
+    } = t, {
+        elem_id: A = ""
+    } = t, {
+        elem_classes: a = []
+    } = t, {
+        variant: h = "solid"
+    } = t, {
+        border_mode: o = "base"
+    } = t, {
+        padding: F = !0
+    } = t, {
+        type: R = "normal"
+    } = t, {
         test_id: w = void 0
-    } = e, {
-        explicit_call: C = !1
-    } = e, {
+    } = t, {
+        explicit_call: T = !1
+    } = t, {
         container: P = !0
-    } = e, {
-        visible: b = !0
-    } = e, {
-        allow_overflow: k = !0
-    } = e, {
-        scale: F = null
-    } = e, {
-        min_width: x = 0
-    } = e, y = S === "fieldset" ? "fieldset" : "div";
-    return t.$$set = (p) => {
-        "height" in p && i(0, l = p.height), "width" in p && i(1, h = p.width), "elem_id" in p && i(2, _ = p.elem_id), "elem_classes" in p && i(3, c = p.elem_classes), "variant" in p && i(4, o = p.variant), "border_mode" in p && i(5, r = p.border_mode), "padding" in p && i(6, T = p.padding), "type" in p && i(15, S = p.type), "test_id" in p && i(7, w = p.test_id), "explicit_call" in p && i(8, C = p.explicit_call), "container" in p && i(9, P = p.container), "visible" in p && i(10, b = p.visible), "allow_overflow" in p && i(11, k = p.allow_overflow), "scale" in p && i(12, F = p.scale), "min_width" in p && i(13, x = p.min_width), "$$scope" in p && i(16, s = p.$$scope);
+    } = t, {
+        visible: m = !0
+    } = t, {
+        allow_overflow: C = !0
+    } = t, {
+        scale: x = null
+    } = t, {
+        min_width: E = 0
+    } = t, S = R === "fieldset" ? "fieldset" : "div";
+    return i.$$set = (g) => {
+        "height" in g && n(0, p = g.height), "width" in g && n(1, f = g.width), "elem_id" in g && n(2, A = g.elem_id), "elem_classes" in g && n(3, a = g.elem_classes), "variant" in g && n(4, h = g.variant), "border_mode" in g && n(5, o = g.border_mode), "padding" in g && n(6, F = g.padding), "type" in g && n(15, R = g.type), "test_id" in g && n(7, w = g.test_id), "explicit_call" in g && n(8, T = g.explicit_call), "container" in g && n(9, P = g.container), "visible" in g && n(10, m = g.visible), "allow_overflow" in g && n(11, C = g.allow_overflow), "scale" in g && n(12, x = g.scale), "min_width" in g && n(13, E = g.min_width), "$$scope" in g && n(16, s = g.$$scope);
     }, [
-        l,
+        p,
+        f,
+        A,
+        a,
         h,
-        _,
-        c,
         o,
-        r,
-        T,
+        F,
         w,
-        C,
+        T,
         P,
-        b,
-        k,
-        F,
+        m,
+        C,
         x,
-        y,
+        E,
         S,
+        R,
         s,
-        n
+        e
     ];
 }
 class Block extends SvelteComponent$8 {
-    constructor(e) {
-        super(), init$8(this, e, instance$8, create_fragment$8, safe_not_equal$9, {
+    constructor(t) {
+        super(), init$8(this, t, instance$8, create_fragment$8, safe_not_equal$9, {
             height: 0,
             width: 1,
             elem_id: 2,
             elem_classes: 3,
             variant: 4,
             border_mode: 5,
             padding: 6,
@@ -573,310 +570,305 @@
             visible: 10,
             allow_overflow: 11,
             scale: 12,
             min_width: 13
         });
     }
 }
-const Info_svelte_svelte_type_style_lang = "",
-    BlockTitle_svelte_svelte_type_style_lang = "",
-    BlockLabel_svelte_svelte_type_style_lang = "",
-    {
-        SvelteComponent: SvelteComponent$7,
-        append: append$7,
-        attr: attr$7,
-        create_component: create_component$4,
-        destroy_component: destroy_component$4,
-        detach: detach$7,
-        element: element$7,
-        init: init$7,
-        insert: insert$7,
-        mount_component: mount_component$4,
-        safe_not_equal: safe_not_equal$8,
-        set_data: set_data$3,
-        space: space$6,
-        text: text$3,
-        toggle_class: toggle_class$6,
-        transition_in: transition_in$6,
-        transition_out: transition_out$6
-    } = window.__gradio__svelte__internal;
-
-function create_fragment$7(t) {
-    let e, i, n, s, l, h;
-    return n = new /*Icon*/
-    t[1]({}), {
+const {
+    SvelteComponent: SvelteComponent$7,
+    append: append$7,
+    attr: attr$7,
+    create_component: create_component$4,
+    destroy_component: destroy_component$4,
+    detach: detach$7,
+    element: element$7,
+    init: init$7,
+    insert: insert$7,
+    mount_component: mount_component$4,
+    safe_not_equal: safe_not_equal$8,
+    set_data: set_data$3,
+    space: space$6,
+    text: text$3,
+    toggle_class: toggle_class$6,
+    transition_in: transition_in$6,
+    transition_out: transition_out$6
+} = window.__gradio__svelte__internal;
+
+function create_fragment$7(i) {
+    let t, n, e, s, p, f;
+    return e = new /*Icon*/
+    i[1]({}), {
         c() {
-            e = element$7("label"), i = element$7("span"), create_component$4(n.$$.fragment), s = space$6(), l = text$3(
+            t = element$7("label"), n = element$7("span"), create_component$4(e.$$.fragment), s = space$6(), p = text$3(
                 /*label*/
-                t[0]
-            ), attr$7(i, "class", "svelte-9gxdi0"), attr$7(e, "for", ""), attr$7(e, "data-testid", "block-label"), attr$7(e, "class", "svelte-9gxdi0"), toggle_class$6(e, "hide", ! /*show_label*/
-                t[2]), toggle_class$6(e, "sr-only", ! /*show_label*/
-                t[2]), toggle_class$6(
-                e,
+                i[0]
+            ), attr$7(n, "class", "svelte-9gxdi0"), attr$7(t, "for", ""), attr$7(t, "data-testid", "block-label"), attr$7(t, "class", "svelte-9gxdi0"), toggle_class$6(t, "hide", ! /*show_label*/
+                i[2]), toggle_class$6(t, "sr-only", ! /*show_label*/
+                i[2]), toggle_class$6(
+                t,
                 "float",
                 /*float*/
-                t[4]
+                i[4]
             ), toggle_class$6(
-                e,
+                t,
                 "hide-label",
                 /*disable*/
-                t[3]
+                i[3]
             );
         },
-        m(_, c) {
-            insert$7(_, e, c), append$7(e, i), mount_component$4(n, i, null), append$7(e, s), append$7(e, l), h = !0;
+        m(A, a) {
+            insert$7(A, t, a), append$7(t, n), mount_component$4(e, n, null), append$7(t, s), append$7(t, p), f = !0;
         },
-        p(_, [c]) {
-            (!h || c & /*label*/
+        p(A, [a]) {
+            (!f || a & /*label*/
                 1) && set_data$3(
-                l,
+                p,
                 /*label*/
-                _[0]
-            ), (!h || c & /*show_label*/
-                4) && toggle_class$6(e, "hide", ! /*show_label*/
-                _[2]), (!h || c & /*show_label*/
-                4) && toggle_class$6(e, "sr-only", ! /*show_label*/
-                _[2]), (!h || c & /*float*/
+                A[0]
+            ), (!f || a & /*show_label*/
+                4) && toggle_class$6(t, "hide", ! /*show_label*/
+                A[2]), (!f || a & /*show_label*/
+                4) && toggle_class$6(t, "sr-only", ! /*show_label*/
+                A[2]), (!f || a & /*float*/
                 16) && toggle_class$6(
-                e,
+                t,
                 "float",
                 /*float*/
-                _[4]
-            ), (!h || c & /*disable*/
+                A[4]
+            ), (!f || a & /*disable*/
                 8) && toggle_class$6(
-                e,
+                t,
                 "hide-label",
                 /*disable*/
-                _[3]
+                A[3]
             );
         },
-        i(_) {
-            h || (transition_in$6(n.$$.fragment, _), h = !0);
+        i(A) {
+            f || (transition_in$6(e.$$.fragment, A), f = !0);
         },
-        o(_) {
-            transition_out$6(n.$$.fragment, _), h = !1;
+        o(A) {
+            transition_out$6(e.$$.fragment, A), f = !1;
         },
-        d(_) {
-            _ && detach$7(e), destroy_component$4(n);
+        d(A) {
+            A && detach$7(t), destroy_component$4(e);
         }
     };
 }
 
-function instance$7(t, e, i) {
+function instance$7(i, t, n) {
     let {
-        label: n = null
-    } = e, {
+        label: e = null
+    } = t, {
         Icon: s
-    } = e, {
-        show_label: l = !0
-    } = e, {
-        disable: h = !1
-    } = e, {
-        float: _ = !0
-    } = e;
-    return t.$$set = (c) => {
-        "label" in c && i(0, n = c.label), "Icon" in c && i(1, s = c.Icon), "show_label" in c && i(2, l = c.show_label), "disable" in c && i(3, h = c.disable), "float" in c && i(4, _ = c.float);
-    }, [n, s, l, h, _];
+    } = t, {
+        show_label: p = !0
+    } = t, {
+        disable: f = !1
+    } = t, {
+        float: A = !0
+    } = t;
+    return i.$$set = (a) => {
+        "label" in a && n(0, e = a.label), "Icon" in a && n(1, s = a.Icon), "show_label" in a && n(2, p = a.show_label), "disable" in a && n(3, f = a.disable), "float" in a && n(4, A = a.float);
+    }, [e, s, p, f, A];
 }
 class BlockLabel extends SvelteComponent$7 {
-    constructor(e) {
-        super(), init$7(this, e, instance$7, create_fragment$7, safe_not_equal$8, {
+    constructor(t) {
+        super(), init$7(this, t, instance$7, create_fragment$7, safe_not_equal$8, {
             label: 0,
             Icon: 1,
             show_label: 2,
             disable: 3,
             float: 4
         });
     }
 }
-const IconButton_svelte_svelte_type_style_lang = "",
-    {
-        SvelteComponent: SvelteComponent$6,
-        append: append$6,
-        attr: attr$6,
-        bubble: bubble$2,
-        create_component: create_component$3,
-        destroy_component: destroy_component$3,
-        detach: detach$6,
-        element: element$6,
-        init: init$6,
-        insert: insert$6,
-        listen: listen$2,
-        mount_component: mount_component$3,
-        safe_not_equal: safe_not_equal$7,
-        set_data: set_data$2,
-        space: space$5,
-        text: text$2,
-        toggle_class: toggle_class$5,
-        transition_in: transition_in$5,
-        transition_out: transition_out$5
-    } = window.__gradio__svelte__internal;
+const {
+    SvelteComponent: SvelteComponent$6,
+    append: append$6,
+    attr: attr$6,
+    bubble: bubble$2,
+    create_component: create_component$3,
+    destroy_component: destroy_component$3,
+    detach: detach$6,
+    element: element$6,
+    init: init$6,
+    insert: insert$6,
+    listen: listen$2,
+    mount_component: mount_component$3,
+    safe_not_equal: safe_not_equal$7,
+    set_data: set_data$2,
+    space: space$5,
+    text: text$2,
+    toggle_class: toggle_class$5,
+    transition_in: transition_in$5,
+    transition_out: transition_out$5
+} = window.__gradio__svelte__internal;
 
-function create_if_block$4(t) {
-    let e, i;
+function create_if_block$4(i) {
+    let t, n;
     return {
         c() {
-            e = element$6("span"), i = text$2(
+            t = element$6("span"), n = text$2(
                 /*label*/
-                t[1]
-            ), attr$6(e, "class", "svelte-xtz2g8");
+                i[1]
+            ), attr$6(t, "class", "svelte-xtz2g8");
         },
-        m(n, s) {
-            insert$6(n, e, s), append$6(e, i);
+        m(e, s) {
+            insert$6(e, t, s), append$6(t, n);
         },
-        p(n, s) {
+        p(e, s) {
             s & /*label*/
                 2 && set_data$2(
-                    i,
+                    n,
                     /*label*/
-                    n[1]
+                    e[1]
                 );
         },
-        d(n) {
-            n && detach$6(e);
+        d(e) {
+            e && detach$6(t);
         }
     };
 }
 
-function create_fragment$6(t) {
-    let e, i, n, s, l, h, _, c = (
+function create_fragment$6(i) {
+    let t, n, e, s, p, f, A, a = (
         /*show_label*/
-        t[2] && create_if_block$4(t)
+        i[2] && create_if_block$4(i)
     );
     return s = new /*Icon*/
-    t[0]({}), {
+    i[0]({}), {
         c() {
-            e = element$6("button"), c && c.c(), i = space$5(), n = element$6("div"), create_component$3(s.$$.fragment), attr$6(n, "class", "svelte-xtz2g8"), toggle_class$5(
-                n,
+            t = element$6("button"), a && a.c(), n = space$5(), e = element$6("div"), create_component$3(s.$$.fragment), attr$6(e, "class", "svelte-xtz2g8"), toggle_class$5(
+                e,
                 "small",
                 /*size*/
-                t[4] === "small"
+                i[4] === "small"
             ), toggle_class$5(
-                n,
+                e,
                 "large",
                 /*size*/
-                t[4] === "large"
+                i[4] === "large"
             ), attr$6(
-                e,
+                t,
                 "aria-label",
                 /*label*/
-                t[1]
+                i[1]
             ), attr$6(
-                e,
+                t,
                 "title",
                 /*label*/
-                t[1]
-            ), attr$6(e, "class", "svelte-xtz2g8"), toggle_class$5(
-                e,
+                i[1]
+            ), attr$6(t, "class", "svelte-xtz2g8"), toggle_class$5(
+                t,
                 "pending",
                 /*pending*/
-                t[3]
+                i[3]
             ), toggle_class$5(
-                e,
+                t,
                 "padded",
                 /*padded*/
-                t[5]
+                i[5]
             );
         },
-        m(o, r) {
-            insert$6(o, e, r), c && c.m(e, null), append$6(e, i), append$6(e, n), mount_component$3(s, n, null), l = !0, h || (_ = listen$2(
-                e,
+        m(h, o) {
+            insert$6(h, t, o), a && a.m(t, null), append$6(t, n), append$6(t, e), mount_component$3(s, e, null), p = !0, f || (A = listen$2(
+                t,
                 "click",
                 /*click_handler*/
-                t[6]
-            ), h = !0);
+                i[6]
+            ), f = !0);
         },
-        p(o, [r]) {
+        p(h, [o]) {
             /*show_label*/
-            o[2] ? c ? c.p(o, r) : (c = create_if_block$4(o), c.c(), c.m(e, i)) : c && (c.d(1), c = null), (!l || r & /*size*/
+            h[2] ? a ? a.p(h, o) : (a = create_if_block$4(h), a.c(), a.m(t, n)) : a && (a.d(1), a = null), (!p || o & /*size*/
                 16) && toggle_class$5(
-                n,
+                e,
                 "small",
                 /*size*/
-                o[4] === "small"
-            ), (!l || r & /*size*/
+                h[4] === "small"
+            ), (!p || o & /*size*/
                 16) && toggle_class$5(
-                n,
+                e,
                 "large",
                 /*size*/
-                o[4] === "large"
-            ), (!l || r & /*label*/
+                h[4] === "large"
+            ), (!p || o & /*label*/
                 2) && attr$6(
-                e,
+                t,
                 "aria-label",
                 /*label*/
-                o[1]
-            ), (!l || r & /*label*/
+                h[1]
+            ), (!p || o & /*label*/
                 2) && attr$6(
-                e,
+                t,
                 "title",
                 /*label*/
-                o[1]
-            ), (!l || r & /*pending*/
+                h[1]
+            ), (!p || o & /*pending*/
                 8) && toggle_class$5(
-                e,
+                t,
                 "pending",
                 /*pending*/
-                o[3]
-            ), (!l || r & /*padded*/
+                h[3]
+            ), (!p || o & /*padded*/
                 32) && toggle_class$5(
-                e,
+                t,
                 "padded",
                 /*padded*/
-                o[5]
+                h[5]
             );
         },
-        i(o) {
-            l || (transition_in$5(s.$$.fragment, o), l = !0);
+        i(h) {
+            p || (transition_in$5(s.$$.fragment, h), p = !0);
         },
-        o(o) {
-            transition_out$5(s.$$.fragment, o), l = !1;
+        o(h) {
+            transition_out$5(s.$$.fragment, h), p = !1;
         },
-        d(o) {
-            o && detach$6(e), c && c.d(), destroy_component$3(s), h = !1, _();
+        d(h) {
+            h && detach$6(t), a && a.d(), destroy_component$3(s), f = !1, A();
         }
     };
 }
 
-function instance$6(t, e, i) {
+function instance$6(i, t, n) {
     let {
-        Icon: n
-    } = e, {
+        Icon: e
+    } = t, {
         label: s = ""
-    } = e, {
-        show_label: l = !1
-    } = e, {
-        pending: h = !1
-    } = e, {
-        size: _ = "small"
-    } = e, {
-        padded: c = !0
-    } = e;
-
-    function o(r) {
-        bubble$2.call(this, t, r);
-    }
-    return t.$$set = (r) => {
-        "Icon" in r && i(0, n = r.Icon), "label" in r && i(1, s = r.label), "show_label" in r && i(2, l = r.show_label), "pending" in r && i(3, h = r.pending), "size" in r && i(4, _ = r.size), "padded" in r && i(5, c = r.padded);
-    }, [n, s, l, h, _, c, o];
+    } = t, {
+        show_label: p = !1
+    } = t, {
+        pending: f = !1
+    } = t, {
+        size: A = "small"
+    } = t, {
+        padded: a = !0
+    } = t;
+
+    function h(o) {
+        bubble$2.call(this, i, o);
+    }
+    return i.$$set = (o) => {
+        "Icon" in o && n(0, e = o.Icon), "label" in o && n(1, s = o.label), "show_label" in o && n(2, p = o.show_label), "pending" in o && n(3, f = o.pending), "size" in o && n(4, A = o.size), "padded" in o && n(5, a = o.padded);
+    }, [e, s, p, f, A, a, h];
 }
 class IconButton extends SvelteComponent$6 {
-    constructor(e) {
-        super(), init$6(this, e, instance$6, create_fragment$6, safe_not_equal$7, {
+    constructor(t) {
+        super(), init$6(this, t, instance$6, create_fragment$6, safe_not_equal$7, {
             Icon: 0,
             label: 1,
             show_label: 2,
             pending: 3,
             size: 4,
             padded: 5
         });
     }
 }
-const Empty_svelte_svelte_type_style_lang = "",
-    color_values = [{
+const color_values = [{
         color: "red",
         primary: 600,
         secondary: 100
     }, {
         color: "green",
         primary: 600,
         secondary: 100
@@ -1203,490 +1195,487 @@
             700: "#be123c",
             800: "#9f1239",
             900: "#881337",
             950: "#4c0519"
         }
     };
 color_values.reduce(
-    (t, {
-        color: e,
-        primary: i,
-        secondary: n
+    (i, {
+        color: t,
+        primary: n,
+        secondary: e
     }) => ({
-        ...t,
-        [e]: {
-            primary: tw_colors[e][i],
-            secondary: tw_colors[e][n]
+        ...i,
+        [t]: {
+            primary: tw_colors[t][n],
+            secondary: tw_colors[t][e]
         }
     }), {}
 );
-const UploadText_svelte_svelte_type_style_lang = "",
-    Toolbar_svelte_svelte_type_style_lang = "";
 new Intl.Collator(0, {
     numeric: 1
 }).compare;
 
-function is_url$1(t) {
+function is_url$1(i) {
     try {
-        const e = new URL(t);
-        return e.protocol === "http:" || e.protocol === "https:";
+        const t = new URL(i);
+        return t.protocol === "http:" || t.protocol === "https:";
     } catch {
         return !1;
     }
 }
 
-function get_fetchable_url_or_file$1(t, e, i) {
-    return t == null ? i ? `/proxy=${i}file=` : `${e}/file=` : is_url$1(t) ? t : i ? `/proxy=${i}file=${t}` : `${e}/file=${t}`;
+function get_fetchable_url_or_file$1(i, t, n) {
+    return i == null ? n ? `/proxy=${n}file=` : `${t}/file=` : is_url$1(i) ? i : n ? `/proxy=${n}file=${i}` : `${t}/file=${i}`;
 }
-const Button_svelte_svelte_type_style_lang = "",
-    {
-        SvelteComponent: SvelteComponent$5,
-        append: append$5,
-        attr: attr$5,
-        bubble: bubble$1,
-        check_outros: check_outros$3,
-        create_slot: create_slot$2,
-        detach: detach$5,
-        element: element$5,
-        empty: empty$2,
-        get_all_dirty_from_scope: get_all_dirty_from_scope$2,
-        get_slot_changes: get_slot_changes$2,
-        group_outros: group_outros$3,
-        init: init$5,
-        insert: insert$5,
-        listen: listen$1,
-        safe_not_equal: safe_not_equal$6,
-        set_style: set_style$4,
-        space: space$4,
-        src_url_equal,
-        toggle_class: toggle_class$4,
-        transition_in: transition_in$4,
-        transition_out: transition_out$4,
-        update_slot_base: update_slot_base$2
-    } = window.__gradio__svelte__internal;
+const {
+    SvelteComponent: SvelteComponent$5,
+    append: append$5,
+    attr: attr$5,
+    bubble: bubble$1,
+    check_outros: check_outros$3,
+    create_slot: create_slot$2,
+    detach: detach$5,
+    element: element$5,
+    empty: empty$2,
+    get_all_dirty_from_scope: get_all_dirty_from_scope$2,
+    get_slot_changes: get_slot_changes$2,
+    group_outros: group_outros$3,
+    init: init$5,
+    insert: insert$5,
+    listen: listen$1,
+    safe_not_equal: safe_not_equal$6,
+    set_style: set_style$4,
+    space: space$4,
+    src_url_equal,
+    toggle_class: toggle_class$4,
+    transition_in: transition_in$4,
+    transition_out: transition_out$4,
+    update_slot_base: update_slot_base$2
+} = window.__gradio__svelte__internal;
 
-function create_else_block$2(t) {
-    let e, i, n, s, l, h, _ = (
+function create_else_block$2(i) {
+    let t, n, e, s, p, f, A = (
         /*icon*/
-        t[7] && create_if_block_2$1(t)
+        i[7] && create_if_block_2$1(i)
     );
-    const c = (
+    const a = (
             /*#slots*/
-            t[15].default
+            i[15].default
         ),
-        o = create_slot$2(
-            c,
-            t,
+        h = create_slot$2(
+            a,
+            i,
             /*$$scope*/
-            t[14],
+            i[14],
             null
         );
     return {
         c() {
-            e = element$5("button"), _ && _.c(), i = space$4(), o && o.c(), attr$5(e, "class", n = /*size*/
-                    t[4] + " " + /*variant*/
-                    t[3] + " " + /*elem_classes*/
-                    t[1].join(" ") + " svelte-8huxfn"), attr$5(
-                    e,
+            t = element$5("button"), A && A.c(), n = space$4(), h && h.c(), attr$5(t, "class", e = /*size*/
+                    i[4] + " " + /*variant*/
+                    i[3] + " " + /*elem_classes*/
+                    i[1].join(" ") + " svelte-8huxfn"), attr$5(
+                    t,
                     "id",
                     /*elem_id*/
-                    t[0]
-                ), e.disabled = /*disabled*/
-                t[8], toggle_class$4(e, "hidden", ! /*visible*/
-                    t[2]), set_style$4(
-                    e,
+                    i[0]
+                ), t.disabled = /*disabled*/
+                i[8], toggle_class$4(t, "hidden", ! /*visible*/
+                    i[2]), set_style$4(
+                    t,
                     "flex-grow",
                     /*scale*/
-                    t[9]
+                    i[9]
                 ), set_style$4(
-                    e,
+                    t,
                     "width",
                     /*scale*/
-                    t[9] === 0 ? "fit-content" : null
-                ), set_style$4(e, "min-width", typeof /*min_width*/ t[10] == "number" ? `calc(min(${/*min_width*/
-      t[10]}px, 100%))` : null);
-        },
-        m(r, T) {
-            insert$5(r, e, T), _ && _.m(e, null), append$5(e, i), o && o.m(e, null), s = !0, l || (h = listen$1(
-                e,
+                    i[9] === 0 ? "fit-content" : null
+                ), set_style$4(t, "min-width", typeof /*min_width*/ i[10] == "number" ? `calc(min(${/*min_width*/
+      i[10]}px, 100%))` : null);
+        },
+        m(o, F) {
+            insert$5(o, t, F), A && A.m(t, null), append$5(t, n), h && h.m(t, null), s = !0, p || (f = listen$1(
+                t,
                 "click",
                 /*click_handler*/
-                t[16]
-            ), l = !0);
+                i[16]
+            ), p = !0);
         },
-        p(r, T) {
+        p(o, F) {
             /*icon*/
-            r[7] ? _ ? _.p(r, T) : (_ = create_if_block_2$1(r), _.c(), _.m(e, i)) : _ && (_.d(1), _ = null), o && o.p && (!s || T & /*$$scope*/
+            o[7] ? A ? A.p(o, F) : (A = create_if_block_2$1(o), A.c(), A.m(t, n)) : A && (A.d(1), A = null), h && h.p && (!s || F & /*$$scope*/
                     16384) && update_slot_base$2(
+                    h,
+                    a,
                     o,
-                    c,
-                    r,
                     /*$$scope*/
-                    r[14],
+                    o[14],
                     s ? get_slot_changes$2(
-                        c,
+                        a,
                         /*$$scope*/
-                        r[14],
-                        T,
+                        o[14],
+                        F,
                         null
                     ) : get_all_dirty_from_scope$2(
                         /*$$scope*/
-                        r[14]
+                        o[14]
                     ),
                     null
-                ), (!s || T & /*size, variant, elem_classes*/
-                    26 && n !== (n = /*size*/
-                        r[4] + " " + /*variant*/
-                        r[3] + " " + /*elem_classes*/
-                        r[1].join(" ") + " svelte-8huxfn")) && attr$5(e, "class", n), (!s || T & /*elem_id*/
+                ), (!s || F & /*size, variant, elem_classes*/
+                    26 && e !== (e = /*size*/
+                        o[4] + " " + /*variant*/
+                        o[3] + " " + /*elem_classes*/
+                        o[1].join(" ") + " svelte-8huxfn")) && attr$5(t, "class", e), (!s || F & /*elem_id*/
                     1) && attr$5(
-                    e,
+                    t,
                     "id",
                     /*elem_id*/
-                    r[0]
-                ), (!s || T & /*disabled*/
-                    256) && (e.disabled = /*disabled*/
-                    r[8]), (!s || T & /*size, variant, elem_classes, visible*/
-                    30) && toggle_class$4(e, "hidden", ! /*visible*/
-                    r[2]), T & /*scale*/
+                    o[0]
+                ), (!s || F & /*disabled*/
+                    256) && (t.disabled = /*disabled*/
+                    o[8]), (!s || F & /*size, variant, elem_classes, visible*/
+                    30) && toggle_class$4(t, "hidden", ! /*visible*/
+                    o[2]), F & /*scale*/
                 512 && set_style$4(
-                    e,
+                    t,
                     "flex-grow",
                     /*scale*/
-                    r[9]
-                ), T & /*scale*/
+                    o[9]
+                ), F & /*scale*/
                 512 && set_style$4(
-                    e,
+                    t,
                     "width",
                     /*scale*/
-                    r[9] === 0 ? "fit-content" : null
-                ), T & /*min_width*/
-                1024 && set_style$4(e, "min-width", typeof /*min_width*/ r[10] == "number" ? `calc(min(${/*min_width*/
-      r[10]}px, 100%))` : null);
+                    o[9] === 0 ? "fit-content" : null
+                ), F & /*min_width*/
+                1024 && set_style$4(t, "min-width", typeof /*min_width*/ o[10] == "number" ? `calc(min(${/*min_width*/
+      o[10]}px, 100%))` : null);
         },
-        i(r) {
-            s || (transition_in$4(o, r), s = !0);
+        i(o) {
+            s || (transition_in$4(h, o), s = !0);
         },
-        o(r) {
-            transition_out$4(o, r), s = !1;
+        o(o) {
+            transition_out$4(h, o), s = !1;
         },
-        d(r) {
-            r && detach$5(e), _ && _.d(), o && o.d(r), l = !1, h();
+        d(o) {
+            o && detach$5(t), A && A.d(), h && h.d(o), p = !1, f();
         }
     };
 }
 
-function create_if_block$3(t) {
-    let e, i, n, s, l = (
+function create_if_block$3(i) {
+    let t, n, e, s, p = (
         /*icon*/
-        t[7] && create_if_block_1$3(t)
+        i[7] && create_if_block_1$3(i)
     );
-    const h = (
+    const f = (
             /*#slots*/
-            t[15].default
+            i[15].default
         ),
-        _ = create_slot$2(
-            h,
-            t,
+        A = create_slot$2(
+            f,
+            i,
             /*$$scope*/
-            t[14],
+            i[14],
             null
         );
     return {
         c() {
-            e = element$5("a"), l && l.c(), i = space$4(), _ && _.c(), attr$5(
-                e,
+            t = element$5("a"), p && p.c(), n = space$4(), A && A.c(), attr$5(
+                t,
                 "href",
                 /*link*/
-                t[6]
-            ), attr$5(e, "rel", "noopener noreferrer"), attr$5(
-                e,
+                i[6]
+            ), attr$5(t, "rel", "noopener noreferrer"), attr$5(
+                t,
                 "aria-disabled",
                 /*disabled*/
-                t[8]
-            ), attr$5(e, "class", n = /*size*/
-                t[4] + " " + /*variant*/
-                t[3] + " " + /*elem_classes*/
-                t[1].join(" ") + " svelte-8huxfn"), attr$5(
-                e,
+                i[8]
+            ), attr$5(t, "class", e = /*size*/
+                i[4] + " " + /*variant*/
+                i[3] + " " + /*elem_classes*/
+                i[1].join(" ") + " svelte-8huxfn"), attr$5(
+                t,
                 "id",
                 /*elem_id*/
-                t[0]
-            ), toggle_class$4(e, "hidden", ! /*visible*/
-                t[2]), toggle_class$4(
-                e,
+                i[0]
+            ), toggle_class$4(t, "hidden", ! /*visible*/
+                i[2]), toggle_class$4(
+                t,
                 "disabled",
                 /*disabled*/
-                t[8]
+                i[8]
             ), set_style$4(
-                e,
+                t,
                 "flex-grow",
                 /*scale*/
-                t[9]
+                i[9]
             ), set_style$4(
-                e,
+                t,
                 "pointer-events",
                 /*disabled*/
-                t[8] ? "none" : null
+                i[8] ? "none" : null
             ), set_style$4(
-                e,
+                t,
                 "width",
                 /*scale*/
-                t[9] === 0 ? "fit-content" : null
-            ), set_style$4(e, "min-width", typeof /*min_width*/ t[10] == "number" ? `calc(min(${/*min_width*/
-      t[10]}px, 100%))` : null);
+                i[9] === 0 ? "fit-content" : null
+            ), set_style$4(t, "min-width", typeof /*min_width*/ i[10] == "number" ? `calc(min(${/*min_width*/
+      i[10]}px, 100%))` : null);
         },
-        m(c, o) {
-            insert$5(c, e, o), l && l.m(e, null), append$5(e, i), _ && _.m(e, null), s = !0;
+        m(a, h) {
+            insert$5(a, t, h), p && p.m(t, null), append$5(t, n), A && A.m(t, null), s = !0;
         },
-        p(c, o) {
+        p(a, h) {
             /*icon*/
-            c[7] ? l ? l.p(c, o) : (l = create_if_block_1$3(c), l.c(), l.m(e, i)) : l && (l.d(1), l = null), _ && _.p && (!s || o & /*$$scope*/
+            a[7] ? p ? p.p(a, h) : (p = create_if_block_1$3(a), p.c(), p.m(t, n)) : p && (p.d(1), p = null), A && A.p && (!s || h & /*$$scope*/
                     16384) && update_slot_base$2(
-                    _,
-                    h,
-                    c,
+                    A,
+                    f,
+                    a,
                     /*$$scope*/
-                    c[14],
+                    a[14],
                     s ? get_slot_changes$2(
-                        h,
+                        f,
                         /*$$scope*/
-                        c[14],
-                        o,
+                        a[14],
+                        h,
                         null
                     ) : get_all_dirty_from_scope$2(
                         /*$$scope*/
-                        c[14]
+                        a[14]
                     ),
                     null
-                ), (!s || o & /*link*/
+                ), (!s || h & /*link*/
                     64) && attr$5(
-                    e,
+                    t,
                     "href",
                     /*link*/
-                    c[6]
-                ), (!s || o & /*disabled*/
+                    a[6]
+                ), (!s || h & /*disabled*/
                     256) && attr$5(
-                    e,
+                    t,
                     "aria-disabled",
                     /*disabled*/
-                    c[8]
-                ), (!s || o & /*size, variant, elem_classes*/
-                    26 && n !== (n = /*size*/
-                        c[4] + " " + /*variant*/
-                        c[3] + " " + /*elem_classes*/
-                        c[1].join(" ") + " svelte-8huxfn")) && attr$5(e, "class", n), (!s || o & /*elem_id*/
+                    a[8]
+                ), (!s || h & /*size, variant, elem_classes*/
+                    26 && e !== (e = /*size*/
+                        a[4] + " " + /*variant*/
+                        a[3] + " " + /*elem_classes*/
+                        a[1].join(" ") + " svelte-8huxfn")) && attr$5(t, "class", e), (!s || h & /*elem_id*/
                     1) && attr$5(
-                    e,
+                    t,
                     "id",
                     /*elem_id*/
-                    c[0]
-                ), (!s || o & /*size, variant, elem_classes, visible*/
-                    30) && toggle_class$4(e, "hidden", ! /*visible*/
-                    c[2]), (!s || o & /*size, variant, elem_classes, disabled*/
+                    a[0]
+                ), (!s || h & /*size, variant, elem_classes, visible*/
+                    30) && toggle_class$4(t, "hidden", ! /*visible*/
+                    a[2]), (!s || h & /*size, variant, elem_classes, disabled*/
                     282) && toggle_class$4(
-                    e,
+                    t,
                     "disabled",
                     /*disabled*/
-                    c[8]
-                ), o & /*scale*/
+                    a[8]
+                ), h & /*scale*/
                 512 && set_style$4(
-                    e,
+                    t,
                     "flex-grow",
                     /*scale*/
-                    c[9]
-                ), o & /*disabled*/
+                    a[9]
+                ), h & /*disabled*/
                 256 && set_style$4(
-                    e,
+                    t,
                     "pointer-events",
                     /*disabled*/
-                    c[8] ? "none" : null
-                ), o & /*scale*/
+                    a[8] ? "none" : null
+                ), h & /*scale*/
                 512 && set_style$4(
-                    e,
+                    t,
                     "width",
                     /*scale*/
-                    c[9] === 0 ? "fit-content" : null
-                ), o & /*min_width*/
-                1024 && set_style$4(e, "min-width", typeof /*min_width*/ c[10] == "number" ? `calc(min(${/*min_width*/
-      c[10]}px, 100%))` : null);
+                    a[9] === 0 ? "fit-content" : null
+                ), h & /*min_width*/
+                1024 && set_style$4(t, "min-width", typeof /*min_width*/ a[10] == "number" ? `calc(min(${/*min_width*/
+      a[10]}px, 100%))` : null);
         },
-        i(c) {
-            s || (transition_in$4(_, c), s = !0);
+        i(a) {
+            s || (transition_in$4(A, a), s = !0);
         },
-        o(c) {
-            transition_out$4(_, c), s = !1;
+        o(a) {
+            transition_out$4(A, a), s = !1;
         },
-        d(c) {
-            c && detach$5(e), l && l.d(), _ && _.d(c);
+        d(a) {
+            a && detach$5(t), p && p.d(), A && A.d(a);
         }
     };
 }
 
-function create_if_block_2$1(t) {
-    let e, i, n;
+function create_if_block_2$1(i) {
+    let t, n, e;
     return {
         c() {
-            e = element$5("img"), attr$5(e, "class", "button-icon svelte-8huxfn"), src_url_equal(e.src, i = /*icon_path*/
-                t[11]) || attr$5(e, "src", i), attr$5(e, "alt", n = `${/*value*/
-      t[5]} icon`);
-        },
-        m(s, l) {
-            insert$5(s, e, l);
-        },
-        p(s, l) {
-            l & /*icon_path*/
-                2048 && !src_url_equal(e.src, i = /*icon_path*/
-                    s[11]) && attr$5(e, "src", i), l & /*value*/
-                32 && n !== (n = `${/*value*/
-      s[5]} icon`) && attr$5(e, "alt", n);
+            t = element$5("img"), attr$5(t, "class", "button-icon svelte-8huxfn"), src_url_equal(t.src, n = /*icon_path*/
+                i[11]) || attr$5(t, "src", n), attr$5(t, "alt", e = `${/*value*/
+      i[5]} icon`);
+        },
+        m(s, p) {
+            insert$5(s, t, p);
+        },
+        p(s, p) {
+            p & /*icon_path*/
+                2048 && !src_url_equal(t.src, n = /*icon_path*/
+                    s[11]) && attr$5(t, "src", n), p & /*value*/
+                32 && e !== (e = `${/*value*/
+      s[5]} icon`) && attr$5(t, "alt", e);
         },
         d(s) {
-            s && detach$5(e);
+            s && detach$5(t);
         }
     };
 }
 
-function create_if_block_1$3(t) {
-    let e, i, n;
+function create_if_block_1$3(i) {
+    let t, n, e;
     return {
         c() {
-            e = element$5("img"), attr$5(e, "class", "button-icon svelte-8huxfn"), src_url_equal(e.src, i = /*icon_path*/
-                t[11]) || attr$5(e, "src", i), attr$5(e, "alt", n = `${/*value*/
-      t[5]} icon`);
-        },
-        m(s, l) {
-            insert$5(s, e, l);
-        },
-        p(s, l) {
-            l & /*icon_path*/
-                2048 && !src_url_equal(e.src, i = /*icon_path*/
-                    s[11]) && attr$5(e, "src", i), l & /*value*/
-                32 && n !== (n = `${/*value*/
-      s[5]} icon`) && attr$5(e, "alt", n);
+            t = element$5("img"), attr$5(t, "class", "button-icon svelte-8huxfn"), src_url_equal(t.src, n = /*icon_path*/
+                i[11]) || attr$5(t, "src", n), attr$5(t, "alt", e = `${/*value*/
+      i[5]} icon`);
+        },
+        m(s, p) {
+            insert$5(s, t, p);
+        },
+        p(s, p) {
+            p & /*icon_path*/
+                2048 && !src_url_equal(t.src, n = /*icon_path*/
+                    s[11]) && attr$5(t, "src", n), p & /*value*/
+                32 && e !== (e = `${/*value*/
+      s[5]} icon`) && attr$5(t, "alt", e);
         },
         d(s) {
-            s && detach$5(e);
+            s && detach$5(t);
         }
     };
 }
 
-function create_fragment$5(t) {
-    let e, i, n, s;
-    const l = [create_if_block$3, create_else_block$2],
-        h = [];
+function create_fragment$5(i) {
+    let t, n, e, s;
+    const p = [create_if_block$3, create_else_block$2],
+        f = [];
 
-    function _(c, o) {
+    function A(a, h) {
         return (
             /*link*/
-            c[6] && /*link*/
-            c[6].length > 0 ? 0 : 1
+            a[6] && /*link*/
+            a[6].length > 0 ? 0 : 1
         );
     }
-    return e = _(t), i = h[e] = l[e](t), {
+    return t = A(i), n = f[t] = p[t](i), {
         c() {
-            i.c(), n = empty$2();
+            n.c(), e = empty$2();
         },
-        m(c, o) {
-            h[e].m(c, o), insert$5(c, n, o), s = !0;
+        m(a, h) {
+            f[t].m(a, h), insert$5(a, e, h), s = !0;
         },
-        p(c, [o]) {
-            let r = e;
-            e = _(c), e === r ? h[e].p(c, o) : (group_outros$3(), transition_out$4(h[r], 1, 1, () => {
-                h[r] = null;
-            }), check_outros$3(), i = h[e], i ? i.p(c, o) : (i = h[e] = l[e](c), i.c()), transition_in$4(i, 1), i.m(n.parentNode, n));
+        p(a, [h]) {
+            let o = t;
+            t = A(a), t === o ? f[t].p(a, h) : (group_outros$3(), transition_out$4(f[o], 1, 1, () => {
+                f[o] = null;
+            }), check_outros$3(), n = f[t], n ? n.p(a, h) : (n = f[t] = p[t](a), n.c()), transition_in$4(n, 1), n.m(e.parentNode, e));
         },
-        i(c) {
-            s || (transition_in$4(i), s = !0);
+        i(a) {
+            s || (transition_in$4(n), s = !0);
         },
-        o(c) {
-            transition_out$4(i), s = !1;
+        o(a) {
+            transition_out$4(n), s = !1;
         },
-        d(c) {
-            c && detach$5(n), h[e].d(c);
+        d(a) {
+            a && detach$5(e), f[t].d(a);
         }
     };
 }
 
-function instance$5(t, e, i) {
-    let n, {
+function instance$5(i, t, n) {
+    let e, {
             $$slots: s = {},
-            $$scope: l
-        } = e,
+            $$scope: p
+        } = t,
         {
-            elem_id: h = ""
-        } = e,
+            elem_id: f = ""
+        } = t,
         {
-            elem_classes: _ = []
-        } = e,
+            elem_classes: A = []
+        } = t,
         {
-            visible: c = !0
-        } = e,
+            visible: a = !0
+        } = t,
         {
-            variant: o = "secondary"
-        } = e,
+            variant: h = "secondary"
+        } = t,
         {
-            size: r = "lg"
-        } = e,
+            size: o = "lg"
+        } = t,
         {
-            value: T = null
-        } = e,
+            value: F = null
+        } = t,
         {
-            link: S = null
-        } = e,
+            link: R = null
+        } = t,
         {
             icon: w = null
-        } = e,
+        } = t,
         {
-            disabled: C = !1
-        } = e,
+            disabled: T = !1
+        } = t,
         {
             scale: P = null
-        } = e,
+        } = t,
         {
-            min_width: b = void 0
-        } = e,
+            min_width: m = void 0
+        } = t,
         {
-            root: k = ""
-        } = e,
+            root: C = ""
+        } = t,
         {
-            proxy_url: F = null
-        } = e;
+            proxy_url: x = null
+        } = t;
 
-    function x(y) {
-        bubble$1.call(this, t, y);
+    function E(S) {
+        bubble$1.call(this, i, S);
     }
-    return t.$$set = (y) => {
-        "elem_id" in y && i(0, h = y.elem_id), "elem_classes" in y && i(1, _ = y.elem_classes), "visible" in y && i(2, c = y.visible), "variant" in y && i(3, o = y.variant), "size" in y && i(4, r = y.size), "value" in y && i(5, T = y.value), "link" in y && i(6, S = y.link), "icon" in y && i(7, w = y.icon), "disabled" in y && i(8, C = y.disabled), "scale" in y && i(9, P = y.scale), "min_width" in y && i(10, b = y.min_width), "root" in y && i(12, k = y.root), "proxy_url" in y && i(13, F = y.proxy_url), "$$scope" in y && i(14, l = y.$$scope);
-    }, t.$$.update = () => {
-        t.$$.dirty & /*icon, root, proxy_url*/
-            12416 && i(11, n = get_fetchable_url_or_file$1(w, k, F));
+    return i.$$set = (S) => {
+        "elem_id" in S && n(0, f = S.elem_id), "elem_classes" in S && n(1, A = S.elem_classes), "visible" in S && n(2, a = S.visible), "variant" in S && n(3, h = S.variant), "size" in S && n(4, o = S.size), "value" in S && n(5, F = S.value), "link" in S && n(6, R = S.link), "icon" in S && n(7, w = S.icon), "disabled" in S && n(8, T = S.disabled), "scale" in S && n(9, P = S.scale), "min_width" in S && n(10, m = S.min_width), "root" in S && n(12, C = S.root), "proxy_url" in S && n(13, x = S.proxy_url), "$$scope" in S && n(14, p = S.$$scope);
+    }, i.$$.update = () => {
+        i.$$.dirty & /*icon, root, proxy_url*/
+            12416 && n(11, e = get_fetchable_url_or_file$1(w, C, x));
     }, [
+        f,
+        A,
+        a,
         h,
-        _,
-        c,
         o,
-        r,
-        T,
-        S,
+        F,
+        R,
         w,
-        C,
+        T,
         P,
-        b,
-        n,
-        k,
-        F,
-        l,
+        m,
+        e,
+        C,
+        x,
+        p,
         s,
-        x
+        E
     ];
 }
 class Button extends SvelteComponent$5 {
-    constructor(e) {
-        super(), init$5(this, e, instance$5, create_fragment$5, safe_not_equal$6, {
+    constructor(t) {
+        super(), init$5(this, t, instance$5, create_fragment$5, safe_not_equal$6, {
             elem_id: 0,
             elem_classes: 1,
             visible: 2,
             variant: 3,
             size: 4,
             value: 5,
             link: 6,
@@ -1696,1362 +1685,1339 @@
             min_width: 10,
             root: 12,
             proxy_url: 13
         });
     }
 }
 
-function pretty_si(t) {
-    let e = ["", "k", "M", "G", "T", "P", "E", "Z"],
-        i = 0;
-    for (; t > 1e3 && i < e.length - 1;)
-        t /= 1e3, i++;
-    let n = e[i];
-    return (Number.isInteger(t) ? t : t.toFixed(1)) + n;
+function pretty_si(i) {
+    let t = ["", "k", "M", "G", "T", "P", "E", "Z"],
+        n = 0;
+    for (; i > 1e3 && n < t.length - 1;)
+        i /= 1e3, n++;
+    let e = t[n];
+    return (Number.isInteger(i) ? i : i.toFixed(1)) + e;
 }
 
 function noop$2() {}
 
-function run(t) {
-    return t();
-}
-
-function run_all$1(t) {
-    t.forEach(run);
-}
-
-function is_function(t) {
-    return typeof t == "function";
-}
-
-function safe_not_equal$5(t, e) {
-    return t != t ? e == e : t !== e || t && typeof t == "object" || typeof t == "function";
-}
-
-function subscribe(t, ...e) {
-    if (t == null) {
-        for (const n of e)
-            n(void 0);
-        return noop$2;
-    }
-    const i = t.subscribe(...e);
-    return i.unsubscribe ? () => i.unsubscribe() : i;
+function safe_not_equal$5(i, t) {
+    return i != i ? t == t : i !== t || i && typeof i == "object" || typeof i == "function";
 }
 const is_client = typeof window < "u";
 let now = is_client ? () => window.performance.now() : () => Date.now(),
-    raf = is_client ? (t) => requestAnimationFrame(t) : noop$2;
+    raf = is_client ? (i) => requestAnimationFrame(i) : noop$2;
 const tasks = /* @__PURE__ */ new Set();
 
-function run_tasks(t) {
-    tasks.forEach((e) => {
-        e.c(t) || (tasks.delete(e), e.f());
+function run_tasks(i) {
+    tasks.forEach((t) => {
+        t.c(i) || (tasks.delete(t), t.f());
     }), tasks.size !== 0 && raf(run_tasks);
 }
 
-function loop(t) {
-    let e;
+function loop(i) {
+    let t;
     return tasks.size === 0 && raf(run_tasks), {
-        promise: new Promise((i) => {
-            tasks.add(e = {
-                c: t,
-                f: i
+        promise: new Promise((n) => {
+            tasks.add(t = {
+                c: i,
+                f: n
             });
         }),
         abort() {
-            tasks.delete(e);
+            tasks.delete(t);
         }
     };
 }
 const subscriber_queue = [];
 
-function readable(t, e) {
-    return {
-        subscribe: writable(t, e).subscribe
-    };
-}
-
-function writable(t, e = noop$2) {
-    let i;
-    const n = /* @__PURE__ */ new Set();
-
-    function s(_) {
-        if (safe_not_equal$5(t, _) && (t = _, i)) {
-            const c = !subscriber_queue.length;
-            for (const o of n)
-                o[1](), subscriber_queue.push(o, t);
-            if (c) {
-                for (let o = 0; o < subscriber_queue.length; o += 2)
-                    subscriber_queue[o][0](subscriber_queue[o + 1]);
+function writable(i, t = noop$2) {
+    let n;
+    const e = /* @__PURE__ */ new Set();
+
+    function s(A) {
+        if (safe_not_equal$5(i, A) && (i = A, n)) {
+            const a = !subscriber_queue.length;
+            for (const h of e)
+                h[1](), subscriber_queue.push(h, i);
+            if (a) {
+                for (let h = 0; h < subscriber_queue.length; h += 2)
+                    subscriber_queue[h][0](subscriber_queue[h + 1]);
                 subscriber_queue.length = 0;
             }
         }
     }
 
-    function l(_) {
-        s(_(t));
+    function p(A) {
+        s(A(i));
     }
 
-    function h(_, c = noop$2) {
-        const o = [_, c];
-        return n.add(o), n.size === 1 && (i = e(s, l) || noop$2), _(t), () => {
-            n.delete(o), n.size === 0 && i && (i(), i = null);
+    function f(A, a = noop$2) {
+        const h = [A, a];
+        return e.add(h), e.size === 1 && (n = t(s, p) || noop$2), A(i), () => {
+            e.delete(h), e.size === 0 && n && (n(), n = null);
         };
     }
     return {
         set: s,
-        update: l,
-        subscribe: h
+        update: p,
+        subscribe: f
     };
 }
 
-function derived(t, e, i) {
-    const n = !Array.isArray(t),
-        s = n ? [t] : t;
-    if (!s.every(Boolean))
-        throw new Error("derived() expects stores as input, got a falsy value");
-    const l = e.length < 2;
-    return readable(i, (h, _) => {
-        let c = !1;
-        const o = [];
-        let r = 0,
-            T = noop$2;
-        const S = () => {
-                if (r)
-                    return;
-                T();
-                const C = e(n ? o[0] : o, h, _);
-                l ? h(C) : T = is_function(C) ? C : noop$2;
-            },
-            w = s.map(
-                (C, P) => subscribe(
-                    C,
-                    (b) => {
-                        o[P] = b, r &= ~(1 << P), c && S();
-                    },
-                    () => {
-                        r |= 1 << P;
-                    }
-                )
-            );
-        return c = !0, S(),
-            function() {
-                run_all$1(w), T(), c = !1;
-            };
-    });
-}
-
-function is_date(t) {
-    return Object.prototype.toString.call(t) === "[object Date]";
+function is_date(i) {
+    return Object.prototype.toString.call(i) === "[object Date]";
 }
 
-function tick_spring(t, e, i, n) {
-    if (typeof i == "number" || is_date(i)) {
-        const s = n - i,
-            l = (i - e) / (t.dt || 1 / 60),
-            h = t.opts.stiffness * s,
-            _ = t.opts.damping * l,
-            c = (h - _) * t.inv_mass,
-            o = (l + c) * t.dt;
-        return Math.abs(o) < t.opts.precision && Math.abs(s) < t.opts.precision ? n : (t.settled = !1, is_date(i) ? new Date(i.getTime() + o) : i + o);
+function tick_spring(i, t, n, e) {
+    if (typeof n == "number" || is_date(n)) {
+        const s = e - n,
+            p = (n - t) / (i.dt || 1 / 60),
+            f = i.opts.stiffness * s,
+            A = i.opts.damping * p,
+            a = (f - A) * i.inv_mass,
+            h = (p + a) * i.dt;
+        return Math.abs(h) < i.opts.precision && Math.abs(s) < i.opts.precision ? e : (i.settled = !1, is_date(n) ? new Date(n.getTime() + h) : n + h);
     } else {
-        if (Array.isArray(i))
-            return i.map(
-                (s, l) => tick_spring(t, e[l], i[l], n[l])
+        if (Array.isArray(n))
+            return n.map(
+                (s, p) => tick_spring(i, t[p], n[p], e[p])
             );
-        if (typeof i == "object") {
+        if (typeof n == "object") {
             const s = {};
-            for (const l in i)
-                s[l] = tick_spring(t, e[l], i[l], n[l]);
+            for (const p in n)
+                s[p] = tick_spring(i, t[p], n[p], e[p]);
             return s;
         } else
-            throw new Error(`Cannot spring ${typeof i} values`);
+            throw new Error(`Cannot spring ${typeof n} values`);
     }
 }
 
-function spring(t, e = {}) {
-    const i = writable(t),
+function spring(i, t = {}) {
+    const n = writable(i),
         {
-            stiffness: n = 0.15,
+            stiffness: e = 0.15,
             damping: s = 0.8,
-            precision: l = 0.01
-        } = e;
-    let h, _, c, o = t,
-        r = t,
-        T = 1,
-        S = 0,
+            precision: p = 0.01
+        } = t;
+    let f, A, a, h = i,
+        o = i,
+        F = 1,
+        R = 0,
         w = !1;
 
-    function C(b, k = {}) {
-        r = b;
-        const F = c = {};
-        return t == null || k.hard || P.stiffness >= 1 && P.damping >= 1 ? (w = !0, h = now(), o = b, i.set(t = r), Promise.resolve()) : (k.soft && (S = 1 / ((k.soft === !0 ? 0.5 : +k.soft) * 60), T = 0), _ || (h = now(), w = !1, _ = loop((x) => {
+    function T(m, C = {}) {
+        o = m;
+        const x = a = {};
+        return i == null || C.hard || P.stiffness >= 1 && P.damping >= 1 ? (w = !0, f = now(), h = m, n.set(i = o), Promise.resolve()) : (C.soft && (R = 1 / ((C.soft === !0 ? 0.5 : +C.soft) * 60), F = 0), A || (f = now(), w = !1, A = loop((E) => {
             if (w)
-                return w = !1, _ = null, !1;
-            T = Math.min(T + S, 1);
-            const y = {
-                    inv_mass: T,
+                return w = !1, A = null, !1;
+            F = Math.min(F + R, 1);
+            const S = {
+                    inv_mass: F,
                     opts: P,
                     settled: !0,
-                    dt: (x - h) * 60 / 1e3
+                    dt: (E - f) * 60 / 1e3
                 },
-                p = tick_spring(y, o, t, r);
-            return h = x, o = t, i.set(t = p), y.settled && (_ = null), !y.settled;
-        })), new Promise((x) => {
-            _.promise.then(() => {
-                F === c && x();
+                g = tick_spring(S, h, i, o);
+            return f = E, h = i, n.set(i = g), S.settled && (A = null), !S.settled;
+        })), new Promise((E) => {
+            A.promise.then(() => {
+                x === a && E();
             });
         }));
     }
     const P = {
-        set: C,
-        update: (b, k) => C(b(r, t), k),
-        subscribe: i.subscribe,
-        stiffness: n,
+        set: T,
+        update: (m, C) => T(m(o, i), C),
+        subscribe: n.subscribe,
+        stiffness: e,
         damping: s,
-        precision: l
+        precision: p
     };
     return P;
 }
-const Loader_svelte_svelte_type_style_lang = "",
-    {
-        SvelteComponent: SvelteComponent$4,
-        append: append$4,
-        attr: attr$4,
-        component_subscribe,
-        detach: detach$4,
-        element: element$4,
-        init: init$4,
-        insert: insert$4,
-        noop: noop$1,
-        safe_not_equal: safe_not_equal$4,
-        set_style: set_style$3,
-        svg_element,
-        toggle_class: toggle_class$3
-    } = window.__gradio__svelte__internal,
-    {
-        onMount
-    } = window.__gradio__svelte__internal;
+const {
+    SvelteComponent: SvelteComponent$4,
+    append: append$4,
+    attr: attr$4,
+    component_subscribe,
+    detach: detach$4,
+    element: element$4,
+    init: init$4,
+    insert: insert$4,
+    noop: noop$1,
+    safe_not_equal: safe_not_equal$4,
+    set_style: set_style$3,
+    svg_element,
+    toggle_class: toggle_class$3
+} = window.__gradio__svelte__internal, {
+    onMount
+} = window.__gradio__svelte__internal;
 
-function create_fragment$4(t) {
-    let e, i, n, s, l, h, _, c, o, r, T, S;
+function create_fragment$4(i) {
+    let t, n, e, s, p, f, A, a, h, o, F, R;
     return {
         c() {
-            e = element$4("div"), i = svg_element("svg"), n = svg_element("g"), s = svg_element("path"), l = svg_element("path"), h = svg_element("path"), _ = svg_element("path"), c = svg_element("g"), o = svg_element("path"), r = svg_element("path"), T = svg_element("path"), S = svg_element("path"), attr$4(s, "d", "M255.926 0.754768L509.702 139.936V221.027L255.926 81.8465V0.754768Z"), attr$4(s, "fill", "#FF7C00"), attr$4(s, "fill-opacity", "0.4"), attr$4(s, "class", "svelte-43sxxs"), attr$4(l, "d", "M509.69 139.936L254.981 279.641V361.255L509.69 221.55V139.936Z"), attr$4(l, "fill", "#FF7C00"), attr$4(l, "class", "svelte-43sxxs"), attr$4(h, "d", "M0.250138 139.937L254.981 279.641V361.255L0.250138 221.55V139.937Z"), attr$4(h, "fill", "#FF7C00"), attr$4(h, "fill-opacity", "0.4"), attr$4(h, "class", "svelte-43sxxs"), attr$4(_, "d", "M255.923 0.232622L0.236328 139.936V221.55L255.923 81.8469V0.232622Z"), attr$4(_, "fill", "#FF7C00"), attr$4(_, "class", "svelte-43sxxs"), set_style$3(n, "transform", "translate(" + /*$top*/
-                t[1][0] + "px, " + /*$top*/
-                t[1][1] + "px)"), attr$4(o, "d", "M255.926 141.5L509.702 280.681V361.773L255.926 222.592V141.5Z"), attr$4(o, "fill", "#FF7C00"), attr$4(o, "fill-opacity", "0.4"), attr$4(o, "class", "svelte-43sxxs"), attr$4(r, "d", "M509.69 280.679L254.981 420.384V501.998L509.69 362.293V280.679Z"), attr$4(r, "fill", "#FF7C00"), attr$4(r, "class", "svelte-43sxxs"), attr$4(T, "d", "M0.250138 280.681L254.981 420.386V502L0.250138 362.295V280.681Z"), attr$4(T, "fill", "#FF7C00"), attr$4(T, "fill-opacity", "0.4"), attr$4(T, "class", "svelte-43sxxs"), attr$4(S, "d", "M255.923 140.977L0.236328 280.68V362.294L255.923 222.591V140.977Z"), attr$4(S, "fill", "#FF7C00"), attr$4(S, "class", "svelte-43sxxs"), set_style$3(c, "transform", "translate(" + /*$bottom*/
-                t[2][0] + "px, " + /*$bottom*/
-                t[2][1] + "px)"), attr$4(i, "viewBox", "-1200 -1200 3000 3000"), attr$4(i, "fill", "none"), attr$4(i, "xmlns", "http://www.w3.org/2000/svg"), attr$4(i, "class", "svelte-43sxxs"), attr$4(e, "class", "svelte-43sxxs"), toggle_class$3(
-                e,
+            t = element$4("div"), n = svg_element("svg"), e = svg_element("g"), s = svg_element("path"), p = svg_element("path"), f = svg_element("path"), A = svg_element("path"), a = svg_element("g"), h = svg_element("path"), o = svg_element("path"), F = svg_element("path"), R = svg_element("path"), attr$4(s, "d", "M255.926 0.754768L509.702 139.936V221.027L255.926 81.8465V0.754768Z"), attr$4(s, "fill", "#FF7C00"), attr$4(s, "fill-opacity", "0.4"), attr$4(s, "class", "svelte-43sxxs"), attr$4(p, "d", "M509.69 139.936L254.981 279.641V361.255L509.69 221.55V139.936Z"), attr$4(p, "fill", "#FF7C00"), attr$4(p, "class", "svelte-43sxxs"), attr$4(f, "d", "M0.250138 139.937L254.981 279.641V361.255L0.250138 221.55V139.937Z"), attr$4(f, "fill", "#FF7C00"), attr$4(f, "fill-opacity", "0.4"), attr$4(f, "class", "svelte-43sxxs"), attr$4(A, "d", "M255.923 0.232622L0.236328 139.936V221.55L255.923 81.8469V0.232622Z"), attr$4(A, "fill", "#FF7C00"), attr$4(A, "class", "svelte-43sxxs"), set_style$3(e, "transform", "translate(" + /*$top*/
+                i[1][0] + "px, " + /*$top*/
+                i[1][1] + "px)"), attr$4(h, "d", "M255.926 141.5L509.702 280.681V361.773L255.926 222.592V141.5Z"), attr$4(h, "fill", "#FF7C00"), attr$4(h, "fill-opacity", "0.4"), attr$4(h, "class", "svelte-43sxxs"), attr$4(o, "d", "M509.69 280.679L254.981 420.384V501.998L509.69 362.293V280.679Z"), attr$4(o, "fill", "#FF7C00"), attr$4(o, "class", "svelte-43sxxs"), attr$4(F, "d", "M0.250138 280.681L254.981 420.386V502L0.250138 362.295V280.681Z"), attr$4(F, "fill", "#FF7C00"), attr$4(F, "fill-opacity", "0.4"), attr$4(F, "class", "svelte-43sxxs"), attr$4(R, "d", "M255.923 140.977L0.236328 280.68V362.294L255.923 222.591V140.977Z"), attr$4(R, "fill", "#FF7C00"), attr$4(R, "class", "svelte-43sxxs"), set_style$3(a, "transform", "translate(" + /*$bottom*/
+                i[2][0] + "px, " + /*$bottom*/
+                i[2][1] + "px)"), attr$4(n, "viewBox", "-1200 -1200 3000 3000"), attr$4(n, "fill", "none"), attr$4(n, "xmlns", "http://www.w3.org/2000/svg"), attr$4(n, "class", "svelte-43sxxs"), attr$4(t, "class", "svelte-43sxxs"), toggle_class$3(
+                t,
                 "margin",
                 /*margin*/
-                t[0]
+                i[0]
             );
         },
-        m(w, C) {
-            insert$4(w, e, C), append$4(e, i), append$4(i, n), append$4(n, s), append$4(n, l), append$4(n, h), append$4(n, _), append$4(i, c), append$4(c, o), append$4(c, r), append$4(c, T), append$4(c, S);
+        m(w, T) {
+            insert$4(w, t, T), append$4(t, n), append$4(n, e), append$4(e, s), append$4(e, p), append$4(e, f), append$4(e, A), append$4(n, a), append$4(a, h), append$4(a, o), append$4(a, F), append$4(a, R);
         },
-        p(w, [C]) {
-            C & /*$top*/
-                2 && set_style$3(n, "transform", "translate(" + /*$top*/
+        p(w, [T]) {
+            T & /*$top*/
+                2 && set_style$3(e, "transform", "translate(" + /*$top*/
                     w[1][0] + "px, " + /*$top*/
-                    w[1][1] + "px)"), C & /*$bottom*/
-                4 && set_style$3(c, "transform", "translate(" + /*$bottom*/
+                    w[1][1] + "px)"), T & /*$bottom*/
+                4 && set_style$3(a, "transform", "translate(" + /*$bottom*/
                     w[2][0] + "px, " + /*$bottom*/
-                    w[2][1] + "px)"), C & /*margin*/
+                    w[2][1] + "px)"), T & /*margin*/
                 1 && toggle_class$3(
-                    e,
+                    t,
                     "margin",
                     /*margin*/
                     w[0]
                 );
         },
         i: noop$1,
         o: noop$1,
         d(w) {
-            w && detach$4(e);
+            w && detach$4(t);
         }
     };
 }
 
-function instance$4(t, e, i) {
-    let n, s, {
-        margin: l = !0
-    } = e;
-    const h = spring([0, 0]);
-    component_subscribe(t, h, (S) => i(1, n = S));
-    const _ = spring([0, 0]);
-    component_subscribe(t, _, (S) => i(2, s = S));
-    let c;
-    async function o() {
-        await Promise.all([h.set([125, 140]), _.set([-125, -140])]), await Promise.all([h.set([-125, 140]), _.set([125, -140])]), await Promise.all([h.set([-125, 0]), _.set([125, -0])]), await Promise.all([h.set([125, 0]), _.set([-125, 0])]);
+function instance$4(i, t, n) {
+    let e, s;
+    var p = this && this.__awaiter || function(w, T, P, m) {
+        function C(x) {
+            return x instanceof P ? x : new P(function(E) {
+                E(x);
+            });
+        }
+        return new(P || (P = Promise))(function(x, E) {
+            function S($) {
+                try {
+                    v(m.next($));
+                } catch (M) {
+                    E(M);
+                }
+            }
+
+            function g($) {
+                try {
+                    v(m.throw($));
+                } catch (M) {
+                    E(M);
+                }
+            }
+
+            function v($) {
+                $.done ? x($.value) : C($.value).then(S, g);
+            }
+            v((m = m.apply(w, T || [])).next());
+        });
+    };
+    let {
+        margin: f = !0
+    } = t;
+    const A = spring([0, 0]);
+    component_subscribe(i, A, (w) => n(1, e = w));
+    const a = spring([0, 0]);
+    component_subscribe(i, a, (w) => n(2, s = w));
+    let h;
+
+    function o() {
+        return p(this, void 0, void 0, function*() {
+            yield Promise.all([A.set([125, 140]), a.set([-125, -140])]), yield Promise.all([A.set([-125, 140]), a.set([125, -140])]), yield Promise.all([A.set([-125, 0]), a.set([125, -0])]), yield Promise.all([A.set([125, 0]), a.set([-125, 0])]);
+        });
     }
-    async function r() {
-        await o(), c || r();
+
+    function F() {
+        return p(this, void 0, void 0, function*() {
+            yield o(), h || F();
+        });
     }
-    async function T() {
-        await Promise.all([h.set([125, 0]), _.set([-125, 0])]), r();
+
+    function R() {
+        return p(this, void 0, void 0, function*() {
+            yield Promise.all([A.set([125, 0]), a.set([-125, 0])]), F();
+        });
     }
-    return onMount(() => (T(), () => c = !0)), t.$$set = (S) => {
-        "margin" in S && i(0, l = S.margin);
-    }, [l, n, s, h, _];
+    return onMount(() => (R(), () => h = !0)), i.$$set = (w) => {
+        "margin" in w && n(0, f = w.margin);
+    }, [f, e, s, A, a];
 }
 class Loader extends SvelteComponent$4 {
-    constructor(e) {
-        super(), init$4(this, e, instance$4, create_fragment$4, safe_not_equal$4, {
+    constructor(t) {
+        super(), init$4(this, t, instance$4, create_fragment$4, safe_not_equal$4, {
             margin: 0
         });
     }
 }
-const index_svelte_svelte_type_style_lang = "",
-    {
-        SvelteComponent: SvelteComponent$3,
-        append: append$3,
-        attr: attr$3,
-        binding_callbacks: binding_callbacks$2,
-        check_outros: check_outros$2,
-        create_component: create_component$2,
-        create_slot: create_slot$1,
-        destroy_component: destroy_component$2,
-        destroy_each,
-        detach: detach$3,
-        element: element$3,
-        empty: empty$1,
-        ensure_array_like,
-        get_all_dirty_from_scope: get_all_dirty_from_scope$1,
-        get_slot_changes: get_slot_changes$1,
-        group_outros: group_outros$2,
-        init: init$3,
-        insert: insert$3,
-        mount_component: mount_component$2,
-        noop,
-        safe_not_equal: safe_not_equal$3,
-        set_data: set_data$1,
-        set_style: set_style$2,
-        space: space$3,
-        text: text$1,
-        toggle_class: toggle_class$2,
-        transition_in: transition_in$3,
-        transition_out: transition_out$3,
-        update_slot_base: update_slot_base$1
-    } = window.__gradio__svelte__internal,
-    {
-        tick: tick$2
-    } = window.__gradio__svelte__internal,
-    {
-        onDestroy
-    } = window.__gradio__svelte__internal,
-    get_error_slot_changes = (t) => ({}),
-    get_error_slot_context = (t) => ({});
-
-function get_each_context(t, e, i) {
-    const n = t.slice();
-    return n[38] = e[i], n[40] = i, n;
-}
-
-function get_each_context_1(t, e, i) {
-    const n = t.slice();
-    return n[38] = e[i], n;
+const {
+    SvelteComponent: SvelteComponent$3,
+    append: append$3,
+    attr: attr$3,
+    binding_callbacks: binding_callbacks$2,
+    check_outros: check_outros$2,
+    create_component: create_component$2,
+    create_slot: create_slot$1,
+    destroy_component: destroy_component$2,
+    destroy_each,
+    detach: detach$3,
+    element: element$3,
+    empty: empty$1,
+    ensure_array_like,
+    get_all_dirty_from_scope: get_all_dirty_from_scope$1,
+    get_slot_changes: get_slot_changes$1,
+    group_outros: group_outros$2,
+    init: init$3,
+    insert: insert$3,
+    mount_component: mount_component$2,
+    noop,
+    safe_not_equal: safe_not_equal$3,
+    set_data: set_data$1,
+    set_style: set_style$2,
+    space: space$3,
+    text: text$1,
+    toggle_class: toggle_class$2,
+    transition_in: transition_in$3,
+    transition_out: transition_out$3,
+    update_slot_base: update_slot_base$1
+} = window.__gradio__svelte__internal, {
+    tick: tick$2
+} = window.__gradio__svelte__internal, {
+    onDestroy
+} = window.__gradio__svelte__internal, get_error_slot_changes = (i) => ({}), get_error_slot_context = (i) => ({});
+
+function get_each_context(i, t, n) {
+    const e = i.slice();
+    return e[39] = t[n], e[41] = n, e;
+}
+
+function get_each_context_1(i, t, n) {
+    const e = i.slice();
+    return e[39] = t[n], e;
 }
 
-function create_if_block_17(t) {
-    let e, i = (
+function create_if_block_17(i) {
+    let t, n = (
             /*i18n*/
-            t[1]("common.error") + ""
+            i[1]("common.error") + ""
         ),
-        n, s, l;
-    const h = (
+        e, s, p;
+    const f = (
             /*#slots*/
-            t[29].error
+            i[29].error
         ),
-        _ = create_slot$1(
-            h,
-            t,
+        A = create_slot$1(
+            f,
+            i,
             /*$$scope*/
-            t[28],
+            i[28],
             get_error_slot_context
         );
     return {
         c() {
-            e = element$3("span"), n = text$1(i), s = space$3(), _ && _.c(), attr$3(e, "class", "error svelte-14miwb5");
+            t = element$3("span"), e = text$1(n), s = space$3(), A && A.c(), attr$3(t, "class", "error svelte-14miwb5");
         },
-        m(c, o) {
-            insert$3(c, e, o), append$3(e, n), insert$3(c, s, o), _ && _.m(c, o), l = !0;
+        m(a, h) {
+            insert$3(a, t, h), append$3(t, e), insert$3(a, s, h), A && A.m(a, h), p = !0;
         },
-        p(c, o) {
-            (!l || o[0] & /*i18n*/
-                2) && i !== (i = /*i18n*/
-                c[1]("common.error") + "") && set_data$1(n, i), _ && _.p && (!l || o[0] & /*$$scope*/
+        p(a, h) {
+            (!p || h[0] & /*i18n*/
+                2) && n !== (n = /*i18n*/
+                a[1]("common.error") + "") && set_data$1(e, n), A && A.p && (!p || h[0] & /*$$scope*/
                 268435456) && update_slot_base$1(
-                _,
-                h,
-                c,
+                A,
+                f,
+                a,
                 /*$$scope*/
-                c[28],
-                l ? get_slot_changes$1(
-                    h,
+                a[28],
+                p ? get_slot_changes$1(
+                    f,
                     /*$$scope*/
-                    c[28],
-                    o,
+                    a[28],
+                    h,
                     get_error_slot_changes
                 ) : get_all_dirty_from_scope$1(
                     /*$$scope*/
-                    c[28]
+                    a[28]
                 ),
                 get_error_slot_context
             );
         },
-        i(c) {
-            l || (transition_in$3(_, c), l = !0);
+        i(a) {
+            p || (transition_in$3(A, a), p = !0);
         },
-        o(c) {
-            transition_out$3(_, c), l = !1;
+        o(a) {
+            transition_out$3(A, a), p = !1;
         },
-        d(c) {
-            c && (detach$3(e), detach$3(s)), _ && _.d(c);
+        d(a) {
+            a && (detach$3(t), detach$3(s)), A && A.d(a);
         }
     };
 }
 
-function create_if_block$2(t) {
-    let e, i, n, s, l, h, _, c, o, r = (
+function create_if_block$2(i) {
+    let t, n, e, s, p, f, A, a, h, o = (
         /*variant*/
-        t[8] === "default" && /*show_eta_bar*/
-        t[18] && /*show_progress*/
-        t[6] === "full" && create_if_block_16(t)
+        i[8] === "default" && /*show_eta_bar*/
+        i[18] && /*show_progress*/
+        i[6] === "full" && create_if_block_16(i)
     );
 
-    function T(x, y) {
+    function F(E, S) {
         if (
             /*progress*/
-            x[7]
+            E[7]
         )
             return create_if_block_11;
         if (
             /*queue_position*/
-            x[2] !== null && /*queue_size*/
-            x[3] !== void 0 && /*queue_position*/
-            x[2] >= 0
+            E[2] !== null && /*queue_size*/
+            E[3] !== void 0 && /*queue_position*/
+            E[2] >= 0
         )
             return create_if_block_14;
         if (
             /*queue_position*/
-            x[2] === 0
+            E[2] === 0
         )
             return create_if_block_15;
     }
-    let S = T(t),
-        w = S && S(t),
-        C = (
+    let R = F(i),
+        w = R && R(i),
+        T = (
             /*timer*/
-            t[5] && create_if_block_10(t)
+            i[5] && create_if_block_10(i)
         );
     const P = [create_if_block_2, create_if_block_9],
-        b = [];
+        m = [];
 
-    function k(x, y) {
+    function C(E, S) {
         return (
             /*last_progress_level*/
-            x[15] != null ? 0 : (
+            E[15] != null ? 0 : (
                 /*show_progress*/
-                x[6] === "full" ? 1 : -1
+                E[6] === "full" ? 1 : -1
             )
         );
     }
-    ~(l = k(t)) && (h = b[l] = P[l](t));
-    let F = ! /*timer*/
-        t[5] && create_if_block_1$2(t);
+    ~(p = C(i)) && (f = m[p] = P[p](i));
+    let x = ! /*timer*/
+        i[5] && create_if_block_1$2(i);
     return {
         c() {
-            r && r.c(), e = space$3(), i = element$3("div"), w && w.c(), n = space$3(), C && C.c(), s = space$3(), h && h.c(), _ = space$3(), F && F.c(), c = empty$1(), attr$3(i, "class", "progress-text svelte-14miwb5"), toggle_class$2(
-                i,
+            o && o.c(), t = space$3(), n = element$3("div"), w && w.c(), e = space$3(), T && T.c(), s = space$3(), f && f.c(), A = space$3(), x && x.c(), a = empty$1(), attr$3(n, "class", "progress-text svelte-14miwb5"), toggle_class$2(
+                n,
                 "meta-text-center",
                 /*variant*/
-                t[8] === "center"
+                i[8] === "center"
             ), toggle_class$2(
-                i,
+                n,
                 "meta-text",
                 /*variant*/
-                t[8] === "default"
+                i[8] === "default"
             );
         },
-        m(x, y) {
-            r && r.m(x, y), insert$3(x, e, y), insert$3(x, i, y), w && w.m(i, null), append$3(i, n), C && C.m(i, null), insert$3(x, s, y), ~l && b[l].m(x, y), insert$3(x, _, y), F && F.m(x, y), insert$3(x, c, y), o = !0;
+        m(E, S) {
+            o && o.m(E, S), insert$3(E, t, S), insert$3(E, n, S), w && w.m(n, null), append$3(n, e), T && T.m(n, null), insert$3(E, s, S), ~p && m[p].m(E, S), insert$3(E, A, S), x && x.m(E, S), insert$3(E, a, S), h = !0;
         },
-        p(x, y) {
+        p(E, S) {
             /*variant*/
-            x[8] === "default" && /*show_eta_bar*/
-                x[18] && /*show_progress*/
-                x[6] === "full" ? r ? r.p(x, y) : (r = create_if_block_16(x), r.c(), r.m(e.parentNode, e)) : r && (r.d(1), r = null), S === (S = T(x)) && w ? w.p(x, y) : (w && w.d(1), w = S && S(x), w && (w.c(), w.m(i, n))), /*timer*/
-                x[5] ? C ? C.p(x, y) : (C = create_if_block_10(x), C.c(), C.m(i, null)) : C && (C.d(1), C = null), (!o || y[0] & /*variant*/
+            E[8] === "default" && /*show_eta_bar*/
+                E[18] && /*show_progress*/
+                E[6] === "full" ? o ? o.p(E, S) : (o = create_if_block_16(E), o.c(), o.m(t.parentNode, t)) : o && (o.d(1), o = null), R === (R = F(E)) && w ? w.p(E, S) : (w && w.d(1), w = R && R(E), w && (w.c(), w.m(n, e))), /*timer*/
+                E[5] ? T ? T.p(E, S) : (T = create_if_block_10(E), T.c(), T.m(n, null)) : T && (T.d(1), T = null), (!h || S[0] & /*variant*/
                     256) && toggle_class$2(
-                    i,
+                    n,
                     "meta-text-center",
                     /*variant*/
-                    x[8] === "center"
-                ), (!o || y[0] & /*variant*/
+                    E[8] === "center"
+                ), (!h || S[0] & /*variant*/
                     256) && toggle_class$2(
-                    i,
+                    n,
                     "meta-text",
                     /*variant*/
-                    x[8] === "default"
+                    E[8] === "default"
                 );
-            let p = l;
-            l = k(x), l === p ? ~l && b[l].p(x, y) : (h && (group_outros$2(), transition_out$3(b[p], 1, 1, () => {
-                    b[p] = null;
-                }), check_outros$2()), ~l ? (h = b[l], h ? h.p(x, y) : (h = b[l] = P[l](x), h.c()), transition_in$3(h, 1), h.m(_.parentNode, _)) : h = null), /*timer*/
-                x[5] ? F && (F.d(1), F = null) : F ? F.p(x, y) : (F = create_if_block_1$2(x), F.c(), F.m(c.parentNode, c));
+            let g = p;
+            p = C(E), p === g ? ~p && m[p].p(E, S) : (f && (group_outros$2(), transition_out$3(m[g], 1, 1, () => {
+                    m[g] = null;
+                }), check_outros$2()), ~p ? (f = m[p], f ? f.p(E, S) : (f = m[p] = P[p](E), f.c()), transition_in$3(f, 1), f.m(A.parentNode, A)) : f = null), /*timer*/
+                E[5] ? x && (x.d(1), x = null) : x ? x.p(E, S) : (x = create_if_block_1$2(E), x.c(), x.m(a.parentNode, a));
         },
-        i(x) {
-            o || (transition_in$3(h), o = !0);
+        i(E) {
+            h || (transition_in$3(f), h = !0);
         },
-        o(x) {
-            transition_out$3(h), o = !1;
+        o(E) {
+            transition_out$3(f), h = !1;
         },
-        d(x) {
-            x && (detach$3(e), detach$3(i), detach$3(s), detach$3(_), detach$3(c)), r && r.d(x), w && w.d(), C && C.d(), ~l && b[l].d(x), F && F.d(x);
+        d(E) {
+            E && (detach$3(t), detach$3(n), detach$3(s), detach$3(A), detach$3(a)), o && o.d(E), w && w.d(), T && T.d(), ~p && m[p].d(E), x && x.d(E);
         }
     };
 }
 
-function create_if_block_16(t) {
-    let e, i = `translateX(${/*eta_level*/
-  (t[17] || 0) * 100 - 100}%)`;
+function create_if_block_16(i) {
+    let t, n = `translateX(${/*eta_level*/
+  (i[17] || 0) * 100 - 100}%)`;
     return {
         c() {
-            e = element$3("div"), attr$3(e, "class", "eta-bar svelte-14miwb5"), set_style$2(e, "transform", i);
+            t = element$3("div"), attr$3(t, "class", "eta-bar svelte-14miwb5"), set_style$2(t, "transform", n);
         },
-        m(n, s) {
-            insert$3(n, e, s);
+        m(e, s) {
+            insert$3(e, t, s);
         },
-        p(n, s) {
+        p(e, s) {
             s[0] & /*eta_level*/
-                131072 && i !== (i = `translateX(${/*eta_level*/
-      (n[17] || 0) * 100 - 100}%)`) && set_style$2(e, "transform", i);
+                131072 && n !== (n = `translateX(${/*eta_level*/
+      (e[17] || 0) * 100 - 100}%)`) && set_style$2(t, "transform", n);
         },
-        d(n) {
-            n && detach$3(e);
+        d(e) {
+            e && detach$3(t);
         }
     };
 }
 
-function create_if_block_15(t) {
-    let e;
+function create_if_block_15(i) {
+    let t;
     return {
         c() {
-            e = text$1("processing |");
+            t = text$1("processing |");
         },
-        m(i, n) {
-            insert$3(i, e, n);
+        m(n, e) {
+            insert$3(n, t, e);
         },
         p: noop,
-        d(i) {
-            i && detach$3(e);
+        d(n) {
+            n && detach$3(t);
         }
     };
 }
 
-function create_if_block_14(t) {
-    let e, i = (
+function create_if_block_14(i) {
+    let t, n = (
             /*queue_position*/
-            t[2] + 1 + ""
+            i[2] + 1 + ""
         ),
-        n, s, l, h;
+        e, s, p, f;
     return {
         c() {
-            e = text$1("queue: "), n = text$1(i), s = text$1("/"), l = text$1(
+            t = text$1("queue: "), e = text$1(n), s = text$1("/"), p = text$1(
                 /*queue_size*/
-                t[3]
-            ), h = text$1(" |");
+                i[3]
+            ), f = text$1(" |");
         },
-        m(_, c) {
-            insert$3(_, e, c), insert$3(_, n, c), insert$3(_, s, c), insert$3(_, l, c), insert$3(_, h, c);
+        m(A, a) {
+            insert$3(A, t, a), insert$3(A, e, a), insert$3(A, s, a), insert$3(A, p, a), insert$3(A, f, a);
         },
-        p(_, c) {
-            c[0] & /*queue_position*/
-                4 && i !== (i = /*queue_position*/
-                    _[2] + 1 + "") && set_data$1(n, i), c[0] & /*queue_size*/
+        p(A, a) {
+            a[0] & /*queue_position*/
+                4 && n !== (n = /*queue_position*/
+                    A[2] + 1 + "") && set_data$1(e, n), a[0] & /*queue_size*/
                 8 && set_data$1(
-                    l,
+                    p,
                     /*queue_size*/
-                    _[3]
+                    A[3]
                 );
         },
-        d(_) {
-            _ && (detach$3(e), detach$3(n), detach$3(s), detach$3(l), detach$3(h));
+        d(A) {
+            A && (detach$3(t), detach$3(e), detach$3(s), detach$3(p), detach$3(f));
         }
     };
 }
 
-function create_if_block_11(t) {
-    let e, i = ensure_array_like(
+function create_if_block_11(i) {
+    let t, n = ensure_array_like(
             /*progress*/
-            t[7]
+            i[7]
         ),
-        n = [];
-    for (let s = 0; s < i.length; s += 1)
-        n[s] = create_each_block_1(get_each_context_1(t, i, s));
+        e = [];
+    for (let s = 0; s < n.length; s += 1)
+        e[s] = create_each_block_1(get_each_context_1(i, n, s));
     return {
         c() {
-            for (let s = 0; s < n.length; s += 1)
-                n[s].c();
-            e = empty$1();
-        },
-        m(s, l) {
-            for (let h = 0; h < n.length; h += 1)
-                n[h] && n[h].m(s, l);
-            insert$3(s, e, l);
+            for (let s = 0; s < e.length; s += 1)
+                e[s].c();
+            t = empty$1();
+        },
+        m(s, p) {
+            for (let f = 0; f < e.length; f += 1)
+                e[f] && e[f].m(s, p);
+            insert$3(s, t, p);
         },
-        p(s, l) {
-            if (l[0] & /*progress*/
+        p(s, p) {
+            if (p[0] & /*progress*/
                 128) {
-                i = ensure_array_like(
+                n = ensure_array_like(
                     /*progress*/
                     s[7]
                 );
-                let h;
-                for (h = 0; h < i.length; h += 1) {
-                    const _ = get_each_context_1(s, i, h);
-                    n[h] ? n[h].p(_, l) : (n[h] = create_each_block_1(_), n[h].c(), n[h].m(e.parentNode, e));
+                let f;
+                for (f = 0; f < n.length; f += 1) {
+                    const A = get_each_context_1(s, n, f);
+                    e[f] ? e[f].p(A, p) : (e[f] = create_each_block_1(A), e[f].c(), e[f].m(t.parentNode, t));
                 }
-                for (; h < n.length; h += 1)
-                    n[h].d(1);
-                n.length = i.length;
+                for (; f < e.length; f += 1)
+                    e[f].d(1);
+                e.length = n.length;
             }
         },
         d(s) {
-            s && detach$3(e), destroy_each(n, s);
+            s && detach$3(t), destroy_each(e, s);
         }
     };
 }
 
-function create_if_block_12(t) {
-    let e, i = (
+function create_if_block_12(i) {
+    let t, n = (
             /*p*/
-            t[38].unit + ""
+            i[39].unit + ""
         ),
-        n, s, l = " ",
-        h;
+        e, s, p = " ",
+        f;
 
-    function _(r, T) {
+    function A(o, F) {
         return (
             /*p*/
-            r[38].length != null ? create_if_block_13 : create_else_block$1
+            o[39].length != null ? create_if_block_13 : create_else_block$1
         );
     }
-    let c = _(t),
-        o = c(t);
+    let a = A(i),
+        h = a(i);
     return {
         c() {
-            o.c(), e = space$3(), n = text$1(i), s = text$1(" | "), h = text$1(l);
+            h.c(), t = space$3(), e = text$1(n), s = text$1(" | "), f = text$1(p);
         },
-        m(r, T) {
-            o.m(r, T), insert$3(r, e, T), insert$3(r, n, T), insert$3(r, s, T), insert$3(r, h, T);
+        m(o, F) {
+            h.m(o, F), insert$3(o, t, F), insert$3(o, e, F), insert$3(o, s, F), insert$3(o, f, F);
         },
-        p(r, T) {
-            c === (c = _(r)) && o ? o.p(r, T) : (o.d(1), o = c(r), o && (o.c(), o.m(e.parentNode, e))), T[0] & /*progress*/
-                128 && i !== (i = /*p*/
-                    r[38].unit + "") && set_data$1(n, i);
+        p(o, F) {
+            a === (a = A(o)) && h ? h.p(o, F) : (h.d(1), h = a(o), h && (h.c(), h.m(t.parentNode, t))), F[0] & /*progress*/
+                128 && n !== (n = /*p*/
+                    o[39].unit + "") && set_data$1(e, n);
         },
-        d(r) {
-            r && (detach$3(e), detach$3(n), detach$3(s), detach$3(h)), o.d(r);
+        d(o) {
+            o && (detach$3(t), detach$3(e), detach$3(s), detach$3(f)), h.d(o);
         }
     };
 }
 
-function create_else_block$1(t) {
-    let e = pretty_si(
+function create_else_block$1(i) {
+    let t = pretty_si(
             /*p*/
-            t[38].index || 0
+            i[39].index || 0
         ) + "",
-        i;
+        n;
     return {
         c() {
-            i = text$1(e);
+            n = text$1(t);
         },
-        m(n, s) {
-            insert$3(n, i, s);
+        m(e, s) {
+            insert$3(e, n, s);
         },
-        p(n, s) {
+        p(e, s) {
             s[0] & /*progress*/
-                128 && e !== (e = pretty_si(
+                128 && t !== (t = pretty_si(
                     /*p*/
-                    n[38].index || 0
-                ) + "") && set_data$1(i, e);
+                    e[39].index || 0
+                ) + "") && set_data$1(n, t);
         },
-        d(n) {
-            n && detach$3(i);
+        d(e) {
+            e && detach$3(n);
         }
     };
 }
 
-function create_if_block_13(t) {
-    let e = pretty_si(
+function create_if_block_13(i) {
+    let t = pretty_si(
             /*p*/
-            t[38].index || 0
+            i[39].index || 0
         ) + "",
-        i, n, s = pretty_si(
+        n, e, s = pretty_si(
             /*p*/
-            t[38].length
+            i[39].length
         ) + "",
-        l;
+        p;
     return {
         c() {
-            i = text$1(e), n = text$1("/"), l = text$1(s);
+            n = text$1(t), e = text$1("/"), p = text$1(s);
         },
-        m(h, _) {
-            insert$3(h, i, _), insert$3(h, n, _), insert$3(h, l, _);
+        m(f, A) {
+            insert$3(f, n, A), insert$3(f, e, A), insert$3(f, p, A);
         },
-        p(h, _) {
-            _[0] & /*progress*/
-                128 && e !== (e = pretty_si(
+        p(f, A) {
+            A[0] & /*progress*/
+                128 && t !== (t = pretty_si(
                     /*p*/
-                    h[38].index || 0
-                ) + "") && set_data$1(i, e), _[0] & /*progress*/
+                    f[39].index || 0
+                ) + "") && set_data$1(n, t), A[0] & /*progress*/
                 128 && s !== (s = pretty_si(
                     /*p*/
-                    h[38].length
-                ) + "") && set_data$1(l, s);
+                    f[39].length
+                ) + "") && set_data$1(p, s);
         },
-        d(h) {
-            h && (detach$3(i), detach$3(n), detach$3(l));
+        d(f) {
+            f && (detach$3(n), detach$3(e), detach$3(p));
         }
     };
 }
 
-function create_each_block_1(t) {
-    let e, i = (
+function create_each_block_1(i) {
+    let t, n = (
         /*p*/
-        t[38].index != null && create_if_block_12(t)
+        i[39].index != null && create_if_block_12(i)
     );
     return {
         c() {
-            i && i.c(), e = empty$1();
+            n && n.c(), t = empty$1();
         },
-        m(n, s) {
-            i && i.m(n, s), insert$3(n, e, s);
+        m(e, s) {
+            n && n.m(e, s), insert$3(e, t, s);
         },
-        p(n, s) {
+        p(e, s) {
             /*p*/
-            n[38].index != null ? i ? i.p(n, s) : (i = create_if_block_12(n), i.c(), i.m(e.parentNode, e)) : i && (i.d(1), i = null);
+            e[39].index != null ? n ? n.p(e, s) : (n = create_if_block_12(e), n.c(), n.m(t.parentNode, t)) : n && (n.d(1), n = null);
         },
-        d(n) {
-            n && detach$3(e), i && i.d(n);
+        d(e) {
+            e && detach$3(t), n && n.d(e);
         }
     };
 }
 
-function create_if_block_10(t) {
-    let e, i = (
+function create_if_block_10(i) {
+    let t, n = (
             /*eta*/
-            t[0] ? `/${/*formatted_eta*/
-    t[19]}` : ""
+            i[0] ? `/${/*formatted_eta*/
+    i[19]}` : ""
         ),
-        n, s;
+        e, s;
     return {
         c() {
-            e = text$1(
+            t = text$1(
                 /*formatted_timer*/
-                t[20]
-            ), n = text$1(i), s = text$1("s");
+                i[20]
+            ), e = text$1(n), s = text$1("s");
         },
-        m(l, h) {
-            insert$3(l, e, h), insert$3(l, n, h), insert$3(l, s, h);
+        m(p, f) {
+            insert$3(p, t, f), insert$3(p, e, f), insert$3(p, s, f);
         },
-        p(l, h) {
-            h[0] & /*formatted_timer*/
+        p(p, f) {
+            f[0] & /*formatted_timer*/
                 1048576 && set_data$1(
-                    e,
+                    t,
                     /*formatted_timer*/
-                    l[20]
-                ), h[0] & /*eta, formatted_eta*/
-                524289 && i !== (i = /*eta*/
-                    l[0] ? `/${/*formatted_eta*/
-      l[19]}` : "") && set_data$1(n, i);
+                    p[20]
+                ), f[0] & /*eta, formatted_eta*/
+                524289 && n !== (n = /*eta*/
+                    p[0] ? `/${/*formatted_eta*/
+      p[19]}` : "") && set_data$1(e, n);
         },
-        d(l) {
-            l && (detach$3(e), detach$3(n), detach$3(s));
+        d(p) {
+            p && (detach$3(t), detach$3(e), detach$3(s));
         }
     };
 }
 
-function create_if_block_9(t) {
-    let e, i;
-    return e = new Loader({
+function create_if_block_9(i) {
+    let t, n;
+    return t = new Loader({
         props: {
             margin: (
                 /*variant*/
-                t[8] === "default"
+                i[8] === "default"
             )
         }
     }), {
         c() {
-            create_component$2(e.$$.fragment);
+            create_component$2(t.$$.fragment);
         },
-        m(n, s) {
-            mount_component$2(e, n, s), i = !0;
+        m(e, s) {
+            mount_component$2(t, e, s), n = !0;
         },
-        p(n, s) {
-            const l = {};
+        p(e, s) {
+            const p = {};
             s[0] & /*variant*/
-                256 && (l.margin = /*variant*/
-                    n[8] === "default"), e.$set(l);
+                256 && (p.margin = /*variant*/
+                    e[8] === "default"), t.$set(p);
         },
-        i(n) {
-            i || (transition_in$3(e.$$.fragment, n), i = !0);
+        i(e) {
+            n || (transition_in$3(t.$$.fragment, e), n = !0);
         },
-        o(n) {
-            transition_out$3(e.$$.fragment, n), i = !1;
+        o(e) {
+            transition_out$3(t.$$.fragment, e), n = !1;
         },
-        d(n) {
-            destroy_component$2(e, n);
+        d(e) {
+            destroy_component$2(t, e);
         }
     };
 }
 
-function create_if_block_2(t) {
-    let e, i, n, s, l, h = `${/*last_progress_level*/
-  t[15] * 100}%`,
-        _ = (
+function create_if_block_2(i) {
+    let t, n, e, s, p, f = `${/*last_progress_level*/
+  i[15] * 100}%`,
+        A = (
             /*progress*/
-            t[7] != null && create_if_block_3(t)
+            i[7] != null && create_if_block_3(i)
         );
     return {
         c() {
-            e = element$3("div"), i = element$3("div"), _ && _.c(), n = space$3(), s = element$3("div"), l = element$3("div"), attr$3(i, "class", "progress-level-inner svelte-14miwb5"), attr$3(l, "class", "progress-bar svelte-14miwb5"), set_style$2(l, "width", h), attr$3(s, "class", "progress-bar-wrap svelte-14miwb5"), attr$3(e, "class", "progress-level svelte-14miwb5");
+            t = element$3("div"), n = element$3("div"), A && A.c(), e = space$3(), s = element$3("div"), p = element$3("div"), attr$3(n, "class", "progress-level-inner svelte-14miwb5"), attr$3(p, "class", "progress-bar svelte-14miwb5"), set_style$2(p, "width", f), attr$3(s, "class", "progress-bar-wrap svelte-14miwb5"), attr$3(t, "class", "progress-level svelte-14miwb5");
         },
-        m(c, o) {
-            insert$3(c, e, o), append$3(e, i), _ && _.m(i, null), append$3(e, n), append$3(e, s), append$3(s, l), t[30](l);
+        m(a, h) {
+            insert$3(a, t, h), append$3(t, n), A && A.m(n, null), append$3(t, e), append$3(t, s), append$3(s, p), i[30](p);
         },
-        p(c, o) {
+        p(a, h) {
             /*progress*/
-            c[7] != null ? _ ? _.p(c, o) : (_ = create_if_block_3(c), _.c(), _.m(i, null)) : _ && (_.d(1), _ = null), o[0] & /*last_progress_level*/
-                32768 && h !== (h = `${/*last_progress_level*/
-      c[15] * 100}%`) && set_style$2(l, "width", h);
+            a[7] != null ? A ? A.p(a, h) : (A = create_if_block_3(a), A.c(), A.m(n, null)) : A && (A.d(1), A = null), h[0] & /*last_progress_level*/
+                32768 && f !== (f = `${/*last_progress_level*/
+      a[15] * 100}%`) && set_style$2(p, "width", f);
         },
         i: noop,
         o: noop,
-        d(c) {
-            c && detach$3(e), _ && _.d(), t[30](null);
+        d(a) {
+            a && detach$3(t), A && A.d(), i[30](null);
         }
     };
 }
 
-function create_if_block_3(t) {
-    let e, i = ensure_array_like(
+function create_if_block_3(i) {
+    let t, n = ensure_array_like(
             /*progress*/
-            t[7]
+            i[7]
         ),
-        n = [];
-    for (let s = 0; s < i.length; s += 1)
-        n[s] = create_each_block(get_each_context(t, i, s));
+        e = [];
+    for (let s = 0; s < n.length; s += 1)
+        e[s] = create_each_block(get_each_context(i, n, s));
     return {
         c() {
-            for (let s = 0; s < n.length; s += 1)
-                n[s].c();
-            e = empty$1();
-        },
-        m(s, l) {
-            for (let h = 0; h < n.length; h += 1)
-                n[h] && n[h].m(s, l);
-            insert$3(s, e, l);
+            for (let s = 0; s < e.length; s += 1)
+                e[s].c();
+            t = empty$1();
+        },
+        m(s, p) {
+            for (let f = 0; f < e.length; f += 1)
+                e[f] && e[f].m(s, p);
+            insert$3(s, t, p);
         },
-        p(s, l) {
-            if (l[0] & /*progress_level, progress*/
+        p(s, p) {
+            if (p[0] & /*progress_level, progress*/
                 16512) {
-                i = ensure_array_like(
+                n = ensure_array_like(
                     /*progress*/
                     s[7]
                 );
-                let h;
-                for (h = 0; h < i.length; h += 1) {
-                    const _ = get_each_context(s, i, h);
-                    n[h] ? n[h].p(_, l) : (n[h] = create_each_block(_), n[h].c(), n[h].m(e.parentNode, e));
+                let f;
+                for (f = 0; f < n.length; f += 1) {
+                    const A = get_each_context(s, n, f);
+                    e[f] ? e[f].p(A, p) : (e[f] = create_each_block(A), e[f].c(), e[f].m(t.parentNode, t));
                 }
-                for (; h < n.length; h += 1)
-                    n[h].d(1);
-                n.length = i.length;
+                for (; f < e.length; f += 1)
+                    e[f].d(1);
+                e.length = n.length;
             }
         },
         d(s) {
-            s && detach$3(e), destroy_each(n, s);
+            s && detach$3(t), destroy_each(e, s);
         }
     };
 }
 
-function create_if_block_4(t) {
-    let e, i, n, s, l = (
+function create_if_block_4(i) {
+    let t, n, e, s, p = (
             /*i*/
-            t[40] !== 0 && create_if_block_8()
+            i[41] !== 0 && create_if_block_8()
         ),
-        h = (
+        f = (
             /*p*/
-            t[38].desc != null && create_if_block_7(t)
+            i[39].desc != null && create_if_block_7(i)
         ),
-        _ = (
+        A = (
             /*p*/
-            t[38].desc != null && /*progress_level*/
-            t[14] && /*progress_level*/
-            t[14][
+            i[39].desc != null && /*progress_level*/
+            i[14] && /*progress_level*/
+            i[14][
                 /*i*/
-                t[40]
+                i[41]
             ] != null && create_if_block_6()
         ),
-        c = (
+        a = (
             /*progress_level*/
-            t[14] != null && create_if_block_5(t)
+            i[14] != null && create_if_block_5(i)
         );
     return {
         c() {
-            l && l.c(), e = space$3(), h && h.c(), i = space$3(), _ && _.c(), n = space$3(), c && c.c(), s = empty$1();
+            p && p.c(), t = space$3(), f && f.c(), n = space$3(), A && A.c(), e = space$3(), a && a.c(), s = empty$1();
         },
-        m(o, r) {
-            l && l.m(o, r), insert$3(o, e, r), h && h.m(o, r), insert$3(o, i, r), _ && _.m(o, r), insert$3(o, n, r), c && c.m(o, r), insert$3(o, s, r);
+        m(h, o) {
+            p && p.m(h, o), insert$3(h, t, o), f && f.m(h, o), insert$3(h, n, o), A && A.m(h, o), insert$3(h, e, o), a && a.m(h, o), insert$3(h, s, o);
         },
-        p(o, r) {
+        p(h, o) {
             /*p*/
-            o[38].desc != null ? h ? h.p(o, r) : (h = create_if_block_7(o), h.c(), h.m(i.parentNode, i)) : h && (h.d(1), h = null), /*p*/
-                o[38].desc != null && /*progress_level*/
-                o[14] && /*progress_level*/
-                o[14][
+            h[39].desc != null ? f ? f.p(h, o) : (f = create_if_block_7(h), f.c(), f.m(n.parentNode, n)) : f && (f.d(1), f = null), /*p*/
+                h[39].desc != null && /*progress_level*/
+                h[14] && /*progress_level*/
+                h[14][
                     /*i*/
-                    o[40]
-                ] != null ? _ || (_ = create_if_block_6(), _.c(), _.m(n.parentNode, n)) : _ && (_.d(1), _ = null), /*progress_level*/
-                o[14] != null ? c ? c.p(o, r) : (c = create_if_block_5(o), c.c(), c.m(s.parentNode, s)) : c && (c.d(1), c = null);
+                    h[41]
+                ] != null ? A || (A = create_if_block_6(), A.c(), A.m(e.parentNode, e)) : A && (A.d(1), A = null), /*progress_level*/
+                h[14] != null ? a ? a.p(h, o) : (a = create_if_block_5(h), a.c(), a.m(s.parentNode, s)) : a && (a.d(1), a = null);
         },
-        d(o) {
-            o && (detach$3(e), detach$3(i), detach$3(n), detach$3(s)), l && l.d(o), h && h.d(o), _ && _.d(o), c && c.d(o);
+        d(h) {
+            h && (detach$3(t), detach$3(n), detach$3(e), detach$3(s)), p && p.d(h), f && f.d(h), A && A.d(h), a && a.d(h);
         }
     };
 }
 
-function create_if_block_8(t) {
-    let e;
+function create_if_block_8(i) {
+    let t;
     return {
         c() {
-            e = text$1(" /");
+            t = text$1(" /");
         },
-        m(i, n) {
-            insert$3(i, e, n);
+        m(n, e) {
+            insert$3(n, t, e);
         },
-        d(i) {
-            i && detach$3(e);
+        d(n) {
+            n && detach$3(t);
         }
     };
 }
 
-function create_if_block_7(t) {
-    let e = (
+function create_if_block_7(i) {
+    let t = (
             /*p*/
-            t[38].desc + ""
+            i[39].desc + ""
         ),
-        i;
+        n;
     return {
         c() {
-            i = text$1(e);
+            n = text$1(t);
         },
-        m(n, s) {
-            insert$3(n, i, s);
+        m(e, s) {
+            insert$3(e, n, s);
         },
-        p(n, s) {
+        p(e, s) {
             s[0] & /*progress*/
-                128 && e !== (e = /*p*/
-                    n[38].desc + "") && set_data$1(i, e);
+                128 && t !== (t = /*p*/
+                    e[39].desc + "") && set_data$1(n, t);
         },
-        d(n) {
-            n && detach$3(i);
+        d(e) {
+            e && detach$3(n);
         }
     };
 }
 
-function create_if_block_6(t) {
-    let e;
+function create_if_block_6(i) {
+    let t;
     return {
         c() {
-            e = text$1("-");
+            t = text$1("-");
         },
-        m(i, n) {
-            insert$3(i, e, n);
+        m(n, e) {
+            insert$3(n, t, e);
         },
-        d(i) {
-            i && detach$3(e);
+        d(n) {
+            n && detach$3(t);
         }
     };
 }
 
-function create_if_block_5(t) {
-    let e = (100 * /*progress_level*/
-            (t[14][
+function create_if_block_5(i) {
+    let t = (100 * /*progress_level*/
+            (i[14][
                 /*i*/
-                t[40]
+                i[41]
             ] || 0)).toFixed(1) + "",
-        i, n;
+        n, e;
     return {
         c() {
-            i = text$1(e), n = text$1("%");
+            n = text$1(t), e = text$1("%");
         },
-        m(s, l) {
-            insert$3(s, i, l), insert$3(s, n, l);
+        m(s, p) {
+            insert$3(s, n, p), insert$3(s, e, p);
         },
-        p(s, l) {
-            l[0] & /*progress_level*/
-                16384 && e !== (e = (100 * /*progress_level*/
+        p(s, p) {
+            p[0] & /*progress_level*/
+                16384 && t !== (t = (100 * /*progress_level*/
                     (s[14][
                         /*i*/
-                        s[40]
-                    ] || 0)).toFixed(1) + "") && set_data$1(i, e);
+                        s[41]
+                    ] || 0)).toFixed(1) + "") && set_data$1(n, t);
         },
         d(s) {
-            s && (detach$3(i), detach$3(n));
+            s && (detach$3(n), detach$3(e));
         }
     };
 }
 
-function create_each_block(t) {
-    let e, i = (
+function create_each_block(i) {
+    let t, n = (
         /*p*/
-        (t[38].desc != null || /*progress_level*/
-            t[14] && /*progress_level*/
-            t[14][
+        (i[39].desc != null || /*progress_level*/
+            i[14] && /*progress_level*/
+            i[14][
                 /*i*/
-                t[40]
-            ] != null) && create_if_block_4(t)
+                i[41]
+            ] != null) && create_if_block_4(i)
     );
     return {
         c() {
-            i && i.c(), e = empty$1();
+            n && n.c(), t = empty$1();
         },
-        m(n, s) {
-            i && i.m(n, s), insert$3(n, e, s);
+        m(e, s) {
+            n && n.m(e, s), insert$3(e, t, s);
         },
-        p(n, s) {
+        p(e, s) {
             /*p*/
-            n[38].desc != null || /*progress_level*/
-                n[14] && /*progress_level*/
-                n[14][
+            e[39].desc != null || /*progress_level*/
+                e[14] && /*progress_level*/
+                e[14][
                     /*i*/
-                    n[40]
-                ] != null ? i ? i.p(n, s) : (i = create_if_block_4(n), i.c(), i.m(e.parentNode, e)) : i && (i.d(1), i = null);
+                    e[41]
+                ] != null ? n ? n.p(e, s) : (n = create_if_block_4(e), n.c(), n.m(t.parentNode, t)) : n && (n.d(1), n = null);
         },
-        d(n) {
-            n && detach$3(e), i && i.d(n);
+        d(e) {
+            e && detach$3(t), n && n.d(e);
         }
     };
 }
 
-function create_if_block_1$2(t) {
-    let e, i;
+function create_if_block_1$2(i) {
+    let t, n;
     return {
         c() {
-            e = element$3("p"), i = text$1(
+            t = element$3("p"), n = text$1(
                 /*loading_text*/
-                t[9]
-            ), attr$3(e, "class", "loading svelte-14miwb5");
+                i[9]
+            ), attr$3(t, "class", "loading svelte-14miwb5");
         },
-        m(n, s) {
-            insert$3(n, e, s), append$3(e, i);
+        m(e, s) {
+            insert$3(e, t, s), append$3(t, n);
         },
-        p(n, s) {
+        p(e, s) {
             s[0] & /*loading_text*/
                 512 && set_data$1(
-                    i,
+                    n,
                     /*loading_text*/
-                    n[9]
+                    e[9]
                 );
         },
-        d(n) {
-            n && detach$3(e);
+        d(e) {
+            e && detach$3(t);
         }
     };
 }
 
-function create_fragment$3(t) {
-    let e, i, n, s, l;
-    const h = [create_if_block$2, create_if_block_17],
-        _ = [];
+function create_fragment$3(i) {
+    let t, n, e, s, p;
+    const f = [create_if_block$2, create_if_block_17],
+        A = [];
 
-    function c(o, r) {
+    function a(h, o) {
         return (
             /*status*/
-            o[4] === "pending" ? 0 : (
+            h[4] === "pending" ? 0 : (
                 /*status*/
-                o[4] === "error" ? 1 : -1
+                h[4] === "error" ? 1 : -1
             )
         );
     }
-    return ~(i = c(t)) && (n = _[i] = h[i](t)), {
+    return ~(n = a(i)) && (e = A[n] = f[n](i)), {
         c() {
-            e = element$3("div"), n && n.c(), attr$3(e, "class", s = "wrap " + /*variant*/
-                t[8] + " " + /*show_progress*/
-                t[6] + " svelte-14miwb5"), toggle_class$2(e, "hide", ! /*status*/
-                t[4] || /*status*/
-                t[4] === "complete" || /*show_progress*/
-                t[6] === "hidden"), toggle_class$2(
-                e,
+            t = element$3("div"), e && e.c(), attr$3(t, "class", s = "wrap " + /*variant*/
+                i[8] + " " + /*show_progress*/
+                i[6] + " svelte-14miwb5"), toggle_class$2(t, "hide", ! /*status*/
+                i[4] || /*status*/
+                i[4] === "complete" || /*show_progress*/
+                i[6] === "hidden"), toggle_class$2(
+                t,
                 "translucent",
                 /*variant*/
-                t[8] === "center" && /*status*/
-                (t[4] === "pending" || /*status*/
-                    t[4] === "error") || /*translucent*/
-                t[11] || /*show_progress*/
-                t[6] === "minimal"
+                i[8] === "center" && /*status*/
+                (i[4] === "pending" || /*status*/
+                    i[4] === "error") || /*translucent*/
+                i[11] || /*show_progress*/
+                i[6] === "minimal"
             ), toggle_class$2(
-                e,
+                t,
                 "generating",
                 /*status*/
-                t[4] === "generating"
+                i[4] === "generating"
             ), toggle_class$2(
-                e,
+                t,
                 "border",
                 /*border*/
-                t[12]
+                i[12]
             ), set_style$2(
-                e,
+                t,
                 "position",
                 /*absolute*/
-                t[10] ? "absolute" : "static"
+                i[10] ? "absolute" : "static"
             ), set_style$2(
-                e,
+                t,
                 "padding",
                 /*absolute*/
-                t[10] ? "0" : "var(--size-8) 0"
+                i[10] ? "0" : "var(--size-8) 0"
             );
         },
-        m(o, r) {
-            insert$3(o, e, r), ~i && _[i].m(e, null), t[31](e), l = !0;
+        m(h, o) {
+            insert$3(h, t, o), ~n && A[n].m(t, null), i[31](t), p = !0;
         },
-        p(o, r) {
-            let T = i;
-            i = c(o), i === T ? ~i && _[i].p(o, r) : (n && (group_outros$2(), transition_out$3(_[T], 1, 1, () => {
-                    _[T] = null;
-                }), check_outros$2()), ~i ? (n = _[i], n ? n.p(o, r) : (n = _[i] = h[i](o), n.c()), transition_in$3(n, 1), n.m(e, null)) : n = null), (!l || r[0] & /*variant, show_progress*/
+        p(h, o) {
+            let F = n;
+            n = a(h), n === F ? ~n && A[n].p(h, o) : (e && (group_outros$2(), transition_out$3(A[F], 1, 1, () => {
+                    A[F] = null;
+                }), check_outros$2()), ~n ? (e = A[n], e ? e.p(h, o) : (e = A[n] = f[n](h), e.c()), transition_in$3(e, 1), e.m(t, null)) : e = null), (!p || o[0] & /*variant, show_progress*/
                     320 && s !== (s = "wrap " + /*variant*/
-                        o[8] + " " + /*show_progress*/
-                        o[6] + " svelte-14miwb5")) && attr$3(e, "class", s), (!l || r[0] & /*variant, show_progress, status, show_progress*/
-                    336) && toggle_class$2(e, "hide", ! /*status*/
-                    o[4] || /*status*/
-                    o[4] === "complete" || /*show_progress*/
-                    o[6] === "hidden"), (!l || r[0] & /*variant, show_progress, variant, status, translucent, show_progress*/
+                        h[8] + " " + /*show_progress*/
+                        h[6] + " svelte-14miwb5")) && attr$3(t, "class", s), (!p || o[0] & /*variant, show_progress, status, show_progress*/
+                    336) && toggle_class$2(t, "hide", ! /*status*/
+                    h[4] || /*status*/
+                    h[4] === "complete" || /*show_progress*/
+                    h[6] === "hidden"), (!p || o[0] & /*variant, show_progress, variant, status, translucent, show_progress*/
                     2384) && toggle_class$2(
-                    e,
+                    t,
                     "translucent",
                     /*variant*/
-                    o[8] === "center" && /*status*/
-                    (o[4] === "pending" || /*status*/
-                        o[4] === "error") || /*translucent*/
-                    o[11] || /*show_progress*/
-                    o[6] === "minimal"
-                ), (!l || r[0] & /*variant, show_progress, status*/
+                    h[8] === "center" && /*status*/
+                    (h[4] === "pending" || /*status*/
+                        h[4] === "error") || /*translucent*/
+                    h[11] || /*show_progress*/
+                    h[6] === "minimal"
+                ), (!p || o[0] & /*variant, show_progress, status*/
                     336) && toggle_class$2(
-                    e,
+                    t,
                     "generating",
                     /*status*/
-                    o[4] === "generating"
-                ), (!l || r[0] & /*variant, show_progress, border*/
+                    h[4] === "generating"
+                ), (!p || o[0] & /*variant, show_progress, border*/
                     4416) && toggle_class$2(
-                    e,
+                    t,
                     "border",
                     /*border*/
-                    o[12]
-                ), r[0] & /*absolute*/
+                    h[12]
+                ), o[0] & /*absolute*/
                 1024 && set_style$2(
-                    e,
+                    t,
                     "position",
                     /*absolute*/
-                    o[10] ? "absolute" : "static"
-                ), r[0] & /*absolute*/
+                    h[10] ? "absolute" : "static"
+                ), o[0] & /*absolute*/
                 1024 && set_style$2(
-                    e,
+                    t,
                     "padding",
                     /*absolute*/
-                    o[10] ? "0" : "var(--size-8) 0"
+                    h[10] ? "0" : "var(--size-8) 0"
                 );
         },
-        i(o) {
-            l || (transition_in$3(n), l = !0);
+        i(h) {
+            p || (transition_in$3(e), p = !0);
         },
-        o(o) {
-            transition_out$3(n), l = !1;
+        o(h) {
+            transition_out$3(e), p = !1;
         },
-        d(o) {
-            o && detach$3(e), ~i && _[i].d(), t[31](null);
+        d(h) {
+            h && detach$3(t), ~n && A[n].d(), i[31](null);
         }
     };
 }
-let items = [],
-    called = !1;
-async function scroll_into_view(t, e = !0) {
-    if (!(window.__gradio_mode__ === "website" || window.__gradio_mode__ !== "app" && e !== !0)) {
-        if (items.push(t), !called)
-            called = !0;
-        else
-            return;
-        await tick$2(), requestAnimationFrame(() => {
-            let i = [0, 0];
-            for (let n = 0; n < items.length; n++) {
-                const l = items[n].getBoundingClientRect();
-                (n === 0 || l.top + window.scrollY <= i[0]) && (i[0] = l.top + window.scrollY, i[1] = n);
-            }
-            window.scrollTo({
-                top: i[0] - 20,
-                behavior: "smooth"
-            }), called = !1, items = [];
+var __awaiter = function(i, t, n, e) {
+    function s(p) {
+        return p instanceof n ? p : new n(function(f) {
+            f(p);
         });
     }
+    return new(n || (n = Promise))(function(p, f) {
+        function A(o) {
+            try {
+                h(e.next(o));
+            } catch (F) {
+                f(F);
+            }
+        }
+
+        function a(o) {
+            try {
+                h(e.throw(o));
+            } catch (F) {
+                f(F);
+            }
+        }
+
+        function h(o) {
+            o.done ? p(o.value) : s(o.value).then(A, a);
+        }
+        h((e = e.apply(i, t || [])).next());
+    });
+};
+let items = [],
+    called = !1;
+
+function scroll_into_view(i) {
+    return __awaiter(this, arguments, void 0, function*(t, n = !0) {
+        if (!(window.__gradio_mode__ === "website" || window.__gradio_mode__ !== "app" && n !== !0)) {
+            if (items.push(t), !called)
+                called = !0;
+            else
+                return;
+            yield tick$2(), requestAnimationFrame(() => {
+                let e = [0, 0];
+                for (let s = 0; s < items.length; s++) {
+                    const f = items[s].getBoundingClientRect();
+                    (s === 0 || f.top + window.scrollY <= e[0]) && (e[0] = f.top + window.scrollY, e[1] = s);
+                }
+                window.scrollTo({
+                    top: e[0] - 20,
+                    behavior: "smooth"
+                }), called = !1, items = [];
+            });
+        }
+    });
 }
 
-function instance$3(t, e, i) {
-    let n, {
-            $$slots: s = {},
-            $$scope: l
-        } = e,
-        {
-            i18n: h
-        } = e,
-        {
-            eta: _ = null
-        } = e,
-        {
-            queue: c = !1
-        } = e,
-        {
-            queue_position: o
-        } = e,
-        {
-            queue_size: r
-        } = e,
-        {
-            status: T
-        } = e,
-        {
-            scroll_to_output: S = !1
-        } = e,
-        {
-            timer: w = !0
-        } = e,
-        {
-            show_progress: C = "full"
-        } = e,
-        {
-            message: P = null
-        } = e,
-        {
-            progress: b = null
-        } = e,
-        {
-            variant: k = "default"
-        } = e,
-        {
-            loading_text: F = "Loading..."
-        } = e,
-        {
-            absolute: x = !0
-        } = e,
-        {
-            translucent: y = !1
-        } = e,
-        {
-            border: p = !1
-        } = e,
-        {
-            autoscroll: E
-        } = e,
-        $, M = !1,
-        m = 0,
-        N = 0,
-        D = null,
-        X = 0,
-        G = null,
-        I, B = null,
-        ee = !0;
-    const Y = () => {
-        i(25, m = performance.now()), i(26, N = 0), M = !0, q();
+function instance$3(i, t, n) {
+    let e, {
+        $$slots: s = {},
+        $$scope: p
+    } = t;
+    this && this.__awaiter;
+    let {
+        i18n: f
+    } = t, {
+        eta: A = null
+    } = t, {
+        queue: a = !1
+    } = t, {
+        queue_position: h
+    } = t, {
+        queue_size: o
+    } = t, {
+        status: F
+    } = t, {
+        scroll_to_output: R = !1
+    } = t, {
+        timer: w = !0
+    } = t, {
+        show_progress: T = "full"
+    } = t, {
+        message: P = null
+    } = t, {
+        progress: m = null
+    } = t, {
+        variant: C = "default"
+    } = t, {
+        loading_text: x = "Loading..."
+    } = t, {
+        absolute: E = !0
+    } = t, {
+        translucent: S = !1
+    } = t, {
+        border: g = !1
+    } = t, {
+        autoscroll: v
+    } = t, $, M = !1, _ = 0, N = 0, D = null, X = 0, Y = null, I, U = null, G = !0;
+    const V = () => {
+        n(25, _ = performance.now()), n(26, N = 0), M = !0, H();
     };
 
-    function q() {
+    function H() {
         requestAnimationFrame(() => {
-            i(26, N = (performance.now() - m) / 1e3), M && q();
+            n(26, N = (performance.now() - _) / 1e3), M && H();
         });
     }
 
-    function le() {
-        i(26, N = 0), M && (M = !1);
+    function st() {
+        n(26, N = 0), M && (M = !1);
     }
     onDestroy(() => {
-        M && le();
+        M && st();
     });
-    let pe = null;
+    let dt = null;
 
-    function we(R) {
-        binding_callbacks$2[R ? "unshift" : "push"](() => {
-            B = R, i(16, B), i(7, b), i(14, G), i(15, I);
+    function yt(k) {
+        binding_callbacks$2[k ? "unshift" : "push"](() => {
+            U = k, n(16, U), n(7, m), n(14, Y), n(15, I);
         });
     }
 
-    function be(R) {
-        binding_callbacks$2[R ? "unshift" : "push"](() => {
-            $ = R, i(13, $);
+    function gt(k) {
+        binding_callbacks$2[k ? "unshift" : "push"](() => {
+            $ = k, n(13, $);
         });
     }
-    return t.$$set = (R) => {
-        "i18n" in R && i(1, h = R.i18n), "eta" in R && i(0, _ = R.eta), "queue" in R && i(21, c = R.queue), "queue_position" in R && i(2, o = R.queue_position), "queue_size" in R && i(3, r = R.queue_size), "status" in R && i(4, T = R.status), "scroll_to_output" in R && i(22, S = R.scroll_to_output), "timer" in R && i(5, w = R.timer), "show_progress" in R && i(6, C = R.show_progress), "message" in R && i(23, P = R.message), "progress" in R && i(7, b = R.progress), "variant" in R && i(8, k = R.variant), "loading_text" in R && i(9, F = R.loading_text), "absolute" in R && i(10, x = R.absolute), "translucent" in R && i(11, y = R.translucent), "border" in R && i(12, p = R.border), "autoscroll" in R && i(24, E = R.autoscroll), "$$scope" in R && i(28, l = R.$$scope);
-    }, t.$$.update = () => {
-        t.$$.dirty[0] & /*eta, old_eta, queue, timer_start*/
-            169869313 && (_ === null ? i(0, _ = D) : c && i(0, _ = (performance.now() - m) / 1e3 + _), _ != null && (i(19, pe = _.toFixed(1)), i(27, D = _))), t.$$.dirty[0] & /*eta, timer_diff*/
-            67108865 && i(17, X = _ === null || _ <= 0 || !N ? null : Math.min(N / _, 1)), t.$$.dirty[0] & /*progress*/
-            128 && b != null && i(18, ee = !1), t.$$.dirty[0] & /*progress, progress_level, progress_bar, last_progress_level*/
-            114816 && (b != null ? i(14, G = b.map((R) => {
-                if (R.index != null && R.length != null)
-                    return R.index / R.length;
-                if (R.progress != null)
-                    return R.progress;
-            })) : i(14, G = null), G ? (i(15, I = G[G.length - 1]), B && (I === 0 ? i(16, B.style.transition = "0", B) : i(16, B.style.transition = "150ms", B))) : i(15, I = void 0)), t.$$.dirty[0] & /*status*/
-            16 && (T === "pending" ? Y() : le()), t.$$.dirty[0] & /*el, scroll_to_output, status, autoscroll*/
-            20979728 && $ && S && (T === "pending" || T === "complete") && scroll_into_view($, E), t.$$.dirty[0] & /*status, message*/
-            8388624, t.$$.dirty[0] & /*timer_diff*/
-            67108864 && i(20, n = N.toFixed(1));
+    return i.$$set = (k) => {
+        "i18n" in k && n(1, f = k.i18n), "eta" in k && n(0, A = k.eta), "queue" in k && n(21, a = k.queue), "queue_position" in k && n(2, h = k.queue_position), "queue_size" in k && n(3, o = k.queue_size), "status" in k && n(4, F = k.status), "scroll_to_output" in k && n(22, R = k.scroll_to_output), "timer" in k && n(5, w = k.timer), "show_progress" in k && n(6, T = k.show_progress), "message" in k && n(23, P = k.message), "progress" in k && n(7, m = k.progress), "variant" in k && n(8, C = k.variant), "loading_text" in k && n(9, x = k.loading_text), "absolute" in k && n(10, E = k.absolute), "translucent" in k && n(11, S = k.translucent), "border" in k && n(12, g = k.border), "autoscroll" in k && n(24, v = k.autoscroll), "$$scope" in k && n(28, p = k.$$scope);
+    }, i.$$.update = () => {
+        i.$$.dirty[0] & /*eta, old_eta, queue, timer_start*/
+            169869313 && (A === null ? n(0, A = D) : a && n(0, A = (performance.now() - _) / 1e3 + A), A != null && (n(19, dt = A.toFixed(1)), n(27, D = A))), i.$$.dirty[0] & /*eta, timer_diff*/
+            67108865 && n(17, X = A === null || A <= 0 || !N ? null : Math.min(N / A, 1)), i.$$.dirty[0] & /*progress*/
+            128 && m != null && n(18, G = !1), i.$$.dirty[0] & /*progress, progress_level, progress_bar, last_progress_level*/
+            114816 && (m != null ? n(14, Y = m.map((k) => {
+                if (k.index != null && k.length != null)
+                    return k.index / k.length;
+                if (k.progress != null)
+                    return k.progress;
+            })) : n(14, Y = null), Y ? (n(15, I = Y[Y.length - 1]), U && (I === 0 ? n(16, U.style.transition = "0", U) : n(16, U.style.transition = "150ms", U))) : n(15, I = void 0)), i.$$.dirty[0] & /*status*/
+            16 && (F === "pending" ? V() : st()), i.$$.dirty[0] & /*el, scroll_to_output, status, autoscroll*/
+            20979728 && $ && R && (F === "pending" || F === "complete") && scroll_into_view($, v), i.$$.dirty[0] & /*status, message*/
+            8388624, i.$$.dirty[0] & /*timer_diff*/
+            67108864 && n(20, e = N.toFixed(1));
     }, [
-        _,
+        A,
+        f,
         h,
         o,
-        r,
-        T,
+        F,
         w,
+        T,
+        m,
         C,
-        b,
-        k,
-        F,
         x,
-        y,
-        p,
+        E,
+        S,
+        g,
         $,
-        G,
+        Y,
         I,
-        B,
+        U,
         X,
-        ee,
-        pe,
-        n,
-        c,
-        S,
+        G,
+        dt,
+        e,
+        a,
+        R,
         P,
-        E,
-        m,
+        v,
+        _,
         N,
         D,
-        l,
+        p,
         s,
-        we,
-        be
+        yt,
+        gt
     ];
 }
 class Static extends SvelteComponent$3 {
-    constructor(e) {
+    constructor(t) {
         super(), init$3(
             this,
-            e,
+            t,
             instance$3,
             create_fragment$3,
             safe_not_equal$3, {
                 i18n: 1,
                 eta: 0,
                 queue: 21,
                 queue_position: 2,
@@ -3070,1077 +3036,1075 @@
                 autoscroll: 24
             },
             null,
             [-1, -1]
         );
     }
 }
-const ToastContent_svelte_svelte_type_style_lang = "",
-    Toast_svelte_svelte_type_style_lang = "";
 var fn = new Intl.Collator(0, {
     numeric: 1
 }).compare;
 
-function semiver(t, e, i) {
-    return t = t.split("."), e = e.split("."), fn(t[0], e[0]) || fn(t[1], e[1]) || (e[2] = e.slice(2).join("."), i = /[.-]/.test(t[2] = t.slice(2).join(".")), i == /[.-]/.test(e[2]) ? fn(t[2], e[2]) : i ? -1 : 1);
+function semiver(i, t, n) {
+    return i = i.split("."), t = t.split("."), fn(i[0], t[0]) || fn(i[1], t[1]) || (t[2] = t.slice(2).join("."), n = /[.-]/.test(i[2] = i.slice(2).join(".")), n == /[.-]/.test(t[2]) ? fn(i[2], t[2]) : n ? -1 : 1);
 }
 
-function resolve_root(t, e, i) {
-    return e.startsWith("http://") || e.startsWith("https://") ? i ? t : e : t + e;
+function resolve_root(i, t, n) {
+    return t.startsWith("http://") || t.startsWith("https://") ? n ? i : t : i + t;
 }
 
-function determine_protocol(t) {
-    if (t.startsWith("http")) {
+function determine_protocol(i) {
+    if (i.startsWith("http")) {
         const {
-            protocol: e,
-            host: i
-        } = new URL(t);
-        return i.endsWith("hf.space") ? {
+            protocol: t,
+            host: n
+        } = new URL(i);
+        return n.endsWith("hf.space") ? {
             ws_protocol: "wss",
-            host: i,
-            http_protocol: e
+            host: n,
+            http_protocol: t
         } : {
-            ws_protocol: e === "https:" ? "wss" : "ws",
-            http_protocol: e,
-            host: i
+            ws_protocol: t === "https:" ? "wss" : "ws",
+            http_protocol: t,
+            host: n
         };
-    } else if (t.startsWith("file:"))
+    } else if (i.startsWith("file:"))
         return {
             ws_protocol: "ws",
             http_protocol: "http:",
             host: "lite.local"
             // Special fake hostname only used for this case. This matches the hostname allowed in `is_self_host()` in `js/wasm/network/host.ts`.
         };
     return {
         ws_protocol: "wss",
         http_protocol: "https:",
-        host: t
+        host: i
     };
 }
 const RE_SPACE_NAME = /^[^\/]*\/[^\/]*$/,
     RE_SPACE_DOMAIN = /.*hf\.space\/{0,1}$/;
-async function process_endpoint(t, e) {
-    const i = {};
-    e && (i.Authorization = `Bearer ${e}`);
-    const n = t.trim();
-    if (RE_SPACE_NAME.test(n))
+async function process_endpoint(i, t) {
+    const n = {};
+    t && (n.Authorization = `Bearer ${t}`);
+    const e = i.trim();
+    if (RE_SPACE_NAME.test(e))
         try {
             const s = await fetch(
-                `https://huggingface.co/api/spaces/${n}/host`, {
-                    headers: i
+                `https://huggingface.co/api/spaces/${e}/host`, {
+                    headers: n
                 }
             );
             if (s.status !== 200)
                 throw new Error("Space metadata could not be loaded.");
-            const l = (await s.json()).host;
+            const p = (await s.json()).host;
             return {
-                space_id: t,
-                ...determine_protocol(l)
+                space_id: i,
+                ...determine_protocol(p)
             };
         } catch (s) {
             throw new Error("Space metadata could not be loaded." + s.message);
         }
-    if (RE_SPACE_DOMAIN.test(n)) {
+    if (RE_SPACE_DOMAIN.test(e)) {
         const {
             ws_protocol: s,
-            http_protocol: l,
-            host: h
-        } = determine_protocol(n);
+            http_protocol: p,
+            host: f
+        } = determine_protocol(e);
         return {
-            space_id: h.replace(".hf.space", ""),
+            space_id: f.replace(".hf.space", ""),
             ws_protocol: s,
-            http_protocol: l,
-            host: h
+            http_protocol: p,
+            host: f
         };
     }
     return {
         space_id: !1,
-        ...determine_protocol(n)
+        ...determine_protocol(e)
     };
 }
 
-function map_names_to_ids(t) {
-    let e = {};
-    return t.forEach(({
-        api_name: i
-    }, n) => {
-        i && (e[i] = n);
-    }), e;
+function map_names_to_ids(i) {
+    let t = {};
+    return i.forEach(({
+        api_name: n
+    }, e) => {
+        n && (t[n] = e);
+    }), t;
 }
 const RE_DISABLED_DISCUSSION = /^(?=[^]*\b[dD]iscussions{0,1}\b)(?=[^]*\b[dD]isabled\b)[^]*$/;
-async function discussions_enabled(t) {
+async function discussions_enabled(i) {
     try {
-        const i = (await fetch(
-            `https://huggingface.co/api/spaces/${t}/discussions`, {
+        const n = (await fetch(
+            `https://huggingface.co/api/spaces/${i}/discussions`, {
                 method: "HEAD"
             }
         )).headers.get("x-error-message");
-        return !(i && RE_DISABLED_DISCUSSION.test(i));
+        return !(n && RE_DISABLED_DISCUSSION.test(n));
     } catch {
         return !1;
     }
 }
 
-function normalise_file(t, e, i) {
-    if (t == null)
+function normalise_file(i, t, n) {
+    if (i == null)
         return null;
-    if (Array.isArray(t)) {
-        const n = [];
-        for (const s of t)
-            s == null ? n.push(null) : n.push(normalise_file(s, e, i));
-        return n;
+    if (Array.isArray(i)) {
+        const e = [];
+        for (const s of i)
+            s == null ? e.push(null) : e.push(normalise_file(s, t, n));
+        return e;
     }
-    return t.is_stream ? i == null ? new FileData({
-        ...t,
-        url: e + "/stream/" + t.path
+    return i.is_stream ? n == null ? new FileData({
+        ...i,
+        url: t + "/stream/" + i.path
     }) : new FileData({
-        ...t,
-        url: "/proxy=" + i + "stream/" + t.path
+        ...i,
+        url: "/proxy=" + n + "stream/" + i.path
     }) : new FileData({
-        ...t,
-        url: get_fetchable_url_or_file(t.path, e, i)
+        ...i,
+        url: get_fetchable_url_or_file(i.path, t, n)
     });
 }
 
-function is_url(t) {
+function is_url(i) {
     try {
-        const e = new URL(t);
-        return e.protocol === "http:" || e.protocol === "https:";
+        const t = new URL(i);
+        return t.protocol === "http:" || t.protocol === "https:";
     } catch {
         return !1;
     }
 }
 
-function get_fetchable_url_or_file(t, e, i) {
-    return t == null ? i ? `/proxy=${i}file=` : `${e}/file=` : is_url(t) ? t : i ? `/proxy=${i}file=${t}` : `${e}/file=${t}`;
+function get_fetchable_url_or_file(i, t, n) {
+    return i == null ? n ? `/proxy=${n}file=` : `${t}/file=` : is_url(i) ? i : n ? `/proxy=${n}file=${i}` : `${t}/file=${i}`;
 }
-async function upload(t, e, i = upload_files) {
-    let n = (Array.isArray(t) ? t : [t]).map(
+async function upload(i, t, n = upload_files) {
+    let e = (Array.isArray(i) ? i : [i]).map(
         (s) => s.blob
     );
     return await Promise.all(
-        await i(e, n).then(
+        await n(t, e).then(
             async (s) => {
                 if (s.error)
                     throw new Error(s.error);
-                return s.files ? s.files.map((l, h) => {
-                    const _ = new FileData({
-                        ...t[h],
-                        path: l
+                return s.files ? s.files.map((p, f) => {
+                    const A = new FileData({
+                        ...i[f],
+                        path: p
                     });
-                    return normalise_file(_, e, null);
+                    return normalise_file(A, t, null);
                 }) : [];
             }
         )
     );
 }
-async function prepare_files(t, e) {
-    return t.map(
-        (i, n) => new FileData({
-            path: i.name,
-            orig_name: i.name,
-            blob: i,
-            size: i.size,
-            mime_type: i.type,
-            is_stream: e
+async function prepare_files(i, t) {
+    return i.map(
+        (n, e) => new FileData({
+            path: n.name,
+            orig_name: n.name,
+            blob: n,
+            size: n.size,
+            mime_type: n.type,
+            is_stream: t
         })
     );
 }
 class FileData {
     constructor({
-        path: e,
-        url: i,
-        orig_name: n,
+        path: t,
+        url: n,
+        orig_name: e,
         size: s,
-        blob: l,
-        is_stream: h,
-        mime_type: _,
-        alt_text: c
+        blob: p,
+        is_stream: f,
+        mime_type: A,
+        alt_text: a
     }) {
-        this.path = e, this.url = i, this.orig_name = n, this.size = s, this.blob = i ? void 0 : l, this.is_stream = h, this.mime_type = _, this.alt_text = c;
+        this.path = t, this.url = n, this.orig_name = e, this.size = s, this.blob = n ? void 0 : p, this.is_stream = f, this.mime_type = A, this.alt_text = a;
     }
 }
 const QUEUE_FULL_MSG = "This application is too busy. Keep trying!",
     BROKEN_CONNECTION_MSG = "Connection errored out.";
 let NodeBlob;
 
-function api_factory(t, e) {
+function api_factory(i, t) {
     return {
-        post_data: i,
-        upload_files: n,
+        post_data: n,
+        upload_files: e,
         client: s,
-        handle_blob: l
+        handle_blob: p
     };
-    async function i(h, _, c) {
-        const o = {
+    async function n(f, A, a) {
+        const h = {
             "Content-Type": "application/json"
         };
-        c && (o.Authorization = `Bearer ${c}`);
+        a && (h.Authorization = `Bearer ${a}`);
         try {
-            var r = await t(h, {
+            var o = await i(f, {
                 method: "POST",
-                body: JSON.stringify(_),
-                headers: o
+                body: JSON.stringify(A),
+                headers: h
             });
         } catch {
             return [{
                 error: BROKEN_CONNECTION_MSG
             }, 500];
         }
-        return [await r.json(), r.status];
+        return [await o.json(), o.status];
     }
-    async function n(h, _, c) {
-        const o = {};
-        c && (o.Authorization = `Bearer ${c}`);
-        const r = 1e3,
-            T = [];
-        for (let w = 0; w < _.length; w += r) {
-            const C = _.slice(w, w + r),
+    async function e(f, A, a) {
+        const h = {};
+        a && (h.Authorization = `Bearer ${a}`);
+        const o = 1e3,
+            F = [];
+        for (let w = 0; w < A.length; w += o) {
+            const T = A.slice(w, w + o),
                 P = new FormData();
-            C.forEach((k) => {
-                P.append("files", k);
+            T.forEach((C) => {
+                P.append("files", C);
             });
             try {
-                var S = await t(`${h}/upload`, {
+                var R = await i(`${f}/upload`, {
                     method: "POST",
                     body: P,
-                    headers: o
+                    headers: h
                 });
             } catch {
                 return {
                     error: BROKEN_CONNECTION_MSG
                 };
             }
-            const b = await S.json();
-            T.push(...b);
+            const m = await R.json();
+            F.push(...m);
         }
         return {
-            files: T
+            files: F
         };
     }
-    async function s(h, _ = {
+    async function s(f, A = {
         normalise_files: !0
     }) {
-        return new Promise(async (c) => {
+        return new Promise(async (a) => {
             const {
-                status_callback: o,
-                hf_token: r,
-                normalise_files: T
-            } = _, S = {
+                status_callback: h,
+                hf_token: o,
+                normalise_files: F
+            } = A, R = {
                 predict: N,
                 submit: D,
-                view_api: G,
+                view_api: Y,
                 component_server: X
-            }, w = T ?? !0;
+            }, w = F ?? !0;
             if ((typeof window > "u" || !("WebSocket" in window)) && !global.Websocket) {
-                const I = await import("./wrapper-98f94c21-d1a5537c.js");
+                const I = await import("./wrapper-98f94c21-DqR3tIm1.js");
                 NodeBlob = (await Promise.resolve().then(() => __viteBrowserExternal)).Blob, global.WebSocket = I.WebSocket;
             }
             const {
-                ws_protocol: C,
+                ws_protocol: T,
                 http_protocol: P,
-                host: b,
-                space_id: k
-            } = await process_endpoint(h, r), F = Math.random().toString(36).substring(2), x = {};
-            let y, p = {},
-                E = !1;
-            r && k && (E = await get_jwt(k, r));
+                host: m,
+                space_id: C
+            } = await process_endpoint(f, o), x = Math.random().toString(36).substring(2), E = {};
+            let S, g = {},
+                v = !1;
+            o && C && (v = await get_jwt(C, o));
             async function $(I) {
-                if (y = I, p = map_names_to_ids((I == null ? void 0 : I.dependencies) || []), y.auth_required)
+                if (S = I, g = map_names_to_ids((I == null ? void 0 : I.dependencies) || []), S.auth_required)
                     return {
-                        config: y,
-                        ...S
+                        config: S,
+                        ...R
                     };
                 try {
-                    M = await G(y);
-                } catch (B) {
-                    console.error(`Could not get api details: ${B.message}`);
+                    M = await Y(S);
+                } catch (U) {
+                    console.error(`Could not get api details: ${U.message}`);
                 }
                 return {
-                    config: y,
-                    ...S
+                    config: S,
+                    ...R
                 };
             }
             let M;
-            async function m(I) {
-                if (o && o(I), I.status === "running")
+            async function _(I) {
+                if (h && h(I), I.status === "running")
                     try {
-                        y = await resolve_config(
-                            t,
-                            `${P}//${b}`,
-                            r
+                        S = await resolve_config(
+                            i,
+                            `${P}//${m}`,
+                            o
                         );
-                        const B = await $(y);
-                        c(B);
-                    } catch (B) {
-                        console.error(B), o && o({
+                        const U = await $(S);
+                        a(U);
+                    } catch (U) {
+                        console.error(U), h && h({
                             status: "error",
                             message: "Could not load this space.",
                             load_status: "error",
                             detail: "NOT_FOUND"
                         });
                     }
             }
             try {
-                y = await resolve_config(
-                    t,
-                    `${P}//${b}`,
-                    r
+                S = await resolve_config(
+                    i,
+                    `${P}//${m}`,
+                    o
                 );
-                const I = await $(y);
-                c(I);
+                const I = await $(S);
+                a(I);
             } catch (I) {
-                console.error(I), k ? check_space_status(
-                    k,
-                    RE_SPACE_NAME.test(k) ? "space_name" : "subdomain",
-                    m
-                ) : o && o({
+                console.error(I), C ? check_space_status(
+                    C,
+                    RE_SPACE_NAME.test(C) ? "space_name" : "subdomain",
+                    _
+                ) : h && h({
                     status: "error",
                     message: "Could not load this space.",
                     load_status: "error",
                     detail: "NOT_FOUND"
                 });
             }
 
-            function N(I, B, ee) {
-                let Y = !1,
-                    q = !1,
-                    le;
+            function N(I, U, G) {
+                let V = !1,
+                    H = !1,
+                    st;
                 if (typeof I == "number")
-                    le = y.dependencies[I];
+                    st = S.dependencies[I];
                 else {
-                    const pe = I.replace(/^\//, "");
-                    le = y.dependencies[p[pe]];
+                    const dt = I.replace(/^\//, "");
+                    st = S.dependencies[g[dt]];
                 }
-                if (le.types.continuous)
+                if (st.types.continuous)
                     throw new Error(
                         "Cannot call predict on this function as it may run forever. Use submit instead"
                     );
-                return new Promise((pe, we) => {
-                    const be = D(I, B, ee);
-                    let R;
-                    be.on("data", (d) => {
-                        q && (be.destroy(), pe(d)), Y = !0, R = d;
-                    }).on("status", (d) => {
-                        d.stage === "error" && we(d), d.stage === "complete" && (q = !0, Y && (be.destroy(), pe(R)));
+                return new Promise((dt, yt) => {
+                    const gt = D(I, U, G);
+                    let k;
+                    gt.on("data", (l) => {
+                        H && (gt.destroy(), dt(l)), V = !0, k = l;
+                    }).on("status", (l) => {
+                        l.stage === "error" && yt(l), l.stage === "complete" && (H = !0, V && (gt.destroy(), dt(k)));
                     });
                 });
             }
 
-            function D(I, B, ee) {
-                let Y, q;
+            function D(I, U, G) {
+                let V, H;
                 if (typeof I == "number")
-                    Y = I, q = M.unnamed_endpoints[Y];
+                    V = I, H = M.unnamed_endpoints[V];
                 else {
                     const Z = I.replace(/^\//, "");
-                    Y = p[Z], q = M.named_endpoints[I.trim()];
+                    V = g[Z], H = M.named_endpoints[I.trim()];
                 }
-                if (typeof Y != "number")
+                if (typeof V != "number")
                     throw new Error(
                         "There is no endpoint matching that name of fn_index matching that number."
                     );
-                let le, pe, we = y.protocol ?? "sse";
-                const be = typeof I == "number" ? "/predict" : I;
-                let R, d = null,
-                    g = !1;
-                const f = {};
-                let v = "";
-                typeof window < "u" && (v = new URLSearchParams(window.location.search).toString()), l(
-                    `${P}//${resolve_root(b, y.path, !0)}`,
-                    B,
-                    q,
-                    r
+                let st, dt, yt = S.protocol ?? "sse";
+                const gt = typeof I == "number" ? "/predict" : I;
+                let k, l = null,
+                    u = !1;
+                const d = {};
+                let b = "";
+                typeof window < "u" && (b = new URLSearchParams(window.location.search).toString()), p(
+                    `${P}//${resolve_root(m, S.path, !0)}`,
+                    U,
+                    H,
+                    o
                 ).then((Z) => {
-                    if (R = {
+                    if (k = {
                             data: Z || [],
-                            event_data: ee,
-                            fn_index: Y
-                        }, skip_queue(Y, y))
-                        A({
+                            event_data: G,
+                            fn_index: V
+                        }, skip_queue(V, S))
+                        y({
                             type: "status",
-                            endpoint: be,
+                            endpoint: gt,
                             stage: "pending",
                             queue: !1,
-                            fn_index: Y,
+                            fn_index: V,
                             time: /* @__PURE__ */ new Date()
-                        }), i(
-                            `${P}//${resolve_root(b, y.path, !0)}/run${be.startsWith("/") ? be : `/${be}`}${v ? "?" + v : ""}`, {
-                                ...R,
-                                session_hash: F
+                        }), n(
+                            `${P}//${resolve_root(m, S.path, !0)}/run${gt.startsWith("/") ? gt : `/${gt}`}${b ? "?" + b : ""}`, {
+                                ...k,
+                                session_hash: x
                             },
-                            r
-                        ).then(([ue, me]) => {
-                            const fe = w ? transform_output(
-                                ue.data,
-                                q,
-                                y.root,
-                                y.root_url
-                            ) : ue.data;
-                            me == 200 ? (A({
+                            o
+                        ).then(([ht, mt]) => {
+                            const ft = w ? transform_output(
+                                ht.data,
+                                H,
+                                S.root,
+                                S.root_url
+                            ) : ht.data;
+                            mt == 200 ? (y({
                                 type: "data",
-                                endpoint: be,
-                                fn_index: Y,
-                                data: fe,
+                                endpoint: gt,
+                                fn_index: V,
+                                data: ft,
                                 time: /* @__PURE__ */ new Date()
-                            }), A({
+                            }), y({
                                 type: "status",
-                                endpoint: be,
-                                fn_index: Y,
+                                endpoint: gt,
+                                fn_index: V,
                                 stage: "complete",
-                                eta: ue.average_duration,
+                                eta: ht.average_duration,
                                 queue: !1,
                                 time: /* @__PURE__ */ new Date()
-                            })) : A({
+                            })) : y({
                                 type: "status",
                                 stage: "error",
-                                endpoint: be,
-                                fn_index: Y,
-                                message: ue.error,
+                                endpoint: gt,
+                                fn_index: V,
+                                message: ht.error,
                                 queue: !1,
                                 time: /* @__PURE__ */ new Date()
                             });
-                        }).catch((ue) => {
-                            A({
+                        }).catch((ht) => {
+                            y({
                                 type: "status",
                                 stage: "error",
-                                message: ue.message,
-                                endpoint: be,
-                                fn_index: Y,
+                                message: ht.message,
+                                endpoint: gt,
+                                fn_index: V,
                                 queue: !1,
                                 time: /* @__PURE__ */ new Date()
                             });
                         });
-                    else if (we == "ws") {
-                        A({
+                    else if (yt == "ws") {
+                        y({
                             type: "status",
                             stage: "pending",
                             queue: !0,
-                            endpoint: be,
-                            fn_index: Y,
+                            endpoint: gt,
+                            fn_index: V,
                             time: /* @__PURE__ */ new Date()
                         });
-                        let ue = new URL(`${C}://${resolve_root(
-              b,
-              y.path,
+                        let ht = new URL(`${T}://${resolve_root(
+              m,
+              S.path,
               !0
             )}
-							/queue/join${v ? "?" + v : ""}`);
-                        E && ue.searchParams.set("__sign", E), le = e(ue), le.onclose = (me) => {
-                            me.wasClean || A({
+							/queue/join${b ? "?" + b : ""}`);
+                        v && ht.searchParams.set("__sign", v), st = t(ht), st.onclose = (mt) => {
+                            mt.wasClean || y({
                                 type: "status",
                                 stage: "error",
                                 broken: !0,
                                 message: BROKEN_CONNECTION_MSG,
                                 queue: !0,
-                                endpoint: be,
-                                fn_index: Y,
+                                endpoint: gt,
+                                fn_index: V,
                                 time: /* @__PURE__ */ new Date()
                             });
-                        }, le.onmessage = function(me) {
-                            const fe = JSON.parse(me.data),
+                        }, st.onmessage = function(mt) {
+                            const ft = JSON.parse(mt.data),
                                 {
-                                    type: Pe,
-                                    status: Fe,
-                                    data: Ee
+                                    type: kt,
+                                    status: Rt,
+                                    data: St
                                 } = handle_message(
-                                    fe,
-                                    x[Y]
+                                    ft,
+                                    E[V]
                                 );
-                            if (Pe === "update" && Fe && !g)
-                                A({
+                            if (kt === "update" && Rt && !u)
+                                y({
                                     type: "status",
-                                    endpoint: be,
-                                    fn_index: Y,
+                                    endpoint: gt,
+                                    fn_index: V,
                                     time: /* @__PURE__ */ new Date(),
-                                    ...Fe
-                                }), Fe.stage === "error" && le.close();
-                            else if (Pe === "hash") {
-                                le.send(JSON.stringify({
-                                    fn_index: Y,
-                                    session_hash: F
+                                    ...Rt
+                                }), Rt.stage === "error" && st.close();
+                            else if (kt === "hash") {
+                                st.send(JSON.stringify({
+                                    fn_index: V,
+                                    session_hash: x
                                 }));
                                 return;
                             } else
-                                Pe === "data" ? le.send(JSON.stringify({
-                                    ...R,
-                                    session_hash: F
-                                })) : Pe === "complete" ? g = Fe : Pe === "log" ? A({
+                                kt === "data" ? st.send(JSON.stringify({
+                                    ...k,
+                                    session_hash: x
+                                })) : kt === "complete" ? u = Rt : kt === "log" ? y({
                                     type: "log",
-                                    log: Ee.log,
-                                    level: Ee.level,
-                                    endpoint: be,
-                                    fn_index: Y
-                                }) : Pe === "generating" && A({
+                                    log: St.log,
+                                    level: St.level,
+                                    endpoint: gt,
+                                    fn_index: V
+                                }) : kt === "generating" && y({
                                     type: "status",
                                     time: /* @__PURE__ */ new Date(),
-                                    ...Fe,
-                                    stage: Fe == null ? void 0 : Fe.stage,
+                                    ...Rt,
+                                    stage: Rt == null ? void 0 : Rt.stage,
                                     queue: !0,
-                                    endpoint: be,
-                                    fn_index: Y
+                                    endpoint: gt,
+                                    fn_index: V
                                 });
-                            Ee && (A({
+                            St && (y({
                                 type: "data",
                                 time: /* @__PURE__ */ new Date(),
                                 data: w ? transform_output(
-                                    Ee.data,
-                                    q,
-                                    y.root,
-                                    y.root_url
-                                ) : Ee.data,
-                                endpoint: be,
-                                fn_index: Y
-                            }), g && (A({
+                                    St.data,
+                                    H,
+                                    S.root,
+                                    S.root_url
+                                ) : St.data,
+                                endpoint: gt,
+                                fn_index: V
+                            }), u && (y({
                                 type: "status",
                                 time: /* @__PURE__ */ new Date(),
-                                ...g,
-                                stage: Fe == null ? void 0 : Fe.stage,
+                                ...u,
+                                stage: Rt == null ? void 0 : Rt.stage,
                                 queue: !0,
-                                endpoint: be,
-                                fn_index: Y
-                            }), le.close()));
-                        }, semiver(y.version || "2.0.0", "3.6") < 0 && addEventListener(
+                                endpoint: gt,
+                                fn_index: V
+                            }), st.close()));
+                        }, semiver(S.version || "2.0.0", "3.6") < 0 && addEventListener(
                             "open",
-                            () => le.send(JSON.stringify({
-                                hash: F
+                            () => st.send(JSON.stringify({
+                                hash: x
                             }))
                         );
                     } else {
-                        A({
+                        y({
                             type: "status",
                             stage: "pending",
                             queue: !0,
-                            endpoint: be,
-                            fn_index: Y,
+                            endpoint: gt,
+                            fn_index: V,
                             time: /* @__PURE__ */ new Date()
                         });
-                        var ce = new URLSearchParams({
-                            fn_index: Y.toString(),
-                            session_hash: F
+                        var lt = new URLSearchParams({
+                            fn_index: V.toString(),
+                            session_hash: x
                         }).toString();
-                        let ue = new URL(
+                        let ht = new URL(
                             `${P}//${resolve_root(
-                b,
-                y.path,
+                m,
+                S.path,
                 !0
-              )}/queue/join?${ce}`
+              )}/queue/join?${lt}`
                         );
-                        pe = new EventSource(ue), pe.onmessage = async function(me) {
-                            const fe = JSON.parse(me.data),
+                        dt = new EventSource(ht), dt.onmessage = async function(mt) {
+                            const ft = JSON.parse(mt.data),
                                 {
-                                    type: Pe,
-                                    status: Fe,
-                                    data: Ee
+                                    type: kt,
+                                    status: Rt,
+                                    data: St
                                 } = handle_message(
-                                    fe,
-                                    x[Y]
+                                    ft,
+                                    E[V]
                                 );
-                            if (Pe === "update" && Fe && !g)
-                                A({
+                            if (kt === "update" && Rt && !u)
+                                y({
                                     type: "status",
-                                    endpoint: be,
-                                    fn_index: Y,
+                                    endpoint: gt,
+                                    fn_index: V,
                                     time: /* @__PURE__ */ new Date(),
-                                    ...Fe
-                                }), Fe.stage === "error" && pe.close();
-                            else if (Pe === "data") {
-                                d = fe.event_id;
-                                let [De, _e] = await i(
+                                    ...Rt
+                                }), Rt.stage === "error" && dt.close();
+                            else if (kt === "data") {
+                                l = ft.event_id;
+                                let [It, _t] = await n(
                                     `${P}//${resolve_root(
-                    b,
-                    y.path,
+                    m,
+                    S.path,
                     !0
                   )}/queue/data`, {
-                                        ...R,
-                                        session_hash: F,
-                                        event_id: d
+                                        ...k,
+                                        session_hash: x,
+                                        event_id: l
                                     },
-                                    r
+                                    o
                                 );
-                                _e !== 200 && (A({
+                                _t !== 200 && (y({
                                     type: "status",
                                     stage: "error",
                                     message: BROKEN_CONNECTION_MSG,
                                     queue: !0,
-                                    endpoint: be,
-                                    fn_index: Y,
+                                    endpoint: gt,
+                                    fn_index: V,
                                     time: /* @__PURE__ */ new Date()
-                                }), pe.close());
+                                }), dt.close());
                             } else
-                                Pe === "complete" ? g = Fe : Pe === "log" ? A({
+                                kt === "complete" ? u = Rt : kt === "log" ? y({
                                     type: "log",
-                                    log: Ee.log,
-                                    level: Ee.level,
-                                    endpoint: be,
-                                    fn_index: Y
-                                }) : Pe === "generating" && A({
+                                    log: St.log,
+                                    level: St.level,
+                                    endpoint: gt,
+                                    fn_index: V
+                                }) : kt === "generating" && y({
                                     type: "status",
                                     time: /* @__PURE__ */ new Date(),
-                                    ...Fe,
-                                    stage: Fe == null ? void 0 : Fe.stage,
+                                    ...Rt,
+                                    stage: Rt == null ? void 0 : Rt.stage,
                                     queue: !0,
-                                    endpoint: be,
-                                    fn_index: Y
+                                    endpoint: gt,
+                                    fn_index: V
                                 });
-                            Ee && (A({
+                            St && (y({
                                 type: "data",
                                 time: /* @__PURE__ */ new Date(),
                                 data: w ? transform_output(
-                                    Ee.data,
-                                    q,
-                                    y.root,
-                                    y.root_url
-                                ) : Ee.data,
-                                endpoint: be,
-                                fn_index: Y
-                            }), g && (A({
+                                    St.data,
+                                    H,
+                                    S.root,
+                                    S.root_url
+                                ) : St.data,
+                                endpoint: gt,
+                                fn_index: V
+                            }), u && (y({
                                 type: "status",
                                 time: /* @__PURE__ */ new Date(),
-                                ...g,
-                                stage: Fe == null ? void 0 : Fe.stage,
+                                ...u,
+                                stage: Rt == null ? void 0 : Rt.stage,
                                 queue: !0,
-                                endpoint: be,
-                                fn_index: Y
-                            }), pe.close()));
+                                endpoint: gt,
+                                fn_index: V
+                            }), dt.close()));
                         };
                     }
                 });
 
-                function A(Z) {
-                    const ue = f[Z.type] || [];
-                    ue == null || ue.forEach((me) => me(Z));
+                function y(Z) {
+                    const ht = d[Z.type] || [];
+                    ht == null || ht.forEach((mt) => mt(Z));
                 }
 
-                function O(Z, ce) {
-                    const ue = f,
-                        me = ue[Z] || [];
-                    return ue[Z] = me, me == null || me.push(ce), {
+                function O(Z, lt) {
+                    const ht = d,
+                        mt = ht[Z] || [];
+                    return ht[Z] = mt, mt == null || mt.push(lt), {
                         on: O,
-                        off: H,
+                        off: B,
                         cancel: z,
-                        destroy: ae
+                        destroy: it
                     };
                 }
 
-                function H(Z, ce) {
-                    const ue = f;
-                    let me = ue[Z] || [];
-                    return me = me == null ? void 0 : me.filter((fe) => fe !== ce), ue[Z] = me, {
+                function B(Z, lt) {
+                    const ht = d;
+                    let mt = ht[Z] || [];
+                    return mt = mt == null ? void 0 : mt.filter((ft) => ft !== lt), ht[Z] = mt, {
                         on: O,
-                        off: H,
+                        off: B,
                         cancel: z,
-                        destroy: ae
+                        destroy: it
                     };
                 }
                 async function z() {
                     const Z = {
                         stage: "complete",
                         queue: !1,
                         time: /* @__PURE__ */ new Date()
                     };
-                    g = Z, A({
+                    u = Z, y({
                         ...Z,
                         type: "status",
-                        endpoint: be,
-                        fn_index: Y
+                        endpoint: gt,
+                        fn_index: V
                     });
-                    let ce = {};
-                    we === "ws" ? (le && le.readyState === 0 ? le.addEventListener("open", () => {
-                        le.close();
-                    }) : le.close(), ce = {
-                        fn_index: Y,
-                        session_hash: F
-                    }) : (pe.close(), ce = {
-                        event_id: d
+                    let lt = {};
+                    yt === "ws" ? (st && st.readyState === 0 ? st.addEventListener("open", () => {
+                        st.close();
+                    }) : st.close(), lt = {
+                        fn_index: V,
+                        session_hash: x
+                    }) : (dt.close(), lt = {
+                        event_id: l
                     });
                     try {
-                        await t(
+                        await i(
                             `${P}//${resolve_root(
-                b,
-                y.path,
+                m,
+                S.path,
                 !0
               )}/reset`, {
                                 headers: {
                                     "Content-Type": "application/json"
                                 },
                                 method: "POST",
-                                body: JSON.stringify(ce)
+                                body: JSON.stringify(lt)
                             }
                         );
                     } catch {
                         console.warn(
                             "The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable."
                         );
                     }
                 }
 
-                function ae() {
-                    for (const Z in f)
-                        f[Z].forEach((ce) => {
-                            H(Z, ce);
+                function it() {
+                    for (const Z in d)
+                        d[Z].forEach((lt) => {
+                            B(Z, lt);
                         });
                 }
                 return {
                     on: O,
-                    off: H,
+                    off: B,
                     cancel: z,
-                    destroy: ae
+                    destroy: it
                 };
             }
-            async function X(I, B, ee) {
-                var Y;
-                const q = {
+            async function X(I, U, G) {
+                var V;
+                const H = {
                     "Content-Type": "application/json"
                 };
-                r && (q.Authorization = `Bearer ${r}`);
-                let le, pe = y.components.find(
-                    (R) => R.id === I
+                o && (H.Authorization = `Bearer ${o}`);
+                let st, dt = S.components.find(
+                    (k) => k.id === I
                 );
-                (Y = pe == null ? void 0 : pe.props) != null && Y.root_url ? le = pe.props.root_url : le = `${P}//${resolve_root(
-          b,
-          y.path,
+                (V = dt == null ? void 0 : dt.props) != null && V.root_url ? st = dt.props.root_url : st = `${P}//${resolve_root(
+          m,
+          S.path,
           !0
         )}/`;
-                const we = await t(
-                    `${le}component_server/`, {
+                const yt = await i(
+                    `${st}component_server/`, {
                         method: "POST",
                         body: JSON.stringify({
-                            data: ee,
+                            data: G,
                             component_id: I,
-                            fn_name: B,
-                            session_hash: F
+                            fn_name: U,
+                            session_hash: x
                         }),
-                        headers: q
+                        headers: H
                     }
                 );
-                if (!we.ok)
+                if (!yt.ok)
                     throw new Error(
-                        "Could not connect to component server: " + we.statusText
+                        "Could not connect to component server: " + yt.statusText
                     );
-                return await we.json();
+                return await yt.json();
             }
-            async function G(I) {
+            async function Y(I) {
                 if (M)
                     return M;
-                const B = {
+                const U = {
                     "Content-Type": "application/json"
                 };
-                r && (B.Authorization = `Bearer ${r}`);
-                let ee;
-                if (semiver(I.version || "2.0.0", "3.30") < 0 ? ee = await t(
+                o && (U.Authorization = `Bearer ${o}`);
+                let G;
+                if (semiver(I.version || "2.0.0", "3.30") < 0 ? G = await i(
                         "https://gradio-space-api-fetcher-v2.hf.space/api", {
                             method: "POST",
                             body: JSON.stringify({
                                 serialize: !1,
                                 config: JSON.stringify(I)
                             }),
-                            headers: B
+                            headers: U
                         }
-                    ) : ee = await t(`${I.root}/info`, {
-                        headers: B
-                    }), !ee.ok)
+                    ) : G = await i(`${I.root}/info`, {
+                        headers: U
+                    }), !G.ok)
                     throw new Error(BROKEN_CONNECTION_MSG);
-                let Y = await ee.json();
-                return "api" in Y && (Y = Y.api), Y.named_endpoints["/predict"] && !Y.unnamed_endpoints[0] && (Y.unnamed_endpoints[0] = Y.named_endpoints["/predict"]), transform_api_info(Y, I, p);
+                let V = await G.json();
+                return "api" in V && (V = V.api), V.named_endpoints["/predict"] && !V.unnamed_endpoints[0] && (V.unnamed_endpoints[0] = V.named_endpoints["/predict"]), transform_api_info(V, I, g);
             }
         });
     }
-    async function l(h, _, c, o) {
-        const r = await walk_and_store_blobs(
-            _,
+    async function p(f, A, a, h) {
+        const o = await walk_and_store_blobs(
+            A,
             void 0,
             [],
             !0,
-            c
+            a
         );
         return Promise.all(
-            r.map(async ({
-                path: T,
-                blob: S,
+            o.map(async ({
+                path: F,
+                blob: R,
                 type: w
             }) => {
-                if (S) {
-                    const C = (await n(h, [S], o)).files[0];
+                if (R) {
+                    const T = (await e(f, [R], h)).files[0];
                     return {
-                        path: T,
-                        file_url: C,
+                        path: F,
+                        file_url: T,
                         type: w,
-                        name: S == null ? void 0 : S.name
+                        name: R == null ? void 0 : R.name
                     };
                 }
                 return {
-                    path: T,
+                    path: F,
                     type: w
                 };
             })
-        ).then((T) => (T.forEach(({
-            path: S,
+        ).then((F) => (F.forEach(({
+            path: R,
             file_url: w,
-            type: C,
+            type: T,
             name: P
         }) => {
-            if (C === "Gallery")
-                update_object(_, w, S);
+            if (T === "Gallery")
+                update_object(A, w, R);
             else if (w) {
-                const b = new FileData({
+                const m = new FileData({
                     path: w,
                     orig_name: P
                 });
-                update_object(_, b, S);
+                update_object(A, m, R);
             }
-        }), _));
+        }), A));
     }
 }
 const {
     post_data,
     upload_files,
     client,
     handle_blob
 } = api_factory(
     fetch,
-    (...t) => new WebSocket(...t)
+    (...i) => new WebSocket(...i)
 );
 
-function transform_output(t, e, i, n) {
-    return t.map((s, l) => {
-        var h, _, c, o;
-        return ((_ = (h = e == null ? void 0 : e.returns) == null ? void 0 : h[l]) == null ? void 0 : _.component) === "File" ? normalise_file(s, i, n) : ((o = (c = e == null ? void 0 : e.returns) == null ? void 0 : c[l]) == null ? void 0 : o.component) === "Gallery" ? s.map((r) => Array.isArray(r) ? [normalise_file(r[0], i, n), r[1]] : [normalise_file(r, i, n), null]) : typeof s == "object" && s.path ? normalise_file(s, i, n) : s;
+function transform_output(i, t, n, e) {
+    return i.map((s, p) => {
+        var f, A, a, h;
+        return ((A = (f = t == null ? void 0 : t.returns) == null ? void 0 : f[p]) == null ? void 0 : A.component) === "File" ? normalise_file(s, n, e) : ((h = (a = t == null ? void 0 : t.returns) == null ? void 0 : a[p]) == null ? void 0 : h.component) === "Gallery" ? s.map((o) => Array.isArray(o) ? [normalise_file(o[0], n, e), o[1]] : [normalise_file(o, n, e), null]) : typeof s == "object" && s.path ? normalise_file(s, n, e) : s;
     });
 }
 
-function get_type(t, e, i, n) {
-    switch (t.type) {
+function get_type(i, t, n, e) {
+    switch (i.type) {
         case "string":
             return "string";
         case "boolean":
             return "boolean";
         case "number":
             return "number";
     }
-    if (i === "JSONSerializable" || i === "StringSerializable")
+    if (n === "JSONSerializable" || n === "StringSerializable")
         return "any";
-    if (i === "ListStringSerializable")
+    if (n === "ListStringSerializable")
         return "string[]";
-    if (e === "Image")
-        return n === "parameter" ? "Blob | File | Buffer" : "string";
-    if (i === "FileSerializable")
-        return (t == null ? void 0 : t.type) === "array" ? n === "parameter" ? "(Blob | File | Buffer)[]" : "{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]" : n === "parameter" ? "Blob | File | Buffer" : "{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}";
-    if (i === "GallerySerializable")
-        return n === "parameter" ? "[(Blob | File | Buffer), (string | null)][]" : "[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]";
+    if (t === "Image")
+        return e === "parameter" ? "Blob | File | Buffer" : "string";
+    if (n === "FileSerializable")
+        return (i == null ? void 0 : i.type) === "array" ? e === "parameter" ? "(Blob | File | Buffer)[]" : "{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]" : e === "parameter" ? "Blob | File | Buffer" : "{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}";
+    if (n === "GallerySerializable")
+        return e === "parameter" ? "[(Blob | File | Buffer), (string | null)][]" : "[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]";
 }
 
-function get_description(t, e) {
-    return e === "GallerySerializable" ? "array of [file, label] tuples" : e === "ListStringSerializable" ? "array of strings" : e === "FileSerializable" ? "array of files or single file" : t.description;
+function get_description(i, t) {
+    return t === "GallerySerializable" ? "array of [file, label] tuples" : t === "ListStringSerializable" ? "array of strings" : t === "FileSerializable" ? "array of files or single file" : i.description;
 }
 
-function transform_api_info(t, e, i) {
-    const n = {
+function transform_api_info(i, t, n) {
+    const e = {
         named_endpoints: {},
         unnamed_endpoints: {}
     };
-    for (const s in t) {
-        const l = t[s];
-        for (const h in l) {
-            const _ = e.dependencies[h] ? h : i[h.replace("/", "")],
-                c = l[h];
-            n[s][h] = {}, n[s][h].parameters = {}, n[s][h].returns = {}, n[s][h].type = e.dependencies[_].types, n[s][h].parameters = c.parameters.map(
+    for (const s in i) {
+        const p = i[s];
+        for (const f in p) {
+            const A = t.dependencies[f] ? f : n[f.replace("/", "")],
+                a = p[f];
+            e[s][f] = {}, e[s][f].parameters = {}, e[s][f].returns = {}, e[s][f].type = t.dependencies[A].types, e[s][f].parameters = a.parameters.map(
                 ({
-                    label: o,
-                    component: r,
-                    type: T,
-                    serializer: S
+                    label: h,
+                    component: o,
+                    type: F,
+                    serializer: R
                 }) => ({
-                    label: o,
-                    component: r,
-                    type: get_type(T, r, S, "parameter"),
-                    description: get_description(T, S)
+                    label: h,
+                    component: o,
+                    type: get_type(F, o, R, "parameter"),
+                    description: get_description(F, R)
                 })
-            ), n[s][h].returns = c.returns.map(
+            ), e[s][f].returns = a.returns.map(
                 ({
-                    label: o,
-                    component: r,
-                    type: T,
-                    serializer: S
+                    label: h,
+                    component: o,
+                    type: F,
+                    serializer: R
                 }) => ({
-                    label: o,
-                    component: r,
-                    type: get_type(T, r, S, "return"),
-                    description: get_description(T, S)
+                    label: h,
+                    component: o,
+                    type: get_type(F, o, R, "return"),
+                    description: get_description(F, R)
                 })
             );
         }
     }
-    return n;
+    return e;
 }
-async function get_jwt(t, e) {
+async function get_jwt(i, t) {
     try {
-        return (await (await fetch(`https://huggingface.co/api/spaces/${t}/jwt`, {
+        return (await (await fetch(`https://huggingface.co/api/spaces/${i}/jwt`, {
             headers: {
-                Authorization: `Bearer ${e}`
+                Authorization: `Bearer ${t}`
             }
         })).json()).token || !1;
-    } catch (i) {
-        return console.error(i), !1;
+    } catch (n) {
+        return console.error(n), !1;
     }
 }
 
-function update_object(t, e, i) {
-    for (; i.length > 1;)
-        t = t[i.shift()];
-    t[i.shift()] = e;
-}
-async function walk_and_store_blobs(t, e = void 0, i = [], n = !1, s = void 0) {
-    if (Array.isArray(t)) {
-        let l = [];
+function update_object(i, t, n) {
+    for (; n.length > 1;)
+        i = i[n.shift()];
+    i[n.shift()] = t;
+}
+async function walk_and_store_blobs(i, t = void 0, n = [], e = !1, s = void 0) {
+    if (Array.isArray(i)) {
+        let p = [];
         return await Promise.all(
-            t.map(async (h, _) => {
-                var c;
-                let o = i.slice();
-                o.push(_);
-                const r = await walk_and_store_blobs(
-                    t[_],
-                    n ? ((c = s == null ? void 0 : s.parameters[_]) == null ? void 0 : c.component) || void 0 : e,
-                    o,
+            i.map(async (f, A) => {
+                var a;
+                let h = n.slice();
+                h.push(A);
+                const o = await walk_and_store_blobs(
+                    i[A],
+                    e ? ((a = s == null ? void 0 : s.parameters[A]) == null ? void 0 : a.component) || void 0 : t,
+                    h,
                     !1,
                     s
                 );
-                l = l.concat(r);
+                p = p.concat(o);
             })
-        ), l;
+        ), p;
     } else {
-        if (globalThis.Buffer && t instanceof globalThis.Buffer)
+        if (globalThis.Buffer && i instanceof globalThis.Buffer)
             return [{
-                path: i,
-                blob: e === "Image" ? !1 : new NodeBlob([t]),
-                type: e
+                path: n,
+                blob: t === "Image" ? !1 : new NodeBlob([i]),
+                type: t
             }];
-        if (typeof t == "object") {
-            let l = [];
-            for (let h in t)
-                if (t.hasOwnProperty(h)) {
-                    let _ = i.slice();
-                    _.push(h), l = l.concat(
+        if (typeof i == "object") {
+            let p = [];
+            for (let f in i)
+                if (i.hasOwnProperty(f)) {
+                    let A = n.slice();
+                    A.push(f), p = p.concat(
                         await walk_and_store_blobs(
-                            t[h],
+                            i[f],
                             void 0,
-                            _,
+                            A,
                             !1,
                             s
                         )
                     );
                 }
-            return l;
+            return p;
         }
     }
     return [];
 }
 
-function skip_queue(t, e) {
-    var i, n, s, l;
-    return !(((n = (i = e == null ? void 0 : e.dependencies) == null ? void 0 : i[t]) == null ? void 0 : n.queue) === null ? e.enable_queue : (l = (s = e == null ? void 0 : e.dependencies) == null ? void 0 : s[t]) != null && l.queue) || !1;
-}
-async function resolve_config(t, e, i) {
-    const n = {};
-    if (i && (n.Authorization = `Bearer ${i}`), typeof window < "u" && window.gradio_config && location.origin !== "http://localhost:9876" && !window.gradio_config.dev_mode) {
+function skip_queue(i, t) {
+    var n, e, s, p;
+    return !(((e = (n = t == null ? void 0 : t.dependencies) == null ? void 0 : n[i]) == null ? void 0 : e.queue) === null ? t.enable_queue : (p = (s = t == null ? void 0 : t.dependencies) == null ? void 0 : s[i]) != null && p.queue) || !1;
+}
+async function resolve_config(i, t, n) {
+    const e = {};
+    if (n && (e.Authorization = `Bearer ${n}`), typeof window < "u" && window.gradio_config && location.origin !== "http://localhost:9876" && !window.gradio_config.dev_mode) {
         const s = window.gradio_config.root,
-            l = window.gradio_config;
-        return l.root = resolve_root(e, l.root, !1), {
-            ...l,
+            p = window.gradio_config;
+        return p.root = resolve_root(t, p.root, !1), {
+            ...p,
             path: s
         };
-    } else if (e) {
-        let s = await t(`${e}/config`, {
-            headers: n
+    } else if (t) {
+        let s = await i(`${t}/config`, {
+            headers: e
         });
         if (s.status === 200) {
-            const l = await s.json();
-            return l.path = l.path ?? "", l.root = e, l;
+            const p = await s.json();
+            return p.path = p.path ?? "", p.root = t, p;
         }
         throw new Error("Could not get config.");
     }
     throw new Error("No config or app endpoint found");
 }
-async function check_space_status(t, e, i) {
-    let n = e === "subdomain" ? `https://huggingface.co/api/spaces/by-subdomain/${t}` : `https://huggingface.co/api/spaces/${t}`,
-        s, l;
+async function check_space_status(i, t, n) {
+    let e = t === "subdomain" ? `https://huggingface.co/api/spaces/by-subdomain/${i}` : `https://huggingface.co/api/spaces/${i}`,
+        s, p;
     try {
-        if (s = await fetch(n), l = s.status, l !== 200)
+        if (s = await fetch(e), p = s.status, p !== 200)
             throw new Error();
         s = await s.json();
     } catch {
-        i({
+        n({
             status: "error",
             load_status: "error",
             message: "Could not get space status",
             detail: "NOT_FOUND"
         });
         return;
     }
-    if (!s || l !== 200)
+    if (!s || p !== 200)
         return;
     const {
         runtime: {
-            stage: h
+            stage: f
         },
-        id: _
+        id: A
     } = s;
-    switch (h) {
+    switch (f) {
         case "STOPPED":
         case "SLEEPING":
-            i({
+            n({
                 status: "sleeping",
                 load_status: "pending",
                 message: "Space is asleep. Waking it up...",
-                detail: h
+                detail: f
             }), setTimeout(() => {
-                check_space_status(t, e, i);
+                check_space_status(i, t, n);
             }, 1e3);
             break;
         case "PAUSED":
-            i({
+            n({
                 status: "paused",
                 load_status: "error",
                 message: "This space has been paused by the author. If you would like to try this demo, consider duplicating the space.",
-                detail: h,
-                discussions_enabled: await discussions_enabled(_)
+                detail: f,
+                discussions_enabled: await discussions_enabled(A)
             });
             break;
         case "RUNNING":
         case "RUNNING_BUILDING":
-            i({
+            n({
                 status: "running",
                 load_status: "complete",
                 message: "",
-                detail: h
+                detail: f
             });
             break;
         case "BUILDING":
-            i({
+            n({
                 status: "building",
                 load_status: "pending",
                 message: "Space is building...",
-                detail: h
+                detail: f
             }), setTimeout(() => {
-                check_space_status(t, e, i);
+                check_space_status(i, t, n);
             }, 1e3);
             break;
         default:
-            i({
+            n({
                 status: "space_error",
                 load_status: "error",
                 message: "This space is experiencing an issue.",
-                detail: h,
-                discussions_enabled: await discussions_enabled(_)
+                detail: f,
+                discussions_enabled: await discussions_enabled(A)
             });
             break;
     }
 }
 
-function handle_message(t, e) {
-    switch (t.msg) {
+function handle_message(i, t) {
+    switch (i.msg) {
         case "send_data":
             return {
                 type: "data"
             };
         case "send_hash":
             return {
                 type: "hash"
@@ -4148,3866 +4112,477 @@
         case "queue_full":
             return {
                 type: "update",
                     status: {
                         queue: !0,
                         message: QUEUE_FULL_MSG,
                         stage: "error",
-                        code: t.code,
-                        success: t.success
+                        code: i.code,
+                        success: i.success
                     }
             };
         case "estimation":
             return {
                 type: "update",
                     status: {
                         queue: !0,
-                        stage: e || "pending",
-                        code: t.code,
-                        size: t.queue_size,
-                        position: t.rank,
-                        eta: t.rank_eta,
-                        success: t.success
+                        stage: t || "pending",
+                        code: i.code,
+                        size: i.queue_size,
+                        position: i.rank,
+                        eta: i.rank_eta,
+                        success: i.success
                     }
             };
         case "progress":
             return {
                 type: "update",
                     status: {
                         queue: !0,
                         stage: "pending",
-                        code: t.code,
-                        progress_data: t.progress_data,
-                        success: t.success
+                        code: i.code,
+                        progress_data: i.progress_data,
+                        success: i.success
                     }
             };
         case "log":
             return {
-                type: "log", data: t
+                type: "log", data: i
             };
         case "process_generating":
             return {
                 type: "generating",
                     status: {
                         queue: !0,
-                        message: t.success ? null : t.output.error,
-                        stage: t.success ? "generating" : "error",
-                        code: t.code,
-                        progress_data: t.progress_data,
-                        eta: t.average_duration
+                        message: i.success ? null : i.output.error,
+                        stage: i.success ? "generating" : "error",
+                        code: i.code,
+                        progress_data: i.progress_data,
+                        eta: i.average_duration
                     },
-                    data: t.success ? t.output : null
+                    data: i.success ? i.output : null
             };
         case "process_completed":
-            return "error" in t.output ? {
+            return "error" in i.output ? {
                 type: "update",
                 status: {
                     queue: !0,
-                    message: t.output.error,
+                    message: i.output.error,
                     stage: "error",
-                    code: t.code,
-                    success: t.success
+                    code: i.code,
+                    success: i.success
                 }
             } : {
                 type: "complete",
                 status: {
                     queue: !0,
-                    message: t.success ? void 0 : t.output.error,
-                    stage: t.success ? "complete" : "error",
-                    code: t.code,
-                    progress_data: t.progress_data,
-                    eta: t.output.average_duration
+                    message: i.success ? void 0 : i.output.error,
+                    stage: i.success ? "complete" : "error",
+                    code: i.code,
+                    progress_data: i.progress_data,
+                    eta: i.output.average_duration
                 },
-                data: t.success ? t.output : null
+                data: i.success ? i.output : null
             };
         case "process_starts":
             return {
                 type: "update",
                     status: {
                         queue: !0,
                         stage: "pending",
-                        code: t.code,
-                        size: t.rank,
+                        code: i.code,
+                        size: i.rank,
                         position: 0,
-                        success: t.success
+                        success: i.success
                     }
             };
     }
     return {
         type: "none",
         status: {
             stage: "error",
             queue: !0
         }
     };
 }
+const {
+    SvelteComponent: SvelteComponent$2,
+    append: append$2,
+    attr: attr$2,
+    binding_callbacks: binding_callbacks$1,
+    bubble,
+    create_slot,
+    detach: detach$2,
+    element: element$2,
+    get_all_dirty_from_scope,
+    get_slot_changes,
+    init: init$2,
+    insert: insert$2,
+    listen,
+    prevent_default,
+    run_all,
+    safe_not_equal: safe_not_equal$2,
+    space: space$2,
+    stop_propagation,
+    toggle_class: toggle_class$1,
+    transition_in: transition_in$2,
+    transition_out: transition_out$2,
+    update_slot_base
+} = window.__gradio__svelte__internal, {
+    createEventDispatcher: createEventDispatcher$1,
+    tick: tick$1,
+    getContext
+} = window.__gradio__svelte__internal;
 
-function getDefaultExportFromCjs(t) {
-    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
-}
-
-function getAugmentedNamespace(t) {
-    if (t.__esModule)
-        return t;
-    var e = t.default;
-    if (typeof e == "function") {
-        var i = function n() {
-            if (this instanceof n) {
-                var s = [null];
-                s.push.apply(s, arguments);
-                var l = Function.bind.apply(e, s);
-                return new l();
-            }
-            return e.apply(this, arguments);
-        };
-        i.prototype = e.prototype;
-    } else
-        i = {};
-    return Object.defineProperty(i, "__esModule", {
-        value: !0
-    }), Object.keys(t).forEach(function(n) {
-        var s = Object.getOwnPropertyDescriptor(t, n);
-        Object.defineProperty(i, n, s.get ? s : {
-            enumerable: !0,
-            get: function() {
-                return t[n];
-            }
-        });
-    }), i;
-}
-var isMergeableObject = function(e) {
-    return isNonNullObject(e) && !isSpecial(e);
-};
-
-function isNonNullObject(t) {
-    return !!t && typeof t == "object";
-}
-
-function isSpecial(t) {
-    var e = Object.prototype.toString.call(t);
-    return e === "[object RegExp]" || e === "[object Date]" || isReactElement(t);
-}
-var canUseSymbol = typeof Symbol == "function" && Symbol.for,
-    REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
-
-function isReactElement(t) {
-    return t.$$typeof === REACT_ELEMENT_TYPE;
-}
-
-function emptyTarget(t) {
-    return Array.isArray(t) ? [] : {};
-}
-
-function cloneUnlessOtherwiseSpecified(t, e) {
-    return e.clone !== !1 && e.isMergeableObject(t) ? deepmerge(emptyTarget(t), t, e) : t;
-}
-
-function defaultArrayMerge(t, e, i) {
-    return t.concat(e).map(function(n) {
-        return cloneUnlessOtherwiseSpecified(n, i);
-    });
-}
-
-function getMergeFunction(t, e) {
-    if (!e.customMerge)
-        return deepmerge;
-    var i = e.customMerge(t);
-    return typeof i == "function" ? i : deepmerge;
-}
-
-function getEnumerableOwnPropertySymbols(t) {
-    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(t).filter(function(e) {
-        return Object.propertyIsEnumerable.call(t, e);
-    }) : [];
-}
-
-function getKeys(t) {
-    return Object.keys(t).concat(getEnumerableOwnPropertySymbols(t));
-}
-
-function propertyIsOnObject(t, e) {
-    try {
-        return e in t;
-    } catch {
-        return !1;
-    }
-}
-
-function propertyIsUnsafe(t, e) {
-    return propertyIsOnObject(t, e) && !(Object.hasOwnProperty.call(t, e) && Object.propertyIsEnumerable.call(t, e));
-}
-
-function mergeObject(t, e, i) {
-    var n = {};
-    return i.isMergeableObject(t) && getKeys(t).forEach(function(s) {
-        n[s] = cloneUnlessOtherwiseSpecified(t[s], i);
-    }), getKeys(e).forEach(function(s) {
-        propertyIsUnsafe(t, s) || (propertyIsOnObject(t, s) && i.isMergeableObject(e[s]) ? n[s] = getMergeFunction(s, i)(t[s], e[s], i) : n[s] = cloneUnlessOtherwiseSpecified(e[s], i));
-    }), n;
-}
-
-function deepmerge(t, e, i) {
-    i = i || {}, i.arrayMerge = i.arrayMerge || defaultArrayMerge, i.isMergeableObject = i.isMergeableObject || isMergeableObject, i.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
-    var n = Array.isArray(e),
-        s = Array.isArray(t),
-        l = n === s;
-    return l ? n ? i.arrayMerge(t, e, i) : mergeObject(t, e, i) : cloneUnlessOtherwiseSpecified(e, i);
-}
-deepmerge.all = function(e, i) {
-    if (!Array.isArray(e))
-        throw new Error("first argument should be an array");
-    return e.reduce(function(n, s) {
-        return deepmerge(n, s, i);
-    }, {});
-};
-var deepmerge_1 = deepmerge,
-    cjs = deepmerge_1;
-const deepmerge$1 = /* @__PURE__ */ getDefaultExportFromCjs(cjs);
-var extendStatics = function(t, e) {
-    return extendStatics = Object.setPrototypeOf || {
-        __proto__: []
-    }
-    instanceof Array && function(i, n) {
-        i.__proto__ = n;
-    } || function(i, n) {
-        for (var s in n)
-            Object.prototype.hasOwnProperty.call(n, s) && (i[s] = n[s]);
-    }, extendStatics(t, e);
-};
-
-function __extends(t, e) {
-    if (typeof e != "function" && e !== null)
-        throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
-    extendStatics(t, e);
-
-    function i() {
-        this.constructor = t;
-    }
-    t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
-}
-var __assign = function() {
-    return __assign = Object.assign || function(e) {
-        for (var i, n = 1, s = arguments.length; n < s; n++) {
-            i = arguments[n];
-            for (var l in i)
-                Object.prototype.hasOwnProperty.call(i, l) && (e[l] = i[l]);
-        }
-        return e;
-    }, __assign.apply(this, arguments);
-};
-
-function __spreadArray(t, e, i) {
-    if (i || arguments.length === 2)
-        for (var n = 0, s = e.length, l; n < s; n++)
-            (l || !(n in e)) && (l || (l = Array.prototype.slice.call(e, 0, n)), l[n] = e[n]);
-    return t.concat(l || Array.prototype.slice.call(e));
-}
-typeof SuppressedError == "function" && SuppressedError;
-var ErrorKind;
-(function(t) {
-    t[t.EXPECT_ARGUMENT_CLOSING_BRACE = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE", t[t.EMPTY_ARGUMENT = 2] = "EMPTY_ARGUMENT", t[t.MALFORMED_ARGUMENT = 3] = "MALFORMED_ARGUMENT", t[t.EXPECT_ARGUMENT_TYPE = 4] = "EXPECT_ARGUMENT_TYPE", t[t.INVALID_ARGUMENT_TYPE = 5] = "INVALID_ARGUMENT_TYPE", t[t.EXPECT_ARGUMENT_STYLE = 6] = "EXPECT_ARGUMENT_STYLE", t[t.INVALID_NUMBER_SKELETON = 7] = "INVALID_NUMBER_SKELETON", t[t.INVALID_DATE_TIME_SKELETON = 8] = "INVALID_DATE_TIME_SKELETON", t[t.EXPECT_NUMBER_SKELETON = 9] = "EXPECT_NUMBER_SKELETON", t[t.EXPECT_DATE_TIME_SKELETON = 10] = "EXPECT_DATE_TIME_SKELETON", t[t.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE", t[t.EXPECT_SELECT_ARGUMENT_OPTIONS = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS", t[t.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE", t[t.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE", t[t.EXPECT_SELECT_ARGUMENT_SELECTOR = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR", t[t.EXPECT_PLURAL_ARGUMENT_SELECTOR = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR", t[t.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT", t[t.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT", t[t.INVALID_PLURAL_ARGUMENT_SELECTOR = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR", t[t.DUPLICATE_PLURAL_ARGUMENT_SELECTOR = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR", t[t.DUPLICATE_SELECT_ARGUMENT_SELECTOR = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR", t[t.MISSING_OTHER_CLAUSE = 22] = "MISSING_OTHER_CLAUSE", t[t.INVALID_TAG = 23] = "INVALID_TAG", t[t.INVALID_TAG_NAME = 25] = "INVALID_TAG_NAME", t[t.UNMATCHED_CLOSING_TAG = 26] = "UNMATCHED_CLOSING_TAG", t[t.UNCLOSED_TAG = 27] = "UNCLOSED_TAG";
-})(ErrorKind || (ErrorKind = {}));
-var TYPE;
-(function(t) {
-    t[t.literal = 0] = "literal", t[t.argument = 1] = "argument", t[t.number = 2] = "number", t[t.date = 3] = "date", t[t.time = 4] = "time", t[t.select = 5] = "select", t[t.plural = 6] = "plural", t[t.pound = 7] = "pound", t[t.tag = 8] = "tag";
-})(TYPE || (TYPE = {}));
-var SKELETON_TYPE;
-(function(t) {
-    t[t.number = 0] = "number", t[t.dateTime = 1] = "dateTime";
-})(SKELETON_TYPE || (SKELETON_TYPE = {}));
-
-function isLiteralElement(t) {
-    return t.type === TYPE.literal;
-}
-
-function isArgumentElement(t) {
-    return t.type === TYPE.argument;
-}
-
-function isNumberElement(t) {
-    return t.type === TYPE.number;
-}
-
-function isDateElement(t) {
-    return t.type === TYPE.date;
-}
-
-function isTimeElement(t) {
-    return t.type === TYPE.time;
-}
-
-function isSelectElement(t) {
-    return t.type === TYPE.select;
-}
-
-function isPluralElement(t) {
-    return t.type === TYPE.plural;
-}
-
-function isPoundElement(t) {
-    return t.type === TYPE.pound;
-}
-
-function isTagElement(t) {
-    return t.type === TYPE.tag;
-}
-
-function isNumberSkeleton(t) {
-    return !!(t && typeof t == "object" && t.type === SKELETON_TYPE.number);
-}
-
-function isDateTimeSkeleton(t) {
-    return !!(t && typeof t == "object" && t.type === SKELETON_TYPE.dateTime);
-}
-var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/,
-    DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
-
-function parseDateTimeSkeleton(t) {
-    var e = {};
-    return t.replace(DATE_TIME_REGEX, function(i) {
-        var n = i.length;
-        switch (i[0]) {
-            case "G":
-                e.era = n === 4 ? "long" : n === 5 ? "narrow" : "short";
-                break;
-            case "y":
-                e.year = n === 2 ? "2-digit" : "numeric";
-                break;
-            case "Y":
-            case "u":
-            case "U":
-            case "r":
-                throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
-            case "q":
-            case "Q":
-                throw new RangeError("`q/Q` (quarter) patterns are not supported");
-            case "M":
-            case "L":
-                e.month = ["numeric", "2-digit", "short", "long", "narrow"][n - 1];
-                break;
-            case "w":
-            case "W":
-                throw new RangeError("`w/W` (week) patterns are not supported");
-            case "d":
-                e.day = ["numeric", "2-digit"][n - 1];
-                break;
-            case "D":
-            case "F":
-            case "g":
-                throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
-            case "E":
-                e.weekday = n === 4 ? "short" : n === 5 ? "narrow" : "short";
-                break;
-            case "e":
-                if (n < 4)
-                    throw new RangeError("`e..eee` (weekday) patterns are not supported");
-                e.weekday = ["short", "long", "narrow", "short"][n - 4];
-                break;
-            case "c":
-                if (n < 4)
-                    throw new RangeError("`c..ccc` (weekday) patterns are not supported");
-                e.weekday = ["short", "long", "narrow", "short"][n - 4];
-                break;
-            case "a":
-                e.hour12 = !0;
-                break;
-            case "b":
-            case "B":
-                throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
-            case "h":
-                e.hourCycle = "h12", e.hour = ["numeric", "2-digit"][n - 1];
-                break;
-            case "H":
-                e.hourCycle = "h23", e.hour = ["numeric", "2-digit"][n - 1];
-                break;
-            case "K":
-                e.hourCycle = "h11", e.hour = ["numeric", "2-digit"][n - 1];
-                break;
-            case "k":
-                e.hourCycle = "h24", e.hour = ["numeric", "2-digit"][n - 1];
-                break;
-            case "j":
-            case "J":
-            case "C":
-                throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
-            case "m":
-                e.minute = ["numeric", "2-digit"][n - 1];
-                break;
-            case "s":
-                e.second = ["numeric", "2-digit"][n - 1];
-                break;
-            case "S":
-            case "A":
-                throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
-            case "z":
-                e.timeZoneName = n < 4 ? "short" : "long";
-                break;
-            case "Z":
-            case "O":
-            case "v":
-            case "V":
-            case "X":
-            case "x":
-                throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");
-        }
-        return "";
-    }), e;
-}
-var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;
-
-function parseNumberSkeletonFromString(t) {
-    if (t.length === 0)
-        throw new Error("Number skeleton cannot be empty");
-    for (var e = t.split(WHITE_SPACE_REGEX).filter(function(S) {
-            return S.length > 0;
-        }), i = [], n = 0, s = e; n < s.length; n++) {
-        var l = s[n],
-            h = l.split("/");
-        if (h.length === 0)
-            throw new Error("Invalid number skeleton");
-        for (var _ = h[0], c = h.slice(1), o = 0, r = c; o < r.length; o++) {
-            var T = r[o];
-            if (T.length === 0)
-                throw new Error("Invalid number skeleton");
-        }
-        i.push({
-            stem: _,
-            options: c
-        });
-    }
-    return i;
-}
-
-function icuUnitToEcma(t) {
-    return t.replace(/^(.*?)-/, "");
-}
-var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g,
-    SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g,
-    INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g,
-    CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
-
-function parseSignificantPrecision(t) {
-    var e = {};
-    return t[t.length - 1] === "r" ? e.roundingPriority = "morePrecision" : t[t.length - 1] === "s" && (e.roundingPriority = "lessPrecision"), t.replace(SIGNIFICANT_PRECISION_REGEX, function(i, n, s) {
-        return typeof s != "string" ? (e.minimumSignificantDigits = n.length, e.maximumSignificantDigits = n.length) : s === "+" ? e.minimumSignificantDigits = n.length : n[0] === "#" ? e.maximumSignificantDigits = n.length : (e.minimumSignificantDigits = n.length, e.maximumSignificantDigits = n.length + (typeof s == "string" ? s.length : 0)), "";
-    }), e;
-}
-
-function parseSign(t) {
-    switch (t) {
-        case "sign-auto":
-            return {
-                signDisplay: "auto"
-            };
-        case "sign-accounting":
-        case "()":
-            return {
-                currencySign: "accounting"
-            };
-        case "sign-always":
-        case "+!":
-            return {
-                signDisplay: "always"
-            };
-        case "sign-accounting-always":
-        case "()!":
-            return {
-                signDisplay: "always",
-                    currencySign: "accounting"
-            };
-        case "sign-except-zero":
-        case "+?":
-            return {
-                signDisplay: "exceptZero"
-            };
-        case "sign-accounting-except-zero":
-        case "()?":
-            return {
-                signDisplay: "exceptZero",
-                    currencySign: "accounting"
-            };
-        case "sign-never":
-        case "+_":
-            return {
-                signDisplay: "never"
-            };
-    }
-}
-
-function parseConciseScientificAndEngineeringStem(t) {
-    var e;
-    if (t[0] === "E" && t[1] === "E" ? (e = {
-            notation: "engineering"
-        }, t = t.slice(2)) : t[0] === "E" && (e = {
-            notation: "scientific"
-        }, t = t.slice(1)), e) {
-        var i = t.slice(0, 2);
-        if (i === "+!" ? (e.signDisplay = "always", t = t.slice(2)) : i === "+?" && (e.signDisplay = "exceptZero", t = t.slice(2)), !CONCISE_INTEGER_WIDTH_REGEX.test(t))
-            throw new Error("Malformed concise eng/scientific notation");
-        e.minimumIntegerDigits = t.length;
-    }
-    return e;
-}
-
-function parseNotationOptions(t) {
-    var e = {},
-        i = parseSign(t);
-    return i || e;
-}
-
-function parseNumberSkeleton(t) {
-    for (var e = {}, i = 0, n = t; i < n.length; i++) {
-        var s = n[i];
-        switch (s.stem) {
-            case "percent":
-            case "%":
-                e.style = "percent";
-                continue;
-            case "%x100":
-                e.style = "percent", e.scale = 100;
-                continue;
-            case "currency":
-                e.style = "currency", e.currency = s.options[0];
-                continue;
-            case "group-off":
-            case ",_":
-                e.useGrouping = !1;
-                continue;
-            case "precision-integer":
-            case ".":
-                e.maximumFractionDigits = 0;
-                continue;
-            case "measure-unit":
-            case "unit":
-                e.style = "unit", e.unit = icuUnitToEcma(s.options[0]);
-                continue;
-            case "compact-short":
-            case "K":
-                e.notation = "compact", e.compactDisplay = "short";
-                continue;
-            case "compact-long":
-            case "KK":
-                e.notation = "compact", e.compactDisplay = "long";
-                continue;
-            case "scientific":
-                e = __assign(__assign(__assign({}, e), {
-                    notation: "scientific"
-                }), s.options.reduce(function(c, o) {
-                    return __assign(__assign({}, c), parseNotationOptions(o));
-                }, {}));
-                continue;
-            case "engineering":
-                e = __assign(__assign(__assign({}, e), {
-                    notation: "engineering"
-                }), s.options.reduce(function(c, o) {
-                    return __assign(__assign({}, c), parseNotationOptions(o));
-                }, {}));
-                continue;
-            case "notation-simple":
-                e.notation = "standard";
-                continue;
-            case "unit-width-narrow":
-                e.currencyDisplay = "narrowSymbol", e.unitDisplay = "narrow";
-                continue;
-            case "unit-width-short":
-                e.currencyDisplay = "code", e.unitDisplay = "short";
-                continue;
-            case "unit-width-full-name":
-                e.currencyDisplay = "name", e.unitDisplay = "long";
-                continue;
-            case "unit-width-iso-code":
-                e.currencyDisplay = "symbol";
-                continue;
-            case "scale":
-                e.scale = parseFloat(s.options[0]);
-                continue;
-            case "integer-width":
-                if (s.options.length > 1)
-                    throw new RangeError("integer-width stems only accept a single optional option");
-                s.options[0].replace(INTEGER_WIDTH_REGEX, function(c, o, r, T, S, w) {
-                    if (o)
-                        e.minimumIntegerDigits = r.length;
-                    else {
-                        if (T && S)
-                            throw new Error("We currently do not support maximum integer digits");
-                        if (w)
-                            throw new Error("We currently do not support exact integer digits");
-                    }
-                    return "";
-                });
-                continue;
-        }
-        if (CONCISE_INTEGER_WIDTH_REGEX.test(s.stem)) {
-            e.minimumIntegerDigits = s.stem.length;
-            continue;
-        }
-        if (FRACTION_PRECISION_REGEX.test(s.stem)) {
-            if (s.options.length > 1)
-                throw new RangeError("Fraction-precision stems only accept a single optional option");
-            s.stem.replace(FRACTION_PRECISION_REGEX, function(c, o, r, T, S, w) {
-                return r === "*" ? e.minimumFractionDigits = o.length : T && T[0] === "#" ? e.maximumFractionDigits = T.length : S && w ? (e.minimumFractionDigits = S.length, e.maximumFractionDigits = S.length + w.length) : (e.minimumFractionDigits = o.length, e.maximumFractionDigits = o.length), "";
-            });
-            var l = s.options[0];
-            l === "w" ? e = __assign(__assign({}, e), {
-                trailingZeroDisplay: "stripIfInteger"
-            }) : l && (e = __assign(__assign({}, e), parseSignificantPrecision(l)));
-            continue;
-        }
-        if (SIGNIFICANT_PRECISION_REGEX.test(s.stem)) {
-            e = __assign(__assign({}, e), parseSignificantPrecision(s.stem));
-            continue;
-        }
-        var h = parseSign(s.stem);
-        h && (e = __assign(__assign({}, e), h));
-        var _ = parseConciseScientificAndEngineeringStem(s.stem);
-        _ && (e = __assign(__assign({}, e), _));
-    }
-    return e;
-}
-var timeData = {
-    AX: [
-        "H"
-    ],
-    BQ: [
-        "H"
-    ],
-    CP: [
-        "H"
-    ],
-    CZ: [
-        "H"
-    ],
-    DK: [
-        "H"
-    ],
-    FI: [
-        "H"
-    ],
-    ID: [
-        "H"
-    ],
-    IS: [
-        "H"
-    ],
-    ML: [
-        "H"
-    ],
-    NE: [
-        "H"
-    ],
-    RU: [
-        "H"
-    ],
-    SE: [
-        "H"
-    ],
-    SJ: [
-        "H"
-    ],
-    SK: [
-        "H"
-    ],
-    AS: [
-        "h",
-        "H"
-    ],
-    BT: [
-        "h",
-        "H"
-    ],
-    DJ: [
-        "h",
-        "H"
-    ],
-    ER: [
-        "h",
-        "H"
-    ],
-    GH: [
-        "h",
-        "H"
-    ],
-    IN: [
-        "h",
-        "H"
-    ],
-    LS: [
-        "h",
-        "H"
-    ],
-    PG: [
-        "h",
-        "H"
-    ],
-    PW: [
-        "h",
-        "H"
-    ],
-    SO: [
-        "h",
-        "H"
-    ],
-    TO: [
-        "h",
-        "H"
-    ],
-    VU: [
-        "h",
-        "H"
-    ],
-    WS: [
-        "h",
-        "H"
-    ],
-    "001": [
-        "H",
-        "h"
-    ],
-    AL: [
-        "h",
-        "H",
-        "hB"
-    ],
-    TD: [
-        "h",
-        "H",
-        "hB"
-    ],
-    "ca-ES": [
-        "H",
-        "h",
-        "hB"
-    ],
-    CF: [
-        "H",
-        "h",
-        "hB"
-    ],
-    CM: [
-        "H",
-        "h",
-        "hB"
-    ],
-    "fr-CA": [
-        "H",
-        "h",
-        "hB"
-    ],
-    "gl-ES": [
-        "H",
-        "h",
-        "hB"
-    ],
-    "it-CH": [
-        "H",
-        "h",
-        "hB"
-    ],
-    "it-IT": [
-        "H",
-        "h",
-        "hB"
-    ],
-    LU: [
-        "H",
-        "h",
-        "hB"
-    ],
-    NP: [
-        "H",
-        "h",
-        "hB"
-    ],
-    PF: [
-        "H",
-        "h",
-        "hB"
-    ],
-    SC: [
-        "H",
-        "h",
-        "hB"
-    ],
-    SM: [
-        "H",
-        "h",
-        "hB"
-    ],
-    SN: [
-        "H",
-        "h",
-        "hB"
-    ],
-    TF: [
-        "H",
-        "h",
-        "hB"
-    ],
-    VA: [
-        "H",
-        "h",
-        "hB"
-    ],
-    CY: [
-        "h",
-        "H",
-        "hb",
-        "hB"
-    ],
-    GR: [
-        "h",
-        "H",
-        "hb",
-        "hB"
-    ],
-    CO: [
-        "h",
-        "H",
-        "hB",
-        "hb"
-    ],
-    DO: [
-        "h",
-        "H",
-        "hB",
-        "hb"
-    ],
-    KP: [
-        "h",
-        "H",
-        "hB",
-        "hb"
-    ],
-    KR: [
-        "h",
-        "H",
-        "hB",
-        "hb"
-    ],
-    NA: [
-        "h",
-        "H",
-        "hB",
-        "hb"
-    ],
-    PA: [
-        "h",
-        "H",
-        "hB",
-        "hb"
-    ],
-    PR: [
-        "h",
-        "H",
-        "hB",
-        "hb"
-    ],
-    VE: [
-        "h",
-        "H",
-        "hB",
-        "hb"
-    ],
-    AC: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    AI: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    BW: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    BZ: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    CC: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    CK: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    CX: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    DG: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    FK: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    GB: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    GG: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    GI: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    IE: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    IM: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    IO: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    JE: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    LT: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    MK: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    MN: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    MS: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    NF: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    NG: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    NR: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    NU: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    PN: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    SH: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    SX: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    TA: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    ZA: [
-        "H",
-        "h",
-        "hb",
-        "hB"
-    ],
-    "af-ZA": [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    AR: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    CL: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    CR: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    CU: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    EA: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    "es-BO": [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    "es-BR": [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    "es-EC": [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    "es-ES": [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    "es-GQ": [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    "es-PE": [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    GT: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    HN: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    IC: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    KG: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    KM: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    LK: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    MA: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    MX: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    NI: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    PY: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    SV: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    UY: [
-        "H",
-        "h",
-        "hB",
-        "hb"
-    ],
-    JP: [
-        "H",
-        "h",
-        "K"
-    ],
-    AD: [
-        "H",
-        "hB"
-    ],
-    AM: [
-        "H",
-        "hB"
-    ],
-    AO: [
-        "H",
-        "hB"
-    ],
-    AT: [
-        "H",
-        "hB"
-    ],
-    AW: [
-        "H",
-        "hB"
-    ],
-    BE: [
-        "H",
-        "hB"
-    ],
-    BF: [
-        "H",
-        "hB"
-    ],
-    BJ: [
-        "H",
-        "hB"
-    ],
-    BL: [
-        "H",
-        "hB"
-    ],
-    BR: [
-        "H",
-        "hB"
-    ],
-    CG: [
-        "H",
-        "hB"
-    ],
-    CI: [
-        "H",
-        "hB"
-    ],
-    CV: [
-        "H",
-        "hB"
-    ],
-    DE: [
-        "H",
-        "hB"
-    ],
-    EE: [
-        "H",
-        "hB"
-    ],
-    FR: [
-        "H",
-        "hB"
-    ],
-    GA: [
-        "H",
-        "hB"
-    ],
-    GF: [
-        "H",
-        "hB"
-    ],
-    GN: [
-        "H",
-        "hB"
-    ],
-    GP: [
-        "H",
-        "hB"
-    ],
-    GW: [
-        "H",
-        "hB"
-    ],
-    HR: [
-        "H",
-        "hB"
-    ],
-    IL: [
-        "H",
-        "hB"
-    ],
-    IT: [
-        "H",
-        "hB"
-    ],
-    KZ: [
-        "H",
-        "hB"
-    ],
-    MC: [
-        "H",
-        "hB"
-    ],
-    MD: [
-        "H",
-        "hB"
-    ],
-    MF: [
-        "H",
-        "hB"
-    ],
-    MQ: [
-        "H",
-        "hB"
-    ],
-    MZ: [
-        "H",
-        "hB"
-    ],
-    NC: [
-        "H",
-        "hB"
-    ],
-    NL: [
-        "H",
-        "hB"
-    ],
-    PM: [
-        "H",
-        "hB"
-    ],
-    PT: [
-        "H",
-        "hB"
-    ],
-    RE: [
-        "H",
-        "hB"
-    ],
-    RO: [
-        "H",
-        "hB"
-    ],
-    SI: [
-        "H",
-        "hB"
-    ],
-    SR: [
-        "H",
-        "hB"
-    ],
-    ST: [
-        "H",
-        "hB"
-    ],
-    TG: [
-        "H",
-        "hB"
-    ],
-    TR: [
-        "H",
-        "hB"
-    ],
-    WF: [
-        "H",
-        "hB"
-    ],
-    YT: [
-        "H",
-        "hB"
-    ],
-    BD: [
-        "h",
-        "hB",
-        "H"
-    ],
-    PK: [
-        "h",
-        "hB",
-        "H"
-    ],
-    AZ: [
-        "H",
-        "hB",
-        "h"
-    ],
-    BA: [
-        "H",
-        "hB",
-        "h"
-    ],
-    BG: [
-        "H",
-        "hB",
-        "h"
-    ],
-    CH: [
-        "H",
-        "hB",
-        "h"
-    ],
-    GE: [
-        "H",
-        "hB",
-        "h"
-    ],
-    LI: [
-        "H",
-        "hB",
-        "h"
-    ],
-    ME: [
-        "H",
-        "hB",
-        "h"
-    ],
-    RS: [
-        "H",
-        "hB",
-        "h"
-    ],
-    UA: [
-        "H",
-        "hB",
-        "h"
-    ],
-    UZ: [
-        "H",
-        "hB",
-        "h"
-    ],
-    XK: [
-        "H",
-        "hB",
-        "h"
-    ],
-    AG: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    AU: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    BB: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    BM: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    BS: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    CA: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    DM: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    "en-001": [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    FJ: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    FM: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    GD: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    GM: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    GU: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    GY: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    JM: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    KI: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    KN: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    KY: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    LC: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    LR: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    MH: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    MP: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    MW: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    NZ: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    SB: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    SG: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    SL: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    SS: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    SZ: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    TC: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    TT: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    UM: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    US: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    VC: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    VG: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    VI: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    ZM: [
-        "h",
-        "hb",
-        "H",
-        "hB"
-    ],
-    BO: [
-        "H",
-        "hB",
-        "h",
-        "hb"
-    ],
-    EC: [
-        "H",
-        "hB",
-        "h",
-        "hb"
-    ],
-    ES: [
-        "H",
-        "hB",
-        "h",
-        "hb"
-    ],
-    GQ: [
-        "H",
-        "hB",
-        "h",
-        "hb"
-    ],
-    PE: [
-        "H",
-        "hB",
-        "h",
-        "hb"
-    ],
-    AE: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    "ar-001": [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    BH: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    DZ: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    EG: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    EH: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    HK: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    IQ: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    JO: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    KW: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    LB: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    LY: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    MO: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    MR: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    OM: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    PH: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    PS: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    QA: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    SA: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    SD: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    SY: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    TN: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    YE: [
-        "h",
-        "hB",
-        "hb",
-        "H"
-    ],
-    AF: [
-        "H",
-        "hb",
-        "hB",
-        "h"
-    ],
-    LA: [
-        "H",
-        "hb",
-        "hB",
-        "h"
-    ],
-    CN: [
-        "H",
-        "hB",
-        "hb",
-        "h"
-    ],
-    LV: [
-        "H",
-        "hB",
-        "hb",
-        "h"
-    ],
-    TL: [
-        "H",
-        "hB",
-        "hb",
-        "h"
-    ],
-    "zu-ZA": [
-        "H",
-        "hB",
-        "hb",
-        "h"
-    ],
-    CD: [
-        "hB",
-        "H"
-    ],
-    IR: [
-        "hB",
-        "H"
-    ],
-    "hi-IN": [
-        "hB",
-        "h",
-        "H"
-    ],
-    "kn-IN": [
-        "hB",
-        "h",
-        "H"
-    ],
-    "ml-IN": [
-        "hB",
-        "h",
-        "H"
-    ],
-    "te-IN": [
-        "hB",
-        "h",
-        "H"
-    ],
-    KH: [
-        "hB",
-        "h",
-        "H",
-        "hb"
-    ],
-    "ta-IN": [
-        "hB",
-        "h",
-        "hb",
-        "H"
-    ],
-    BN: [
-        "hb",
-        "hB",
-        "h",
-        "H"
-    ],
-    MY: [
-        "hb",
-        "hB",
-        "h",
-        "H"
-    ],
-    ET: [
-        "hB",
-        "hb",
-        "h",
-        "H"
-    ],
-    "gu-IN": [
-        "hB",
-        "hb",
-        "h",
-        "H"
-    ],
-    "mr-IN": [
-        "hB",
-        "hb",
-        "h",
-        "H"
-    ],
-    "pa-IN": [
-        "hB",
-        "hb",
-        "h",
-        "H"
-    ],
-    TW: [
-        "hB",
-        "hb",
-        "h",
-        "H"
-    ],
-    KE: [
-        "hB",
-        "hb",
-        "H",
-        "h"
-    ],
-    MM: [
-        "hB",
-        "hb",
-        "H",
-        "h"
-    ],
-    TZ: [
-        "hB",
-        "hb",
-        "H",
-        "h"
-    ],
-    UG: [
-        "hB",
-        "hb",
-        "H",
-        "h"
-    ]
-};
-
-function getBestPattern(t, e) {
-    for (var i = "", n = 0; n < t.length; n++) {
-        var s = t.charAt(n);
-        if (s === "j") {
-            for (var l = 0; n + 1 < t.length && t.charAt(n + 1) === s;)
-                l++, n++;
-            var h = 1 + (l & 1),
-                _ = l < 2 ? 1 : 3 + (l >> 1),
-                c = "a",
-                o = getDefaultHourSymbolFromLocale(e);
-            for ((o == "H" || o == "k") && (_ = 0); _-- > 0;)
-                i += c;
-            for (; h-- > 0;)
-                i = o + i;
-        } else
-            s === "J" ? i += "H" : i += s;
-    }
-    return i;
-}
-
-function getDefaultHourSymbolFromLocale(t) {
-    var e = t.hourCycle;
-    if (e === void 0 && // @ts-ignore hourCycle(s) is not identified yet
-        t.hourCycles && // @ts-ignore
-        t.hourCycles.length && (e = t.hourCycles[0]), e)
-        switch (e) {
-            case "h24":
-                return "k";
-            case "h23":
-                return "H";
-            case "h12":
-                return "h";
-            case "h11":
-                return "K";
-            default:
-                throw new Error("Invalid hourCycle");
-        }
-    var i = t.language,
-        n;
-    i !== "root" && (n = t.maximize().region);
-    var s = timeData[n || ""] || timeData[i || ""] || timeData["".concat(i, "-001")] || timeData["001"];
-    return s[0];
-}
-var _a, SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*")),
-    SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
-
-function createLocation(t, e) {
-    return {
-        start: t,
-        end: e
-    };
-}
-var hasNativeStartsWith = !!String.prototype.startsWith,
-    hasNativeFromCodePoint = !!String.fromCodePoint,
-    hasNativeFromEntries = !!Object.fromEntries,
-    hasNativeCodePointAt = !!String.prototype.codePointAt,
-    hasTrimStart = !!String.prototype.trimStart,
-    hasTrimEnd = !!String.prototype.trimEnd,
-    hasNativeIsSafeInteger = !!Number.isSafeInteger,
-    isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function(t) {
-        return typeof t == "number" && isFinite(t) && Math.floor(t) === t && Math.abs(t) <= 9007199254740991;
-    },
-    REGEX_SUPPORTS_U_AND_Y = !0;
-try {
-    var re = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
-    REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec("a")) === null || _a === void 0 ? void 0 : _a[0]) === "a";
-} catch {
-    REGEX_SUPPORTS_U_AND_Y = !1;
-}
-var startsWith = hasNativeStartsWith ? (
-        // Native
-        function(e, i, n) {
-            return e.startsWith(i, n);
-        }
-    ) : (
-        // For IE11
-        function(e, i, n) {
-            return e.slice(n, n + i.length) === i;
-        }
-    ),
-    fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : (
-        // IE11
-        function() {
-            for (var e = [], i = 0; i < arguments.length; i++)
-                e[i] = arguments[i];
-            for (var n = "", s = e.length, l = 0, h; s > l;) {
-                if (h = e[l++], h > 1114111)
-                    throw RangeError(h + " is not a valid code point");
-                n += h < 65536 ? String.fromCharCode(h) : String.fromCharCode(((h -= 65536) >> 10) + 55296, h % 1024 + 56320);
-            }
-            return n;
-        }
-    ),
-    fromEntries = (
-        // native
-        hasNativeFromEntries ? Object.fromEntries : (
-            // Ponyfill
-            function(e) {
-                for (var i = {}, n = 0, s = e; n < s.length; n++) {
-                    var l = s[n],
-                        h = l[0],
-                        _ = l[1];
-                    i[h] = _;
-                }
-                return i;
-            }
-        )
-    ),
-    codePointAt = hasNativeCodePointAt ? (
-        // Native
-        function(e, i) {
-            return e.codePointAt(i);
-        }
-    ) : (
-        // IE 11
-        function(e, i) {
-            var n = e.length;
-            if (!(i < 0 || i >= n)) {
-                var s = e.charCodeAt(i),
-                    l;
-                return s < 55296 || s > 56319 || i + 1 === n || (l = e.charCodeAt(i + 1)) < 56320 || l > 57343 ? s : (s - 55296 << 10) + (l - 56320) + 65536;
-            }
-        }
-    ),
-    trimStart = hasTrimStart ? (
-        // Native
-        function(e) {
-            return e.trimStart();
-        }
-    ) : (
-        // Ponyfill
-        function(e) {
-            return e.replace(SPACE_SEPARATOR_START_REGEX, "");
-        }
-    ),
-    trimEnd = hasTrimEnd ? (
-        // Native
-        function(e) {
-            return e.trimEnd();
-        }
-    ) : (
-        // Ponyfill
-        function(e) {
-            return e.replace(SPACE_SEPARATOR_END_REGEX, "");
-        }
-    );
-
-function RE(t, e) {
-    return new RegExp(t, e);
-}
-var matchIdentifierAtIndex;
-if (REGEX_SUPPORTS_U_AND_Y) {
-    var IDENTIFIER_PREFIX_RE_1 = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
-    matchIdentifierAtIndex = function(e, i) {
-        var n;
-        IDENTIFIER_PREFIX_RE_1.lastIndex = i;
-        var s = IDENTIFIER_PREFIX_RE_1.exec(e);
-        return (n = s[1]) !== null && n !== void 0 ? n : "";
-    };
-} else
-    matchIdentifierAtIndex = function(e, i) {
-        for (var n = [];;) {
-            var s = codePointAt(e, i);
-            if (s === void 0 || _isWhiteSpace(s) || _isPatternSyntax(s))
-                break;
-            n.push(s), i += s >= 65536 ? 2 : 1;
-        }
-        return fromCodePoint.apply(void 0, n);
-    };
-var Parser = (
-    /** @class */
-    function() {
-        function t(e, i) {
-            i === void 0 && (i = {}), this.message = e, this.position = {
-                offset: 0,
-                line: 1,
-                column: 1
-            }, this.ignoreTag = !!i.ignoreTag, this.locale = i.locale, this.requiresOtherClause = !!i.requiresOtherClause, this.shouldParseSkeletons = !!i.shouldParseSkeletons;
-        }
-        return t.prototype.parse = function() {
-            if (this.offset() !== 0)
-                throw Error("parser can only be used once");
-            return this.parseMessage(0, "", !1);
-        }, t.prototype.parseMessage = function(e, i, n) {
-            for (var s = []; !this.isEOF();) {
-                var l = this.char();
-                if (l === 123) {
-                    var h = this.parseArgument(e, n);
-                    if (h.err)
-                        return h;
-                    s.push(h.val);
-                } else {
-                    if (l === 125 && e > 0)
-                        break;
-                    if (l === 35 && (i === "plural" || i === "selectordinal")) {
-                        var _ = this.clonePosition();
-                        this.bump(), s.push({
-                            type: TYPE.pound,
-                            location: createLocation(_, this.clonePosition())
-                        });
-                    } else if (l === 60 && !this.ignoreTag && this.peek() === 47) {
-                        if (n)
-                            break;
-                        return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
-                    } else if (l === 60 && !this.ignoreTag && _isAlpha(this.peek() || 0)) {
-                        var h = this.parseTag(e, i);
-                        if (h.err)
-                            return h;
-                        s.push(h.val);
-                    } else {
-                        var h = this.parseLiteral(e, i);
-                        if (h.err)
-                            return h;
-                        s.push(h.val);
-                    }
-                }
-            }
-            return {
-                val: s,
-                err: null
-            };
-        }, t.prototype.parseTag = function(e, i) {
-            var n = this.clonePosition();
-            this.bump();
-            var s = this.parseTagName();
-            if (this.bumpSpace(), this.bumpIf("/>"))
-                return {
-                    val: {
-                        type: TYPE.literal,
-                        value: "<".concat(s, "/>"),
-                        location: createLocation(n, this.clonePosition())
-                    },
-                    err: null
-                };
-            if (this.bumpIf(">")) {
-                var l = this.parseMessage(e + 1, i, !0);
-                if (l.err)
-                    return l;
-                var h = l.val,
-                    _ = this.clonePosition();
-                if (this.bumpIf("</")) {
-                    if (this.isEOF() || !_isAlpha(this.char()))
-                        return this.error(ErrorKind.INVALID_TAG, createLocation(_, this.clonePosition()));
-                    var c = this.clonePosition(),
-                        o = this.parseTagName();
-                    return s !== o ? this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(c, this.clonePosition())) : (this.bumpSpace(), this.bumpIf(">") ? {
-                        val: {
-                            type: TYPE.tag,
-                            value: s,
-                            children: h,
-                            location: createLocation(n, this.clonePosition())
-                        },
-                        err: null
-                    } : this.error(ErrorKind.INVALID_TAG, createLocation(_, this.clonePosition())));
-                } else
-                    return this.error(ErrorKind.UNCLOSED_TAG, createLocation(n, this.clonePosition()));
-            } else
-                return this.error(ErrorKind.INVALID_TAG, createLocation(n, this.clonePosition()));
-        }, t.prototype.parseTagName = function() {
-            var e = this.offset();
-            for (this.bump(); !this.isEOF() && _isPotentialElementNameChar(this.char());)
-                this.bump();
-            return this.message.slice(e, this.offset());
-        }, t.prototype.parseLiteral = function(e, i) {
-            for (var n = this.clonePosition(), s = "";;) {
-                var l = this.tryParseQuote(i);
-                if (l) {
-                    s += l;
-                    continue;
-                }
-                var h = this.tryParseUnquoted(e, i);
-                if (h) {
-                    s += h;
-                    continue;
-                }
-                var _ = this.tryParseLeftAngleBracket();
-                if (_) {
-                    s += _;
-                    continue;
-                }
-                break;
-            }
-            var c = createLocation(n, this.clonePosition());
-            return {
-                val: {
-                    type: TYPE.literal,
-                    value: s,
-                    location: c
-                },
-                err: null
-            };
-        }, t.prototype.tryParseLeftAngleBracket = function() {
-            return !this.isEOF() && this.char() === 60 && (this.ignoreTag || // If at the opening tag or closing tag position, bail.
-                !_isAlphaOrSlash(this.peek() || 0)) ? (this.bump(), "<") : null;
-        }, t.prototype.tryParseQuote = function(e) {
-            if (this.isEOF() || this.char() !== 39)
-                return null;
-            switch (this.peek()) {
-                case 39:
-                    return this.bump(), this.bump(), "'";
-                case 123:
-                case 60:
-                case 62:
-                case 125:
-                    break;
-                case 35:
-                    if (e === "plural" || e === "selectordinal")
-                        break;
-                    return null;
-                default:
-                    return null;
-            }
-            this.bump();
-            var i = [this.char()];
-            for (this.bump(); !this.isEOF();) {
-                var n = this.char();
-                if (n === 39)
-                    if (this.peek() === 39)
-                        i.push(39), this.bump();
-                    else {
-                        this.bump();
-                        break;
-                    }
-                else
-                    i.push(n);
-                this.bump();
-            }
-            return fromCodePoint.apply(void 0, i);
-        }, t.prototype.tryParseUnquoted = function(e, i) {
-            if (this.isEOF())
-                return null;
-            var n = this.char();
-            return n === 60 || n === 123 || n === 35 && (i === "plural" || i === "selectordinal") || n === 125 && e > 0 ? null : (this.bump(), fromCodePoint(n));
-        }, t.prototype.parseArgument = function(e, i) {
-            var n = this.clonePosition();
-            if (this.bump(), this.bumpSpace(), this.isEOF())
-                return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(n, this.clonePosition()));
-            if (this.char() === 125)
-                return this.bump(), this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(n, this.clonePosition()));
-            var s = this.parseIdentifierIfPossible().value;
-            if (!s)
-                return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(n, this.clonePosition()));
-            if (this.bumpSpace(), this.isEOF())
-                return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(n, this.clonePosition()));
-            switch (this.char()) {
-                case 125:
-                    return this.bump(), {
-                        val: {
-                            type: TYPE.argument,
-                            // value does not include the opening and closing braces.
-                            value: s,
-                            location: createLocation(n, this.clonePosition())
-                        },
-                        err: null
-                    };
-                case 44:
-                    return this.bump(), this.bumpSpace(), this.isEOF() ? this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(n, this.clonePosition())) : this.parseArgumentOptions(e, i, s, n);
-                default:
-                    return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(n, this.clonePosition()));
-            }
-        }, t.prototype.parseIdentifierIfPossible = function() {
-            var e = this.clonePosition(),
-                i = this.offset(),
-                n = matchIdentifierAtIndex(this.message, i),
-                s = i + n.length;
-            this.bumpTo(s);
-            var l = this.clonePosition(),
-                h = createLocation(e, l);
-            return {
-                value: n,
-                location: h
-            };
-        }, t.prototype.parseArgumentOptions = function(e, i, n, s) {
-            var l, h = this.clonePosition(),
-                _ = this.parseIdentifierIfPossible().value,
-                c = this.clonePosition();
-            switch (_) {
-                case "":
-                    return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(h, c));
-                case "number":
-                case "date":
-                case "time": {
-                    this.bumpSpace();
-                    var o = null;
-                    if (this.bumpIf(",")) {
-                        this.bumpSpace();
-                        var r = this.clonePosition(),
-                            T = this.parseSimpleArgStyleIfPossible();
-                        if (T.err)
-                            return T;
-                        var S = trimEnd(T.val);
-                        if (S.length === 0)
-                            return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
-                        var w = createLocation(r, this.clonePosition());
-                        o = {
-                            style: S,
-                            styleLocation: w
-                        };
-                    }
-                    var C = this.tryParseArgumentClose(s);
-                    if (C.err)
-                        return C;
-                    var P = createLocation(s, this.clonePosition());
-                    if (o && startsWith(o == null ? void 0 : o.style, "::", 0)) {
-                        var b = trimStart(o.style.slice(2));
-                        if (_ === "number") {
-                            var T = this.parseNumberSkeletonFromString(b, o.styleLocation);
-                            return T.err ? T : {
-                                val: {
-                                    type: TYPE.number,
-                                    value: n,
-                                    location: P,
-                                    style: T.val
-                                },
-                                err: null
-                            };
-                        } else {
-                            if (b.length === 0)
-                                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, P);
-                            var k = b;
-                            this.locale && (k = getBestPattern(b, this.locale));
-                            var S = {
-                                    type: SKELETON_TYPE.dateTime,
-                                    pattern: k,
-                                    location: o.styleLocation,
-                                    parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(k) : {}
-                                },
-                                F = _ === "date" ? TYPE.date : TYPE.time;
-                            return {
-                                val: {
-                                    type: F,
-                                    value: n,
-                                    location: P,
-                                    style: S
-                                },
-                                err: null
-                            };
-                        }
-                    }
-                    return {
-                        val: {
-                            type: _ === "number" ? TYPE.number : _ === "date" ? TYPE.date : TYPE.time,
-                            value: n,
-                            location: P,
-                            style: (l = o == null ? void 0 : o.style) !== null && l !== void 0 ? l : null
-                        },
-                        err: null
-                    };
-                }
-                case "plural":
-                case "selectordinal":
-                case "select": {
-                    var x = this.clonePosition();
-                    if (this.bumpSpace(), !this.bumpIf(","))
-                        return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(x, __assign({}, x)));
-                    this.bumpSpace();
-                    var y = this.parseIdentifierIfPossible(),
-                        p = 0;
-                    if (_ !== "select" && y.value === "offset") {
-                        if (!this.bumpIf(":"))
-                            return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
-                        this.bumpSpace();
-                        var T = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
-                        if (T.err)
-                            return T;
-                        this.bumpSpace(), y = this.parseIdentifierIfPossible(), p = T.val;
-                    }
-                    var E = this.tryParsePluralOrSelectOptions(e, _, i, y);
-                    if (E.err)
-                        return E;
-                    var C = this.tryParseArgumentClose(s);
-                    if (C.err)
-                        return C;
-                    var $ = createLocation(s, this.clonePosition());
-                    return _ === "select" ? {
-                        val: {
-                            type: TYPE.select,
-                            value: n,
-                            options: fromEntries(E.val),
-                            location: $
-                        },
-                        err: null
-                    } : {
-                        val: {
-                            type: TYPE.plural,
-                            value: n,
-                            options: fromEntries(E.val),
-                            offset: p,
-                            pluralType: _ === "plural" ? "cardinal" : "ordinal",
-                            location: $
-                        },
-                        err: null
-                    };
-                }
-                default:
-                    return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(h, c));
-            }
-        }, t.prototype.tryParseArgumentClose = function(e) {
-            return this.isEOF() || this.char() !== 125 ? this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(e, this.clonePosition())) : (this.bump(), {
-                val: !0,
-                err: null
-            });
-        }, t.prototype.parseSimpleArgStyleIfPossible = function() {
-            for (var e = 0, i = this.clonePosition(); !this.isEOF();) {
-                var n = this.char();
-                switch (n) {
-                    case 39: {
-                        this.bump();
-                        var s = this.clonePosition();
-                        if (!this.bumpUntil("'"))
-                            return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(s, this.clonePosition()));
-                        this.bump();
-                        break;
-                    }
-                    case 123: {
-                        e += 1, this.bump();
-                        break;
-                    }
-                    case 125: {
-                        if (e > 0)
-                            e -= 1;
-                        else
-                            return {
-                                val: this.message.slice(i.offset, this.offset()),
-                                err: null
-                            };
-                        break;
-                    }
-                    default:
-                        this.bump();
-                        break;
-                }
-            }
-            return {
-                val: this.message.slice(i.offset, this.offset()),
-                err: null
-            };
-        }, t.prototype.parseNumberSkeletonFromString = function(e, i) {
-            var n = [];
-            try {
-                n = parseNumberSkeletonFromString(e);
-            } catch {
-                return this.error(ErrorKind.INVALID_NUMBER_SKELETON, i);
-            }
-            return {
-                val: {
-                    type: SKELETON_TYPE.number,
-                    tokens: n,
-                    location: i,
-                    parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(n) : {}
-                },
-                err: null
-            };
-        }, t.prototype.tryParsePluralOrSelectOptions = function(e, i, n, s) {
-            for (var l, h = !1, _ = [], c = /* @__PURE__ */ new Set(), o = s.value, r = s.location;;) {
-                if (o.length === 0) {
-                    var T = this.clonePosition();
-                    if (i !== "select" && this.bumpIf("=")) {
-                        var S = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
-                        if (S.err)
-                            return S;
-                        r = createLocation(T, this.clonePosition()), o = this.message.slice(T.offset, this.offset());
-                    } else
-                        break;
-                }
-                if (c.has(o))
-                    return this.error(i === "select" ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, r);
-                o === "other" && (h = !0), this.bumpSpace();
-                var w = this.clonePosition();
-                if (!this.bumpIf("{"))
-                    return this.error(i === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
-                var C = this.parseMessage(e + 1, i, n);
-                if (C.err)
-                    return C;
-                var P = this.tryParseArgumentClose(w);
-                if (P.err)
-                    return P;
-                _.push([
-                    o, {
-                        value: C.val,
-                        location: createLocation(w, this.clonePosition())
-                    }
-                ]), c.add(o), this.bumpSpace(), l = this.parseIdentifierIfPossible(), o = l.value, r = l.location;
-            }
-            return _.length === 0 ? this.error(i === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition())) : this.requiresOtherClause && !h ? this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition())) : {
-                val: _,
-                err: null
-            };
-        }, t.prototype.tryParseDecimalInteger = function(e, i) {
-            var n = 1,
-                s = this.clonePosition();
-            this.bumpIf("+") || this.bumpIf("-") && (n = -1);
-            for (var l = !1, h = 0; !this.isEOF();) {
-                var _ = this.char();
-                if (_ >= 48 && _ <= 57)
-                    l = !0, h = h * 10 + (_ - 48), this.bump();
-                else
-                    break;
-            }
-            var c = createLocation(s, this.clonePosition());
-            return l ? (h *= n, isSafeInteger(h) ? {
-                val: h,
-                err: null
-            } : this.error(i, c)) : this.error(e, c);
-        }, t.prototype.offset = function() {
-            return this.position.offset;
-        }, t.prototype.isEOF = function() {
-            return this.offset() === this.message.length;
-        }, t.prototype.clonePosition = function() {
-            return {
-                offset: this.position.offset,
-                line: this.position.line,
-                column: this.position.column
-            };
-        }, t.prototype.char = function() {
-            var e = this.position.offset;
-            if (e >= this.message.length)
-                throw Error("out of bound");
-            var i = codePointAt(this.message, e);
-            if (i === void 0)
-                throw Error("Offset ".concat(e, " is at invalid UTF-16 code unit boundary"));
-            return i;
-        }, t.prototype.error = function(e, i) {
-            return {
-                val: null,
-                err: {
-                    kind: e,
-                    message: this.message,
-                    location: i
-                }
-            };
-        }, t.prototype.bump = function() {
-            if (!this.isEOF()) {
-                var e = this.char();
-                e === 10 ? (this.position.line += 1, this.position.column = 1, this.position.offset += 1) : (this.position.column += 1, this.position.offset += e < 65536 ? 1 : 2);
-            }
-        }, t.prototype.bumpIf = function(e) {
-            if (startsWith(this.message, e, this.offset())) {
-                for (var i = 0; i < e.length; i++)
-                    this.bump();
-                return !0;
-            }
-            return !1;
-        }, t.prototype.bumpUntil = function(e) {
-            var i = this.offset(),
-                n = this.message.indexOf(e, i);
-            return n >= 0 ? (this.bumpTo(n), !0) : (this.bumpTo(this.message.length), !1);
-        }, t.prototype.bumpTo = function(e) {
-            if (this.offset() > e)
-                throw Error("targetOffset ".concat(e, " must be greater than or equal to the current offset ").concat(this.offset()));
-            for (e = Math.min(e, this.message.length);;) {
-                var i = this.offset();
-                if (i === e)
-                    break;
-                if (i > e)
-                    throw Error("targetOffset ".concat(e, " is at invalid UTF-16 code unit boundary"));
-                if (this.bump(), this.isEOF())
-                    break;
-            }
-        }, t.prototype.bumpSpace = function() {
-            for (; !this.isEOF() && _isWhiteSpace(this.char());)
-                this.bump();
-        }, t.prototype.peek = function() {
-            if (this.isEOF())
-                return null;
-            var e = this.char(),
-                i = this.offset(),
-                n = this.message.charCodeAt(i + (e >= 65536 ? 2 : 1));
-            return n ?? null;
-        }, t;
-    }()
-);
-
-function _isAlpha(t) {
-    return t >= 97 && t <= 122 || t >= 65 && t <= 90;
-}
-
-function _isAlphaOrSlash(t) {
-    return _isAlpha(t) || t === 47;
-}
-
-function _isPotentialElementNameChar(t) {
-    return t === 45 || t === 46 || t >= 48 && t <= 57 || t === 95 || t >= 97 && t <= 122 || t >= 65 && t <= 90 || t == 183 || t >= 192 && t <= 214 || t >= 216 && t <= 246 || t >= 248 && t <= 893 || t >= 895 && t <= 8191 || t >= 8204 && t <= 8205 || t >= 8255 && t <= 8256 || t >= 8304 && t <= 8591 || t >= 11264 && t <= 12271 || t >= 12289 && t <= 55295 || t >= 63744 && t <= 64975 || t >= 65008 && t <= 65533 || t >= 65536 && t <= 983039;
-}
-
-function _isWhiteSpace(t) {
-    return t >= 9 && t <= 13 || t === 32 || t === 133 || t >= 8206 && t <= 8207 || t === 8232 || t === 8233;
-}
-
-function _isPatternSyntax(t) {
-    return t >= 33 && t <= 35 || t === 36 || t >= 37 && t <= 39 || t === 40 || t === 41 || t === 42 || t === 43 || t === 44 || t === 45 || t >= 46 && t <= 47 || t >= 58 && t <= 59 || t >= 60 && t <= 62 || t >= 63 && t <= 64 || t === 91 || t === 92 || t === 93 || t === 94 || t === 96 || t === 123 || t === 124 || t === 125 || t === 126 || t === 161 || t >= 162 && t <= 165 || t === 166 || t === 167 || t === 169 || t === 171 || t === 172 || t === 174 || t === 176 || t === 177 || t === 182 || t === 187 || t === 191 || t === 215 || t === 247 || t >= 8208 && t <= 8213 || t >= 8214 && t <= 8215 || t === 8216 || t === 8217 || t === 8218 || t >= 8219 && t <= 8220 || t === 8221 || t === 8222 || t === 8223 || t >= 8224 && t <= 8231 || t >= 8240 && t <= 8248 || t === 8249 || t === 8250 || t >= 8251 && t <= 8254 || t >= 8257 && t <= 8259 || t === 8260 || t === 8261 || t === 8262 || t >= 8263 && t <= 8273 || t === 8274 || t === 8275 || t >= 8277 && t <= 8286 || t >= 8592 && t <= 8596 || t >= 8597 && t <= 8601 || t >= 8602 && t <= 8603 || t >= 8604 && t <= 8607 || t === 8608 || t >= 8609 && t <= 8610 || t === 8611 || t >= 8612 && t <= 8613 || t === 8614 || t >= 8615 && t <= 8621 || t === 8622 || t >= 8623 && t <= 8653 || t >= 8654 && t <= 8655 || t >= 8656 && t <= 8657 || t === 8658 || t === 8659 || t === 8660 || t >= 8661 && t <= 8691 || t >= 8692 && t <= 8959 || t >= 8960 && t <= 8967 || t === 8968 || t === 8969 || t === 8970 || t === 8971 || t >= 8972 && t <= 8991 || t >= 8992 && t <= 8993 || t >= 8994 && t <= 9e3 || t === 9001 || t === 9002 || t >= 9003 && t <= 9083 || t === 9084 || t >= 9085 && t <= 9114 || t >= 9115 && t <= 9139 || t >= 9140 && t <= 9179 || t >= 9180 && t <= 9185 || t >= 9186 && t <= 9254 || t >= 9255 && t <= 9279 || t >= 9280 && t <= 9290 || t >= 9291 && t <= 9311 || t >= 9472 && t <= 9654 || t === 9655 || t >= 9656 && t <= 9664 || t === 9665 || t >= 9666 && t <= 9719 || t >= 9720 && t <= 9727 || t >= 9728 && t <= 9838 || t === 9839 || t >= 9840 && t <= 10087 || t === 10088 || t === 10089 || t === 10090 || t === 10091 || t === 10092 || t === 10093 || t === 10094 || t === 10095 || t === 10096 || t === 10097 || t === 10098 || t === 10099 || t === 10100 || t === 10101 || t >= 10132 && t <= 10175 || t >= 10176 && t <= 10180 || t === 10181 || t === 10182 || t >= 10183 && t <= 10213 || t === 10214 || t === 10215 || t === 10216 || t === 10217 || t === 10218 || t === 10219 || t === 10220 || t === 10221 || t === 10222 || t === 10223 || t >= 10224 && t <= 10239 || t >= 10240 && t <= 10495 || t >= 10496 && t <= 10626 || t === 10627 || t === 10628 || t === 10629 || t === 10630 || t === 10631 || t === 10632 || t === 10633 || t === 10634 || t === 10635 || t === 10636 || t === 10637 || t === 10638 || t === 10639 || t === 10640 || t === 10641 || t === 10642 || t === 10643 || t === 10644 || t === 10645 || t === 10646 || t === 10647 || t === 10648 || t >= 10649 && t <= 10711 || t === 10712 || t === 10713 || t === 10714 || t === 10715 || t >= 10716 && t <= 10747 || t === 10748 || t === 10749 || t >= 10750 && t <= 11007 || t >= 11008 && t <= 11055 || t >= 11056 && t <= 11076 || t >= 11077 && t <= 11078 || t >= 11079 && t <= 11084 || t >= 11085 && t <= 11123 || t >= 11124 && t <= 11125 || t >= 11126 && t <= 11157 || t === 11158 || t >= 11159 && t <= 11263 || t >= 11776 && t <= 11777 || t === 11778 || t === 11779 || t === 11780 || t === 11781 || t >= 11782 && t <= 11784 || t === 11785 || t === 11786 || t === 11787 || t === 11788 || t === 11789 || t >= 11790 && t <= 11798 || t === 11799 || t >= 11800 && t <= 11801 || t === 11802 || t === 11803 || t === 11804 || t === 11805 || t >= 11806 && t <= 11807 || t === 11808 || t === 11809 || t === 11810 || t === 11811 || t === 11812 || t === 11813 || t === 11814 || t === 11815 || t === 11816 || t === 11817 || t >= 11818 && t <= 11822 || t === 11823 || t >= 11824 && t <= 11833 || t >= 11834 && t <= 11835 || t >= 11836 && t <= 11839 || t === 11840 || t === 11841 || t === 11842 || t >= 11843 && t <= 11855 || t >= 11856 && t <= 11857 || t === 11858 || t >= 11859 && t <= 11903 || t >= 12289 && t <= 12291 || t === 12296 || t === 12297 || t === 12298 || t === 12299 || t === 12300 || t === 12301 || t === 12302 || t === 12303 || t === 12304 || t === 12305 || t >= 12306 && t <= 12307 || t === 12308 || t === 12309 || t === 12310 || t === 12311 || t === 12312 || t === 12313 || t === 12314 || t === 12315 || t === 12316 || t === 12317 || t >= 12318 && t <= 12319 || t === 12320 || t === 12336 || t === 64830 || t === 64831 || t >= 65093 && t <= 65094;
-}
-
-function pruneLocation(t) {
-    t.forEach(function(e) {
-        if (delete e.location, isSelectElement(e) || isPluralElement(e))
-            for (var i in e.options)
-                delete e.options[i].location, pruneLocation(e.options[i].value);
-        else
-            isNumberElement(e) && isNumberSkeleton(e.style) || (isDateElement(e) || isTimeElement(e)) && isDateTimeSkeleton(e.style) ? delete e.style.location : isTagElement(e) && pruneLocation(e.children);
-    });
-}
-
-function parse(t, e) {
-    e === void 0 && (e = {}), e = __assign({
-        shouldParseSkeletons: !0,
-        requiresOtherClause: !0
-    }, e);
-    var i = new Parser(t, e).parse();
-    if (i.err) {
-        var n = SyntaxError(ErrorKind[i.err.kind]);
-        throw n.location = i.err.location, n.originalMessage = i.err.message, n;
-    }
-    return e != null && e.captureLocation || pruneLocation(i.val), i.val;
-}
-
-function memoize(t, e) {
-    var i = e && e.cache ? e.cache : cacheDefault,
-        n = e && e.serializer ? e.serializer : serializerDefault,
-        s = e && e.strategy ? e.strategy : strategyDefault;
-    return s(t, {
-        cache: i,
-        serializer: n
-    });
-}
-
-function isPrimitive(t) {
-    return t == null || typeof t == "number" || typeof t == "boolean";
-}
-
-function monadic(t, e, i, n) {
-    var s = isPrimitive(n) ? n : i(n),
-        l = e.get(s);
-    return typeof l > "u" && (l = t.call(this, n), e.set(s, l)), l;
-}
-
-function variadic(t, e, i) {
-    var n = Array.prototype.slice.call(arguments, 3),
-        s = i(n),
-        l = e.get(s);
-    return typeof l > "u" && (l = t.apply(this, n), e.set(s, l)), l;
-}
-
-function assemble(t, e, i, n, s) {
-    return i.bind(e, t, n, s);
-}
-
-function strategyDefault(t, e) {
-    var i = t.length === 1 ? monadic : variadic;
-    return assemble(t, this, i, e.cache.create(), e.serializer);
-}
-
-function strategyVariadic(t, e) {
-    return assemble(t, this, variadic, e.cache.create(), e.serializer);
-}
-
-function strategyMonadic(t, e) {
-    return assemble(t, this, monadic, e.cache.create(), e.serializer);
-}
-var serializerDefault = function() {
-    return JSON.stringify(arguments);
-};
-
-function ObjectWithoutPrototypeCache() {
-    this.cache = /* @__PURE__ */ Object.create(null);
-}
-ObjectWithoutPrototypeCache.prototype.get = function(t) {
-    return this.cache[t];
-};
-ObjectWithoutPrototypeCache.prototype.set = function(t, e) {
-    this.cache[t] = e;
-};
-var cacheDefault = {
-        create: function() {
-            return new ObjectWithoutPrototypeCache();
-        }
-    },
-    strategies = {
-        variadic: strategyVariadic,
-        monadic: strategyMonadic
-    },
-    ErrorCode;
-(function(t) {
-    t.MISSING_VALUE = "MISSING_VALUE", t.INVALID_VALUE = "INVALID_VALUE", t.MISSING_INTL_API = "MISSING_INTL_API";
-})(ErrorCode || (ErrorCode = {}));
-var FormatError = (
-        /** @class */
-        function(t) {
-            __extends(e, t);
-
-            function e(i, n, s) {
-                var l = t.call(this, i) || this;
-                return l.code = n, l.originalMessage = s, l;
-            }
-            return e.prototype.toString = function() {
-                return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
-            }, e;
-        }(Error)
-    ),
-    InvalidValueError = (
-        /** @class */
-        function(t) {
-            __extends(e, t);
-
-            function e(i, n, s, l) {
-                return t.call(this, 'Invalid values for "'.concat(i, '": "').concat(n, '". Options are "').concat(Object.keys(s).join('", "'), '"'), ErrorCode.INVALID_VALUE, l) || this;
-            }
-            return e;
-        }(FormatError)
-    ),
-    InvalidValueTypeError = (
-        /** @class */
-        function(t) {
-            __extends(e, t);
-
-            function e(i, n, s) {
-                return t.call(this, 'Value for "'.concat(i, '" must be of type ').concat(n), ErrorCode.INVALID_VALUE, s) || this;
-            }
-            return e;
-        }(FormatError)
-    ),
-    MissingValueError = (
-        /** @class */
-        function(t) {
-            __extends(e, t);
-
-            function e(i, n) {
-                return t.call(this, 'The intl string context variable "'.concat(i, '" was not provided to the string "').concat(n, '"'), ErrorCode.MISSING_VALUE, n) || this;
-            }
-            return e;
-        }(FormatError)
-    ),
-    PART_TYPE;
-(function(t) {
-    t[t.literal = 0] = "literal", t[t.object = 1] = "object";
-})(PART_TYPE || (PART_TYPE = {}));
-
-function mergeLiteral(t) {
-    return t.length < 2 ? t : t.reduce(function(e, i) {
-        var n = e[e.length - 1];
-        return !n || n.type !== PART_TYPE.literal || i.type !== PART_TYPE.literal ? e.push(i) : n.value += i.value, e;
-    }, []);
-}
-
-function isFormatXMLElementFn(t) {
-    return typeof t == "function";
-}
-
-function formatToParts(t, e, i, n, s, l, h) {
-    if (t.length === 1 && isLiteralElement(t[0]))
-        return [{
-            type: PART_TYPE.literal,
-            value: t[0].value
-        }];
-    for (var _ = [], c = 0, o = t; c < o.length; c++) {
-        var r = o[c];
-        if (isLiteralElement(r)) {
-            _.push({
-                type: PART_TYPE.literal,
-                value: r.value
-            });
-            continue;
-        }
-        if (isPoundElement(r)) {
-            typeof l == "number" && _.push({
-                type: PART_TYPE.literal,
-                value: i.getNumberFormat(e).format(l)
-            });
-            continue;
-        }
-        var T = r.value;
-        if (!(s && T in s))
-            throw new MissingValueError(T, h);
-        var S = s[T];
-        if (isArgumentElement(r)) {
-            (!S || typeof S == "string" || typeof S == "number") && (S = typeof S == "string" || typeof S == "number" ? String(S) : ""), _.push({
-                type: typeof S == "string" ? PART_TYPE.literal : PART_TYPE.object,
-                value: S
-            });
-            continue;
-        }
-        if (isDateElement(r)) {
-            var w = typeof r.style == "string" ? n.date[r.style] : isDateTimeSkeleton(r.style) ? r.style.parsedOptions : void 0;
-            _.push({
-                type: PART_TYPE.literal,
-                value: i.getDateTimeFormat(e, w).format(S)
-            });
-            continue;
-        }
-        if (isTimeElement(r)) {
-            var w = typeof r.style == "string" ? n.time[r.style] : isDateTimeSkeleton(r.style) ? r.style.parsedOptions : n.time.medium;
-            _.push({
-                type: PART_TYPE.literal,
-                value: i.getDateTimeFormat(e, w).format(S)
-            });
-            continue;
-        }
-        if (isNumberElement(r)) {
-            var w = typeof r.style == "string" ? n.number[r.style] : isNumberSkeleton(r.style) ? r.style.parsedOptions : void 0;
-            w && w.scale && (S = S * (w.scale || 1)), _.push({
-                type: PART_TYPE.literal,
-                value: i.getNumberFormat(e, w).format(S)
-            });
-            continue;
-        }
-        if (isTagElement(r)) {
-            var C = r.children,
-                P = r.value,
-                b = s[P];
-            if (!isFormatXMLElementFn(b))
-                throw new InvalidValueTypeError(P, "function", h);
-            var k = formatToParts(C, e, i, n, s, l),
-                F = b(k.map(function(p) {
-                    return p.value;
-                }));
-            Array.isArray(F) || (F = [F]), _.push.apply(_, F.map(function(p) {
-                return {
-                    type: typeof p == "string" ? PART_TYPE.literal : PART_TYPE.object,
-                    value: p
-                };
-            }));
-        }
-        if (isSelectElement(r)) {
-            var x = r.options[S] || r.options.other;
-            if (!x)
-                throw new InvalidValueError(r.value, S, Object.keys(r.options), h);
-            _.push.apply(_, formatToParts(x.value, e, i, n, s));
-            continue;
-        }
-        if (isPluralElement(r)) {
-            var x = r.options["=".concat(S)];
-            if (!x) {
-                if (!Intl.PluralRules)
-                    throw new FormatError(`Intl.PluralRules is not available in this environment.
-Try polyfilling it using "@formatjs/intl-pluralrules"
-`, ErrorCode.MISSING_INTL_API, h);
-                var y = i.getPluralRules(e, {
-                    type: r.pluralType
-                }).select(S - (r.offset || 0));
-                x = r.options[y] || r.options.other;
-            }
-            if (!x)
-                throw new InvalidValueError(r.value, S, Object.keys(r.options), h);
-            _.push.apply(_, formatToParts(x.value, e, i, n, s, S - (r.offset || 0)));
-            continue;
-        }
-    }
-    return mergeLiteral(_);
-}
-
-function mergeConfig(t, e) {
-    return e ? __assign(__assign(__assign({}, t || {}), e || {}), Object.keys(t).reduce(function(i, n) {
-        return i[n] = __assign(__assign({}, t[n]), e[n] || {}), i;
-    }, {})) : t;
-}
-
-function mergeConfigs(t, e) {
-    return e ? Object.keys(t).reduce(function(i, n) {
-        return i[n] = mergeConfig(t[n], e[n]), i;
-    }, __assign({}, t)) : t;
-}
-
-function createFastMemoizeCache(t) {
-    return {
-        create: function() {
-            return {
-                get: function(e) {
-                    return t[e];
-                },
-                set: function(e, i) {
-                    t[e] = i;
-                }
-            };
-        }
-    };
-}
-
-function createDefaultFormatters(t) {
-    return t === void 0 && (t = {
-        number: {},
-        dateTime: {},
-        pluralRules: {}
-    }), {
-        getNumberFormat: memoize(function() {
-            for (var e, i = [], n = 0; n < arguments.length; n++)
-                i[n] = arguments[n];
-            return new((e = Intl.NumberFormat).bind.apply(e, __spreadArray([void 0], i, !1)))();
-        }, {
-            cache: createFastMemoizeCache(t.number),
-            strategy: strategies.variadic
-        }),
-        getDateTimeFormat: memoize(function() {
-            for (var e, i = [], n = 0; n < arguments.length; n++)
-                i[n] = arguments[n];
-            return new((e = Intl.DateTimeFormat).bind.apply(e, __spreadArray([void 0], i, !1)))();
-        }, {
-            cache: createFastMemoizeCache(t.dateTime),
-            strategy: strategies.variadic
-        }),
-        getPluralRules: memoize(function() {
-            for (var e, i = [], n = 0; n < arguments.length; n++)
-                i[n] = arguments[n];
-            return new((e = Intl.PluralRules).bind.apply(e, __spreadArray([void 0], i, !1)))();
-        }, {
-            cache: createFastMemoizeCache(t.pluralRules),
-            strategy: strategies.variadic
-        })
-    };
-}
-var IntlMessageFormat = (
-    /** @class */
-    function() {
-        function t(e, i, n, s) {
-            var l = this;
-            if (i === void 0 && (i = t.defaultLocale), this.formatterCache = {
-                    number: {},
-                    dateTime: {},
-                    pluralRules: {}
-                }, this.format = function(h) {
-                    var _ = l.formatToParts(h);
-                    if (_.length === 1)
-                        return _[0].value;
-                    var c = _.reduce(function(o, r) {
-                        return !o.length || r.type !== PART_TYPE.literal || typeof o[o.length - 1] != "string" ? o.push(r.value) : o[o.length - 1] += r.value, o;
-                    }, []);
-                    return c.length <= 1 ? c[0] || "" : c;
-                }, this.formatToParts = function(h) {
-                    return formatToParts(l.ast, l.locales, l.formatters, l.formats, h, void 0, l.message);
-                }, this.resolvedOptions = function() {
-                    return {
-                        locale: l.resolvedLocale.toString()
-                    };
-                }, this.getAst = function() {
-                    return l.ast;
-                }, this.locales = i, this.resolvedLocale = t.resolveLocale(i), typeof e == "string") {
-                if (this.message = e, !t.__parse)
-                    throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
-                this.ast = t.__parse(e, {
-                    ignoreTag: s == null ? void 0 : s.ignoreTag,
-                    locale: this.resolvedLocale
-                });
-            } else
-                this.ast = e;
-            if (!Array.isArray(this.ast))
-                throw new TypeError("A message must be provided as a String or AST.");
-            this.formats = mergeConfigs(t.formats, n), this.formatters = s && s.formatters || createDefaultFormatters(this.formatterCache);
-        }
-        return Object.defineProperty(t, "defaultLocale", {
-            get: function() {
-                return t.memoizedDefaultLocale || (t.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale), t.memoizedDefaultLocale;
-            },
-            enumerable: !1,
-            configurable: !0
-        }), t.memoizedDefaultLocale = null, t.resolveLocale = function(e) {
-            var i = Intl.NumberFormat.supportedLocalesOf(e);
-            return i.length > 0 ? new Intl.Locale(i[0]) : new Intl.Locale(typeof e == "string" ? e : e[0]);
-        }, t.__parse = parse, t.formats = {
-            number: {
-                integer: {
-                    maximumFractionDigits: 0
-                },
-                currency: {
-                    style: "currency"
-                },
-                percent: {
-                    style: "percent"
-                }
-            },
-            date: {
-                short: {
-                    month: "numeric",
-                    day: "numeric",
-                    year: "2-digit"
-                },
-                medium: {
-                    month: "short",
-                    day: "numeric",
-                    year: "numeric"
-                },
-                long: {
-                    month: "long",
-                    day: "numeric",
-                    year: "numeric"
-                },
-                full: {
-                    weekday: "long",
-                    month: "long",
-                    day: "numeric",
-                    year: "numeric"
-                }
-            },
-            time: {
-                short: {
-                    hour: "numeric",
-                    minute: "numeric"
-                },
-                medium: {
-                    hour: "numeric",
-                    minute: "numeric",
-                    second: "numeric"
-                },
-                long: {
-                    hour: "numeric",
-                    minute: "numeric",
-                    second: "numeric",
-                    timeZoneName: "short"
-                },
-                full: {
-                    hour: "numeric",
-                    minute: "numeric",
-                    second: "numeric",
-                    timeZoneName: "short"
-                }
-            }
-        }, t;
-    }()
-);
-
-function delve(t, e) {
-    if (e == null)
-        return;
-    if (e in t)
-        return t[e];
-    const i = e.split(".");
-    let n = t;
-    for (let s = 0; s < i.length; s++)
-        if (typeof n == "object") {
-            if (s > 0) {
-                const l = i.slice(s, i.length).join(".");
-                if (l in n) {
-                    n = n[l];
-                    break;
-                }
-            }
-            n = n[i[s]];
-        } else
-            n = void 0;
-    return n;
-}
-const lookupCache = {},
-    addToCache = (t, e, i) => i && (e in lookupCache || (lookupCache[e] = {}), t in lookupCache[e] || (lookupCache[e][t] = i), i),
-    lookup = (t, e) => {
-        if (e == null)
-            return;
-        if (e in lookupCache && t in lookupCache[e])
-            return lookupCache[e][t];
-        const i = getPossibleLocales(e);
-        for (let n = 0; n < i.length; n++) {
-            const s = i[n],
-                l = getMessageFromDictionary(s, t);
-            if (l)
-                return addToCache(t, e, l);
-        }
-    };
-let dictionary;
-const $dictionary = writable({});
-
-function getLocaleDictionary(t) {
-    return dictionary[t] || null;
-}
-
-function hasLocaleDictionary(t) {
-    return t in dictionary;
-}
-
-function getMessageFromDictionary(t, e) {
-    if (!hasLocaleDictionary(t))
-        return null;
-    const i = getLocaleDictionary(t);
-    return delve(i, e);
-}
-
-function getClosestAvailableLocale(t) {
-    if (t == null)
-        return;
-    const e = getPossibleLocales(t);
-    for (let i = 0; i < e.length; i++) {
-        const n = e[i];
-        if (hasLocaleDictionary(n))
-            return n;
-    }
-}
-
-function addMessages(t, ...e) {
-    delete lookupCache[t], $dictionary.update((i) => (i[t] = deepmerge$1.all([i[t] || {}, ...e]), i));
-}
-derived(
-    [$dictionary],
-    ([t]) => Object.keys(t)
-);
-$dictionary.subscribe((t) => dictionary = t);
-const queue = {};
-
-function removeLoaderFromQueue(t, e) {
-    queue[t].delete(e), queue[t].size === 0 && delete queue[t];
-}
-
-function getLocaleQueue(t) {
-    return queue[t];
-}
-
-function getLocalesQueues(t) {
-    return getPossibleLocales(t).map((e) => {
-        const i = getLocaleQueue(e);
-        return [e, i ? [...i] : []];
-    }).filter(([, e]) => e.length > 0);
-}
-
-function hasLocaleQueue(t) {
-    return t == null ? !1 : getPossibleLocales(t).some(
-        (e) => {
-            var i;
-            return (i = getLocaleQueue(e)) == null ? void 0 : i.size;
-        }
-    );
-}
-
-function loadLocaleQueue(t, e) {
-    return Promise.all(
-        e.map((n) => (removeLoaderFromQueue(t, n), n().then((s) => s.default || s)))
-    ).then((n) => addMessages(t, ...n));
-}
-const activeFlushes = {};
-
-function flush(t) {
-    if (!hasLocaleQueue(t))
-        return t in activeFlushes ? activeFlushes[t] : Promise.resolve();
-    const e = getLocalesQueues(t);
-    return activeFlushes[t] = Promise.all(
-        e.map(
-            ([i, n]) => loadLocaleQueue(i, n)
-        )
-    ).then(() => {
-        if (hasLocaleQueue(t))
-            return flush(t);
-        delete activeFlushes[t];
-    }), activeFlushes[t];
-}
-const defaultFormats = {
-        number: {
-            scientific: {
-                notation: "scientific"
-            },
-            engineering: {
-                notation: "engineering"
-            },
-            compactLong: {
-                notation: "compact",
-                compactDisplay: "long"
-            },
-            compactShort: {
-                notation: "compact",
-                compactDisplay: "short"
-            }
-        },
-        date: {
-            short: {
-                month: "numeric",
-                day: "numeric",
-                year: "2-digit"
-            },
-            medium: {
-                month: "short",
-                day: "numeric",
-                year: "numeric"
-            },
-            long: {
-                month: "long",
-                day: "numeric",
-                year: "numeric"
-            },
-            full: {
-                weekday: "long",
-                month: "long",
-                day: "numeric",
-                year: "numeric"
-            }
-        },
-        time: {
-            short: {
-                hour: "numeric",
-                minute: "numeric"
-            },
-            medium: {
-                hour: "numeric",
-                minute: "numeric",
-                second: "numeric"
-            },
-            long: {
-                hour: "numeric",
-                minute: "numeric",
-                second: "numeric",
-                timeZoneName: "short"
-            },
-            full: {
-                hour: "numeric",
-                minute: "numeric",
-                second: "numeric",
-                timeZoneName: "short"
-            }
-        }
-    },
-    defaultOptions = {
-        fallbackLocale: null,
-        loadingDelay: 200,
-        formats: defaultFormats,
-        warnOnMissingMessages: !0,
-        handleMissingMessage: void 0,
-        ignoreTag: !0
-    },
-    options = defaultOptions;
-
-function getOptions() {
-    return options;
-}
-const $isLoading = writable(!1);
-var __defProp$1 = Object.defineProperty,
-    __defProps = Object.defineProperties,
-    __getOwnPropDescs = Object.getOwnPropertyDescriptors,
-    __getOwnPropSymbols$1 = Object.getOwnPropertySymbols,
-    __hasOwnProp$1 = Object.prototype.hasOwnProperty,
-    __propIsEnum$1 = Object.prototype.propertyIsEnumerable,
-    __defNormalProp$1 = (t, e, i) => e in t ? __defProp$1(t, e, {
-        enumerable: !0,
-        configurable: !0,
-        writable: !0,
-        value: i
-    }) : t[e] = i,
-    __spreadValues$1 = (t, e) => {
-        for (var i in e || (e = {}))
-            __hasOwnProp$1.call(e, i) && __defNormalProp$1(t, i, e[i]);
-        if (__getOwnPropSymbols$1)
-            for (var i of __getOwnPropSymbols$1(e))
-                __propIsEnum$1.call(e, i) && __defNormalProp$1(t, i, e[i]);
-        return t;
-    },
-    __spreadProps = (t, e) => __defProps(t, __getOwnPropDescs(e));
-let current;
-const internalLocale = writable(null);
-
-function getSubLocales(t) {
-    return t.split("-").map((e, i, n) => n.slice(0, i + 1).join("-")).reverse();
-}
-
-function getPossibleLocales(t, e = getOptions().fallbackLocale) {
-    const i = getSubLocales(t);
-    return e ? [... /* @__PURE__ */ new Set([...i, ...getSubLocales(e)])] : i;
-}
-
-function getCurrentLocale() {
-    return current ?? void 0;
-}
-internalLocale.subscribe((t) => {
-    current = t ?? void 0, typeof window < "u" && t != null && document.documentElement.setAttribute("lang", t);
-});
-const set = (t) => {
-        if (t && getClosestAvailableLocale(t) && hasLocaleQueue(t)) {
-            const {
-                loadingDelay: e
-            } = getOptions();
-            let i;
-            return typeof window < "u" && getCurrentLocale() != null && e ? i = window.setTimeout(
-                () => $isLoading.set(!0),
-                e
-            ) : $isLoading.set(!0), flush(t).then(() => {
-                internalLocale.set(t);
-            }).finally(() => {
-                clearTimeout(i), $isLoading.set(!1);
-            });
-        }
-        return internalLocale.set(t);
-    },
-    $locale = __spreadProps(__spreadValues$1({}, internalLocale), {
-        set
-    }),
-    monadicMemoize = (t) => {
-        const e = /* @__PURE__ */ Object.create(null);
-        return (n) => {
-            const s = JSON.stringify(n);
-            return s in e ? e[s] : e[s] = t(n);
-        };
-    };
-var __defProp = Object.defineProperty,
-    __getOwnPropSymbols = Object.getOwnPropertySymbols,
-    __hasOwnProp = Object.prototype.hasOwnProperty,
-    __propIsEnum = Object.prototype.propertyIsEnumerable,
-    __defNormalProp = (t, e, i) => e in t ? __defProp(t, e, {
-        enumerable: !0,
-        configurable: !0,
-        writable: !0,
-        value: i
-    }) : t[e] = i,
-    __spreadValues = (t, e) => {
-        for (var i in e || (e = {}))
-            __hasOwnProp.call(e, i) && __defNormalProp(t, i, e[i]);
-        if (__getOwnPropSymbols)
-            for (var i of __getOwnPropSymbols(e))
-                __propIsEnum.call(e, i) && __defNormalProp(t, i, e[i]);
-        return t;
-    },
-    __objRest = (t, e) => {
-        var i = {};
-        for (var n in t)
-            __hasOwnProp.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
-        if (t != null && __getOwnPropSymbols)
-            for (var n of __getOwnPropSymbols(t))
-                e.indexOf(n) < 0 && __propIsEnum.call(t, n) && (i[n] = t[n]);
-        return i;
-    };
-const getIntlFormatterOptions = (t, e) => {
-        const {
-            formats: i
-        } = getOptions();
-        if (t in i && e in i[t])
-            return i[t][e];
-        throw new Error(`[svelte-i18n] Unknown "${e}" ${t} format.`);
-    },
-    createNumberFormatter = monadicMemoize(
-        (t) => {
-            var e = t,
-                {
-                    locale: i,
-                    format: n
-                } = e,
-                s = __objRest(e, ["locale", "format"]);
-            if (i == null)
-                throw new Error('[svelte-i18n] A "locale" must be set to format numbers');
-            return n && (s = getIntlFormatterOptions("number", n)), new Intl.NumberFormat(i, s);
-        }
-    ),
-    createDateFormatter = monadicMemoize(
-        (t) => {
-            var e = t,
-                {
-                    locale: i,
-                    format: n
-                } = e,
-                s = __objRest(e, ["locale", "format"]);
-            if (i == null)
-                throw new Error('[svelte-i18n] A "locale" must be set to format dates');
-            return n ? s = getIntlFormatterOptions("date", n) : Object.keys(s).length === 0 && (s = getIntlFormatterOptions("date", "short")), new Intl.DateTimeFormat(i, s);
-        }
-    ),
-    createTimeFormatter = monadicMemoize(
-        (t) => {
-            var e = t,
-                {
-                    locale: i,
-                    format: n
-                } = e,
-                s = __objRest(e, ["locale", "format"]);
-            if (i == null)
-                throw new Error(
-                    '[svelte-i18n] A "locale" must be set to format time values'
-                );
-            return n ? s = getIntlFormatterOptions("time", n) : Object.keys(s).length === 0 && (s = getIntlFormatterOptions("time", "short")), new Intl.DateTimeFormat(i, s);
-        }
-    ),
-    getNumberFormatter = (t = {}) => {
-        var e = t,
-            {
-                locale: i = getCurrentLocale()
-            } = e,
-            n = __objRest(e, [
-                "locale"
-            ]);
-        return createNumberFormatter(__spreadValues({
-            locale: i
-        }, n));
-    },
-    getDateFormatter = (t = {}) => {
-        var e = t,
-            {
-                locale: i = getCurrentLocale()
-            } = e,
-            n = __objRest(e, [
-                "locale"
-            ]);
-        return createDateFormatter(__spreadValues({
-            locale: i
-        }, n));
-    },
-    getTimeFormatter = (t = {}) => {
-        var e = t,
-            {
-                locale: i = getCurrentLocale()
-            } = e,
-            n = __objRest(e, [
-                "locale"
-            ]);
-        return createTimeFormatter(__spreadValues({
-            locale: i
-        }, n));
-    },
-    getMessageFormatter = monadicMemoize(
-        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
-        (t, e = getCurrentLocale()) => new IntlMessageFormat(t, e, getOptions().formats, {
-            ignoreTag: getOptions().ignoreTag
-        })
-    ),
-    formatMessage = (t, e = {}) => {
-        var i, n, s, l;
-        let h = e;
-        typeof t == "object" && (h = t, t = h.id);
-        const {
-            values: _,
-            locale: c = getCurrentLocale(),
-            default: o
-        } = h;
-        if (c == null)
-            throw new Error(
-                "[svelte-i18n] Cannot format a message without first setting the initial locale."
-            );
-        let r = lookup(t, c);
-        if (!r)
-            r = (l = (s = (n = (i = getOptions()).handleMissingMessage) == null ? void 0 : n.call(i, {
-                locale: c,
-                id: t,
-                defaultValue: o
-            })) != null ? s : o) != null ? l : t;
-        else if (typeof r != "string")
-            return console.warn(
-                `[svelte-i18n] Message with id "${t}" must be of type "string", found: "${typeof r}". Gettin its value through the "$format" method is deprecated; use the "json" method instead.`
-            ), r;
-        if (!_)
-            return r;
-        let T = r;
-        try {
-            T = getMessageFormatter(r, c).format(_);
-        } catch (S) {
-            S instanceof Error && console.warn(
-                `[svelte-i18n] Message "${t}" has syntax error:`,
-                S.message
-            );
-        }
-        return T;
-    },
-    formatTime = (t, e) => getTimeFormatter(e).format(t),
-    formatDate = (t, e) => getDateFormatter(e).format(t),
-    formatNumber = (t, e) => getNumberFormatter(e).format(t),
-    getJSON = (t, e = getCurrentLocale()) => lookup(t, e);
-derived([$locale, $dictionary], () => formatMessage);
-derived([$locale], () => formatTime);
-derived([$locale], () => formatDate);
-derived([$locale], () => formatNumber);
-derived([$locale, $dictionary], () => getJSON);
-const Upload_svelte_svelte_type_style_lang = "",
-    {
-        SvelteComponent: SvelteComponent$2,
-        append: append$2,
-        attr: attr$2,
-        binding_callbacks: binding_callbacks$1,
-        bubble,
-        create_slot,
-        detach: detach$2,
-        element: element$2,
-        get_all_dirty_from_scope,
-        get_slot_changes,
-        init: init$2,
-        insert: insert$2,
-        listen,
-        prevent_default,
-        run_all,
-        safe_not_equal: safe_not_equal$2,
-        space: space$2,
-        stop_propagation,
-        toggle_class: toggle_class$1,
-        transition_in: transition_in$2,
-        transition_out: transition_out$2,
-        update_slot_base
-    } = window.__gradio__svelte__internal,
-    {
-        createEventDispatcher: createEventDispatcher$1,
-        tick: tick$1,
-        getContext
-    } = window.__gradio__svelte__internal;
-
-function create_fragment$2(t) {
-    let e, i, n, s, l, h, _, c, o;
-    const r = (
+function create_fragment$2(i) {
+    let t, n, e, s, p, f, A, a, h;
+    const o = (
             /*#slots*/
-            t[16].default
+            i[16].default
         ),
-        T = create_slot(
-            r,
-            t,
+        F = create_slot(
+            o,
+            i,
             /*$$scope*/
-            t[15],
+            i[15],
             null
         );
     return {
         c() {
-            e = element$2("button"), T && T.c(), i = space$2(), n = element$2("input"), attr$2(n, "type", "file"), attr$2(
-                    n,
+            t = element$2("button"), F && F.c(), n = space$2(), e = element$2("input"), attr$2(e, "type", "file"), attr$2(
+                    e,
                     "accept",
                     /*filetype*/
-                    t[0]
-                ), n.multiple = s = /*file_count*/
-                t[4] === "multiple" || void 0, attr$2(n, "webkitdirectory", l = /*file_count*/
-                    t[4] === "directory" || void 0), attr$2(n, "mozdirectory", h = /*file_count*/
-                    t[4] === "directory" || void 0), attr$2(n, "class", "svelte-18dlsnh"), attr$2(e, "class", "svelte-18dlsnh"), toggle_class$1(
-                    e,
+                    i[0]
+                ), e.multiple = s = /*file_count*/
+                i[4] === "multiple" || void 0, attr$2(e, "webkitdirectory", p = /*file_count*/
+                    i[4] === "directory" || void 0), attr$2(e, "mozdirectory", f = /*file_count*/
+                    i[4] === "directory" || void 0), attr$2(e, "class", "svelte-18dlsnh"), attr$2(t, "class", "svelte-18dlsnh"), toggle_class$1(
+                    t,
                     "hidden",
                     /*hidden*/
-                    t[5]
+                    i[5]
                 ), toggle_class$1(
-                    e,
+                    t,
                     "center",
                     /*center*/
-                    t[2]
+                    i[2]
                 ), toggle_class$1(
-                    e,
+                    t,
                     "boundedheight",
                     /*boundedheight*/
-                    t[1]
+                    i[1]
                 ), toggle_class$1(
-                    e,
+                    t,
                     "flex",
                     /*flex*/
-                    t[3]
+                    i[3]
                 );
         },
-        m(S, w) {
-            insert$2(S, e, w), T && T.m(e, null), append$2(e, i), append$2(e, n), t[24](n), _ = !0, c || (o = [
+        m(R, w) {
+            insert$2(R, t, w), F && F.m(t, null), append$2(t, n), append$2(t, e), i[24](e), A = !0, a || (h = [
                 listen(
-                    n,
+                    e,
                     "change",
                     /*load_files_from_upload*/
-                    t[9]
+                    i[9]
                 ),
-                listen(e, "drag", stop_propagation(prevent_default(
+                listen(t, "drag", stop_propagation(prevent_default(
                     /*drag_handler*/
-                    t[17]
+                    i[17]
                 ))),
-                listen(e, "dragstart", stop_propagation(prevent_default(
+                listen(t, "dragstart", stop_propagation(prevent_default(
                     /*dragstart_handler*/
-                    t[18]
+                    i[18]
                 ))),
-                listen(e, "dragend", stop_propagation(prevent_default(
+                listen(t, "dragend", stop_propagation(prevent_default(
                     /*dragend_handler*/
-                    t[19]
+                    i[19]
                 ))),
-                listen(e, "dragover", stop_propagation(prevent_default(
+                listen(t, "dragover", stop_propagation(prevent_default(
                     /*dragover_handler*/
-                    t[20]
+                    i[20]
                 ))),
-                listen(e, "dragenter", stop_propagation(prevent_default(
+                listen(t, "dragenter", stop_propagation(prevent_default(
                     /*dragenter_handler*/
-                    t[21]
+                    i[21]
                 ))),
-                listen(e, "dragleave", stop_propagation(prevent_default(
+                listen(t, "dragleave", stop_propagation(prevent_default(
                     /*dragleave_handler*/
-                    t[22]
+                    i[22]
                 ))),
-                listen(e, "drop", stop_propagation(prevent_default(
+                listen(t, "drop", stop_propagation(prevent_default(
                     /*drop_handler*/
-                    t[23]
+                    i[23]
                 ))),
                 listen(
-                    e,
+                    t,
                     "click",
                     /*open_file_upload*/
-                    t[6]
+                    i[6]
                 ),
                 listen(
-                    e,
+                    t,
                     "drop",
                     /*loadFilesFromDrop*/
-                    t[10]
+                    i[10]
                 ),
                 listen(
-                    e,
+                    t,
                     "dragenter",
                     /*updateDragging*/
-                    t[8]
+                    i[8]
                 ),
                 listen(
-                    e,
+                    t,
                     "dragleave",
                     /*updateDragging*/
-                    t[8]
+                    i[8]
                 )
-            ], c = !0);
+            ], a = !0);
         },
-        p(S, [w]) {
-            T && T.p && (!_ || w & /*$$scope*/
+        p(R, [w]) {
+            F && F.p && (!A || w & /*$$scope*/
                 32768) && update_slot_base(
-                T,
-                r,
-                S,
+                F,
+                o,
+                R,
                 /*$$scope*/
-                S[15],
-                _ ? get_slot_changes(
-                    r,
+                R[15],
+                A ? get_slot_changes(
+                    o,
                     /*$$scope*/
-                    S[15],
+                    R[15],
                     w,
                     null
                 ) : get_all_dirty_from_scope(
                     /*$$scope*/
-                    S[15]
+                    R[15]
                 ),
                 null
-            ), (!_ || w & /*filetype*/
+            ), (!A || w & /*filetype*/
                 1) && attr$2(
-                n,
+                e,
                 "accept",
                 /*filetype*/
-                S[0]
-            ), (!_ || w & /*file_count*/
+                R[0]
+            ), (!A || w & /*file_count*/
                 16 && s !== (s = /*file_count*/
-                    S[4] === "multiple" || void 0)) && (n.multiple = s), (!_ || w & /*file_count*/
-                16 && l !== (l = /*file_count*/
-                    S[4] === "directory" || void 0)) && attr$2(n, "webkitdirectory", l), (!_ || w & /*file_count*/
-                16 && h !== (h = /*file_count*/
-                    S[4] === "directory" || void 0)) && attr$2(n, "mozdirectory", h), (!_ || w & /*hidden*/
+                    R[4] === "multiple" || void 0)) && (e.multiple = s), (!A || w & /*file_count*/
+                16 && p !== (p = /*file_count*/
+                    R[4] === "directory" || void 0)) && attr$2(e, "webkitdirectory", p), (!A || w & /*file_count*/
+                16 && f !== (f = /*file_count*/
+                    R[4] === "directory" || void 0)) && attr$2(e, "mozdirectory", f), (!A || w & /*hidden*/
                 32) && toggle_class$1(
-                e,
+                t,
                 "hidden",
                 /*hidden*/
-                S[5]
-            ), (!_ || w & /*center*/
+                R[5]
+            ), (!A || w & /*center*/
                 4) && toggle_class$1(
-                e,
+                t,
                 "center",
                 /*center*/
-                S[2]
-            ), (!_ || w & /*boundedheight*/
+                R[2]
+            ), (!A || w & /*boundedheight*/
                 2) && toggle_class$1(
-                e,
+                t,
                 "boundedheight",
                 /*boundedheight*/
-                S[1]
-            ), (!_ || w & /*flex*/
+                R[1]
+            ), (!A || w & /*flex*/
                 8) && toggle_class$1(
-                e,
+                t,
                 "flex",
                 /*flex*/
-                S[3]
+                R[3]
             );
         },
-        i(S) {
-            _ || (transition_in$2(T, S), _ = !0);
+        i(R) {
+            A || (transition_in$2(F, R), A = !0);
         },
-        o(S) {
-            transition_out$2(T, S), _ = !1;
+        o(R) {
+            transition_out$2(F, R), A = !1;
         },
-        d(S) {
-            S && detach$2(e), T && T.d(S), t[24](null), c = !1, run_all(o);
+        d(R) {
+            R && detach$2(t), F && F.d(R), i[24](null), a = !1, run_all(h);
         }
     };
 }
 
-function _optionalChain(t) {
-    let e, i = t[0],
-        n = 1;
-    for (; n < t.length;) {
-        const s = t[n],
-            l = t[n + 1];
-        if (n += 2, (s === "optionalAccess" || s === "optionalCall") && i == null)
-            return;
-        s === "access" || s === "optionalAccess" ? (e = i, i = l(i)) : (s === "call" || s === "optionalCall") && (i = l((...h) => i.call(e, ...h)), e = void 0);
-    }
-    return i;
-}
-
-function is_valid_mimetype(t, e) {
-    return !t || t === "*" ? !0 : t.endsWith("/*") ? e.startsWith(t.slice(0, -1)) : t === e;
+function is_valid_mimetype(i, t) {
+    return !i || i === "*" ? !0 : i.endsWith("/*") ? t.startsWith(i.slice(0, -1)) : i === t;
 }
 
-function instance$2(t, e, i) {
+function instance$2(i, t, n) {
     let {
-        $$slots: n = {},
+        $$slots: e = {},
         $$scope: s
-    } = e, {
-        filetype: l = null
-    } = e, {
-        dragging: h = !1
-    } = e, {
-        boundedheight: _ = !0
-    } = e, {
-        center: c = !0
-    } = e, {
-        flex: o = !0
-    } = e, {
-        file_count: r = "single"
-    } = e, {
-        disable_click: T = !1
-    } = e, {
-        root: S
-    } = e, {
-        hidden: w = !1
-    } = e;
-    const C = getContext("upload_files");
-    let P;
-    const b = createEventDispatcher$1();
+    } = t;
+    var p = this && this.__awaiter || function(G, V, H, st) {
+        function dt(yt) {
+            return yt instanceof H ? yt : new H(function(gt) {
+                gt(yt);
+            });
+        }
+        return new(H || (H = Promise))(function(yt, gt) {
+            function k(d) {
+                try {
+                    u(st.next(d));
+                } catch (b) {
+                    gt(b);
+                }
+            }
 
-    function k() {
-        i(11, h = !h);
-    }
+            function l(d) {
+                try {
+                    u(st.throw(d));
+                } catch (b) {
+                    gt(b);
+                }
+            }
 
-    function F() {
-        T || (i(7, P.value = "", P), P.click());
-    }
-    async function x(B) {
-        await tick$1();
-        const ee = await upload(B, S, C);
-        return b("load", r === "single" ? _optionalChain([ee, "optionalAccess", (Y) => Y[0]]) : ee), ee || [];
+            function u(d) {
+                d.done ? yt(d.value) : dt(d.value).then(k, l);
+            }
+            u((st = st.apply(G, V || [])).next());
+        });
+    };
+    let {
+        filetype: f = null
+    } = t, {
+        dragging: A = !1
+    } = t, {
+        boundedheight: a = !0
+    } = t, {
+        center: h = !0
+    } = t, {
+        flex: o = !0
+    } = t, {
+        file_count: F = "single"
+    } = t, {
+        disable_click: R = !1
+    } = t, {
+        root: w
+    } = t, {
+        hidden: T = !1
+    } = t;
+    const P = getContext("upload_files");
+    let m;
+    const C = createEventDispatcher$1();
+
+    function x() {
+        n(11, A = !A);
+    }
+
+    function E() {
+        R || (n(7, m.value = "", m), m.click());
+    }
+
+    function S(G) {
+        return p(this, void 0, void 0, function*() {
+            yield tick$1();
+            const V = yield upload(G, w, P);
+            return C("load", F === "single" ? V == null ? void 0 : V[0] : V), V || [];
+        });
     }
-    async function y(B) {
-        if (!B.length)
-            return;
-        let ee = B.map((q) => new File([q], q.name)),
-            Y = await prepare_files(ee);
-        return await x(Y);
+
+    function g(G) {
+        return p(this, void 0, void 0, function*() {
+            if (!G.length)
+                return;
+            let V = G.map((st) => new File([st], st.name)),
+                H = yield prepare_files(V);
+            return yield S(H);
+        });
     }
-    async function p(B) {
-        const ee = B.target;
-        ee.files && await y(Array.from(ee.files));
+
+    function v(G) {
+        return p(this, void 0, void 0, function*() {
+            const V = G.target;
+            V.files && (yield g(Array.from(V.files)));
+        });
     }
-    async function E(B) {
-        if (i(11, h = !1), !_optionalChain([B, "access", (Y) => Y.dataTransfer, "optionalAccess", (Y) => Y.files]))
-            return;
-        const ee = Array.from(B.dataTransfer.files).filter((Y) => _optionalChain([
-            l,
-            "optionalAccess",
-            (q) => q.split,
-            "call",
-            (q) => q(","),
-            "access",
-            (q) => q.some,
-            "call",
-            (q) => q((le) => is_valid_mimetype(le, Y.type))
-        ]) ? !0 : (b("error", `Invalid file type only ${l} allowed.`), !1));
-        await y(ee);
+
+    function $(G) {
+        return p(this, void 0, void 0, function*() {
+            var V;
+            if (n(11, A = !1), !(!((V = G.dataTransfer) === null || V === void 0) && V.files))
+                return;
+            const H = Array.from(G.dataTransfer.files).filter((st) => f != null && f.split(",").some((dt) => is_valid_mimetype(dt, st.type)) ? !0 : (C("error", `Invalid file type only ${f} allowed.`), !1));
+            yield g(H);
+        });
     }
 
-    function $(B) {
-        bubble.call(this, t, B);
+    function M(G) {
+        bubble.call(this, i, G);
     }
 
-    function M(B) {
-        bubble.call(this, t, B);
+    function _(G) {
+        bubble.call(this, i, G);
     }
 
-    function m(B) {
-        bubble.call(this, t, B);
+    function N(G) {
+        bubble.call(this, i, G);
     }
 
-    function N(B) {
-        bubble.call(this, t, B);
+    function D(G) {
+        bubble.call(this, i, G);
     }
 
-    function D(B) {
-        bubble.call(this, t, B);
+    function X(G) {
+        bubble.call(this, i, G);
     }
 
-    function X(B) {
-        bubble.call(this, t, B);
+    function Y(G) {
+        bubble.call(this, i, G);
     }
 
-    function G(B) {
-        bubble.call(this, t, B);
+    function I(G) {
+        bubble.call(this, i, G);
     }
 
-    function I(B) {
-        binding_callbacks$1[B ? "unshift" : "push"](() => {
-            P = B, i(7, P);
+    function U(G) {
+        binding_callbacks$1[G ? "unshift" : "push"](() => {
+            m = G, n(7, m);
         });
     }
-    return t.$$set = (B) => {
-        "filetype" in B && i(0, l = B.filetype), "dragging" in B && i(11, h = B.dragging), "boundedheight" in B && i(1, _ = B.boundedheight), "center" in B && i(2, c = B.center), "flex" in B && i(3, o = B.flex), "file_count" in B && i(4, r = B.file_count), "disable_click" in B && i(12, T = B.disable_click), "root" in B && i(13, S = B.root), "hidden" in B && i(5, w = B.hidden), "$$scope" in B && i(15, s = B.$$scope);
+    return i.$$set = (G) => {
+        "filetype" in G && n(0, f = G.filetype), "dragging" in G && n(11, A = G.dragging), "boundedheight" in G && n(1, a = G.boundedheight), "center" in G && n(2, h = G.center), "flex" in G && n(3, o = G.flex), "file_count" in G && n(4, F = G.file_count), "disable_click" in G && n(12, R = G.disable_click), "root" in G && n(13, w = G.root), "hidden" in G && n(5, T = G.hidden), "$$scope" in G && n(15, s = G.$$scope);
     }, [
-        l,
-        _,
-        c,
+        f,
+        a,
+        h,
         o,
-        r,
-        w,
         F,
-        P,
-        k,
-        p,
-        E,
-        h,
         T,
-        S,
-        y,
-        s,
-        n,
+        E,
+        m,
+        x,
+        v,
         $,
+        A,
+        R,
+        w,
+        g,
+        s,
+        e,
         M,
-        m,
+        _,
         N,
         D,
         X,
-        G,
-        I
+        Y,
+        I,
+        U
     ];
 }
 class Upload extends SvelteComponent$2 {
-    constructor(e) {
-        super(), init$2(this, e, instance$2, create_fragment$2, safe_not_equal$2, {
+    constructor(t) {
+        super(), init$2(this, t, instance$2, create_fragment$2, safe_not_equal$2, {
             filetype: 0,
             dragging: 11,
             boundedheight: 1,
             center: 2,
             flex: 3,
             file_count: 4,
             disable_click: 12,
@@ -8020,338 +4595,360 @@
     get open_file_upload() {
         return this.$$.ctx[6];
     }
     get load_files() {
         return this.$$.ctx[14];
     }
 }
-const ModifyUpload_svelte_svelte_type_style_lang = "",
-    {
-        SvelteComponent: SvelteComponent$1,
-        append: append$1,
-        attr: attr$1,
-        check_outros: check_outros$1,
-        create_component: create_component$1,
-        destroy_component: destroy_component$1,
-        detach: detach$1,
-        element: element$1,
-        group_outros: group_outros$1,
-        init: init$1,
-        insert: insert$1,
-        mount_component: mount_component$1,
-        safe_not_equal: safe_not_equal$1,
-        set_style: set_style$1,
-        space: space$1,
-        toggle_class,
-        transition_in: transition_in$1,
-        transition_out: transition_out$1
-    } = window.__gradio__svelte__internal,
-    {
-        createEventDispatcher
-    } = window.__gradio__svelte__internal;
-
-function create_if_block_1$1(t) {
-    let e, i;
-    return e = new IconButton({
+const {
+    SvelteComponent: SvelteComponent$1,
+    append: append$1,
+    attr: attr$1,
+    check_outros: check_outros$1,
+    create_component: create_component$1,
+    destroy_component: destroy_component$1,
+    detach: detach$1,
+    element: element$1,
+    group_outros: group_outros$1,
+    init: init$1,
+    insert: insert$1,
+    mount_component: mount_component$1,
+    safe_not_equal: safe_not_equal$1,
+    set_style: set_style$1,
+    space: space$1,
+    toggle_class,
+    transition_in: transition_in$1,
+    transition_out: transition_out$1
+} = window.__gradio__svelte__internal, {
+    createEventDispatcher
+} = window.__gradio__svelte__internal;
+
+function create_if_block_1$1(i) {
+    let t, n;
+    return t = new IconButton({
         props: {
             Icon: Edit,
             label: (
                 /*i18n*/
-                t[3]("common.edit")
+                i[3]("common.edit")
             )
         }
-    }), e.$on(
+    }), t.$on(
         "click",
         /*click_handler*/
-        t[5]
+        i[5]
     ), {
         c() {
-            create_component$1(e.$$.fragment);
+            create_component$1(t.$$.fragment);
         },
-        m(n, s) {
-            mount_component$1(e, n, s), i = !0;
+        m(e, s) {
+            mount_component$1(t, e, s), n = !0;
         },
-        p(n, s) {
-            const l = {};
+        p(e, s) {
+            const p = {};
             s & /*i18n*/
-                8 && (l.label = /*i18n*/
-                    n[3]("common.edit")), e.$set(l);
+                8 && (p.label = /*i18n*/
+                    e[3]("common.edit")), t.$set(p);
         },
-        i(n) {
-            i || (transition_in$1(e.$$.fragment, n), i = !0);
+        i(e) {
+            n || (transition_in$1(t.$$.fragment, e), n = !0);
         },
-        o(n) {
-            transition_out$1(e.$$.fragment, n), i = !1;
+        o(e) {
+            transition_out$1(t.$$.fragment, e), n = !1;
         },
-        d(n) {
-            destroy_component$1(e, n);
+        d(e) {
+            destroy_component$1(t, e);
         }
     };
 }
 
-function create_if_block$1(t) {
-    let e, i;
-    return e = new IconButton({
+function create_if_block$1(i) {
+    let t, n;
+    return t = new IconButton({
         props: {
             Icon: Undo,
             label: (
                 /*i18n*/
-                t[3]("common.undo")
+                i[3]("common.undo")
             )
         }
-    }), e.$on(
+    }), t.$on(
         "click",
         /*click_handler_1*/
-        t[6]
+        i[6]
     ), {
         c() {
-            create_component$1(e.$$.fragment);
+            create_component$1(t.$$.fragment);
         },
-        m(n, s) {
-            mount_component$1(e, n, s), i = !0;
+        m(e, s) {
+            mount_component$1(t, e, s), n = !0;
         },
-        p(n, s) {
-            const l = {};
+        p(e, s) {
+            const p = {};
             s & /*i18n*/
-                8 && (l.label = /*i18n*/
-                    n[3]("common.undo")), e.$set(l);
+                8 && (p.label = /*i18n*/
+                    e[3]("common.undo")), t.$set(p);
         },
-        i(n) {
-            i || (transition_in$1(e.$$.fragment, n), i = !0);
+        i(e) {
+            n || (transition_in$1(t.$$.fragment, e), n = !0);
         },
-        o(n) {
-            transition_out$1(e.$$.fragment, n), i = !1;
+        o(e) {
+            transition_out$1(t.$$.fragment, e), n = !1;
         },
-        d(n) {
-            destroy_component$1(e, n);
+        d(e) {
+            destroy_component$1(t, e);
         }
     };
 }
 
-function create_fragment$1(t) {
-    let e, i, n, s, l, h = (
+function create_fragment$1(i) {
+    let t, n, e, s, p, f = (
             /*editable*/
-            t[0] && create_if_block_1$1(t)
+            i[0] && create_if_block_1$1(i)
         ),
-        _ = (
+        A = (
             /*undoable*/
-            t[1] && create_if_block$1(t)
+            i[1] && create_if_block$1(i)
         );
     return s = new IconButton({
         props: {
             Icon: Clear,
             label: (
                 /*i18n*/
-                t[3]("common.clear")
+                i[3]("common.clear")
             )
         }
     }), s.$on(
         "click",
         /*click_handler_2*/
-        t[7]
+        i[7]
     ), {
         c() {
-            e = element$1("div"), h && h.c(), i = space$1(), _ && _.c(), n = space$1(), create_component$1(s.$$.fragment), attr$1(e, "class", "svelte-1wj0ocy"), toggle_class(e, "not-absolute", ! /*absolute*/
-                t[2]), set_style$1(
-                e,
+            t = element$1("div"), f && f.c(), n = space$1(), A && A.c(), e = space$1(), create_component$1(s.$$.fragment), attr$1(t, "class", "svelte-1wj0ocy"), toggle_class(t, "not-absolute", ! /*absolute*/
+                i[2]), set_style$1(
+                t,
                 "position",
                 /*absolute*/
-                t[2] ? "absolute" : "static"
+                i[2] ? "absolute" : "static"
             );
         },
-        m(c, o) {
-            insert$1(c, e, o), h && h.m(e, null), append$1(e, i), _ && _.m(e, null), append$1(e, n), mount_component$1(s, e, null), l = !0;
+        m(a, h) {
+            insert$1(a, t, h), f && f.m(t, null), append$1(t, n), A && A.m(t, null), append$1(t, e), mount_component$1(s, t, null), p = !0;
         },
-        p(c, [o]) {
+        p(a, [h]) {
             /*editable*/
-            c[0] ? h ? (h.p(c, o), o & /*editable*/
-                    1 && transition_in$1(h, 1)) : (h = create_if_block_1$1(c), h.c(), transition_in$1(h, 1), h.m(e, i)) : h && (group_outros$1(), transition_out$1(h, 1, 1, () => {
-                    h = null;
+            a[0] ? f ? (f.p(a, h), h & /*editable*/
+                    1 && transition_in$1(f, 1)) : (f = create_if_block_1$1(a), f.c(), transition_in$1(f, 1), f.m(t, n)) : f && (group_outros$1(), transition_out$1(f, 1, 1, () => {
+                    f = null;
                 }), check_outros$1()), /*undoable*/
-                c[1] ? _ ? (_.p(c, o), o & /*undoable*/
-                    2 && transition_in$1(_, 1)) : (_ = create_if_block$1(c), _.c(), transition_in$1(_, 1), _.m(e, n)) : _ && (group_outros$1(), transition_out$1(_, 1, 1, () => {
-                    _ = null;
+                a[1] ? A ? (A.p(a, h), h & /*undoable*/
+                    2 && transition_in$1(A, 1)) : (A = create_if_block$1(a), A.c(), transition_in$1(A, 1), A.m(t, e)) : A && (group_outros$1(), transition_out$1(A, 1, 1, () => {
+                    A = null;
                 }), check_outros$1());
-            const r = {};
-            o & /*i18n*/
-                8 && (r.label = /*i18n*/
-                    c[3]("common.clear")), s.$set(r), (!l || o & /*absolute*/
-                    4) && toggle_class(e, "not-absolute", ! /*absolute*/
-                    c[2]), o & /*absolute*/
+            const o = {};
+            h & /*i18n*/
+                8 && (o.label = /*i18n*/
+                    a[3]("common.clear")), s.$set(o), (!p || h & /*absolute*/
+                    4) && toggle_class(t, "not-absolute", ! /*absolute*/
+                    a[2]), h & /*absolute*/
                 4 && set_style$1(
-                    e,
+                    t,
                     "position",
                     /*absolute*/
-                    c[2] ? "absolute" : "static"
+                    a[2] ? "absolute" : "static"
                 );
         },
-        i(c) {
-            l || (transition_in$1(h), transition_in$1(_), transition_in$1(s.$$.fragment, c), l = !0);
+        i(a) {
+            p || (transition_in$1(f), transition_in$1(A), transition_in$1(s.$$.fragment, a), p = !0);
         },
-        o(c) {
-            transition_out$1(h), transition_out$1(_), transition_out$1(s.$$.fragment, c), l = !1;
+        o(a) {
+            transition_out$1(f), transition_out$1(A), transition_out$1(s.$$.fragment, a), p = !1;
         },
-        d(c) {
-            c && detach$1(e), h && h.d(), _ && _.d(), destroy_component$1(s);
+        d(a) {
+            a && detach$1(t), f && f.d(), A && A.d(), destroy_component$1(s);
         }
     };
 }
 
-function instance$1(t, e, i) {
+function instance$1(i, t, n) {
     let {
-        editable: n = !1
-    } = e, {
+        editable: e = !1
+    } = t, {
         undoable: s = !1
-    } = e, {
-        absolute: l = !0
-    } = e, {
-        i18n: h
-    } = e;
-    const _ = createEventDispatcher(),
-        c = () => _("edit"),
-        o = () => _("undo"),
-        r = (T) => {
-            _("clear"), T.stopPropagation();
+    } = t, {
+        absolute: p = !0
+    } = t, {
+        i18n: f
+    } = t;
+    const A = createEventDispatcher(),
+        a = () => A("edit"),
+        h = () => A("undo"),
+        o = (F) => {
+            A("clear"), F.stopPropagation();
         };
-    return t.$$set = (T) => {
-        "editable" in T && i(0, n = T.editable), "undoable" in T && i(1, s = T.undoable), "absolute" in T && i(2, l = T.absolute), "i18n" in T && i(3, h = T.i18n);
+    return i.$$set = (F) => {
+        "editable" in F && n(0, e = F.editable), "undoable" in F && n(1, s = F.undoable), "absolute" in F && n(2, p = F.absolute), "i18n" in F && n(3, f = F.i18n);
     }, [
-        n,
+        e,
         s,
-        l,
+        p,
+        f,
+        A,
+        a,
         h,
-        _,
-        c,
-        o,
-        r
+        o
     ];
 }
 class ModifyUpload extends SvelteComponent$1 {
-    constructor(e) {
-        super(), init$1(this, e, instance$1, create_fragment$1, safe_not_equal$1, {
+    constructor(t) {
+        super(), init$1(this, t, instance$1, create_fragment$1, safe_not_equal$1, {
             editable: 0,
             undoable: 1,
             absolute: 2,
             i18n: 3
         });
     }
 }
 
-function commonjsRequire(t) {
-    throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
+function getAugmentedNamespace(i) {
+    if (i.__esModule)
+        return i;
+    var t = i.default;
+    if (typeof t == "function") {
+        var n = function e() {
+            return this instanceof e ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
+        };
+        n.prototype = t.prototype;
+    } else
+        n = {};
+    return Object.defineProperty(n, "__esModule", {
+        value: !0
+    }), Object.keys(i).forEach(function(e) {
+        var s = Object.getOwnPropertyDescriptor(i, e);
+        Object.defineProperty(n, e, s.get ? s : {
+            enumerable: !0,
+            get: function() {
+                return i[e];
+            }
+        });
+    }), n;
+}
+
+function commonjsRequire(i) {
+    throw new Error('Could not dynamically require "' + i + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
 }
 var pdf = {
     exports: {}
 };
 const require$$5$1 = {},
     __viteBrowserExternal = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
         __proto__: null,
         default: require$$5$1
     }, Symbol.toStringTag, {
         value: "Module"
     })),
     require$$5 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal);
 (function(module, exports) {
-    (function(e, i) {
-        module.exports = e.pdfjsLib = i();
+    (function(t, n) {
+        module.exports = t.pdfjsLib = n();
     })(globalThis, () => (
         /******/
         (() => {
             var __webpack_modules__ = [,
                     /* 1 */
                     /***/
-                    (t, e) => {
-                        var Ye;
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t) => {
+                        var Vt;
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.VerbosityLevel = e.Util = e.UnknownErrorException = e.UnexpectedResponseException = e.TextRenderingMode = e.RenderingIntentFlag = e.PromiseCapability = e.PermissionFlag = e.PasswordResponses = e.PasswordException = e.PageActionEventType = e.OPS = e.MissingPDFException = e.MAX_IMAGE_SIZE_TO_CACHE = e.LINE_FACTOR = e.LINE_DESCENT_FACTOR = e.InvalidPDFException = e.ImageKind = e.IDENTITY_MATRIX = e.FormatError = e.FeatureTest = e.FONT_IDENTITY_MATRIX = e.DocumentActionEventType = e.CMapCompressionType = e.BaseException = e.BASELINE_FACTOR = e.AnnotationType = e.AnnotationReplyType = e.AnnotationPrefix = e.AnnotationMode = e.AnnotationFlag = e.AnnotationFieldFlag = e.AnnotationEditorType = e.AnnotationEditorPrefix = e.AnnotationEditorParamsType = e.AnnotationBorderStyleType = e.AnnotationActionEventType = e.AbortException = void 0, e.assert = le, e.bytesToString = z, e.createValidAbsoluteUrl = we, e.getModificationDate = xe, e.getUuid = Xe, e.getVerbosityLevel = B, e.info = ee, e.isArrayBuffer = ge, e.isArrayEqual = Ce, e.isNodeJS = void 0, e.normalizeUnicode = ze, e.objectFromMap = ue, e.objectSize = ce, e.setVerbosityLevel = I, e.shadow = be, e.string32 = Z, e.stringToBytes = ae, e.stringToPDFString = _e, e.stringToUTF8String = ie, e.unreachable = q, e.utf8StringToString = se, e.warn = Y;
-                        const i = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
-                        e.isNodeJS = i;
-                        const n = [1, 0, 0, 1, 0, 0];
-                        e.IDENTITY_MATRIX = n;
+                        }), t.VerbosityLevel = t.Util = t.UnknownErrorException = t.UnexpectedResponseException = t.TextRenderingMode = t.RenderingIntentFlag = t.PromiseCapability = t.PermissionFlag = t.PasswordResponses = t.PasswordException = t.PageActionEventType = t.OPS = t.MissingPDFException = t.MAX_IMAGE_SIZE_TO_CACHE = t.LINE_FACTOR = t.LINE_DESCENT_FACTOR = t.InvalidPDFException = t.ImageKind = t.IDENTITY_MATRIX = t.FormatError = t.FeatureTest = t.FONT_IDENTITY_MATRIX = t.DocumentActionEventType = t.CMapCompressionType = t.BaseException = t.BASELINE_FACTOR = t.AnnotationType = t.AnnotationReplyType = t.AnnotationPrefix = t.AnnotationMode = t.AnnotationFlag = t.AnnotationFieldFlag = t.AnnotationEditorType = t.AnnotationEditorPrefix = t.AnnotationEditorParamsType = t.AnnotationBorderStyleType = t.AnnotationActionEventType = t.AbortException = void 0, t.assert = st, t.bytesToString = z, t.createValidAbsoluteUrl = yt, t.getModificationDate = Tt, t.getUuid = Gt, t.getVerbosityLevel = U, t.info = G, t.isArrayBuffer = pt, t.isArrayEqual = Ct, t.isNodeJS = void 0, t.normalizeUnicode = zt, t.objectFromMap = ht, t.objectSize = lt, t.setVerbosityLevel = I, t.shadow = gt, t.string32 = Z, t.stringToBytes = it, t.stringToPDFString = _t, t.stringToUTF8String = rt, t.unreachable = H, t.utf8StringToString = at, t.warn = V;
+                        const n = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
+                        t.isNodeJS = n;
+                        const e = [1, 0, 0, 1, 0, 0];
+                        t.IDENTITY_MATRIX = e;
                         const s = [1e-3, 0, 0, 1e-3, 0, 0];
-                        e.FONT_IDENTITY_MATRIX = s;
-                        const l = 1e7;
-                        e.MAX_IMAGE_SIZE_TO_CACHE = l;
-                        const h = 1.35;
-                        e.LINE_FACTOR = h;
-                        const _ = 0.35;
-                        e.LINE_DESCENT_FACTOR = _;
-                        const c = _ / h;
-                        e.BASELINE_FACTOR = c;
-                        const o = {
+                        t.FONT_IDENTITY_MATRIX = s;
+                        const p = 1e7;
+                        t.MAX_IMAGE_SIZE_TO_CACHE = p;
+                        const f = 1.35;
+                        t.LINE_FACTOR = f;
+                        const A = 0.35;
+                        t.LINE_DESCENT_FACTOR = A;
+                        const a = A / f;
+                        t.BASELINE_FACTOR = a;
+                        const h = {
                             ANY: 1,
                             DISPLAY: 2,
                             PRINT: 4,
                             SAVE: 8,
                             ANNOTATIONS_FORMS: 16,
                             ANNOTATIONS_STORAGE: 32,
                             ANNOTATIONS_DISABLE: 64,
                             OPLIST: 256
                         };
-                        e.RenderingIntentFlag = o;
-                        const r = {
+                        t.RenderingIntentFlag = h;
+                        const o = {
                             DISABLE: 0,
                             ENABLE: 1,
                             ENABLE_FORMS: 2,
                             ENABLE_STORAGE: 3
                         };
-                        e.AnnotationMode = r;
-                        const T = "pdfjs_internal_editor_";
-                        e.AnnotationEditorPrefix = T;
-                        const S = {
+                        t.AnnotationMode = o;
+                        const F = "pdfjs_internal_editor_";
+                        t.AnnotationEditorPrefix = F;
+                        const R = {
                             DISABLE: -1,
                             NONE: 0,
                             FREETEXT: 3,
                             STAMP: 13,
                             INK: 15
                         };
-                        e.AnnotationEditorType = S;
+                        t.AnnotationEditorType = R;
                         const w = {
                             RESIZE: 1,
                             CREATE: 2,
                             FREETEXT_SIZE: 11,
                             FREETEXT_COLOR: 12,
                             FREETEXT_OPACITY: 13,
                             INK_COLOR: 21,
                             INK_THICKNESS: 22,
                             INK_OPACITY: 23
                         };
-                        e.AnnotationEditorParamsType = w;
-                        const C = {
+                        t.AnnotationEditorParamsType = w;
+                        const T = {
                             PRINT: 4,
                             MODIFY_CONTENTS: 8,
                             COPY: 16,
                             MODIFY_ANNOTATIONS: 32,
                             FILL_INTERACTIVE_FORMS: 256,
                             COPY_FOR_ACCESSIBILITY: 512,
                             ASSEMBLE: 1024,
                             PRINT_HIGH_QUALITY: 2048
                         };
-                        e.PermissionFlag = C;
+                        t.PermissionFlag = T;
                         const P = {
                             FILL: 0,
                             STROKE: 1,
                             FILL_STROKE: 2,
                             INVISIBLE: 3,
                             FILL_ADD_TO_PATH: 4,
                             STROKE_ADD_TO_PATH: 5,
                             FILL_STROKE_ADD_TO_PATH: 6,
                             ADD_TO_PATH: 7,
                             FILL_STROKE_MASK: 3,
                             ADD_TO_PATH_FLAG: 4
                         };
-                        e.TextRenderingMode = P;
-                        const b = {
+                        t.TextRenderingMode = P;
+                        const m = {
                             GRAYSCALE_1BPP: 1,
                             RGB_24BPP: 2,
                             RGBA_32BPP: 3
                         };
-                        e.ImageKind = b;
-                        const k = {
+                        t.ImageKind = m;
+                        const C = {
                             TEXT: 1,
                             LINK: 2,
                             FREETEXT: 3,
                             LINE: 4,
                             SQUARE: 5,
                             CIRCLE: 6,
                             POLYGON: 7,
@@ -8371,34 +4968,34 @@
                             SCREEN: 21,
                             PRINTERMARK: 22,
                             TRAPNET: 23,
                             WATERMARK: 24,
                             THREED: 25,
                             REDACT: 26
                         };
-                        e.AnnotationType = k;
-                        const F = {
+                        t.AnnotationType = C;
+                        const x = {
                             GROUP: "Group",
                             REPLY: "R"
                         };
-                        e.AnnotationReplyType = F;
-                        const x = {
+                        t.AnnotationReplyType = x;
+                        const E = {
                             INVISIBLE: 1,
                             HIDDEN: 2,
                             PRINT: 4,
                             NOZOOM: 8,
                             NOROTATE: 16,
                             NOVIEW: 32,
                             READONLY: 64,
                             LOCKED: 128,
                             TOGGLENOVIEW: 256,
                             LOCKEDCONTENTS: 512
                         };
-                        e.AnnotationFlag = x;
-                        const y = {
+                        t.AnnotationFlag = E;
+                        const S = {
                             READONLY: 1,
                             REQUIRED: 2,
                             NOEXPORT: 4,
                             MULTILINE: 4096,
                             PASSWORD: 8192,
                             NOTOGGLETOOFF: 16384,
                             RADIO: 32768,
@@ -8411,24 +5008,24 @@
                             DONOTSPELLCHECK: 4194304,
                             DONOTSCROLL: 8388608,
                             COMB: 16777216,
                             RICHTEXT: 33554432,
                             RADIOSINUNISON: 33554432,
                             COMMITONSELCHANGE: 67108864
                         };
-                        e.AnnotationFieldFlag = y;
-                        const p = {
+                        t.AnnotationFieldFlag = S;
+                        const g = {
                             SOLID: 1,
                             DASHED: 2,
                             BEVELED: 3,
                             INSET: 4,
                             UNDERLINE: 5
                         };
-                        e.AnnotationBorderStyleType = p;
-                        const E = {
+                        t.AnnotationBorderStyleType = g;
+                        const v = {
                             E: "Mouse Enter",
                             X: "Mouse Exit",
                             D: "Mouse Down",
                             U: "Mouse Up",
                             Fo: "Focus",
                             Bl: "Blur",
                             PO: "PageOpen",
@@ -8436,39 +5033,39 @@
                             PV: "PageVisible",
                             PI: "PageInvisible",
                             K: "Keystroke",
                             F: "Format",
                             V: "Validate",
                             C: "Calculate"
                         };
-                        e.AnnotationActionEventType = E;
+                        t.AnnotationActionEventType = v;
                         const $ = {
                             WC: "WillClose",
                             WS: "WillSave",
                             DS: "DidSave",
                             WP: "WillPrint",
                             DP: "DidPrint"
                         };
-                        e.DocumentActionEventType = $;
+                        t.DocumentActionEventType = $;
                         const M = {
                             O: "PageOpen",
                             C: "PageClose"
                         };
-                        e.PageActionEventType = M;
-                        const m = {
+                        t.PageActionEventType = M;
+                        const _ = {
                             ERRORS: 0,
                             WARNINGS: 1,
                             INFOS: 5
                         };
-                        e.VerbosityLevel = m;
+                        t.VerbosityLevel = _;
                         const N = {
                             NONE: 0,
                             BINARY: 1
                         };
-                        e.CMapCompressionType = N;
+                        t.CMapCompressionType = N;
                         const D = {
                             dependency: 1,
                             setLineWidth: 2,
                             setLineCap: 3,
                             setLineJoin: 4,
                             setMiterLimit: 5,
                             setDash: 6,
@@ -8551,389 +5148,389 @@
                             paintInlineImageXObject: 86,
                             paintInlineImageXObjectGroup: 87,
                             paintImageXObjectRepeat: 88,
                             paintImageMaskXObjectRepeat: 89,
                             paintSolidColorImageMask: 90,
                             constructPath: 91
                         };
-                        e.OPS = D;
+                        t.OPS = D;
                         const X = {
                             NEED_PASSWORD: 1,
                             INCORRECT_PASSWORD: 2
                         };
-                        e.PasswordResponses = X;
-                        let G = m.WARNINGS;
+                        t.PasswordResponses = X;
+                        let Y = _.WARNINGS;
 
-                        function I(de) {
-                            Number.isInteger(de) && (G = de);
+                        function I(ut) {
+                            Number.isInteger(ut) && (Y = ut);
                         }
 
-                        function B() {
-                            return G;
+                        function U() {
+                            return Y;
                         }
 
-                        function ee(de) {
-                            G >= m.INFOS && console.log(`Info: ${de}`);
+                        function G(ut) {
+                            Y >= _.INFOS && console.log(`Info: ${ut}`);
                         }
 
-                        function Y(de) {
-                            G >= m.WARNINGS && console.log(`Warning: ${de}`);
+                        function V(ut) {
+                            Y >= _.WARNINGS && console.log(`Warning: ${ut}`);
                         }
 
-                        function q(de) {
-                            throw new Error(de);
+                        function H(ut) {
+                            throw new Error(ut);
                         }
 
-                        function le(de, ne) {
-                            de || q(ne);
+                        function st(ut, nt) {
+                            ut || H(nt);
                         }
 
-                        function pe(de) {
-                            switch (de == null ? void 0 : de.protocol) {
+                        function dt(ut) {
+                            switch (ut == null ? void 0 : ut.protocol) {
                                 case "http:":
                                 case "https:":
                                 case "ftp:":
                                 case "mailto:":
                                 case "tel:":
                                     return !0;
                                 default:
                                     return !1;
                             }
                         }
 
-                        function we(de, ne = null, J = null) {
-                            if (!de)
+                        function yt(ut, nt = null, Q = null) {
+                            if (!ut)
                                 return null;
                             try {
-                                if (J && typeof de == "string") {
-                                    if (J.addDefaultProtocol && de.startsWith("www.")) {
-                                        const Se = de.match(/\./g);
-                                        (Se == null ? void 0 : Se.length) >= 2 && (de = `http://${de}`);
+                                if (Q && typeof ut == "string") {
+                                    if (Q.addDefaultProtocol && ut.startsWith("www.")) {
+                                        const wt = ut.match(/\./g);
+                                        (wt == null ? void 0 : wt.length) >= 2 && (ut = `http://${ut}`);
                                     }
-                                    if (J.tryConvertEncoding)
+                                    if (Q.tryConvertEncoding)
                                         try {
-                                            de = ie(de);
+                                            ut = rt(ut);
                                         } catch {}
                                 }
-                                const ve = ne ? new URL(de, ne) : new URL(de);
-                                if (pe(ve))
-                                    return ve;
+                                const At = nt ? new URL(ut, nt) : new URL(ut);
+                                if (dt(At))
+                                    return At;
                             } catch {}
                             return null;
                         }
 
-                        function be(de, ne, J, ve = !1) {
-                            return Object.defineProperty(de, ne, {
-                                value: J,
-                                enumerable: !ve,
+                        function gt(ut, nt, Q, At = !1) {
+                            return Object.defineProperty(ut, nt, {
+                                value: Q,
+                                enumerable: !At,
                                 configurable: !0,
                                 writable: !1
-                            }), J;
+                            }), Q;
                         }
-                        const R = function() {
-                            function ne(J, ve) {
-                                this.constructor === ne && q("Cannot initialize BaseException."), this.message = J, this.name = ve;
+                        const k = function() {
+                            function nt(Q, At) {
+                                this.constructor === nt && H("Cannot initialize BaseException."), this.message = Q, this.name = At;
                             }
-                            return ne.prototype = new Error(), ne.constructor = ne, ne;
+                            return nt.prototype = new Error(), nt.constructor = nt, nt;
                         }();
-                        e.BaseException = R;
-                        class d extends R {
-                            constructor(ne, J) {
-                                super(ne, "PasswordException"), this.code = J;
+                        t.BaseException = k;
+                        class l extends k {
+                            constructor(nt, Q) {
+                                super(nt, "PasswordException"), this.code = Q;
                             }
                         }
-                        e.PasswordException = d;
-                        class g extends R {
-                            constructor(ne, J) {
-                                super(ne, "UnknownErrorException"), this.details = J;
+                        t.PasswordException = l;
+                        class u extends k {
+                            constructor(nt, Q) {
+                                super(nt, "UnknownErrorException"), this.details = Q;
                             }
                         }
-                        e.UnknownErrorException = g;
-                        class f extends R {
-                            constructor(ne) {
-                                super(ne, "InvalidPDFException");
+                        t.UnknownErrorException = u;
+                        class d extends k {
+                            constructor(nt) {
+                                super(nt, "InvalidPDFException");
                             }
                         }
-                        e.InvalidPDFException = f;
-                        class v extends R {
-                            constructor(ne) {
-                                super(ne, "MissingPDFException");
+                        t.InvalidPDFException = d;
+                        class b extends k {
+                            constructor(nt) {
+                                super(nt, "MissingPDFException");
                             }
                         }
-                        e.MissingPDFException = v;
-                        class A extends R {
-                            constructor(ne, J) {
-                                super(ne, "UnexpectedResponseException"), this.status = J;
+                        t.MissingPDFException = b;
+                        class y extends k {
+                            constructor(nt, Q) {
+                                super(nt, "UnexpectedResponseException"), this.status = Q;
                             }
                         }
-                        e.UnexpectedResponseException = A;
-                        class O extends R {
-                            constructor(ne) {
-                                super(ne, "FormatError");
+                        t.UnexpectedResponseException = y;
+                        class O extends k {
+                            constructor(nt) {
+                                super(nt, "FormatError");
                             }
                         }
-                        e.FormatError = O;
-                        class H extends R {
-                            constructor(ne) {
-                                super(ne, "AbortException");
+                        t.FormatError = O;
+                        class B extends k {
+                            constructor(nt) {
+                                super(nt, "AbortException");
                             }
                         }
-                        e.AbortException = H;
+                        t.AbortException = B;
 
-                        function z(de) {
-                            (typeof de != "object" || (de == null ? void 0 : de.length) === void 0) && q("Invalid argument for bytesToString");
-                            const ne = de.length,
-                                J = 8192;
-                            if (ne < J)
-                                return String.fromCharCode.apply(null, de);
-                            const ve = [];
-                            for (let Se = 0; Se < ne; Se += J) {
-                                const tt = Math.min(Se + J, ne),
-                                    et = de.subarray(Se, tt);
-                                ve.push(String.fromCharCode.apply(null, et));
+                        function z(ut) {
+                            (typeof ut != "object" || (ut == null ? void 0 : ut.length) === void 0) && H("Invalid argument for bytesToString");
+                            const nt = ut.length,
+                                Q = 8192;
+                            if (nt < Q)
+                                return String.fromCharCode.apply(null, ut);
+                            const At = [];
+                            for (let wt = 0; wt < nt; wt += Q) {
+                                const te = Math.min(wt + Q, nt),
+                                    Qt = ut.subarray(wt, te);
+                                At.push(String.fromCharCode.apply(null, Qt));
                             }
-                            return ve.join("");
+                            return At.join("");
                         }
 
-                        function ae(de) {
-                            typeof de != "string" && q("Invalid argument for stringToBytes");
-                            const ne = de.length,
-                                J = new Uint8Array(ne);
-                            for (let ve = 0; ve < ne; ++ve)
-                                J[ve] = de.charCodeAt(ve) & 255;
-                            return J;
+                        function it(ut) {
+                            typeof ut != "string" && H("Invalid argument for stringToBytes");
+                            const nt = ut.length,
+                                Q = new Uint8Array(nt);
+                            for (let At = 0; At < nt; ++At)
+                                Q[At] = ut.charCodeAt(At) & 255;
+                            return Q;
                         }
 
-                        function Z(de) {
-                            return String.fromCharCode(de >> 24 & 255, de >> 16 & 255, de >> 8 & 255, de & 255);
+                        function Z(ut) {
+                            return String.fromCharCode(ut >> 24 & 255, ut >> 16 & 255, ut >> 8 & 255, ut & 255);
                         }
 
-                        function ce(de) {
-                            return Object.keys(de).length;
+                        function lt(ut) {
+                            return Object.keys(ut).length;
                         }
 
-                        function ue(de) {
-                            const ne = /* @__PURE__ */ Object.create(null);
-                            for (const [J, ve] of de)
-                                ne[J] = ve;
-                            return ne;
+                        function ht(ut) {
+                            const nt = /* @__PURE__ */ Object.create(null);
+                            for (const [Q, At] of ut)
+                                nt[Q] = At;
+                            return nt;
                         }
 
-                        function me() {
-                            const de = new Uint8Array(4);
-                            return de[0] = 1, new Uint32Array(de.buffer, 0, 1)[0] === 1;
+                        function mt() {
+                            const ut = new Uint8Array(4);
+                            return ut[0] = 1, new Uint32Array(ut.buffer, 0, 1)[0] === 1;
                         }
 
-                        function fe() {
+                        function ft() {
                             try {
                                 return new Function(""), !0;
                             } catch {
                                 return !1;
                             }
                         }
-                        class Pe {
+                        class kt {
                             static get isLittleEndian() {
-                                return be(this, "isLittleEndian", me());
+                                return gt(this, "isLittleEndian", mt());
                             }
                             static get isEvalSupported() {
-                                return be(this, "isEvalSupported", fe());
+                                return gt(this, "isEvalSupported", ft());
                             }
                             static get isOffscreenCanvasSupported() {
-                                return be(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
+                                return gt(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
                             }
                             static get platform() {
-                                return typeof navigator > "u" ? be(this, "platform", {
+                                return typeof navigator > "u" ? gt(this, "platform", {
                                     isWin: !1,
                                     isMac: !1
-                                }) : be(this, "platform", {
+                                }) : gt(this, "platform", {
                                     isWin: navigator.platform.includes("Win"),
                                     isMac: navigator.platform.includes("Mac")
                                 });
                             }
                             static get isCSSRoundSupported() {
-                                var ne, J;
-                                return be(this, "isCSSRoundSupported", (J = (ne = globalThis.CSS) == null ? void 0 : ne.supports) == null ? void 0 : J.call(ne, "width: round(1.5px, 1px)"));
+                                var nt, Q;
+                                return gt(this, "isCSSRoundSupported", (Q = (nt = globalThis.CSS) == null ? void 0 : nt.supports) == null ? void 0 : Q.call(nt, "width: round(1.5px, 1px)"));
                             }
                         }
-                        e.FeatureTest = Pe;
-                        const Fe = [...Array(256).keys()].map((de) => de.toString(16).padStart(2, "0"));
-                        class Ee {
-                            static makeHexColor(ne, J, ve) {
-                                return `#${Fe[ne]}${Fe[J]}${Fe[ve]}`;
-                            }
-                            static scaleMinMax(ne, J) {
-                                let ve;
-                                ne[0] ? (ne[0] < 0 && (ve = J[0], J[0] = J[1], J[1] = ve), J[0] *= ne[0], J[1] *= ne[0], ne[3] < 0 && (ve = J[2], J[2] = J[3], J[3] = ve), J[2] *= ne[3], J[3] *= ne[3]) : (ve = J[0], J[0] = J[2], J[2] = ve, ve = J[1], J[1] = J[3], J[3] = ve, ne[1] < 0 && (ve = J[2], J[2] = J[3], J[3] = ve), J[2] *= ne[1], J[3] *= ne[1], ne[2] < 0 && (ve = J[0], J[0] = J[1], J[1] = ve), J[0] *= ne[2], J[1] *= ne[2]), J[0] += ne[4], J[1] += ne[4], J[2] += ne[5], J[3] += ne[5];
-                            }
-                            static transform(ne, J) {
-                                return [ne[0] * J[0] + ne[2] * J[1], ne[1] * J[0] + ne[3] * J[1], ne[0] * J[2] + ne[2] * J[3], ne[1] * J[2] + ne[3] * J[3], ne[0] * J[4] + ne[2] * J[5] + ne[4], ne[1] * J[4] + ne[3] * J[5] + ne[5]];
-                            }
-                            static applyTransform(ne, J) {
-                                const ve = ne[0] * J[0] + ne[1] * J[2] + J[4],
-                                    Se = ne[0] * J[1] + ne[1] * J[3] + J[5];
-                                return [ve, Se];
-                            }
-                            static applyInverseTransform(ne, J) {
-                                const ve = J[0] * J[3] - J[1] * J[2],
-                                    Se = (ne[0] * J[3] - ne[1] * J[2] + J[2] * J[5] - J[4] * J[3]) / ve,
-                                    tt = (-ne[0] * J[1] + ne[1] * J[0] + J[4] * J[1] - J[5] * J[0]) / ve;
-                                return [Se, tt];
-                            }
-                            static getAxialAlignedBoundingBox(ne, J) {
-                                const ve = this.applyTransform(ne, J),
-                                    Se = this.applyTransform(ne.slice(2, 4), J),
-                                    tt = this.applyTransform([ne[0], ne[3]], J),
-                                    et = this.applyTransform([ne[2], ne[1]], J);
-                                return [Math.min(ve[0], Se[0], tt[0], et[0]), Math.min(ve[1], Se[1], tt[1], et[1]), Math.max(ve[0], Se[0], tt[0], et[0]), Math.max(ve[1], Se[1], tt[1], et[1])];
-                            }
-                            static inverseTransform(ne) {
-                                const J = ne[0] * ne[3] - ne[1] * ne[2];
-                                return [ne[3] / J, -ne[1] / J, -ne[2] / J, ne[0] / J, (ne[2] * ne[5] - ne[4] * ne[3]) / J, (ne[4] * ne[1] - ne[5] * ne[0]) / J];
-                            }
-                            static singularValueDecompose2dScale(ne) {
-                                const J = [ne[0], ne[2], ne[1], ne[3]],
-                                    ve = ne[0] * J[0] + ne[1] * J[2],
-                                    Se = ne[0] * J[1] + ne[1] * J[3],
-                                    tt = ne[2] * J[0] + ne[3] * J[2],
-                                    et = ne[2] * J[1] + ne[3] * J[3],
-                                    te = (ve + et) / 2,
-                                    Te = Math.sqrt((ve + et) ** 2 - 4 * (ve * et - tt * Se)) / 2,
-                                    Ne = te + Te || 1,
-                                    ke = te - Te || 1;
-                                return [Math.sqrt(Ne), Math.sqrt(ke)];
-                            }
-                            static normalizeRect(ne) {
-                                const J = ne.slice(0);
-                                return ne[0] > ne[2] && (J[0] = ne[2], J[2] = ne[0]), ne[1] > ne[3] && (J[1] = ne[3], J[3] = ne[1]), J;
-                            }
-                            static intersect(ne, J) {
-                                const ve = Math.max(Math.min(ne[0], ne[2]), Math.min(J[0], J[2])),
-                                    Se = Math.min(Math.max(ne[0], ne[2]), Math.max(J[0], J[2]));
-                                if (ve > Se)
+                        t.FeatureTest = kt;
+                        const Rt = [...Array(256).keys()].map((ut) => ut.toString(16).padStart(2, "0"));
+                        class St {
+                            static makeHexColor(nt, Q, At) {
+                                return `#${Rt[nt]}${Rt[Q]}${Rt[At]}`;
+                            }
+                            static scaleMinMax(nt, Q) {
+                                let At;
+                                nt[0] ? (nt[0] < 0 && (At = Q[0], Q[0] = Q[1], Q[1] = At), Q[0] *= nt[0], Q[1] *= nt[0], nt[3] < 0 && (At = Q[2], Q[2] = Q[3], Q[3] = At), Q[2] *= nt[3], Q[3] *= nt[3]) : (At = Q[0], Q[0] = Q[2], Q[2] = At, At = Q[1], Q[1] = Q[3], Q[3] = At, nt[1] < 0 && (At = Q[2], Q[2] = Q[3], Q[3] = At), Q[2] *= nt[1], Q[3] *= nt[1], nt[2] < 0 && (At = Q[0], Q[0] = Q[1], Q[1] = At), Q[0] *= nt[2], Q[1] *= nt[2]), Q[0] += nt[4], Q[1] += nt[4], Q[2] += nt[5], Q[3] += nt[5];
+                            }
+                            static transform(nt, Q) {
+                                return [nt[0] * Q[0] + nt[2] * Q[1], nt[1] * Q[0] + nt[3] * Q[1], nt[0] * Q[2] + nt[2] * Q[3], nt[1] * Q[2] + nt[3] * Q[3], nt[0] * Q[4] + nt[2] * Q[5] + nt[4], nt[1] * Q[4] + nt[3] * Q[5] + nt[5]];
+                            }
+                            static applyTransform(nt, Q) {
+                                const At = nt[0] * Q[0] + nt[1] * Q[2] + Q[4],
+                                    wt = nt[0] * Q[1] + nt[1] * Q[3] + Q[5];
+                                return [At, wt];
+                            }
+                            static applyInverseTransform(nt, Q) {
+                                const At = Q[0] * Q[3] - Q[1] * Q[2],
+                                    wt = (nt[0] * Q[3] - nt[1] * Q[2] + Q[2] * Q[5] - Q[4] * Q[3]) / At,
+                                    te = (-nt[0] * Q[1] + nt[1] * Q[0] + Q[4] * Q[1] - Q[5] * Q[0]) / At;
+                                return [wt, te];
+                            }
+                            static getAxialAlignedBoundingBox(nt, Q) {
+                                const At = this.applyTransform(nt, Q),
+                                    wt = this.applyTransform(nt.slice(2, 4), Q),
+                                    te = this.applyTransform([nt[0], nt[3]], Q),
+                                    Qt = this.applyTransform([nt[2], nt[1]], Q);
+                                return [Math.min(At[0], wt[0], te[0], Qt[0]), Math.min(At[1], wt[1], te[1], Qt[1]), Math.max(At[0], wt[0], te[0], Qt[0]), Math.max(At[1], wt[1], te[1], Qt[1])];
+                            }
+                            static inverseTransform(nt) {
+                                const Q = nt[0] * nt[3] - nt[1] * nt[2];
+                                return [nt[3] / Q, -nt[1] / Q, -nt[2] / Q, nt[0] / Q, (nt[2] * nt[5] - nt[4] * nt[3]) / Q, (nt[4] * nt[1] - nt[5] * nt[0]) / Q];
+                            }
+                            static singularValueDecompose2dScale(nt) {
+                                const Q = [nt[0], nt[2], nt[1], nt[3]],
+                                    At = nt[0] * Q[0] + nt[1] * Q[2],
+                                    wt = nt[0] * Q[1] + nt[1] * Q[3],
+                                    te = nt[2] * Q[0] + nt[3] * Q[2],
+                                    Qt = nt[2] * Q[1] + nt[3] * Q[3],
+                                    et = (At + Qt) / 2,
+                                    Et = Math.sqrt((At + Qt) ** 2 - 4 * (At * Qt - te * wt)) / 2,
+                                    Ot = et + Et || 1,
+                                    Pt = et - Et || 1;
+                                return [Math.sqrt(Ot), Math.sqrt(Pt)];
+                            }
+                            static normalizeRect(nt) {
+                                const Q = nt.slice(0);
+                                return nt[0] > nt[2] && (Q[0] = nt[2], Q[2] = nt[0]), nt[1] > nt[3] && (Q[1] = nt[3], Q[3] = nt[1]), Q;
+                            }
+                            static intersect(nt, Q) {
+                                const At = Math.max(Math.min(nt[0], nt[2]), Math.min(Q[0], Q[2])),
+                                    wt = Math.min(Math.max(nt[0], nt[2]), Math.max(Q[0], Q[2]));
+                                if (At > wt)
                                     return null;
-                                const tt = Math.max(Math.min(ne[1], ne[3]), Math.min(J[1], J[3])),
-                                    et = Math.min(Math.max(ne[1], ne[3]), Math.max(J[1], J[3]));
-                                return tt > et ? null : [ve, tt, Se, et];
-                            }
-                            static bezierBoundingBox(ne, J, ve, Se, tt, et, te, Te) {
-                                const Ne = [],
-                                    ke = [
+                                const te = Math.max(Math.min(nt[1], nt[3]), Math.min(Q[1], Q[3])),
+                                    Qt = Math.min(Math.max(nt[1], nt[3]), Math.max(Q[1], Q[3]));
+                                return te > Qt ? null : [At, te, wt, Qt];
+                            }
+                            static bezierBoundingBox(nt, Q, At, wt, te, Qt, et, Et) {
+                                const Ot = [],
+                                    Pt = [
                                         [],
                                         []
                                     ];
-                                let $e, Be, Ze, Ae, Ke, Oe, U, u;
-                                for (let Q = 0; Q < 2; ++Q) {
-                                    if (Q === 0 ? (Be = 6 * ne - 12 * ve + 6 * tt, $e = -3 * ne + 9 * ve - 9 * tt + 3 * te, Ze = 3 * ve - 3 * ne) : (Be = 6 * J - 12 * Se + 6 * et, $e = -3 * J + 9 * Se - 9 * et + 3 * Te, Ze = 3 * Se - 3 * J), Math.abs($e) < 1e-12) {
-                                        if (Math.abs(Be) < 1e-12)
+                                let $t, Nt, Jt, vt, Yt, Lt, j, c;
+                                for (let tt = 0; tt < 2; ++tt) {
+                                    if (tt === 0 ? (Nt = 6 * nt - 12 * At + 6 * te, $t = -3 * nt + 9 * At - 9 * te + 3 * et, Jt = 3 * At - 3 * nt) : (Nt = 6 * Q - 12 * wt + 6 * Qt, $t = -3 * Q + 9 * wt - 9 * Qt + 3 * Et, Jt = 3 * wt - 3 * Q), Math.abs($t) < 1e-12) {
+                                        if (Math.abs(Nt) < 1e-12)
                                             continue;
-                                        Ae = -Ze / Be, 0 < Ae && Ae < 1 && Ne.push(Ae);
+                                        vt = -Jt / Nt, 0 < vt && vt < 1 && Ot.push(vt);
                                         continue;
                                     }
-                                    U = Be * Be - 4 * Ze * $e, u = Math.sqrt(U), !(U < 0) && (Ke = (-Be + u) / (2 * $e), 0 < Ke && Ke < 1 && Ne.push(Ke), Oe = (-Be - u) / (2 * $e), 0 < Oe && Oe < 1 && Ne.push(Oe));
+                                    j = Nt * Nt - 4 * Jt * $t, c = Math.sqrt(j), !(j < 0) && (Yt = (-Nt + c) / (2 * $t), 0 < Yt && Yt < 1 && Ot.push(Yt), Lt = (-Nt - c) / (2 * $t), 0 < Lt && Lt < 1 && Ot.push(Lt));
                                 }
-                                let L = Ne.length,
-                                    j;
-                                const V = L;
+                                let L = Ot.length,
+                                    q;
+                                const K = L;
                                 for (; L--;)
-                                    Ae = Ne[L], j = 1 - Ae, ke[0][L] = j * j * j * ne + 3 * j * j * Ae * ve + 3 * j * Ae * Ae * tt + Ae * Ae * Ae * te, ke[1][L] = j * j * j * J + 3 * j * j * Ae * Se + 3 * j * Ae * Ae * et + Ae * Ae * Ae * Te;
-                                return ke[0][V] = ne, ke[1][V] = J, ke[0][V + 1] = te, ke[1][V + 1] = Te, ke[0].length = ke[1].length = V + 2, [Math.min(...ke[0]), Math.min(...ke[1]), Math.max(...ke[0]), Math.max(...ke[1])];
+                                    vt = Ot[L], q = 1 - vt, Pt[0][L] = q * q * q * nt + 3 * q * q * vt * At + 3 * q * vt * vt * te + vt * vt * vt * et, Pt[1][L] = q * q * q * Q + 3 * q * q * vt * wt + 3 * q * vt * vt * Qt + vt * vt * vt * Et;
+                                return Pt[0][K] = nt, Pt[1][K] = Q, Pt[0][K + 1] = et, Pt[1][K + 1] = Et, Pt[0].length = Pt[1].length = K + 2, [Math.min(...Pt[0]), Math.min(...Pt[1]), Math.max(...Pt[0]), Math.max(...Pt[1])];
                             }
                         }
-                        e.Util = Ee;
-                        const De = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
+                        t.Util = St;
+                        const It = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
 
-                        function _e(de) {
-                            if (de[0] >= "ï") {
-                                let J;
-                                if (de[0] === "þ" && de[1] === "ÿ" ? J = "utf-16be" : de[0] === "ÿ" && de[1] === "þ" ? J = "utf-16le" : de[0] === "ï" && de[1] === "»" && de[2] === "¿" && (J = "utf-8"), J)
+                        function _t(ut) {
+                            if (ut[0] >= "ï") {
+                                let Q;
+                                if (ut[0] === "þ" && ut[1] === "ÿ" ? Q = "utf-16be" : ut[0] === "ÿ" && ut[1] === "þ" ? Q = "utf-16le" : ut[0] === "ï" && ut[1] === "»" && ut[2] === "¿" && (Q = "utf-8"), Q)
                                     try {
-                                        const ve = new TextDecoder(J, {
+                                        const At = new TextDecoder(Q, {
                                                 fatal: !0
                                             }),
-                                            Se = ae(de);
-                                        return ve.decode(Se);
-                                    } catch (ve) {
-                                        Y(`stringToPDFString: "${ve}".`);
+                                            wt = it(ut);
+                                        return At.decode(wt);
+                                    } catch (At) {
+                                        V(`stringToPDFString: "${At}".`);
                                     }
                             }
-                            const ne = [];
-                            for (let J = 0, ve = de.length; J < ve; J++) {
-                                const Se = De[de.charCodeAt(J)];
-                                ne.push(Se ? String.fromCharCode(Se) : de.charAt(J));
+                            const nt = [];
+                            for (let Q = 0, At = ut.length; Q < At; Q++) {
+                                const wt = It[ut.charCodeAt(Q)];
+                                nt.push(wt ? String.fromCharCode(wt) : ut.charAt(Q));
                             }
-                            return ne.join("");
+                            return nt.join("");
                         }
 
-                        function ie(de) {
-                            return decodeURIComponent(escape(de));
+                        function rt(ut) {
+                            return decodeURIComponent(escape(ut));
                         }
 
-                        function se(de) {
-                            return unescape(encodeURIComponent(de));
+                        function at(ut) {
+                            return unescape(encodeURIComponent(ut));
                         }
 
-                        function ge(de) {
-                            return typeof de == "object" && (de == null ? void 0 : de.byteLength) !== void 0;
+                        function pt(ut) {
+                            return typeof ut == "object" && (ut == null ? void 0 : ut.byteLength) !== void 0;
                         }
 
-                        function Ce(de, ne) {
-                            if (de.length !== ne.length)
+                        function Ct(ut, nt) {
+                            if (ut.length !== nt.length)
                                 return !1;
-                            for (let J = 0, ve = de.length; J < ve; J++)
-                                if (de[J] !== ne[J])
+                            for (let Q = 0, At = ut.length; Q < At; Q++)
+                                if (ut[Q] !== nt[Q])
                                     return !1;
                             return !0;
                         }
 
-                        function xe(de = /* @__PURE__ */ new Date()) {
-                            return [de.getUTCFullYear().toString(), (de.getUTCMonth() + 1).toString().padStart(2, "0"), de.getUTCDate().toString().padStart(2, "0"), de.getUTCHours().toString().padStart(2, "0"), de.getUTCMinutes().toString().padStart(2, "0"), de.getUTCSeconds().toString().padStart(2, "0")].join("");
+                        function Tt(ut = /* @__PURE__ */ new Date()) {
+                            return [ut.getUTCFullYear().toString(), (ut.getUTCMonth() + 1).toString().padStart(2, "0"), ut.getUTCDate().toString().padStart(2, "0"), ut.getUTCHours().toString().padStart(2, "0"), ut.getUTCMinutes().toString().padStart(2, "0"), ut.getUTCSeconds().toString().padStart(2, "0")].join("");
                         }
-                        class He {
+                        class Bt {
                             constructor() {
-                                W(this, Ye, !1);
-                                this.promise = new Promise((ne, J) => {
-                                    this.resolve = (ve) => {
-                                        oe(this, Ye, !0), ne(ve);
-                                    }, this.reject = (ve) => {
-                                        oe(this, Ye, !0), J(ve);
+                                W(this, Vt, !1);
+                                this.promise = new Promise((nt, Q) => {
+                                    this.resolve = (At) => {
+                                        ot(this, Vt, !0), nt(At);
+                                    }, this.reject = (At) => {
+                                        ot(this, Vt, !0), Q(At);
                                     };
                                 });
                             }
                             get settled() {
-                                return a(this, Ye);
+                                return r(this, Vt);
                             }
                         }
-                        Ye = new WeakMap(), e.PromiseCapability = He;
-                        let We = null,
-                            je = null;
+                        Vt = new WeakMap(), t.PromiseCapability = Bt;
+                        let Wt = null,
+                            jt = null;
 
-                        function ze(de) {
-                            return We || (We = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, je = /* @__PURE__ */ new Map([
+                        function zt(ut) {
+                            return Wt || (Wt = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, jt = /* @__PURE__ */ new Map([
                                 ["ﬅ", "ſt"]
-                            ])), de.replaceAll(We, (ne, J, ve) => J ? J.normalize("NFKC") : je.get(ve));
+                            ])), ut.replaceAll(Wt, (nt, Q, At) => Q ? Q.normalize("NFKC") : jt.get(At));
                         }
 
-                        function Xe() {
+                        function Gt() {
                             if (typeof crypto < "u" && typeof(crypto == null ? void 0 : crypto.randomUUID) == "function")
                                 return crypto.randomUUID();
-                            const de = new Uint8Array(32);
+                            const ut = new Uint8Array(32);
                             if (typeof crypto < "u" && typeof(crypto == null ? void 0 : crypto.getRandomValues) == "function")
-                                crypto.getRandomValues(de);
+                                crypto.getRandomValues(ut);
                             else
-                                for (let ne = 0; ne < 32; ne++)
-                                    de[ne] = Math.floor(Math.random() * 255);
-                            return z(de);
+                                for (let nt = 0; nt < 32; nt++)
+                                    ut[nt] = Math.floor(Math.random() * 255);
+                            return z(ut);
                         }
-                        const Ge = "pdfjs_internal_id_";
-                        e.AnnotationPrefix = Ge;
+                        const qt = "pdfjs_internal_id_";
+                        t.AnnotationPrefix = qt;
                     },
                     /* 2 */
                     /***/
                     (__unused_webpack_module, exports, __w_pdfjs_require__) => {
-                        var t, i, n, s, ut, h, wt, c, o, r, T, S, w, C, P, b, Tt, F, x, Bt, p, E;
+                        var i, n, e, s, he, f, we, a, h, o, F, R, w, T, P, m, Ee, x, E, Ne, g, v;
                         Object.defineProperty(exports, "__esModule", {
                             value: !0
                         }), exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0, Object.defineProperty(exports, "SVGGraphics", {
                             enumerable: !0,
                             get: function() {
                                 return _displaySvg.SVGGraphics;
                             }
@@ -8971,144 +5568,144 @@
                                     url: M
                                 } : (0, _util.isArrayBuffer)(M) && (M = {
                                     data: M
                                 }), typeof M != "object")
                                 throw new Error("Invalid parameter in getDocument, need parameter object.");
                             if (!M.url && !M.data && !M.range)
                                 throw new Error("Invalid parameter object: need either .data, .range or .url");
-                            const m = new PDFDocumentLoadingTask(),
+                            const _ = new PDFDocumentLoadingTask(),
                                 {
                                     docId: N
-                                } = m,
+                                } = _,
                                 D = M.url ? getUrlProp(M.url) : null,
                                 X = M.data ? getDataProp(M.data) : null,
-                                G = M.httpHeaders || null,
+                                Y = M.httpHeaders || null,
                                 I = M.withCredentials === !0,
-                                B = M.password ?? null,
-                                ee = M.range instanceof PDFDataRangeTransport ? M.range : null,
-                                Y = Number.isInteger(M.rangeChunkSize) && M.rangeChunkSize > 0 ? M.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
-                            let q = M.worker instanceof PDFWorker ? M.worker : null;
-                            const le = M.verbosity,
-                                pe = typeof M.docBaseUrl == "string" && !(0, _display_utils.isDataScheme)(M.docBaseUrl) ? M.docBaseUrl : null,
-                                we = typeof M.cMapUrl == "string" ? M.cMapUrl : null,
-                                be = M.cMapPacked !== !1,
-                                R = M.CMapReaderFactory || DefaultCMapReaderFactory,
-                                d = typeof M.standardFontDataUrl == "string" ? M.standardFontDataUrl : null,
-                                g = M.StandardFontDataFactory || DefaultStandardFontDataFactory,
-                                f = M.stopAtErrors !== !0,
-                                v = Number.isInteger(M.maxImageSize) && M.maxImageSize > -1 ? M.maxImageSize : -1,
-                                A = M.isEvalSupported !== !1,
+                                U = M.password ?? null,
+                                G = M.range instanceof PDFDataRangeTransport ? M.range : null,
+                                V = Number.isInteger(M.rangeChunkSize) && M.rangeChunkSize > 0 ? M.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
+                            let H = M.worker instanceof PDFWorker ? M.worker : null;
+                            const st = M.verbosity,
+                                dt = typeof M.docBaseUrl == "string" && !(0, _display_utils.isDataScheme)(M.docBaseUrl) ? M.docBaseUrl : null,
+                                yt = typeof M.cMapUrl == "string" ? M.cMapUrl : null,
+                                gt = M.cMapPacked !== !1,
+                                k = M.CMapReaderFactory || DefaultCMapReaderFactory,
+                                l = typeof M.standardFontDataUrl == "string" ? M.standardFontDataUrl : null,
+                                u = M.StandardFontDataFactory || DefaultStandardFontDataFactory,
+                                d = M.stopAtErrors !== !0,
+                                b = Number.isInteger(M.maxImageSize) && M.maxImageSize > -1 ? M.maxImageSize : -1,
+                                y = M.isEvalSupported !== !1,
                                 O = typeof M.isOffscreenCanvasSupported == "boolean" ? M.isOffscreenCanvasSupported : !_util.isNodeJS,
-                                H = Number.isInteger(M.canvasMaxAreaInBytes) ? M.canvasMaxAreaInBytes : -1,
+                                B = Number.isInteger(M.canvasMaxAreaInBytes) ? M.canvasMaxAreaInBytes : -1,
                                 z = typeof M.disableFontFace == "boolean" ? M.disableFontFace : _util.isNodeJS,
-                                ae = M.fontExtraProperties === !0,
+                                it = M.fontExtraProperties === !0,
                                 Z = M.enableXfa === !0,
-                                ce = M.ownerDocument || globalThis.document,
-                                ue = M.disableRange === !0,
-                                me = M.disableStream === !0,
-                                fe = M.disableAutoFetch === !0,
-                                Pe = M.pdfBug === !0,
-                                Fe = ee ? ee.length : M.length ?? NaN,
-                                Ee = typeof M.useSystemFonts == "boolean" ? M.useSystemFonts : !_util.isNodeJS && !z,
-                                De = typeof M.useWorkerFetch == "boolean" ? M.useWorkerFetch : R === _display_utils.DOMCMapReaderFactory && g === _display_utils.DOMStandardFontDataFactory && we && d && (0, _display_utils.isValidFetchUrl)(we, document.baseURI) && (0, _display_utils.isValidFetchUrl)(d, document.baseURI),
-                                _e = M.canvasFactory || new DefaultCanvasFactory({
-                                    ownerDocument: ce
+                                lt = M.ownerDocument || globalThis.document,
+                                ht = M.disableRange === !0,
+                                mt = M.disableStream === !0,
+                                ft = M.disableAutoFetch === !0,
+                                kt = M.pdfBug === !0,
+                                Rt = G ? G.length : M.length ?? NaN,
+                                St = typeof M.useSystemFonts == "boolean" ? M.useSystemFonts : !_util.isNodeJS && !z,
+                                It = typeof M.useWorkerFetch == "boolean" ? M.useWorkerFetch : k === _display_utils.DOMCMapReaderFactory && u === _display_utils.DOMStandardFontDataFactory && yt && l && (0, _display_utils.isValidFetchUrl)(yt, document.baseURI) && (0, _display_utils.isValidFetchUrl)(l, document.baseURI),
+                                _t = M.canvasFactory || new DefaultCanvasFactory({
+                                    ownerDocument: lt
                                 }),
-                                ie = M.filterFactory || new DefaultFilterFactory({
+                                rt = M.filterFactory || new DefaultFilterFactory({
                                     docId: N,
-                                    ownerDocument: ce
+                                    ownerDocument: lt
                                 }),
-                                se = null;
-                            (0, _util.setVerbosityLevel)(le);
-                            const ge = {
-                                canvasFactory: _e,
-                                filterFactory: ie
+                                at = null;
+                            (0, _util.setVerbosityLevel)(st);
+                            const pt = {
+                                canvasFactory: _t,
+                                filterFactory: rt
                             };
-                            if (De || (ge.cMapReaderFactory = new R({
-                                    baseUrl: we,
-                                    isCompressed: be
-                                }), ge.standardFontDataFactory = new g({
-                                    baseUrl: d
-                                })), !q) {
-                                const He = {
-                                    verbosity: le,
+                            if (It || (pt.cMapReaderFactory = new k({
+                                    baseUrl: yt,
+                                    isCompressed: gt
+                                }), pt.standardFontDataFactory = new u({
+                                    baseUrl: l
+                                })), !H) {
+                                const Bt = {
+                                    verbosity: st,
                                     port: _worker_options.GlobalWorkerOptions.workerPort
                                 };
-                                q = He.port ? PDFWorker.fromPort(He) : new PDFWorker(He), m._worker = q;
+                                H = Bt.port ? PDFWorker.fromPort(Bt) : new PDFWorker(Bt), _._worker = H;
                             }
-                            const Ce = {
+                            const Ct = {
                                     docId: N,
                                     apiVersion: "3.11.174",
                                     data: X,
-                                    password: B,
-                                    disableAutoFetch: fe,
-                                    rangeChunkSize: Y,
-                                    length: Fe,
-                                    docBaseUrl: pe,
+                                    password: U,
+                                    disableAutoFetch: ft,
+                                    rangeChunkSize: V,
+                                    length: Rt,
+                                    docBaseUrl: dt,
                                     enableXfa: Z,
                                     evaluatorOptions: {
-                                        maxImageSize: v,
+                                        maxImageSize: b,
                                         disableFontFace: z,
-                                        ignoreErrors: f,
-                                        isEvalSupported: A,
+                                        ignoreErrors: d,
+                                        isEvalSupported: y,
                                         isOffscreenCanvasSupported: O,
-                                        canvasMaxAreaInBytes: H,
-                                        fontExtraProperties: ae,
-                                        useSystemFonts: Ee,
-                                        cMapUrl: De ? we : null,
-                                        standardFontDataUrl: De ? d : null
+                                        canvasMaxAreaInBytes: B,
+                                        fontExtraProperties: it,
+                                        useSystemFonts: St,
+                                        cMapUrl: It ? yt : null,
+                                        standardFontDataUrl: It ? l : null
                                     }
                                 },
-                                xe = {
-                                    ignoreErrors: f,
-                                    isEvalSupported: A,
+                                Tt = {
+                                    ignoreErrors: d,
+                                    isEvalSupported: y,
                                     disableFontFace: z,
-                                    fontExtraProperties: ae,
+                                    fontExtraProperties: it,
                                     enableXfa: Z,
-                                    ownerDocument: ce,
-                                    disableAutoFetch: fe,
-                                    pdfBug: Pe,
-                                    styleElement: se
+                                    ownerDocument: lt,
+                                    disableAutoFetch: ft,
+                                    pdfBug: kt,
+                                    styleElement: at
                                 };
-                            return q.promise.then(function() {
-                                if (m.destroyed)
+                            return H.promise.then(function() {
+                                if (_.destroyed)
                                     throw new Error("Loading aborted");
-                                const He = _fetchDocument(q, Ce),
-                                    We = new Promise(function(je) {
-                                        let ze;
-                                        ee ? ze = new _transport_stream.PDFDataTransportStream({
-                                            length: Fe,
-                                            initialData: ee.initialData,
-                                            progressiveDone: ee.progressiveDone,
-                                            contentDispositionFilename: ee.contentDispositionFilename,
-                                            disableRange: ue,
-                                            disableStream: me
-                                        }, ee) : X || (ze = ((Ge) => _util.isNodeJS ? new _displayNode_stream.PDFNodeStream(Ge) : (0, _display_utils.isValidFetchUrl)(Ge.url) ? new _displayFetch_stream.PDFFetchStream(Ge) : new _displayNetwork.PDFNetworkStream(Ge))({
+                                const Bt = _fetchDocument(H, Ct),
+                                    Wt = new Promise(function(jt) {
+                                        let zt;
+                                        G ? zt = new _transport_stream.PDFDataTransportStream({
+                                            length: Rt,
+                                            initialData: G.initialData,
+                                            progressiveDone: G.progressiveDone,
+                                            contentDispositionFilename: G.contentDispositionFilename,
+                                            disableRange: ht,
+                                            disableStream: mt
+                                        }, G) : X || (zt = ((qt) => _util.isNodeJS ? new _displayNode_stream.PDFNodeStream(qt) : (0, _display_utils.isValidFetchUrl)(qt.url) ? new _displayFetch_stream.PDFFetchStream(qt) : new _displayNetwork.PDFNetworkStream(qt))({
                                             url: D,
-                                            length: Fe,
-                                            httpHeaders: G,
+                                            length: Rt,
+                                            httpHeaders: Y,
                                             withCredentials: I,
-                                            rangeChunkSize: Y,
-                                            disableRange: ue,
-                                            disableStream: me
-                                        })), je(ze);
+                                            rangeChunkSize: V,
+                                            disableRange: ht,
+                                            disableStream: mt
+                                        })), jt(zt);
                                     });
-                                return Promise.all([He, We]).then(function([je, ze]) {
-                                    if (m.destroyed)
+                                return Promise.all([Bt, Wt]).then(function([jt, zt]) {
+                                    if (_.destroyed)
                                         throw new Error("Loading aborted");
-                                    const Xe = new _message_handler.MessageHandler(N, je, q.port),
-                                        Ge = new WorkerTransport(Xe, m, ze, xe, ge);
-                                    m._transport = Ge, Xe.send("Ready", null);
+                                    const Gt = new _message_handler.MessageHandler(N, jt, H.port),
+                                        qt = new WorkerTransport(Gt, _, zt, Tt, pt);
+                                    _._transport = qt, Gt.send("Ready", null);
                                 });
-                            }).catch(m._capability.reject), m;
+                            }).catch(_._capability.reject), _;
                         }
-                        async function _fetchDocument(M, m) {
+                        async function _fetchDocument(M, _) {
                             if (M.destroyed)
                                 throw new Error("Worker was destroyed");
-                            const N = await M.messageHandler.sendWithPromise("GetDocRequest", m, m.data ? [m.data.buffer] : null);
+                            const N = await M.messageHandler.sendWithPromise("GetDocRequest", _, _.data ? [_.data.buffer] : null);
                             if (M.destroyed)
                                 throw new Error("Worker was destroyed");
                             return N;
                         }
 
                         function getUrlProp(M) {
                             if (M instanceof URL)
@@ -9129,91 +5726,91 @@
                                 return M;
                             if (typeof M == "string")
                                 return (0, _util.stringToBytes)(M);
                             if (typeof M == "object" && !isNaN(M == null ? void 0 : M.length) || (0, _util.isArrayBuffer)(M))
                                 return new Uint8Array(M);
                             throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
                         }
-                        const e = class e {
+                        const t = class t {
                             constructor() {
-                                this._capability = new _util.PromiseCapability(), this._transport = null, this._worker = null, this.docId = `d${_t(e, t)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
+                                this._capability = new _util.PromiseCapability(), this._transport = null, this._worker = null, this.docId = `d${ge(t, i)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
                             }
                             get promise() {
                                 return this._capability.promise;
                             }
                             async destroy() {
-                                var m, N, D;
+                                var _, N, D;
                                 this.destroyed = !0;
                                 try {
-                                    (m = this._worker) != null && m.port && (this._worker._pendingDestroy = !0), await ((N = this._transport) == null ? void 0 : N.destroy());
+                                    (_ = this._worker) != null && _.port && (this._worker._pendingDestroy = !0), await ((N = this._transport) == null ? void 0 : N.destroy());
                                 } catch (X) {
                                     throw (D = this._worker) != null && D.port && delete this._worker._pendingDestroy, X;
                                 }
                                 this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
                             }
                         };
-                        t = new WeakMap(), W(e, t, 0);
-                        let PDFDocumentLoadingTask = e;
+                        i = new WeakMap(), W(t, i, 0);
+                        let PDFDocumentLoadingTask = t;
                         exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
                         class PDFDataRangeTransport {
-                            constructor(m, N, D = !1, X = null) {
-                                this.length = m, this.initialData = N, this.progressiveDone = D, this.contentDispositionFilename = X, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = new _util.PromiseCapability();
+                            constructor(_, N, D = !1, X = null) {
+                                this.length = _, this.initialData = N, this.progressiveDone = D, this.contentDispositionFilename = X, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = new _util.PromiseCapability();
                             }
-                            addRangeListener(m) {
-                                this._rangeListeners.push(m);
+                            addRangeListener(_) {
+                                this._rangeListeners.push(_);
                             }
-                            addProgressListener(m) {
-                                this._progressListeners.push(m);
+                            addProgressListener(_) {
+                                this._progressListeners.push(_);
                             }
-                            addProgressiveReadListener(m) {
-                                this._progressiveReadListeners.push(m);
+                            addProgressiveReadListener(_) {
+                                this._progressiveReadListeners.push(_);
                             }
-                            addProgressiveDoneListener(m) {
-                                this._progressiveDoneListeners.push(m);
+                            addProgressiveDoneListener(_) {
+                                this._progressiveDoneListeners.push(_);
                             }
-                            onDataRange(m, N) {
+                            onDataRange(_, N) {
                                 for (const D of this._rangeListeners)
-                                    D(m, N);
+                                    D(_, N);
                             }
-                            onDataProgress(m, N) {
+                            onDataProgress(_, N) {
                                 this._readyCapability.promise.then(() => {
                                     for (const D of this._progressListeners)
-                                        D(m, N);
+                                        D(_, N);
                                 });
                             }
-                            onDataProgressiveRead(m) {
+                            onDataProgressiveRead(_) {
                                 this._readyCapability.promise.then(() => {
                                     for (const N of this._progressiveReadListeners)
-                                        N(m);
+                                        N(_);
                                 });
                             }
                             onDataProgressiveDone() {
                                 this._readyCapability.promise.then(() => {
-                                    for (const m of this._progressiveDoneListeners)
-                                        m();
+                                    for (const _ of this._progressiveDoneListeners)
+                                        _();
                                 });
                             }
                             transportReady() {
                                 this._readyCapability.resolve();
                             }
-                            requestDataRange(m, N) {
+                            requestDataRange(_, N) {
                                 (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
                             }
                             abort() {}
                         }
                         exports.PDFDataRangeTransport = PDFDataRangeTransport;
                         class PDFDocumentProxy {
-                            constructor(m, N) {
-                                this._pdfInfo = m, this._transport = N, Object.defineProperty(this, "getJavaScript", {
+                            constructor(_, N) {
+                                this._pdfInfo = _, this._transport = N, Object.defineProperty(this, "getJavaScript", {
                                     value: () => ((0, _display_utils.deprecated)("`PDFDocumentProxy.getJavaScript`, please use `PDFDocumentProxy.getJSActions` instead."), this.getJSActions().then((D) => {
                                         if (!D)
                                             return D;
                                         const X = [];
-                                        for (const G in D)
-                                            X.push(...D[G]);
+                                        for (const Y in D)
+                                            X.push(...D[Y]);
                                         return X;
                                     }))
                                 });
                             }
                             get annotationStorage() {
                                 return this._transport.annotationStorage;
                             }
@@ -9228,25 +5825,25 @@
                             }
                             get isPureXfa() {
                                 return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
                             }
                             get allXfaHtml() {
                                 return this._transport._htmlForXfa;
                             }
-                            getPage(m) {
-                                return this._transport.getPage(m);
+                            getPage(_) {
+                                return this._transport.getPage(_);
                             }
-                            getPageIndex(m) {
-                                return this._transport.getPageIndex(m);
+                            getPageIndex(_) {
+                                return this._transport.getPageIndex(_);
                             }
                             getDestinations() {
                                 return this._transport.getDestinations();
                             }
-                            getDestination(m) {
-                                return this._transport.getDestination(m);
+                            getDestination(_) {
+                                return this._transport.getDestination(_);
                             }
                             getPageLabels() {
                                 return this._transport.getPageLabels();
                             }
                             getPageLayout() {
                                 return this._transport.getPageLayout();
                             }
@@ -9285,16 +5882,16 @@
                             }
                             saveDocument() {
                                 return this._transport.saveDocument();
                             }
                             getDownloadInfo() {
                                 return this._transport.downloadInfoCapability.promise;
                             }
-                            cleanup(m = !1) {
-                                return this._transport.startCleanup(m || this.isPureXfa);
+                            cleanup(_ = !1) {
+                                return this._transport.startCleanup(_ || this.isPureXfa);
                             }
                             destroy() {
                                 return this.loadingTask.destroy();
                             }
                             get loadingParams() {
                                 return this._transport.loadingParams;
                             }
@@ -9309,20 +5906,20 @@
                             }
                             getCalculationOrderIds() {
                                 return this._transport.getCalculationOrderIds();
                             }
                         }
                         exports.PDFDocumentProxy = PDFDocumentProxy;
                         class PDFPageProxy {
-                            constructor(m, N, D, X = !1) {
+                            constructor(_, N, D, X = !1) {
                                 W(this, s);
-                                W(this, h);
-                                W(this, i, null);
-                                W(this, n, !1);
-                                this._pageIndex = m, this._pageInfo = N, this._transport = D, this._stats = X ? new _display_utils.StatTimer() : null, this._pdfBug = X, this.commonObjs = D.commonObjs, this.objs = new PDFObjects(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
+                                W(this, f);
+                                W(this, n, null);
+                                W(this, e, !1);
+                                this._pageIndex = _, this._pageInfo = N, this._transport = D, this._stats = X ? new _display_utils.StatTimer() : null, this._pdfBug = X, this.commonObjs = D.commonObjs, this.objs = new PDFObjects(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
                             }
                             get pageNumber() {
                                 return this._pageIndex + 1;
                             }
                             get rotate() {
                                 return this._pageInfo.rotate;
                             }
@@ -9332,371 +5929,371 @@
                             get userUnit() {
                                 return this._pageInfo.userUnit;
                             }
                             get view() {
                                 return this._pageInfo.view;
                             }
                             getViewport({
-                                scale: m,
+                                scale: _,
                                 rotation: N = this.rotate,
                                 offsetX: D = 0,
                                 offsetY: X = 0,
-                                dontFlip: G = !1
+                                dontFlip: Y = !1
                             } = {}) {
                                 return new _display_utils.PageViewport({
                                     viewBox: this.view,
-                                    scale: m,
+                                    scale: _,
                                     rotation: N,
                                     offsetX: D,
                                     offsetY: X,
-                                    dontFlip: G
+                                    dontFlip: Y
                                 });
                             }
                             getAnnotations({
-                                intent: m = "display"
+                                intent: _ = "display"
                             } = {}) {
-                                const N = this._transport.getRenderingIntent(m);
+                                const N = this._transport.getRenderingIntent(_);
                                 return this._transport.getAnnotations(this._pageIndex, N.renderingIntent);
                             }
                             getJSActions() {
                                 return this._transport.getPageJSActions(this._pageIndex);
                             }
                             get filterFactory() {
                                 return this._transport.filterFactory;
                             }
                             get isPureXfa() {
                                 return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
                             }
                             async getXfa() {
-                                var m;
-                                return ((m = this._transport._htmlForXfa) == null ? void 0 : m.children[this._pageIndex]) || null;
+                                var _;
+                                return ((_ = this._transport._htmlForXfa) == null ? void 0 : _.children[this._pageIndex]) || null;
                             }
                             render({
-                                canvasContext: m,
+                                canvasContext: _,
                                 viewport: N,
                                 intent: D = "display",
                                 annotationMode: X = _util.AnnotationMode.ENABLE,
-                                transform: G = null,
+                                transform: Y = null,
                                 background: I = null,
-                                optionalContentConfigPromise: B = null,
-                                annotationCanvasMap: ee = null,
-                                pageColors: Y = null,
-                                printAnnotationStorage: q = null
+                                optionalContentConfigPromise: U = null,
+                                annotationCanvasMap: G = null,
+                                pageColors: V = null,
+                                printAnnotationStorage: H = null
                             }) {
-                                var g, f;
-                                (g = this._stats) == null || g.time("Overall");
-                                const le = this._transport.getRenderingIntent(D, X, q);
-                                oe(this, n, !1), K(this, h, wt).call(this), B || (B = this._transport.getOptionalContentConfig());
-                                let pe = this._intentStates.get(le.cacheKey);
-                                pe || (pe = /* @__PURE__ */ Object.create(null), this._intentStates.set(le.cacheKey, pe)), pe.streamReaderCancelTimeout && (clearTimeout(pe.streamReaderCancelTimeout), pe.streamReaderCancelTimeout = null);
-                                const we = !!(le.renderingIntent & _util.RenderingIntentFlag.PRINT);
-                                pe.displayReadyCapability || (pe.displayReadyCapability = new _util.PromiseCapability(), pe.operatorList = {
+                                var u, d;
+                                (u = this._stats) == null || u.time("Overall");
+                                const st = this._transport.getRenderingIntent(D, X, H);
+                                ot(this, e, !1), J(this, f, we).call(this), U || (U = this._transport.getOptionalContentConfig());
+                                let dt = this._intentStates.get(st.cacheKey);
+                                dt || (dt = /* @__PURE__ */ Object.create(null), this._intentStates.set(st.cacheKey, dt)), dt.streamReaderCancelTimeout && (clearTimeout(dt.streamReaderCancelTimeout), dt.streamReaderCancelTimeout = null);
+                                const yt = !!(st.renderingIntent & _util.RenderingIntentFlag.PRINT);
+                                dt.displayReadyCapability || (dt.displayReadyCapability = new _util.PromiseCapability(), dt.operatorList = {
                                     fnArray: [],
                                     argsArray: [],
                                     lastChunk: !1,
                                     separateAnnots: null
-                                }, (f = this._stats) == null || f.time("Page Request"), this._pumpOperatorList(le));
-                                const be = (v) => {
-                                        var A, O;
-                                        pe.renderTasks.delete(R), (this._maybeCleanupAfterRender || we) && oe(this, n, !0), K(this, s, ut).call(this, !we), v ? (R.capability.reject(v), this._abortOperatorList({
-                                            intentState: pe,
-                                            reason: v instanceof Error ? v : new Error(v)
-                                        })) : R.capability.resolve(), (A = this._stats) == null || A.timeEnd("Rendering"), (O = this._stats) == null || O.timeEnd("Overall");
+                                }, (d = this._stats) == null || d.time("Page Request"), this._pumpOperatorList(st));
+                                const gt = (b) => {
+                                        var y, O;
+                                        dt.renderTasks.delete(k), (this._maybeCleanupAfterRender || yt) && ot(this, e, !0), J(this, s, he).call(this, !yt), b ? (k.capability.reject(b), this._abortOperatorList({
+                                            intentState: dt,
+                                            reason: b instanceof Error ? b : new Error(b)
+                                        })) : k.capability.resolve(), (y = this._stats) == null || y.timeEnd("Rendering"), (O = this._stats) == null || O.timeEnd("Overall");
                                     },
-                                    R = new InternalRenderTask({
-                                        callback: be,
+                                    k = new InternalRenderTask({
+                                        callback: gt,
                                         params: {
-                                            canvasContext: m,
+                                            canvasContext: _,
                                             viewport: N,
-                                            transform: G,
+                                            transform: Y,
                                             background: I
                                         },
                                         objs: this.objs,
                                         commonObjs: this.commonObjs,
-                                        annotationCanvasMap: ee,
-                                        operatorList: pe.operatorList,
+                                        annotationCanvasMap: G,
+                                        operatorList: dt.operatorList,
                                         pageIndex: this._pageIndex,
                                         canvasFactory: this._transport.canvasFactory,
                                         filterFactory: this._transport.filterFactory,
-                                        useRequestAnimationFrame: !we,
+                                        useRequestAnimationFrame: !yt,
                                         pdfBug: this._pdfBug,
-                                        pageColors: Y
+                                        pageColors: V
                                     });
-                                (pe.renderTasks || (pe.renderTasks = /* @__PURE__ */ new Set())).add(R);
-                                const d = R.task;
-                                return Promise.all([pe.displayReadyCapability.promise, B]).then(([v, A]) => {
+                                (dt.renderTasks || (dt.renderTasks = /* @__PURE__ */ new Set())).add(k);
+                                const l = k.task;
+                                return Promise.all([dt.displayReadyCapability.promise, U]).then(([b, y]) => {
                                     var O;
                                     if (this.destroyed) {
-                                        be();
+                                        gt();
                                         return;
                                     }
-                                    (O = this._stats) == null || O.time("Rendering"), R.initializeGraphics({
-                                        transparency: v,
-                                        optionalContentConfig: A
-                                    }), R.operatorListChanged();
-                                }).catch(be), d;
+                                    (O = this._stats) == null || O.time("Rendering"), k.initializeGraphics({
+                                        transparency: b,
+                                        optionalContentConfig: y
+                                    }), k.operatorListChanged();
+                                }).catch(gt), l;
                             }
                             getOperatorList({
-                                intent: m = "display",
+                                intent: _ = "display",
                                 annotationMode: N = _util.AnnotationMode.ENABLE,
                                 printAnnotationStorage: D = null
                             } = {}) {
-                                var ee;
+                                var G;
 
                                 function X() {
-                                    I.operatorList.lastChunk && (I.opListReadCapability.resolve(I.operatorList), I.renderTasks.delete(B));
+                                    I.operatorList.lastChunk && (I.opListReadCapability.resolve(I.operatorList), I.renderTasks.delete(U));
                                 }
-                                const G = this._transport.getRenderingIntent(m, N, D, !0);
-                                let I = this._intentStates.get(G.cacheKey);
-                                I || (I = /* @__PURE__ */ Object.create(null), this._intentStates.set(G.cacheKey, I));
-                                let B;
-                                return I.opListReadCapability || (B = /* @__PURE__ */ Object.create(null), B.operatorListChanged = X, I.opListReadCapability = new _util.PromiseCapability(), (I.renderTasks || (I.renderTasks = /* @__PURE__ */ new Set())).add(B), I.operatorList = {
+                                const Y = this._transport.getRenderingIntent(_, N, D, !0);
+                                let I = this._intentStates.get(Y.cacheKey);
+                                I || (I = /* @__PURE__ */ Object.create(null), this._intentStates.set(Y.cacheKey, I));
+                                let U;
+                                return I.opListReadCapability || (U = /* @__PURE__ */ Object.create(null), U.operatorListChanged = X, I.opListReadCapability = new _util.PromiseCapability(), (I.renderTasks || (I.renderTasks = /* @__PURE__ */ new Set())).add(U), I.operatorList = {
                                     fnArray: [],
                                     argsArray: [],
                                     lastChunk: !1,
                                     separateAnnots: null
-                                }, (ee = this._stats) == null || ee.time("Page Request"), this._pumpOperatorList(G)), I.opListReadCapability.promise;
+                                }, (G = this._stats) == null || G.time("Page Request"), this._pumpOperatorList(Y)), I.opListReadCapability.promise;
                             }
                             streamTextContent({
-                                includeMarkedContent: m = !1,
+                                includeMarkedContent: _ = !1,
                                 disableNormalization: N = !1
                             } = {}) {
                                 return this._transport.messageHandler.sendWithStream("GetTextContent", {
                                     pageIndex: this._pageIndex,
-                                    includeMarkedContent: m === !0,
+                                    includeMarkedContent: _ === !0,
                                     disableNormalization: N === !0
                                 }, {
                                     highWaterMark: 100,
                                     size(X) {
                                         return X.items.length;
                                     }
                                 });
                             }
-                            getTextContent(m = {}) {
+                            getTextContent(_ = {}) {
                                 if (this._transport._htmlForXfa)
                                     return this.getXfa().then((D) => _xfa_text.XfaText.textContent(D));
-                                const N = this.streamTextContent(m);
+                                const N = this.streamTextContent(_);
                                 return new Promise(function(D, X) {
-                                    function G() {
+                                    function Y() {
                                         I.read().then(function({
-                                            value: ee,
-                                            done: Y
+                                            value: G,
+                                            done: V
                                         }) {
-                                            if (Y) {
-                                                D(B);
+                                            if (V) {
+                                                D(U);
                                                 return;
                                             }
-                                            Object.assign(B.styles, ee.styles), B.items.push(...ee.items), G();
+                                            Object.assign(U.styles, G.styles), U.items.push(...G.items), Y();
                                         }, X);
                                     }
                                     const I = N.getReader(),
-                                        B = {
+                                        U = {
                                             items: [],
                                             styles: /* @__PURE__ */ Object.create(null)
                                         };
-                                    G();
+                                    Y();
                                 });
                             }
                             getStructTree() {
                                 return this._transport.getStructTree(this._pageIndex);
                             }
                             _destroy() {
                                 this.destroyed = !0;
-                                const m = [];
+                                const _ = [];
                                 for (const N of this._intentStates.values())
                                     if (this._abortOperatorList({
                                             intentState: N,
                                             reason: new Error("Page was destroyed."),
                                             force: !0
                                         }), !N.opListReadCapability)
                                         for (const D of N.renderTasks)
-                                            m.push(D.completed), D.cancel();
-                                return this.objs.clear(), oe(this, n, !1), K(this, h, wt).call(this), Promise.all(m);
+                                            _.push(D.completed), D.cancel();
+                                return this.objs.clear(), ot(this, e, !1), J(this, f, we).call(this), Promise.all(_);
                             }
-                            cleanup(m = !1) {
-                                oe(this, n, !0);
-                                const N = K(this, s, ut).call(this, !1);
-                                return m && N && this._stats && (this._stats = new _display_utils.StatTimer()), N;
+                            cleanup(_ = !1) {
+                                ot(this, e, !0);
+                                const N = J(this, s, he).call(this, !1);
+                                return _ && N && this._stats && (this._stats = new _display_utils.StatTimer()), N;
                             }
-                            _startRenderPage(m, N) {
-                                var X, G;
+                            _startRenderPage(_, N) {
+                                var X, Y;
                                 const D = this._intentStates.get(N);
-                                D && ((X = this._stats) == null || X.timeEnd("Page Request"), (G = D.displayReadyCapability) == null || G.resolve(m));
+                                D && ((X = this._stats) == null || X.timeEnd("Page Request"), (Y = D.displayReadyCapability) == null || Y.resolve(_));
                             }
-                            _renderPageChunk(m, N) {
-                                for (let D = 0, X = m.length; D < X; D++)
-                                    N.operatorList.fnArray.push(m.fnArray[D]), N.operatorList.argsArray.push(m.argsArray[D]);
-                                N.operatorList.lastChunk = m.lastChunk, N.operatorList.separateAnnots = m.separateAnnots;
+                            _renderPageChunk(_, N) {
+                                for (let D = 0, X = _.length; D < X; D++)
+                                    N.operatorList.fnArray.push(_.fnArray[D]), N.operatorList.argsArray.push(_.argsArray[D]);
+                                N.operatorList.lastChunk = _.lastChunk, N.operatorList.separateAnnots = _.separateAnnots;
                                 for (const D of N.renderTasks)
                                     D.operatorListChanged();
-                                m.lastChunk && K(this, s, ut).call(this, !0);
+                                _.lastChunk && J(this, s, he).call(this, !0);
                             }
                             _pumpOperatorList({
-                                renderingIntent: m,
+                                renderingIntent: _,
                                 cacheKey: N,
                                 annotationStorageSerializable: D
                             }) {
                                 const {
                                     map: X,
-                                    transfers: G
-                                } = D, B = this._transport.messageHandler.sendWithStream("GetOperatorList", {
+                                    transfers: Y
+                                } = D, U = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                                     pageIndex: this._pageIndex,
-                                    intent: m,
+                                    intent: _,
                                     cacheKey: N,
                                     annotationStorage: X
-                                }, G).getReader(), ee = this._intentStates.get(N);
-                                ee.streamReader = B;
-                                const Y = () => {
-                                    B.read().then(({
-                                        value: q,
-                                        done: le
+                                }, Y).getReader(), G = this._intentStates.get(N);
+                                G.streamReader = U;
+                                const V = () => {
+                                    U.read().then(({
+                                        value: H,
+                                        done: st
                                     }) => {
-                                        if (le) {
-                                            ee.streamReader = null;
+                                        if (st) {
+                                            G.streamReader = null;
                                             return;
                                         }
-                                        this._transport.destroyed || (this._renderPageChunk(q, ee), Y());
-                                    }, (q) => {
-                                        if (ee.streamReader = null, !this._transport.destroyed) {
-                                            if (ee.operatorList) {
-                                                ee.operatorList.lastChunk = !0;
-                                                for (const le of ee.renderTasks)
-                                                    le.operatorListChanged();
-                                                K(this, s, ut).call(this, !0);
+                                        this._transport.destroyed || (this._renderPageChunk(H, G), V());
+                                    }, (H) => {
+                                        if (G.streamReader = null, !this._transport.destroyed) {
+                                            if (G.operatorList) {
+                                                G.operatorList.lastChunk = !0;
+                                                for (const st of G.renderTasks)
+                                                    st.operatorListChanged();
+                                                J(this, s, he).call(this, !0);
                                             }
-                                            if (ee.displayReadyCapability)
-                                                ee.displayReadyCapability.reject(q);
-                                            else if (ee.opListReadCapability)
-                                                ee.opListReadCapability.reject(q);
+                                            if (G.displayReadyCapability)
+                                                G.displayReadyCapability.reject(H);
+                                            else if (G.opListReadCapability)
+                                                G.opListReadCapability.reject(H);
                                             else
-                                                throw q;
+                                                throw H;
                                         }
                                     });
                                 };
-                                Y();
+                                V();
                             }
                             _abortOperatorList({
-                                intentState: m,
+                                intentState: _,
                                 reason: N,
                                 force: D = !1
                             }) {
-                                if (m.streamReader) {
-                                    if (m.streamReaderCancelTimeout && (clearTimeout(m.streamReaderCancelTimeout), m.streamReaderCancelTimeout = null), !D) {
-                                        if (m.renderTasks.size > 0)
+                                if (_.streamReader) {
+                                    if (_.streamReaderCancelTimeout && (clearTimeout(_.streamReaderCancelTimeout), _.streamReaderCancelTimeout = null), !D) {
+                                        if (_.renderTasks.size > 0)
                                             return;
                                         if (N instanceof _display_utils.RenderingCancelledException) {
                                             let X = RENDERING_CANCELLED_TIMEOUT;
-                                            N.extraDelay > 0 && N.extraDelay < 1e3 && (X += N.extraDelay), m.streamReaderCancelTimeout = setTimeout(() => {
-                                                m.streamReaderCancelTimeout = null, this._abortOperatorList({
-                                                    intentState: m,
+                                            N.extraDelay > 0 && N.extraDelay < 1e3 && (X += N.extraDelay), _.streamReaderCancelTimeout = setTimeout(() => {
+                                                _.streamReaderCancelTimeout = null, this._abortOperatorList({
+                                                    intentState: _,
                                                     reason: N,
                                                     force: !0
                                                 });
                                             }, X);
                                             return;
                                         }
                                     }
-                                    if (m.streamReader.cancel(new _util.AbortException(N.message)).catch(() => {}), m.streamReader = null, !this._transport.destroyed) {
-                                        for (const [X, G] of this._intentStates)
-                                            if (G === m) {
+                                    if (_.streamReader.cancel(new _util.AbortException(N.message)).catch(() => {}), _.streamReader = null, !this._transport.destroyed) {
+                                        for (const [X, Y] of this._intentStates)
+                                            if (Y === _) {
                                                 this._intentStates.delete(X);
                                                 break;
                                             }
                                         this.cleanup();
                                     }
                                 }
                             }
                             get stats() {
                                 return this._stats;
                             }
                         }
-                        i = new WeakMap(), n = new WeakMap(), s = new WeakSet(), ut = function(m = !1) {
-                            if (K(this, h, wt).call(this), !a(this, n) || this.destroyed)
+                        n = new WeakMap(), e = new WeakMap(), s = new WeakSet(), he = function(_ = !1) {
+                            if (J(this, f, we).call(this), !r(this, e) || this.destroyed)
                                 return !1;
-                            if (m)
-                                return oe(this, i, setTimeout(() => {
-                                    oe(this, i, null), K(this, s, ut).call(this, !1);
+                            if (_)
+                                return ot(this, n, setTimeout(() => {
+                                    ot(this, n, null), J(this, s, he).call(this, !1);
                                 }, DELAYED_CLEANUP_TIMEOUT)), !1;
                             for (const {
                                     renderTasks: N,
                                     operatorList: D
                                 }
                                 of this._intentStates.values())
                                 if (N.size > 0 || !D.lastChunk)
                                     return !1;
-                            return this._intentStates.clear(), this.objs.clear(), oe(this, n, !1), !0;
-                        }, h = new WeakSet(), wt = function() {
-                            a(this, i) && (clearTimeout(a(this, i)), oe(this, i, null));
+                            return this._intentStates.clear(), this.objs.clear(), ot(this, e, !1), !0;
+                        }, f = new WeakSet(), we = function() {
+                            r(this, n) && (clearTimeout(r(this, n)), ot(this, n, null));
                         }, exports.PDFPageProxy = PDFPageProxy;
                         class LoopbackPort {
                             constructor() {
-                                W(this, c, /* @__PURE__ */ new Set());
-                                W(this, o, Promise.resolve());
+                                W(this, a, /* @__PURE__ */ new Set());
+                                W(this, h, Promise.resolve());
                             }
-                            postMessage(m, N) {
+                            postMessage(_, N) {
                                 const D = {
-                                    data: structuredClone(m, N ? {
+                                    data: structuredClone(_, N ? {
                                         transfer: N
                                     } : null)
                                 };
-                                a(this, o).then(() => {
-                                    for (const X of a(this, c))
+                                r(this, h).then(() => {
+                                    for (const X of r(this, a))
                                         X.call(this, D);
                                 });
                             }
-                            addEventListener(m, N) {
-                                a(this, c).add(N);
+                            addEventListener(_, N) {
+                                r(this, a).add(N);
                             }
-                            removeEventListener(m, N) {
-                                a(this, c).delete(N);
+                            removeEventListener(_, N) {
+                                r(this, a).delete(N);
                             }
                             terminate() {
-                                a(this, c).clear();
+                                r(this, a).clear();
                             }
                         }
-                        c = new WeakMap(), o = new WeakMap(), exports.LoopbackPort = LoopbackPort;
+                        a = new WeakMap(), h = new WeakMap(), exports.LoopbackPort = LoopbackPort;
                         const PDFWorkerUtil = {
                             isWorkerDisabled: !1,
                             fallbackWorkerSrc: null,
                             fakeWorkerId: 0
                         };
                         exports.PDFWorkerUtil = PDFWorkerUtil;
                         {
                             if (_util.isNodeJS && typeof commonjsRequire == "function")
                                 PDFWorkerUtil.isWorkerDisabled = !0, PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
                             else if (typeof document == "object") {
-                                const M = (r = document == null ? void 0 : document.currentScript) == null ? void 0 : r.src;
+                                const M = (o = document == null ? void 0 : document.currentScript) == null ? void 0 : o.src;
                                 M && (PDFWorkerUtil.fallbackWorkerSrc = M.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"));
                             }
-                            PDFWorkerUtil.isSameOrigin = function(M, m) {
+                            PDFWorkerUtil.isSameOrigin = function(M, _) {
                                 let N;
                                 try {
                                     if (N = new URL(M), !N.origin || N.origin === "null")
                                         return !1;
                                 } catch {
                                     return !1;
                                 }
-                                const D = new URL(m, N);
+                                const D = new URL(_, N);
                                 return N.origin === D.origin;
                             }, PDFWorkerUtil.createCDNWrapper = function(M) {
-                                const m = `importScripts("${M}");`;
-                                return URL.createObjectURL(new Blob([m]));
+                                const _ = `importScripts("${M}");`;
+                                return URL.createObjectURL(new Blob([_]));
                             };
                         }
                         const _PDFWorker = class _PDFWorker {
                             constructor({
                                 name: M = null,
-                                port: m = null,
+                                port: _ = null,
                                 verbosity: N = (0, _util.getVerbosityLevel)()
                             } = {}) {
                                 var D;
-                                if (this.name = M, this.destroyed = !1, this.verbosity = N, this._readyCapability = new _util.PromiseCapability(), this._port = null, this._webWorker = null, this._messageHandler = null, m) {
-                                    if ((D = a(_PDFWorker, T)) != null && D.has(m))
+                                if (this.name = M, this.destroyed = !1, this.verbosity = N, this._readyCapability = new _util.PromiseCapability(), this._port = null, this._webWorker = null, this._messageHandler = null, _) {
+                                    if ((D = r(_PDFWorker, F)) != null && D.has(_))
                                         throw new Error("Cannot use more than one PDFWorker per port.");
-                                    (a(_PDFWorker, T) || oe(_PDFWorker, T, /* @__PURE__ */ new WeakMap())).set(m, this), this._initializeFromPort(m);
+                                    (r(_PDFWorker, F) || ot(_PDFWorker, F, /* @__PURE__ */ new WeakMap())).set(_, this), this._initializeFromPort(_);
                                     return;
                                 }
                                 this._initialize();
                             }
                             get promise() {
                                 return this._readyCapability.promise;
                             }
@@ -9714,85 +6311,85 @@
                             _initialize() {
                                 if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                                     let {
                                         workerSrc: M
                                     } = _PDFWorker;
                                     try {
                                         PDFWorkerUtil.isSameOrigin(window.location.href, M) || (M = PDFWorkerUtil.createCDNWrapper(new URL(M, window.location).href));
-                                        const m = new Worker(M),
-                                            N = new _message_handler.MessageHandler("main", "worker", m),
+                                        const _ = new Worker(M),
+                                            N = new _message_handler.MessageHandler("main", "worker", _),
                                             D = () => {
-                                                m.removeEventListener("error", X), N.destroy(), m.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
+                                                _.removeEventListener("error", X), N.destroy(), _.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
                                             },
                                             X = () => {
                                                 this._webWorker || D();
                                             };
-                                        m.addEventListener("error", X), N.on("test", (I) => {
-                                            if (m.removeEventListener("error", X), this.destroyed) {
+                                        _.addEventListener("error", X), N.on("test", (I) => {
+                                            if (_.removeEventListener("error", X), this.destroyed) {
                                                 D();
                                                 return;
                                             }
-                                            I ? (this._messageHandler = N, this._port = m, this._webWorker = m, this._readyCapability.resolve(), N.send("configure", {
+                                            I ? (this._messageHandler = N, this._port = _, this._webWorker = _, this._readyCapability.resolve(), N.send("configure", {
                                                 verbosity: this.verbosity
-                                            })) : (this._setupFakeWorker(), N.destroy(), m.terminate());
+                                            })) : (this._setupFakeWorker(), N.destroy(), _.terminate());
                                         }), N.on("ready", (I) => {
-                                            if (m.removeEventListener("error", X), this.destroyed) {
+                                            if (_.removeEventListener("error", X), this.destroyed) {
                                                 D();
                                                 return;
                                             }
                                             try {
-                                                G();
+                                                Y();
                                             } catch {
                                                 this._setupFakeWorker();
                                             }
                                         });
-                                        const G = () => {
+                                        const Y = () => {
                                             const I = new Uint8Array();
                                             N.send("test", I, [I.buffer]);
                                         };
-                                        G();
+                                        Y();
                                         return;
                                     } catch {
                                         (0, _util.info)("The worker has been disabled.");
                                     }
                                 }
                                 this._setupFakeWorker();
                             }
                             _setupFakeWorker() {
                                 PDFWorkerUtil.isWorkerDisabled || ((0, _util.warn)("Setting up fake worker."), PDFWorkerUtil.isWorkerDisabled = !0), _PDFWorker._setupFakeWorkerGlobal.then((M) => {
                                     if (this.destroyed) {
                                         this._readyCapability.reject(new Error("Worker was destroyed"));
                                         return;
                                     }
-                                    const m = new LoopbackPort();
-                                    this._port = m;
+                                    const _ = new LoopbackPort();
+                                    this._port = _;
                                     const N = `fake${PDFWorkerUtil.fakeWorkerId++}`,
-                                        D = new _message_handler.MessageHandler(N + "_worker", N, m);
-                                    M.setup(D, m);
-                                    const X = new _message_handler.MessageHandler(N, N + "_worker", m);
+                                        D = new _message_handler.MessageHandler(N + "_worker", N, _);
+                                    M.setup(D, _);
+                                    const X = new _message_handler.MessageHandler(N, N + "_worker", _);
                                     this._messageHandler = X, this._readyCapability.resolve(), X.send("configure", {
                                         verbosity: this.verbosity
                                     });
                                 }).catch((M) => {
                                     this._readyCapability.reject(new Error(`Setting up fake worker failed: "${M.message}".`));
                                 });
                             }
                             destroy() {
                                 var M;
-                                this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), (M = a(_PDFWorker, T)) == null || M.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
+                                this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), (M = r(_PDFWorker, F)) == null || M.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
                             }
                             static fromPort(M) {
                                 var N;
                                 if (!(M != null && M.port))
                                     throw new Error("PDFWorker.fromPort - invalid method signature.");
-                                const m = (N = a(this, T)) == null ? void 0 : N.get(M.port);
-                                if (m) {
-                                    if (m._pendingDestroy)
+                                const _ = (N = r(this, F)) == null ? void 0 : N.get(M.port);
+                                if (_) {
+                                    if (_._pendingDestroy)
                                         throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
-                                    return m;
+                                    return _;
                                 }
                                 return new _PDFWorker(M);
                             }
                             static get workerSrc() {
                                 if (_worker_options.GlobalWorkerOptions.workerSrc)
                                     return _worker_options.GlobalWorkerOptions.workerSrc;
                                 if (PDFWorkerUtil.fallbackWorkerSrc !== null)
@@ -9817,161 +6414,161 @@
                                         return worker.WorkerMessageHandler;
                                     }
                                     return await (0, _display_utils.loadScript)(this.workerSrc), window.pdfjsWorker.WorkerMessageHandler;
                                 };
                                 return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
                             }
                         };
-                        T = new WeakMap(), W(_PDFWorker, T, void 0);
+                        F = new WeakMap(), W(_PDFWorker, F, void 0);
                         let PDFWorker = _PDFWorker;
                         exports.PDFWorker = PDFWorker;
                         class WorkerTransport {
-                            constructor(m, N, D, X, G) {
-                                W(this, b);
-                                W(this, S, /* @__PURE__ */ new Map());
+                            constructor(_, N, D, X, Y) {
+                                W(this, m);
+                                W(this, R, /* @__PURE__ */ new Map());
                                 W(this, w, /* @__PURE__ */ new Map());
-                                W(this, C, /* @__PURE__ */ new Map());
+                                W(this, T, /* @__PURE__ */ new Map());
                                 W(this, P, null);
-                                this.messageHandler = m, this.loadingTask = N, this.commonObjs = new PDFObjects(), this.fontLoader = new _font_loader.FontLoader({
+                                this.messageHandler = _, this.loadingTask = N, this.commonObjs = new PDFObjects(), this.fontLoader = new _font_loader.FontLoader({
                                     ownerDocument: X.ownerDocument,
                                     styleElement: X.styleElement
-                                }), this._params = X, this.canvasFactory = G.canvasFactory, this.filterFactory = G.filterFactory, this.cMapReaderFactory = G.cMapReaderFactory, this.standardFontDataFactory = G.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = D, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = new _util.PromiseCapability(), this.setupMessageHandler();
+                                }), this._params = X, this.canvasFactory = Y.canvasFactory, this.filterFactory = Y.filterFactory, this.cMapReaderFactory = Y.cMapReaderFactory, this.standardFontDataFactory = Y.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = D, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = new _util.PromiseCapability(), this.setupMessageHandler();
                             }
                             get annotationStorage() {
                                 return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
                             }
-                            getRenderingIntent(m, N = _util.AnnotationMode.ENABLE, D = null, X = !1) {
-                                let G = _util.RenderingIntentFlag.DISPLAY,
+                            getRenderingIntent(_, N = _util.AnnotationMode.ENABLE, D = null, X = !1) {
+                                let Y = _util.RenderingIntentFlag.DISPLAY,
                                     I = _annotation_storage.SerializableEmpty;
-                                switch (m) {
+                                switch (_) {
                                     case "any":
-                                        G = _util.RenderingIntentFlag.ANY;
+                                        Y = _util.RenderingIntentFlag.ANY;
                                         break;
                                     case "display":
                                         break;
                                     case "print":
-                                        G = _util.RenderingIntentFlag.PRINT;
+                                        Y = _util.RenderingIntentFlag.PRINT;
                                         break;
                                     default:
-                                        (0, _util.warn)(`getRenderingIntent - invalid intent: ${m}`);
+                                        (0, _util.warn)(`getRenderingIntent - invalid intent: ${_}`);
                                 }
                                 switch (N) {
                                     case _util.AnnotationMode.DISABLE:
-                                        G += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
+                                        Y += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                                         break;
                                     case _util.AnnotationMode.ENABLE:
                                         break;
                                     case _util.AnnotationMode.ENABLE_FORMS:
-                                        G += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
+                                        Y += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                                         break;
                                     case _util.AnnotationMode.ENABLE_STORAGE:
-                                        G += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE, I = (G & _util.RenderingIntentFlag.PRINT && D instanceof _annotation_storage.PrintAnnotationStorage ? D : this.annotationStorage).serializable;
+                                        Y += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE, I = (Y & _util.RenderingIntentFlag.PRINT && D instanceof _annotation_storage.PrintAnnotationStorage ? D : this.annotationStorage).serializable;
                                         break;
                                     default:
                                         (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${N}`);
                                 }
-                                return X && (G += _util.RenderingIntentFlag.OPLIST), {
-                                    renderingIntent: G,
-                                    cacheKey: `${G}_${I.hash}`,
+                                return X && (Y += _util.RenderingIntentFlag.OPLIST), {
+                                    renderingIntent: Y,
+                                    cacheKey: `${Y}_${I.hash}`,
                                     annotationStorageSerializable: I
                                 };
                             }
                             destroy() {
                                 var D;
                                 if (this.destroyCapability)
                                     return this.destroyCapability.promise;
-                                this.destroyed = !0, this.destroyCapability = new _util.PromiseCapability(), (D = a(this, P)) == null || D.reject(new Error("Worker was destroyed during onPassword callback"));
-                                const m = [];
-                                for (const X of a(this, w).values())
-                                    m.push(X._destroy());
-                                a(this, w).clear(), a(this, C).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
+                                this.destroyed = !0, this.destroyCapability = new _util.PromiseCapability(), (D = r(this, P)) == null || D.reject(new Error("Worker was destroyed during onPassword callback"));
+                                const _ = [];
+                                for (const X of r(this, w).values())
+                                    _.push(X._destroy());
+                                r(this, w).clear(), r(this, T).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
                                 const N = this.messageHandler.sendWithPromise("Terminate", null);
-                                return m.push(N), Promise.all(m).then(() => {
+                                return _.push(N), Promise.all(_).then(() => {
                                     var X;
-                                    this.commonObjs.clear(), this.fontLoader.clear(), a(this, S).clear(), this.filterFactory.destroy(), (X = this._networkStream) == null || X.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
+                                    this.commonObjs.clear(), this.fontLoader.clear(), r(this, R).clear(), this.filterFactory.destroy(), (X = this._networkStream) == null || X.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
                                 }, this.destroyCapability.reject), this.destroyCapability.promise;
                             }
                             setupMessageHandler() {
                                 const {
-                                    messageHandler: m,
+                                    messageHandler: _,
                                     loadingTask: N
                                 } = this;
-                                m.on("GetReader", (D, X) => {
-                                    (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (G) => {
+                                _.on("GetReader", (D, X) => {
+                                    (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (Y) => {
                                         this._lastProgress = {
-                                            loaded: G.loaded,
-                                            total: G.total
+                                            loaded: Y.loaded,
+                                            total: Y.total
                                         };
                                     }, X.onPull = () => {
                                         this._fullReader.read().then(function({
-                                            value: G,
+                                            value: Y,
                                             done: I
                                         }) {
                                             if (I) {
                                                 X.close();
                                                 return;
                                             }
-                                            (0, _util.assert)(G instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), X.enqueue(new Uint8Array(G), 1, [G]);
-                                        }).catch((G) => {
-                                            X.error(G);
+                                            (0, _util.assert)(Y instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), X.enqueue(new Uint8Array(Y), 1, [Y]);
+                                        }).catch((Y) => {
+                                            X.error(Y);
                                         });
-                                    }, X.onCancel = (G) => {
-                                        this._fullReader.cancel(G), X.ready.catch((I) => {
+                                    }, X.onCancel = (Y) => {
+                                        this._fullReader.cancel(Y), X.ready.catch((I) => {
                                             if (!this.destroyed)
                                                 throw I;
                                         });
                                     };
-                                }), m.on("ReaderHeadersReady", (D) => {
+                                }), _.on("ReaderHeadersReady", (D) => {
                                     const X = new _util.PromiseCapability(),
-                                        G = this._fullReader;
-                                    return G.headersReady.then(() => {
+                                        Y = this._fullReader;
+                                    return Y.headersReady.then(() => {
                                         var I;
-                                        (!G.isStreamingSupported || !G.isRangeSupported) && (this._lastProgress && ((I = N.onProgress) == null || I.call(N, this._lastProgress)), G.onProgress = (B) => {
-                                            var ee;
-                                            (ee = N.onProgress) == null || ee.call(N, {
-                                                loaded: B.loaded,
-                                                total: B.total
+                                        (!Y.isStreamingSupported || !Y.isRangeSupported) && (this._lastProgress && ((I = N.onProgress) == null || I.call(N, this._lastProgress)), Y.onProgress = (U) => {
+                                            var G;
+                                            (G = N.onProgress) == null || G.call(N, {
+                                                loaded: U.loaded,
+                                                total: U.total
                                             });
                                         }), X.resolve({
-                                            isStreamingSupported: G.isStreamingSupported,
-                                            isRangeSupported: G.isRangeSupported,
-                                            contentLength: G.contentLength
+                                            isStreamingSupported: Y.isStreamingSupported,
+                                            isRangeSupported: Y.isRangeSupported,
+                                            contentLength: Y.contentLength
                                         });
                                     }, X.reject), X.promise;
-                                }), m.on("GetRangeReader", (D, X) => {
+                                }), _.on("GetRangeReader", (D, X) => {
                                     (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
-                                    const G = this._networkStream.getRangeReader(D.begin, D.end);
-                                    if (!G) {
+                                    const Y = this._networkStream.getRangeReader(D.begin, D.end);
+                                    if (!Y) {
                                         X.close();
                                         return;
                                     }
                                     X.onPull = () => {
-                                        G.read().then(function({
+                                        Y.read().then(function({
                                             value: I,
-                                            done: B
+                                            done: U
                                         }) {
-                                            if (B) {
+                                            if (U) {
                                                 X.close();
                                                 return;
                                             }
                                             (0, _util.assert)(I instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), X.enqueue(new Uint8Array(I), 1, [I]);
                                         }).catch((I) => {
                                             X.error(I);
                                         });
                                     }, X.onCancel = (I) => {
-                                        G.cancel(I), X.ready.catch((B) => {
+                                        Y.cancel(I), X.ready.catch((U) => {
                                             if (!this.destroyed)
-                                                throw B;
+                                                throw U;
                                         });
                                     };
-                                }), m.on("GetDoc", ({
+                                }), _.on("GetDoc", ({
                                     pdfInfo: D
                                 }) => {
                                     this._numPages = D.numPages, this._htmlForXfa = D.htmlForXfa, delete D.htmlForXfa, N._capability.resolve(new PDFDocumentProxy(D, this));
-                                }), m.on("DocException", function(D) {
+                                }), _.on("DocException", function(D) {
                                     let X;
                                     switch (D.name) {
                                         case "PasswordException":
                                             X = new _util.PasswordException(D.message, D.code);
                                             break;
                                         case "InvalidPDFException":
                                             X = new _util.InvalidPDFException(D.message);
@@ -9985,169 +6582,169 @@
                                         case "UnknownErrorException":
                                             X = new _util.UnknownErrorException(D.message, D.details);
                                             break;
                                         default:
                                             (0, _util.unreachable)("DocException - expected a valid Error.");
                                     }
                                     N._capability.reject(X);
-                                }), m.on("PasswordRequest", (D) => {
-                                    if (oe(this, P, new _util.PromiseCapability()), N.onPassword) {
-                                        const X = (G) => {
-                                            G instanceof Error ? a(this, P).reject(G) : a(this, P).resolve({
-                                                password: G
+                                }), _.on("PasswordRequest", (D) => {
+                                    if (ot(this, P, new _util.PromiseCapability()), N.onPassword) {
+                                        const X = (Y) => {
+                                            Y instanceof Error ? r(this, P).reject(Y) : r(this, P).resolve({
+                                                password: Y
                                             });
                                         };
                                         try {
                                             N.onPassword(X, D.code);
-                                        } catch (G) {
-                                            a(this, P).reject(G);
+                                        } catch (Y) {
+                                            r(this, P).reject(Y);
                                         }
                                     } else
-                                        a(this, P).reject(new _util.PasswordException(D.message, D.code));
-                                    return a(this, P).promise;
-                                }), m.on("DataLoaded", (D) => {
+                                        r(this, P).reject(new _util.PasswordException(D.message, D.code));
+                                    return r(this, P).promise;
+                                }), _.on("DataLoaded", (D) => {
                                     var X;
                                     (X = N.onProgress) == null || X.call(N, {
                                         loaded: D.length,
                                         total: D.length
                                     }), this.downloadInfoCapability.resolve(D);
-                                }), m.on("StartRenderPage", (D) => {
+                                }), _.on("StartRenderPage", (D) => {
                                     if (this.destroyed)
                                         return;
-                                    a(this, w).get(D.pageIndex)._startRenderPage(D.transparency, D.cacheKey);
-                                }), m.on("commonobj", ([D, X, G]) => {
+                                    r(this, w).get(D.pageIndex)._startRenderPage(D.transparency, D.cacheKey);
+                                }), _.on("commonobj", ([D, X, Y]) => {
                                     var I;
                                     if (!this.destroyed && !this.commonObjs.has(D))
                                         switch (X) {
                                             case "Font":
-                                                const B = this._params;
-                                                if ("error" in G) {
-                                                    const q = G.error;
-                                                    (0, _util.warn)(`Error during font loading: ${q}`), this.commonObjs.resolve(D, q);
+                                                const U = this._params;
+                                                if ("error" in Y) {
+                                                    const H = Y.error;
+                                                    (0, _util.warn)(`Error during font loading: ${H}`), this.commonObjs.resolve(D, H);
                                                     break;
                                                 }
-                                                const ee = B.pdfBug && ((I = globalThis.FontInspector) != null && I.enabled) ? (q, le) => globalThis.FontInspector.fontAdded(q, le) : null,
-                                                    Y = new _font_loader.FontFaceObject(G, {
-                                                        isEvalSupported: B.isEvalSupported,
-                                                        disableFontFace: B.disableFontFace,
-                                                        ignoreErrors: B.ignoreErrors,
-                                                        inspectFont: ee
+                                                const G = U.pdfBug && ((I = globalThis.FontInspector) != null && I.enabled) ? (H, st) => globalThis.FontInspector.fontAdded(H, st) : null,
+                                                    V = new _font_loader.FontFaceObject(Y, {
+                                                        isEvalSupported: U.isEvalSupported,
+                                                        disableFontFace: U.disableFontFace,
+                                                        ignoreErrors: U.ignoreErrors,
+                                                        inspectFont: G
                                                     });
-                                                this.fontLoader.bind(Y).catch((q) => m.sendWithPromise("FontFallback", {
+                                                this.fontLoader.bind(V).catch((H) => _.sendWithPromise("FontFallback", {
                                                     id: D
                                                 })).finally(() => {
-                                                    !B.fontExtraProperties && Y.data && (Y.data = null), this.commonObjs.resolve(D, Y);
+                                                    !U.fontExtraProperties && V.data && (V.data = null), this.commonObjs.resolve(D, V);
                                                 });
                                                 break;
                                             case "FontPath":
                                             case "Image":
                                             case "Pattern":
-                                                this.commonObjs.resolve(D, G);
+                                                this.commonObjs.resolve(D, Y);
                                                 break;
                                             default:
                                                 throw new Error(`Got unknown common object type ${X}`);
                                         }
-                                }), m.on("obj", ([D, X, G, I]) => {
-                                    var ee;
+                                }), _.on("obj", ([D, X, Y, I]) => {
+                                    var G;
                                     if (this.destroyed)
                                         return;
-                                    const B = a(this, w).get(X);
-                                    if (!B.objs.has(D))
-                                        switch (G) {
+                                    const U = r(this, w).get(X);
+                                    if (!U.objs.has(D))
+                                        switch (Y) {
                                             case "Image":
-                                                if (B.objs.resolve(D, I), I) {
-                                                    let Y;
+                                                if (U.objs.resolve(D, I), I) {
+                                                    let V;
                                                     if (I.bitmap) {
                                                         const {
-                                                            width: q,
-                                                            height: le
+                                                            width: H,
+                                                            height: st
                                                         } = I;
-                                                        Y = q * le * 4;
+                                                        V = H * st * 4;
                                                     } else
-                                                        Y = ((ee = I.data) == null ? void 0 : ee.length) || 0;
-                                                    Y > _util.MAX_IMAGE_SIZE_TO_CACHE && (B._maybeCleanupAfterRender = !0);
+                                                        V = ((G = I.data) == null ? void 0 : G.length) || 0;
+                                                    V > _util.MAX_IMAGE_SIZE_TO_CACHE && (U._maybeCleanupAfterRender = !0);
                                                 }
                                                 break;
                                             case "Pattern":
-                                                B.objs.resolve(D, I);
+                                                U.objs.resolve(D, I);
                                                 break;
                                             default:
-                                                throw new Error(`Got unknown object type ${G}`);
+                                                throw new Error(`Got unknown object type ${Y}`);
                                         }
-                                }), m.on("DocProgress", (D) => {
+                                }), _.on("DocProgress", (D) => {
                                     var X;
                                     this.destroyed || (X = N.onProgress) == null || X.call(N, {
                                         loaded: D.loaded,
                                         total: D.total
                                     });
-                                }), m.on("FetchBuiltInCMap", (D) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(D) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), m.on("FetchStandardFontData", (D) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(D) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
+                                }), _.on("FetchBuiltInCMap", (D) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(D) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), _.on("FetchStandardFontData", (D) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(D) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
                             }
                             getData() {
                                 return this.messageHandler.sendWithPromise("GetData", null);
                             }
                             saveDocument() {
                                 var D;
                                 this.annotationStorage.size <= 0 && (0, _util.warn)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
                                 const {
-                                    map: m,
+                                    map: _,
                                     transfers: N
                                 } = this.annotationStorage.serializable;
                                 return this.messageHandler.sendWithPromise("SaveDocument", {
                                     isPureXfa: !!this._htmlForXfa,
                                     numPages: this._numPages,
-                                    annotationStorage: m,
+                                    annotationStorage: _,
                                     filename: ((D = this._fullReader) == null ? void 0 : D.filename) ?? null
                                 }, N).finally(() => {
                                     this.annotationStorage.resetModified();
                                 });
                             }
-                            getPage(m) {
-                                if (!Number.isInteger(m) || m <= 0 || m > this._numPages)
+                            getPage(_) {
+                                if (!Number.isInteger(_) || _ <= 0 || _ > this._numPages)
                                     return Promise.reject(new Error("Invalid page request."));
-                                const N = m - 1,
-                                    D = a(this, C).get(N);
+                                const N = _ - 1,
+                                    D = r(this, T).get(N);
                                 if (D)
                                     return D;
                                 const X = this.messageHandler.sendWithPromise("GetPage", {
                                     pageIndex: N
-                                }).then((G) => {
+                                }).then((Y) => {
                                     if (this.destroyed)
                                         throw new Error("Transport destroyed");
-                                    const I = new PDFPageProxy(N, G, this, this._params.pdfBug);
-                                    return a(this, w).set(N, I), I;
+                                    const I = new PDFPageProxy(N, Y, this, this._params.pdfBug);
+                                    return r(this, w).set(N, I), I;
                                 });
-                                return a(this, C).set(N, X), X;
+                                return r(this, T).set(N, X), X;
                             }
-                            getPageIndex(m) {
-                                return typeof m != "object" || m === null || !Number.isInteger(m.num) || m.num < 0 || !Number.isInteger(m.gen) || m.gen < 0 ? Promise.reject(new Error("Invalid pageIndex request.")) : this.messageHandler.sendWithPromise("GetPageIndex", {
-                                    num: m.num,
-                                    gen: m.gen
+                            getPageIndex(_) {
+                                return typeof _ != "object" || _ === null || !Number.isInteger(_.num) || _.num < 0 || !Number.isInteger(_.gen) || _.gen < 0 ? Promise.reject(new Error("Invalid pageIndex request.")) : this.messageHandler.sendWithPromise("GetPageIndex", {
+                                    num: _.num,
+                                    gen: _.gen
                                 });
                             }
-                            getAnnotations(m, N) {
+                            getAnnotations(_, N) {
                                 return this.messageHandler.sendWithPromise("GetAnnotations", {
-                                    pageIndex: m,
+                                    pageIndex: _,
                                     intent: N
                                 });
                             }
                             getFieldObjects() {
-                                return K(this, b, Tt).call(this, "GetFieldObjects");
+                                return J(this, m, Ee).call(this, "GetFieldObjects");
                             }
                             hasJSActions() {
-                                return K(this, b, Tt).call(this, "HasJSActions");
+                                return J(this, m, Ee).call(this, "HasJSActions");
                             }
                             getCalculationOrderIds() {
                                 return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
                             }
                             getDestinations() {
                                 return this.messageHandler.sendWithPromise("GetDestinations", null);
                             }
-                            getDestination(m) {
-                                return typeof m != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
-                                    id: m
+                            getDestination(_) {
+                                return typeof _ != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
+                                    id: _
                                 });
                             }
                             getPageLabels() {
                                 return this.messageHandler.sendWithPromise("GetPageLabels", null);
                             }
                             getPageLayout() {
                                 return this.messageHandler.sendWithPromise("GetPageLayout", null);
@@ -10161,3511 +6758,3511 @@
                             getOpenAction() {
                                 return this.messageHandler.sendWithPromise("GetOpenAction", null);
                             }
                             getAttachments() {
                                 return this.messageHandler.sendWithPromise("GetAttachments", null);
                             }
                             getDocJSActions() {
-                                return K(this, b, Tt).call(this, "GetDocJSActions");
+                                return J(this, m, Ee).call(this, "GetDocJSActions");
                             }
-                            getPageJSActions(m) {
+                            getPageJSActions(_) {
                                 return this.messageHandler.sendWithPromise("GetPageJSActions", {
-                                    pageIndex: m
+                                    pageIndex: _
                                 });
                             }
-                            getStructTree(m) {
+                            getStructTree(_) {
                                 return this.messageHandler.sendWithPromise("GetStructTree", {
-                                    pageIndex: m
+                                    pageIndex: _
                                 });
                             }
                             getOutline() {
                                 return this.messageHandler.sendWithPromise("GetOutline", null);
                             }
                             getOptionalContentConfig() {
-                                return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((m) => new _optional_content_config.OptionalContentConfig(m));
+                                return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((_) => new _optional_content_config.OptionalContentConfig(_));
                             }
                             getPermissions() {
                                 return this.messageHandler.sendWithPromise("GetPermissions", null);
                             }
                             getMetadata() {
-                                const m = "GetMetadata",
-                                    N = a(this, S).get(m);
+                                const _ = "GetMetadata",
+                                    N = r(this, R).get(_);
                                 if (N)
                                     return N;
-                                const D = this.messageHandler.sendWithPromise(m, null).then((X) => {
-                                    var G, I;
+                                const D = this.messageHandler.sendWithPromise(_, null).then((X) => {
+                                    var Y, I;
                                     return {
                                         info: X[0],
                                         metadata: X[1] ? new _metadata.Metadata(X[1]) : null,
-                                        contentDispositionFilename: ((G = this._fullReader) == null ? void 0 : G.filename) ?? null,
+                                        contentDispositionFilename: ((Y = this._fullReader) == null ? void 0 : Y.filename) ?? null,
                                         contentLength: ((I = this._fullReader) == null ? void 0 : I.contentLength) ?? null
                                     };
                                 });
-                                return a(this, S).set(m, D), D;
+                                return r(this, R).set(_, D), D;
                             }
                             getMarkInfo() {
                                 return this.messageHandler.sendWithPromise("GetMarkInfo", null);
                             }
-                            async startCleanup(m = !1) {
+                            async startCleanup(_ = !1) {
                                 if (!this.destroyed) {
                                     await this.messageHandler.sendWithPromise("Cleanup", null);
-                                    for (const N of a(this, w).values())
+                                    for (const N of r(this, w).values())
                                         if (!N.cleanup())
                                             throw new Error(`startCleanup: Page ${N.pageNumber} is currently rendering.`);
-                                    this.commonObjs.clear(), m || this.fontLoader.clear(), a(this, S).clear(), this.filterFactory.destroy(!0);
+                                    this.commonObjs.clear(), _ || this.fontLoader.clear(), r(this, R).clear(), this.filterFactory.destroy(!0);
                                 }
                             }
                             get loadingParams() {
                                 const {
-                                    disableAutoFetch: m,
+                                    disableAutoFetch: _,
                                     enableXfa: N
                                 } = this._params;
                                 return (0, _util.shadow)(this, "loadingParams", {
-                                    disableAutoFetch: m,
+                                    disableAutoFetch: _,
                                     enableXfa: N
                                 });
                             }
                         }
-                        S = new WeakMap(), w = new WeakMap(), C = new WeakMap(), P = new WeakMap(), b = new WeakSet(), Tt = function(m, N = null) {
-                            const D = a(this, S).get(m);
+                        R = new WeakMap(), w = new WeakMap(), T = new WeakMap(), P = new WeakMap(), m = new WeakSet(), Ee = function(_, N = null) {
+                            const D = r(this, R).get(_);
                             if (D)
                                 return D;
-                            const X = this.messageHandler.sendWithPromise(m, N);
-                            return a(this, S).set(m, X), X;
+                            const X = this.messageHandler.sendWithPromise(_, N);
+                            return r(this, R).set(_, X), X;
                         };
                         class PDFObjects {
                             constructor() {
-                                W(this, x);
-                                W(this, F, /* @__PURE__ */ Object.create(null));
+                                W(this, E);
+                                W(this, x, /* @__PURE__ */ Object.create(null));
                             }
-                            get(m, N = null) {
+                            get(_, N = null) {
                                 if (N) {
-                                    const X = K(this, x, Bt).call(this, m);
+                                    const X = J(this, E, Ne).call(this, _);
                                     return X.capability.promise.then(() => N(X.data)), null;
                                 }
-                                const D = a(this, F)[m];
+                                const D = r(this, x)[_];
                                 if (!(D != null && D.capability.settled))
-                                    throw new Error(`Requesting object that isn't resolved yet ${m}.`);
+                                    throw new Error(`Requesting object that isn't resolved yet ${_}.`);
                                 return D.data;
                             }
-                            has(m) {
-                                const N = a(this, F)[m];
+                            has(_) {
+                                const N = r(this, x)[_];
                                 return (N == null ? void 0 : N.capability.settled) || !1;
                             }
-                            resolve(m, N = null) {
-                                const D = K(this, x, Bt).call(this, m);
+                            resolve(_, N = null) {
+                                const D = J(this, E, Ne).call(this, _);
                                 D.data = N, D.capability.resolve();
                             }
                             clear() {
-                                var m;
-                                for (const N in a(this, F)) {
+                                var _;
+                                for (const N in r(this, x)) {
                                     const {
                                         data: D
-                                    } = a(this, F)[N];
-                                    (m = D == null ? void 0 : D.bitmap) == null || m.close();
+                                    } = r(this, x)[N];
+                                    (_ = D == null ? void 0 : D.bitmap) == null || _.close();
                                 }
-                                oe(this, F, /* @__PURE__ */ Object.create(null));
+                                ot(this, x, /* @__PURE__ */ Object.create(null));
                             }
                         }
-                        F = new WeakMap(), x = new WeakSet(), Bt = function(m) {
+                        x = new WeakMap(), E = new WeakSet(), Ne = function(_) {
                             var N;
-                            return (N = a(this, F))[m] || (N[m] = {
+                            return (N = r(this, x))[_] || (N[_] = {
                                 capability: new _util.PromiseCapability(),
                                 data: null
                             });
                         };
                         class RenderTask {
-                            constructor(m) {
-                                W(this, p, null);
-                                oe(this, p, m), this.onContinue = null;
+                            constructor(_) {
+                                W(this, g, null);
+                                ot(this, g, _), this.onContinue = null;
                             }
                             get promise() {
-                                return a(this, p).capability.promise;
+                                return r(this, g).capability.promise;
                             }
-                            cancel(m = 0) {
-                                a(this, p).cancel(null, m);
+                            cancel(_ = 0) {
+                                r(this, g).cancel(null, _);
                             }
                             get separateAnnots() {
                                 const {
-                                    separateAnnots: m
-                                } = a(this, p).operatorList;
-                                if (!m)
+                                    separateAnnots: _
+                                } = r(this, g).operatorList;
+                                if (!_)
                                     return !1;
                                 const {
                                     annotationCanvasMap: N
-                                } = a(this, p);
-                                return m.form || m.canvas && (N == null ? void 0 : N.size) > 0;
+                                } = r(this, g);
+                                return _.form || _.canvas && (N == null ? void 0 : N.size) > 0;
                             }
                         }
-                        p = new WeakMap(), exports.RenderTask = RenderTask;
+                        g = new WeakMap(), exports.RenderTask = RenderTask;
                         const $ = class $ {
                             constructor({
-                                callback: m,
+                                callback: _,
                                 params: N,
                                 objs: D,
                                 commonObjs: X,
-                                annotationCanvasMap: G,
+                                annotationCanvasMap: Y,
                                 operatorList: I,
-                                pageIndex: B,
-                                canvasFactory: ee,
-                                filterFactory: Y,
-                                useRequestAnimationFrame: q = !1,
-                                pdfBug: le = !1,
-                                pageColors: pe = null
+                                pageIndex: U,
+                                canvasFactory: G,
+                                filterFactory: V,
+                                useRequestAnimationFrame: H = !1,
+                                pdfBug: st = !1,
+                                pageColors: dt = null
                             }) {
-                                this.callback = m, this.params = N, this.objs = D, this.commonObjs = X, this.annotationCanvasMap = G, this.operatorListIdx = null, this.operatorList = I, this._pageIndex = B, this.canvasFactory = ee, this.filterFactory = Y, this._pdfBug = le, this.pageColors = pe, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = q === !0 && typeof window < "u", this.cancelled = !1, this.capability = new _util.PromiseCapability(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = N.canvasContext.canvas;
+                                this.callback = _, this.params = N, this.objs = D, this.commonObjs = X, this.annotationCanvasMap = Y, this.operatorListIdx = null, this.operatorList = I, this._pageIndex = U, this.canvasFactory = G, this.filterFactory = V, this._pdfBug = st, this.pageColors = dt, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = H === !0 && typeof window < "u", this.cancelled = !1, this.capability = new _util.PromiseCapability(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = N.canvasContext.canvas;
                             }
                             get completed() {
                                 return this.capability.promise.catch(function() {});
                             }
                             initializeGraphics({
-                                transparency: m = !1,
+                                transparency: _ = !1,
                                 optionalContentConfig: N
                             }) {
-                                var B, ee;
+                                var U, G;
                                 if (this.cancelled)
                                     return;
                                 if (this._canvas) {
-                                    if (a($, E).has(this._canvas))
+                                    if (r($, v).has(this._canvas))
                                         throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
-                                    a($, E).add(this._canvas);
+                                    r($, v).add(this._canvas);
                                 }
-                                this._pdfBug && ((B = globalThis.StepperManager) != null && B.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
+                                this._pdfBug && ((U = globalThis.StepperManager) != null && U.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
                                 const {
                                     canvasContext: D,
                                     viewport: X,
-                                    transform: G,
+                                    transform: Y,
                                     background: I
                                 } = this.params;
                                 this.gfx = new _canvas.CanvasGraphics(D, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                                     optionalContentConfig: N
                                 }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
-                                    transform: G,
+                                    transform: Y,
                                     viewport: X,
-                                    transparency: m,
+                                    transparency: _,
                                     background: I
-                                }), this.operatorListIdx = 0, this.graphicsReady = !0, (ee = this.graphicsReadyCallback) == null || ee.call(this);
+                                }), this.operatorListIdx = 0, this.graphicsReady = !0, (G = this.graphicsReadyCallback) == null || G.call(this);
                             }
-                            cancel(m = null, N = 0) {
+                            cancel(_ = null, N = 0) {
                                 var D;
-                                this.running = !1, this.cancelled = !0, (D = this.gfx) == null || D.endDrawing(), a($, E).delete(this._canvas), this.callback(m || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, N));
+                                this.running = !1, this.cancelled = !0, (D = this.gfx) == null || D.endDrawing(), r($, v).delete(this._canvas), this.callback(_ || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, N));
                             }
                             operatorListChanged() {
-                                var m;
+                                var _;
                                 if (!this.graphicsReady) {
                                     this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
                                     return;
                                 }
-                                (m = this.stepper) == null || m.updateOperatorList(this.operatorList), !this.running && this._continue();
+                                (_ = this.stepper) == null || _.updateOperatorList(this.operatorList), !this.running && this._continue();
                             }
                             _continue() {
                                 this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
                             }
                             _scheduleNext() {
                                 this._useRequestAnimationFrame ? window.requestAnimationFrame(() => {
                                     this._nextBound().catch(this._cancelBound);
                                 }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
                             }
                             async _next() {
-                                this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), a($, E).delete(this._canvas), this.callback())));
+                                this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), r($, v).delete(this._canvas), this.callback())));
                             }
                         };
-                        E = new WeakMap(), W($, E, /* @__PURE__ */ new WeakSet());
+                        v = new WeakMap(), W($, v, /* @__PURE__ */ new WeakSet());
                         let InternalRenderTask = $;
                         const version = "3.11.174";
                         exports.version = version;
                         const build = "ce8716743";
                         exports.build = build;
                     },
                     /* 3 */
                     /***/
-                    (t, e, i) => {
-                        var o, r, T, En, w;
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        var h, o, F, vn, w;
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.SerializableEmpty = e.PrintAnnotationStorage = e.AnnotationStorage = void 0;
-                        var n = i(1),
-                            s = i(4),
-                            l = i(8);
-                        const h = Object.freeze({
+                        }), t.SerializableEmpty = t.PrintAnnotationStorage = t.AnnotationStorage = void 0;
+                        var e = n(1),
+                            s = n(4),
+                            p = n(8);
+                        const f = Object.freeze({
                             map: null,
                             hash: "",
                             transfers: void 0
                         });
-                        e.SerializableEmpty = h;
-                        class _ {
+                        t.SerializableEmpty = f;
+                        class A {
                             constructor() {
-                                W(this, T);
-                                W(this, o, !1);
-                                W(this, r, /* @__PURE__ */ new Map());
+                                W(this, F);
+                                W(this, h, !1);
+                                W(this, o, /* @__PURE__ */ new Map());
                                 this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
                             }
-                            getValue(P, b) {
-                                const k = a(this, r).get(P);
-                                return k === void 0 ? b : Object.assign(b, k);
+                            getValue(P, m) {
+                                const C = r(this, o).get(P);
+                                return C === void 0 ? m : Object.assign(m, C);
                             }
                             getRawValue(P) {
-                                return a(this, r).get(P);
+                                return r(this, o).get(P);
                             }
                             remove(P) {
-                                if (a(this, r).delete(P), a(this, r).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
-                                    for (const b of a(this, r).values())
-                                        if (b instanceof s.AnnotationEditor)
+                                if (r(this, o).delete(P), r(this, o).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
+                                    for (const m of r(this, o).values())
+                                        if (m instanceof s.AnnotationEditor)
                                             return;
                                     this.onAnnotationEditor(null);
                                 }
                             }
-                            setValue(P, b) {
-                                const k = a(this, r).get(P);
-                                let F = !1;
-                                if (k !== void 0)
-                                    for (const [x, y] of Object.entries(b))
-                                        k[x] !== y && (F = !0, k[x] = y);
+                            setValue(P, m) {
+                                const C = r(this, o).get(P);
+                                let x = !1;
+                                if (C !== void 0)
+                                    for (const [E, S] of Object.entries(m))
+                                        C[E] !== S && (x = !0, C[E] = S);
                                 else
-                                    F = !0, a(this, r).set(P, b);
-                                F && K(this, T, En).call(this), b instanceof s.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(b.constructor._type);
+                                    x = !0, r(this, o).set(P, m);
+                                x && J(this, F, vn).call(this), m instanceof s.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(m.constructor._type);
                             }
                             has(P) {
-                                return a(this, r).has(P);
+                                return r(this, o).has(P);
                             }
                             getAll() {
-                                return a(this, r).size > 0 ? (0, n.objectFromMap)(a(this, r)) : null;
+                                return r(this, o).size > 0 ? (0, e.objectFromMap)(r(this, o)) : null;
                             }
                             setAll(P) {
-                                for (const [b, k] of Object.entries(P))
-                                    this.setValue(b, k);
+                                for (const [m, C] of Object.entries(P))
+                                    this.setValue(m, C);
                             }
                             get size() {
-                                return a(this, r).size;
+                                return r(this, o).size;
                             }
                             resetModified() {
-                                a(this, o) && (oe(this, o, !1), typeof this.onResetModified == "function" && this.onResetModified());
+                                r(this, h) && (ot(this, h, !1), typeof this.onResetModified == "function" && this.onResetModified());
                             }
                             get print() {
-                                return new c(this);
+                                return new a(this);
                             }
                             get serializable() {
-                                if (a(this, r).size === 0)
-                                    return h;
+                                if (r(this, o).size === 0)
+                                    return f;
                                 const P = /* @__PURE__ */ new Map(),
-                                    b = new l.MurmurHash3_64(),
-                                    k = [],
-                                    F = /* @__PURE__ */ Object.create(null);
-                                let x = !1;
-                                for (const [y, p] of a(this, r)) {
-                                    const E = p instanceof s.AnnotationEditor ? p.serialize(!1, F) : p;
-                                    E && (P.set(y, E), b.update(`${y}:${JSON.stringify(E)}`), x || (x = !!E.bitmap));
-                                }
-                                if (x)
-                                    for (const y of P.values())
-                                        y.bitmap && k.push(y.bitmap);
+                                    m = new p.MurmurHash3_64(),
+                                    C = [],
+                                    x = /* @__PURE__ */ Object.create(null);
+                                let E = !1;
+                                for (const [S, g] of r(this, o)) {
+                                    const v = g instanceof s.AnnotationEditor ? g.serialize(!1, x) : g;
+                                    v && (P.set(S, v), m.update(`${S}:${JSON.stringify(v)}`), E || (E = !!v.bitmap));
+                                }
+                                if (E)
+                                    for (const S of P.values())
+                                        S.bitmap && C.push(S.bitmap);
                                 return P.size > 0 ? {
                                     map: P,
-                                    hash: b.hexdigest(),
-                                    transfers: k
-                                } : h;
+                                    hash: m.hexdigest(),
+                                    transfers: C
+                                } : f;
                             }
                         }
-                        o = new WeakMap(), r = new WeakMap(), T = new WeakSet(), En = function() {
-                            a(this, o) || (oe(this, o, !0), typeof this.onSetModified == "function" && this.onSetModified());
-                        }, e.AnnotationStorage = _;
-                        class c extends _ {
-                            constructor(b) {
+                        h = new WeakMap(), o = new WeakMap(), F = new WeakSet(), vn = function() {
+                            r(this, h) || (ot(this, h, !0), typeof this.onSetModified == "function" && this.onSetModified());
+                        }, t.AnnotationStorage = A;
+                        class a extends A {
+                            constructor(m) {
                                 super();
                                 W(this, w, void 0);
                                 const {
-                                    map: k,
-                                    hash: F,
-                                    transfers: x
-                                } = b.serializable, y = structuredClone(k, x ? {
-                                    transfer: x
+                                    map: C,
+                                    hash: x,
+                                    transfers: E
+                                } = m.serializable, S = structuredClone(C, E ? {
+                                    transfer: E
                                 } : null);
-                                oe(this, w, {
-                                    map: y,
-                                    hash: F,
-                                    transfers: x
+                                ot(this, w, {
+                                    map: S,
+                                    hash: x,
+                                    transfers: E
                                 });
                             }
                             get print() {
-                                (0, n.unreachable)("Should not call PrintAnnotationStorage.print");
+                                (0, e.unreachable)("Should not call PrintAnnotationStorage.print");
                             }
                             get serializable() {
-                                return a(this, w);
+                                return r(this, w);
                             }
                         }
-                        w = new WeakMap(), e.PrintAnnotationStorage = c;
+                        w = new WeakMap(), t.PrintAnnotationStorage = a;
                     },
                     /* 4 */
                     /***/
-                    (t, e, i) => {
-                        var c, o, r, T, S, w, C, P, b, k, F, x, y, p, E, Ht, M, Ut, N, jt, X, Gt, I, Sn, ee, wn, q, Tn, pe, Wt, be, Cn;
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        var a, h, o, F, R, w, T, P, m, C, x, E, S, g, v, Be, M, Ue, N, je, X, qe, I, Sn, G, wn, H, En, dt, We, gt, Cn;
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.AnnotationEditor = void 0;
-                        var n = i(5),
-                            s = i(1),
-                            l = i(6);
-                        const d = class d {
-                            constructor(f) {
-                                W(this, E);
+                        }), t.AnnotationEditor = void 0;
+                        var e = n(5),
+                            s = n(1),
+                            p = n(6);
+                        const l = class l {
+                            constructor(d) {
+                                W(this, v);
                                 W(this, M);
                                 W(this, X);
                                 W(this, I);
-                                W(this, ee);
-                                W(this, q);
-                                W(this, pe);
-                                W(this, be);
-                                W(this, c, "");
-                                W(this, o, !1);
-                                W(this, r, null);
-                                W(this, T, null);
-                                W(this, S, null);
+                                W(this, G);
+                                W(this, H);
+                                W(this, dt);
+                                W(this, gt);
+                                W(this, a, "");
+                                W(this, h, !1);
+                                W(this, o, null);
+                                W(this, F, null);
+                                W(this, R, null);
                                 W(this, w, !1);
-                                W(this, C, null);
+                                W(this, T, null);
                                 W(this, P, this.focusin.bind(this));
-                                W(this, b, this.focusout.bind(this));
-                                W(this, k, !1);
-                                W(this, F, !1);
+                                W(this, m, this.focusout.bind(this));
+                                W(this, C, !1);
                                 W(this, x, !1);
-                                nt(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
-                                nt(this, "_uiManager", null);
-                                nt(this, "_focusEventsAllowed", !0);
-                                nt(this, "_l10nPromise", null);
-                                W(this, y, !1);
-                                W(this, p, d._zIndex++);
-                                this.constructor === d && (0, s.unreachable)("Cannot initialize AnnotationEditor."), this.parent = f.parent, this.id = f.id, this.width = this.height = null, this.pageIndex = f.parent.pageIndex, this.name = f.name, this.div = null, this._uiManager = f.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = f.isCentered, this._structTreeParentId = null;
+                                W(this, E, !1);
+                                ee(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
+                                ee(this, "_uiManager", null);
+                                ee(this, "_focusEventsAllowed", !0);
+                                ee(this, "_l10nPromise", null);
+                                W(this, S, !1);
+                                W(this, g, l._zIndex++);
+                                this.constructor === l && (0, s.unreachable)("Cannot initialize AnnotationEditor."), this.parent = d.parent, this.id = d.id, this.width = this.height = null, this.pageIndex = d.parent.pageIndex, this.name = d.name, this.div = null, this._uiManager = d.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = d.isCentered, this._structTreeParentId = null;
                                 const {
-                                    rotation: v,
+                                    rotation: b,
                                     rawDims: {
-                                        pageWidth: A,
+                                        pageWidth: y,
                                         pageHeight: O,
-                                        pageX: H,
+                                        pageX: B,
                                         pageY: z
                                     }
                                 } = this.parent.viewport;
-                                this.rotation = v, this.pageRotation = (360 + v - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [A, O], this.pageTranslation = [H, z];
-                                const [ae, Z] = this.parentDimensions;
-                                this.x = f.x / ae, this.y = f.y / Z, this.isAttachedToDOM = !1, this.deleted = !1;
+                                this.rotation = b, this.pageRotation = (360 + b - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [y, O], this.pageTranslation = [B, z];
+                                const [it, Z] = this.parentDimensions;
+                                this.x = d.x / it, this.y = d.y / Z, this.isAttachedToDOM = !1, this.deleted = !1;
                             }
                             get editorType() {
                                 return Object.getPrototypeOf(this).constructor._type;
                             }
                             static get _defaultLineColor() {
                                 return (0, s.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
                             }
-                            static deleteAnnotationElement(f) {
-                                const v = new _({
-                                    id: f.parent.getNextId(),
-                                    parent: f.parent,
-                                    uiManager: f._uiManager
-                                });
-                                v.annotationElementId = f.annotationElementId, v.deleted = !0, v._uiManager.addToAnnotationStorage(v);
-                            }
-                            static initialize(f, v = null) {
-                                if (d._l10nPromise || (d._l10nPromise = new Map(["editor_alt_text_button_label", "editor_alt_text_edit_button_label", "editor_alt_text_decorative_tooltip"].map((O) => [O, f.get(O)]))), v != null && v.strings)
-                                    for (const O of v.strings)
-                                        d._l10nPromise.set(O, f.get(O));
-                                if (d._borderLineWidth !== -1)
+                            static deleteAnnotationElement(d) {
+                                const b = new A({
+                                    id: d.parent.getNextId(),
+                                    parent: d.parent,
+                                    uiManager: d._uiManager
+                                });
+                                b.annotationElementId = d.annotationElementId, b.deleted = !0, b._uiManager.addToAnnotationStorage(b);
+                            }
+                            static initialize(d, b = null) {
+                                if (l._l10nPromise || (l._l10nPromise = new Map(["editor_alt_text_button_label", "editor_alt_text_edit_button_label", "editor_alt_text_decorative_tooltip"].map((O) => [O, d.get(O)]))), b != null && b.strings)
+                                    for (const O of b.strings)
+                                        l._l10nPromise.set(O, d.get(O));
+                                if (l._borderLineWidth !== -1)
                                     return;
-                                const A = getComputedStyle(document.documentElement);
-                                d._borderLineWidth = parseFloat(A.getPropertyValue("--outline-width")) || 0;
+                                const y = getComputedStyle(document.documentElement);
+                                l._borderLineWidth = parseFloat(y.getPropertyValue("--outline-width")) || 0;
                             }
-                            static updateDefaultParams(f, v) {}
+                            static updateDefaultParams(d, b) {}
                             static get defaultPropertiesToUpdate() {
                                 return [];
                             }
-                            static isHandlingMimeForPasting(f) {
+                            static isHandlingMimeForPasting(d) {
                                 return !1;
                             }
-                            static paste(f, v) {
+                            static paste(d, b) {
                                 (0, s.unreachable)("Not implemented");
                             }
                             get propertiesToUpdate() {
                                 return [];
                             }
                             get _isDraggable() {
-                                return a(this, y);
+                                return r(this, S);
                             }
-                            set _isDraggable(f) {
-                                var v;
-                                oe(this, y, f), (v = this.div) == null || v.classList.toggle("draggable", f);
+                            set _isDraggable(d) {
+                                var b;
+                                ot(this, S, d), (b = this.div) == null || b.classList.toggle("draggable", d);
                             }
                             center() {
-                                const [f, v] = this.pageDimensions;
+                                const [d, b] = this.pageDimensions;
                                 switch (this.parentRotation) {
                                     case 90:
-                                        this.x -= this.height * v / (f * 2), this.y += this.width * f / (v * 2);
+                                        this.x -= this.height * b / (d * 2), this.y += this.width * d / (b * 2);
                                         break;
                                     case 180:
                                         this.x += this.width / 2, this.y += this.height / 2;
                                         break;
                                     case 270:
-                                        this.x += this.height * v / (f * 2), this.y -= this.width * f / (v * 2);
+                                        this.x += this.height * b / (d * 2), this.y -= this.width * d / (b * 2);
                                         break;
                                     default:
                                         this.x -= this.width / 2, this.y -= this.height / 2;
                                         break;
                                 }
                                 this.fixAndSetPosition();
                             }
-                            addCommands(f) {
-                                this._uiManager.addCommands(f);
+                            addCommands(d) {
+                                this._uiManager.addCommands(d);
                             }
                             get currentLayer() {
                                 return this._uiManager.currentLayer;
                             }
                             setInBackground() {
                                 this.div.style.zIndex = 0;
                             }
                             setInForeground() {
-                                this.div.style.zIndex = a(this, p);
+                                this.div.style.zIndex = r(this, g);
                             }
-                            setParent(f) {
-                                f !== null && (this.pageIndex = f.pageIndex, this.pageDimensions = f.pageDimensions), this.parent = f;
+                            setParent(d) {
+                                d !== null && (this.pageIndex = d.pageIndex, this.pageDimensions = d.pageDimensions), this.parent = d;
                             }
-                            focusin(f) {
-                                this._focusEventsAllowed && (a(this, k) ? oe(this, k, !1) : this.parent.setSelected(this));
+                            focusin(d) {
+                                this._focusEventsAllowed && (r(this, C) ? ot(this, C, !1) : this.parent.setSelected(this));
                             }
-                            focusout(f) {
-                                var A;
+                            focusout(d) {
+                                var y;
                                 if (!this._focusEventsAllowed || !this.isAttachedToDOM)
                                     return;
-                                const v = f.relatedTarget;
-                                v != null && v.closest(`#${this.id}`) || (f.preventDefault(), (A = this.parent) != null && A.isMultipleSelection || this.commitOrRemove());
+                                const b = d.relatedTarget;
+                                b != null && b.closest(`#${this.id}`) || (d.preventDefault(), (y = this.parent) != null && y.isMultipleSelection || this.commitOrRemove());
                             }
                             commitOrRemove() {
                                 this.isEmpty() ? this.remove() : this.commit();
                             }
                             commit() {
                                 this.addToAnnotationStorage();
                             }
                             addToAnnotationStorage() {
                                 this._uiManager.addToAnnotationStorage(this);
                             }
-                            setAt(f, v, A, O) {
-                                const [H, z] = this.parentDimensions;
-                                [A, O] = this.screenToPageTranslation(A, O), this.x = (f + A) / H, this.y = (v + O) / z, this.fixAndSetPosition();
+                            setAt(d, b, y, O) {
+                                const [B, z] = this.parentDimensions;
+                                [y, O] = this.screenToPageTranslation(y, O), this.x = (d + y) / B, this.y = (b + O) / z, this.fixAndSetPosition();
                             }
-                            translate(f, v) {
-                                K(this, E, Ht).call(this, this.parentDimensions, f, v);
+                            translate(d, b) {
+                                J(this, v, Be).call(this, this.parentDimensions, d, b);
                             }
-                            translateInPage(f, v) {
-                                K(this, E, Ht).call(this, this.pageDimensions, f, v), this.div.scrollIntoView({
+                            translateInPage(d, b) {
+                                J(this, v, Be).call(this, this.pageDimensions, d, b), this.div.scrollIntoView({
                                     block: "nearest"
                                 });
                             }
-                            drag(f, v) {
-                                const [A, O] = this.parentDimensions;
-                                if (this.x += f / A, this.y += v / O, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
+                            drag(d, b) {
+                                const [y, O] = this.parentDimensions;
+                                if (this.x += d / y, this.y += b / O, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
                                     const {
-                                        x: ce,
-                                        y: ue
+                                        x: lt,
+                                        y: ht
                                     } = this.div.getBoundingClientRect();
-                                    this.parent.findNewParent(this, ce, ue) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
+                                    this.parent.findNewParent(this, lt, ht) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
                                 }
                                 let {
-                                    x: H,
+                                    x: B,
                                     y: z
                                 } = this;
-                                const [ae, Z] = K(this, M, Ut).call(this);
-                                H += ae, z += Z, this.div.style.left = `${(100 * H).toFixed(2)}%`, this.div.style.top = `${(100 * z).toFixed(2)}%`, this.div.scrollIntoView({
+                                const [it, Z] = J(this, M, Ue).call(this);
+                                B += it, z += Z, this.div.style.left = `${(100 * B).toFixed(2)}%`, this.div.style.top = `${(100 * z).toFixed(2)}%`, this.div.scrollIntoView({
                                     block: "nearest"
                                 });
                             }
                             fixAndSetPosition() {
-                                const [f, v] = this.pageDimensions;
+                                const [d, b] = this.pageDimensions;
                                 let {
-                                    x: A,
+                                    x: y,
                                     y: O,
-                                    width: H,
+                                    width: B,
                                     height: z
                                 } = this;
-                                switch (H *= f, z *= v, A *= f, O *= v, this.rotation) {
+                                switch (B *= d, z *= b, y *= d, O *= b, this.rotation) {
                                     case 0:
-                                        A = Math.max(0, Math.min(f - H, A)), O = Math.max(0, Math.min(v - z, O));
+                                        y = Math.max(0, Math.min(d - B, y)), O = Math.max(0, Math.min(b - z, O));
                                         break;
                                     case 90:
-                                        A = Math.max(0, Math.min(f - z, A)), O = Math.min(v, Math.max(H, O));
+                                        y = Math.max(0, Math.min(d - z, y)), O = Math.min(b, Math.max(B, O));
                                         break;
                                     case 180:
-                                        A = Math.min(f, Math.max(H, A)), O = Math.min(v, Math.max(z, O));
+                                        y = Math.min(d, Math.max(B, y)), O = Math.min(b, Math.max(z, O));
                                         break;
                                     case 270:
-                                        A = Math.min(f, Math.max(z, A)), O = Math.max(0, Math.min(v - H, O));
+                                        y = Math.min(d, Math.max(z, y)), O = Math.max(0, Math.min(b - B, O));
                                         break;
                                 }
-                                this.x = A /= f, this.y = O /= v;
-                                const [ae, Z] = K(this, M, Ut).call(this);
-                                A += ae, O += Z;
+                                this.x = y /= d, this.y = O /= b;
+                                const [it, Z] = J(this, M, Ue).call(this);
+                                y += it, O += Z;
                                 const {
-                                    style: ce
+                                    style: lt
                                 } = this.div;
-                                ce.left = `${(100 * A).toFixed(2)}%`, ce.top = `${(100 * O).toFixed(2)}%`, this.moveInDOM();
+                                lt.left = `${(100 * y).toFixed(2)}%`, lt.top = `${(100 * O).toFixed(2)}%`, this.moveInDOM();
                             }
-                            screenToPageTranslation(f, v) {
-                                var A;
-                                return K(A = d, N, jt).call(A, f, v, this.parentRotation);
-                            }
-                            pageTranslationToScreen(f, v) {
-                                var A;
-                                return K(A = d, N, jt).call(A, f, v, 360 - this.parentRotation);
+                            screenToPageTranslation(d, b) {
+                                var y;
+                                return J(y = l, N, je).call(y, d, b, this.parentRotation);
+                            }
+                            pageTranslationToScreen(d, b) {
+                                var y;
+                                return J(y = l, N, je).call(y, d, b, 360 - this.parentRotation);
                             }
                             get parentScale() {
                                 return this._uiManager.viewParameters.realScale;
                             }
                             get parentRotation() {
                                 return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
                             }
                             get parentDimensions() {
                                 const {
-                                    parentScale: f,
-                                    pageDimensions: [v, A]
-                                } = this, O = v * f, H = A * f;
-                                return s.FeatureTest.isCSSRoundSupported ? [Math.round(O), Math.round(H)] : [O, H];
+                                    parentScale: d,
+                                    pageDimensions: [b, y]
+                                } = this, O = b * d, B = y * d;
+                                return s.FeatureTest.isCSSRoundSupported ? [Math.round(O), Math.round(B)] : [O, B];
                             }
-                            setDims(f, v) {
-                                var H;
-                                const [A, O] = this.parentDimensions;
-                                this.div.style.width = `${(100 * f / A).toFixed(2)}%`, a(this, w) || (this.div.style.height = `${(100 * v / O).toFixed(2)}%`), (H = a(this, r)) == null || H.classList.toggle("small", f < d.SMALL_EDITOR_SIZE || v < d.SMALL_EDITOR_SIZE);
+                            setDims(d, b) {
+                                var B;
+                                const [y, O] = this.parentDimensions;
+                                this.div.style.width = `${(100 * d / y).toFixed(2)}%`, r(this, w) || (this.div.style.height = `${(100 * b / O).toFixed(2)}%`), (B = r(this, o)) == null || B.classList.toggle("small", d < l.SMALL_EDITOR_SIZE || b < l.SMALL_EDITOR_SIZE);
                             }
                             fixDims() {
                                 const {
-                                    style: f
+                                    style: d
                                 } = this.div, {
-                                    height: v,
-                                    width: A
-                                } = f, O = A.endsWith("%"), H = !a(this, w) && v.endsWith("%");
-                                if (O && H)
+                                    height: b,
+                                    width: y
+                                } = d, O = y.endsWith("%"), B = !r(this, w) && b.endsWith("%");
+                                if (O && B)
                                     return;
-                                const [z, ae] = this.parentDimensions;
-                                O || (f.width = `${(100 * parseFloat(A) / z).toFixed(2)}%`), !a(this, w) && !H && (f.height = `${(100 * parseFloat(v) / ae).toFixed(2)}%`);
+                                const [z, it] = this.parentDimensions;
+                                O || (d.width = `${(100 * parseFloat(y) / z).toFixed(2)}%`), !r(this, w) && !B && (d.height = `${(100 * parseFloat(b) / it).toFixed(2)}%`);
                             }
                             getInitialTranslation() {
                                 return [0, 0];
                             }
                             async addAltTextButton() {
-                                if (a(this, r))
+                                if (r(this, o))
                                     return;
-                                const f = oe(this, r, document.createElement("button"));
-                                f.className = "altText";
-                                const v = await d._l10nPromise.get("editor_alt_text_button_label");
-                                f.textContent = v, f.setAttribute("aria-label", v), f.tabIndex = "0", f.addEventListener("contextmenu", l.noContextMenu), f.addEventListener("pointerdown", (A) => A.stopPropagation()), f.addEventListener("click", (A) => {
-                                    A.preventDefault(), this._uiManager.editAltText(this);
+                                const d = ot(this, o, document.createElement("button"));
+                                d.className = "altText";
+                                const b = await l._l10nPromise.get("editor_alt_text_button_label");
+                                d.textContent = b, d.setAttribute("aria-label", b), d.tabIndex = "0", d.addEventListener("contextmenu", p.noContextMenu), d.addEventListener("pointerdown", (y) => y.stopPropagation()), d.addEventListener("click", (y) => {
+                                    y.preventDefault(), this._uiManager.editAltText(this);
                                 }, {
                                     capture: !0
-                                }), f.addEventListener("keydown", (A) => {
-                                    A.target === f && A.key === "Enter" && (A.preventDefault(), this._uiManager.editAltText(this));
-                                }), K(this, pe, Wt).call(this), this.div.append(f), d.SMALL_EDITOR_SIZE || (d.SMALL_EDITOR_SIZE = Math.min(128, Math.round(f.getBoundingClientRect().width * 1.4)));
+                                }), d.addEventListener("keydown", (y) => {
+                                    y.target === d && y.key === "Enter" && (y.preventDefault(), this._uiManager.editAltText(this));
+                                }), J(this, dt, We).call(this), this.div.append(d), l.SMALL_EDITOR_SIZE || (l.SMALL_EDITOR_SIZE = Math.min(128, Math.round(d.getBoundingClientRect().width * 1.4)));
                             }
                             getClientDimensions() {
                                 return this.div.getBoundingClientRect();
                             }
                             get altTextData() {
                                 return {
-                                    altText: a(this, c),
-                                    decorative: a(this, o)
+                                    altText: r(this, a),
+                                    decorative: r(this, h)
                                 };
                             }
                             set altTextData({
-                                altText: f,
-                                decorative: v
+                                altText: d,
+                                decorative: b
                             }) {
-                                a(this, c) === f && a(this, o) === v || (oe(this, c, f), oe(this, o, v), K(this, pe, Wt).call(this));
+                                r(this, a) === d && r(this, h) === b || (ot(this, a, d), ot(this, h, b), J(this, dt, We).call(this));
                             }
                             render() {
-                                this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.setAttribute("tabIndex", 0), this.setInForeground(), this.div.addEventListener("focusin", a(this, P)), this.div.addEventListener("focusout", a(this, b));
-                                const [f, v] = this.parentDimensions;
-                                this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * v / f).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * f / v).toFixed(2)}%`);
-                                const [A, O] = this.getInitialTranslation();
-                                return this.translate(A, O), (0, n.bindEvents)(this, this.div, ["pointerdown"]), this.div;
+                                this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.setAttribute("tabIndex", 0), this.setInForeground(), this.div.addEventListener("focusin", r(this, P)), this.div.addEventListener("focusout", r(this, m));
+                                const [d, b] = this.parentDimensions;
+                                this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * b / d).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * d / b).toFixed(2)}%`);
+                                const [y, O] = this.getInitialTranslation();
+                                return this.translate(y, O), (0, e.bindEvents)(this, this.div, ["pointerdown"]), this.div;
                             }
-                            pointerdown(f) {
+                            pointerdown(d) {
                                 const {
-                                    isMac: v
+                                    isMac: b
                                 } = s.FeatureTest.platform;
-                                if (f.button !== 0 || f.ctrlKey && v) {
-                                    f.preventDefault();
+                                if (d.button !== 0 || d.ctrlKey && b) {
+                                    d.preventDefault();
                                     return;
                                 }
-                                oe(this, k, !0), K(this, be, Cn).call(this, f);
+                                ot(this, C, !0), J(this, gt, Cn).call(this, d);
                             }
                             moveInDOM() {
-                                var f;
-                                (f = this.parent) == null || f.moveEditorInDOM(this);
+                                var d;
+                                (d = this.parent) == null || d.moveEditorInDOM(this);
                             }
-                            _setParentAndPosition(f, v, A) {
-                                f.changeParent(this), this.x = v, this.y = A, this.fixAndSetPosition();
+                            _setParentAndPosition(d, b, y) {
+                                d.changeParent(this), this.x = b, this.y = y, this.fixAndSetPosition();
                             }
-                            getRect(f, v) {
-                                const A = this.parentScale,
-                                    [O, H] = this.pageDimensions,
-                                    [z, ae] = this.pageTranslation,
-                                    Z = f / A,
-                                    ce = v / A,
-                                    ue = this.x * O,
-                                    me = this.y * H,
-                                    fe = this.width * O,
-                                    Pe = this.height * H;
+                            getRect(d, b) {
+                                const y = this.parentScale,
+                                    [O, B] = this.pageDimensions,
+                                    [z, it] = this.pageTranslation,
+                                    Z = d / y,
+                                    lt = b / y,
+                                    ht = this.x * O,
+                                    mt = this.y * B,
+                                    ft = this.width * O,
+                                    kt = this.height * B;
                                 switch (this.rotation) {
                                     case 0:
-                                        return [ue + Z + z, H - me - ce - Pe + ae, ue + Z + fe + z, H - me - ce + ae];
+                                        return [ht + Z + z, B - mt - lt - kt + it, ht + Z + ft + z, B - mt - lt + it];
                                     case 90:
-                                        return [ue + ce + z, H - me + Z + ae, ue + ce + Pe + z, H - me + Z + fe + ae];
+                                        return [ht + lt + z, B - mt + Z + it, ht + lt + kt + z, B - mt + Z + ft + it];
                                     case 180:
-                                        return [ue - Z - fe + z, H - me + ce + ae, ue - Z + z, H - me + ce + Pe + ae];
+                                        return [ht - Z - ft + z, B - mt + lt + it, ht - Z + z, B - mt + lt + kt + it];
                                     case 270:
-                                        return [ue - ce - Pe + z, H - me - Z - fe + ae, ue - ce + z, H - me - Z + ae];
+                                        return [ht - lt - kt + z, B - mt - Z - ft + it, ht - lt + z, B - mt - Z + it];
                                     default:
                                         throw new Error("Invalid rotation");
                                 }
                             }
-                            getRectInCurrentCoords(f, v) {
-                                const [A, O, H, z] = f, ae = H - A, Z = z - O;
+                            getRectInCurrentCoords(d, b) {
+                                const [y, O, B, z] = d, it = B - y, Z = z - O;
                                 switch (this.rotation) {
                                     case 0:
-                                        return [A, v - z, ae, Z];
+                                        return [y, b - z, it, Z];
                                     case 90:
-                                        return [A, v - O, Z, ae];
+                                        return [y, b - O, Z, it];
                                     case 180:
-                                        return [H, v - O, ae, Z];
+                                        return [B, b - O, it, Z];
                                     case 270:
-                                        return [H, v - z, Z, ae];
+                                        return [B, b - z, Z, it];
                                     default:
                                         throw new Error("Invalid rotation");
                                 }
                             }
                             onceAdded() {}
                             isEmpty() {
                                 return !1;
                             }
                             enableEditMode() {
-                                oe(this, x, !0);
+                                ot(this, E, !0);
                             }
                             disableEditMode() {
-                                oe(this, x, !1);
+                                ot(this, E, !1);
                             }
                             isInEditMode() {
-                                return a(this, x);
+                                return r(this, E);
                             }
                             shouldGetKeyboardEvents() {
                                 return !1;
                             }
                             needsToBeRebuilt() {
                                 return this.div && !this.isAttachedToDOM;
                             }
                             rebuild() {
-                                var f, v;
-                                (f = this.div) == null || f.addEventListener("focusin", a(this, P)), (v = this.div) == null || v.addEventListener("focusout", a(this, b));
+                                var d, b;
+                                (d = this.div) == null || d.addEventListener("focusin", r(this, P)), (b = this.div) == null || b.addEventListener("focusout", r(this, m));
                             }
-                            serialize(f = !1, v = null) {
+                            serialize(d = !1, b = null) {
                                 (0, s.unreachable)("An editor must be serializable");
                             }
-                            static deserialize(f, v, A) {
+                            static deserialize(d, b, y) {
                                 const O = new this.prototype.constructor({
-                                    parent: v,
-                                    id: v.getNextId(),
-                                    uiManager: A
-                                });
-                                O.rotation = f.rotation;
-                                const [H, z] = O.pageDimensions, [ae, Z, ce, ue] = O.getRectInCurrentCoords(f.rect, z);
-                                return O.x = ae / H, O.y = Z / z, O.width = ce / H, O.height = ue / z, O;
+                                    parent: b,
+                                    id: b.getNextId(),
+                                    uiManager: y
+                                });
+                                O.rotation = d.rotation;
+                                const [B, z] = O.pageDimensions, [it, Z, lt, ht] = O.getRectInCurrentCoords(d.rect, z);
+                                return O.x = it / B, O.y = Z / z, O.width = lt / B, O.height = ht / z, O;
                             }
                             remove() {
-                                var f;
-                                this.div.removeEventListener("focusin", a(this, P)), this.div.removeEventListener("focusout", a(this, b)), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), (f = a(this, r)) == null || f.remove(), oe(this, r, null), oe(this, T, null);
+                                var d;
+                                this.div.removeEventListener("focusin", r(this, P)), this.div.removeEventListener("focusout", r(this, m)), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), (d = r(this, o)) == null || d.remove(), ot(this, o, null), ot(this, F, null);
                             }
                             get isResizable() {
                                 return !1;
                             }
                             makeResizable() {
-                                this.isResizable && (K(this, I, Sn).call(this), a(this, C).classList.remove("hidden"));
+                                this.isResizable && (J(this, I, Sn).call(this), r(this, T).classList.remove("hidden"));
                             }
                             select() {
-                                var f;
-                                this.makeResizable(), (f = this.div) == null || f.classList.add("selectedEditor");
+                                var d;
+                                this.makeResizable(), (d = this.div) == null || d.classList.add("selectedEditor");
                             }
                             unselect() {
-                                var f, v, A;
-                                (f = a(this, C)) == null || f.classList.add("hidden"), (v = this.div) == null || v.classList.remove("selectedEditor"), (A = this.div) != null && A.contains(document.activeElement) && this._uiManager.currentLayer.div.focus();
+                                var d, b, y;
+                                (d = r(this, T)) == null || d.classList.add("hidden"), (b = this.div) == null || b.classList.remove("selectedEditor"), (y = this.div) != null && y.contains(document.activeElement) && this._uiManager.currentLayer.div.focus();
                             }
-                            updateParams(f, v) {}
+                            updateParams(d, b) {}
                             disableEditing() {
-                                a(this, r) && (a(this, r).hidden = !0);
+                                r(this, o) && (r(this, o).hidden = !0);
                             }
                             enableEditing() {
-                                a(this, r) && (a(this, r).hidden = !1);
+                                r(this, o) && (r(this, o).hidden = !1);
                             }
                             enterInEditMode() {}
                             get contentDiv() {
                                 return this.div;
                             }
                             get isEditing() {
-                                return a(this, F);
+                                return r(this, x);
                             }
-                            set isEditing(f) {
-                                oe(this, F, f), this.parent && (f ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
+                            set isEditing(d) {
+                                ot(this, x, d), this.parent && (d ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
                             }
-                            setAspectRatio(f, v) {
-                                oe(this, w, !0);
-                                const A = f / v,
+                            setAspectRatio(d, b) {
+                                ot(this, w, !0);
+                                const y = d / b,
                                     {
                                         style: O
                                     } = this.div;
-                                O.aspectRatio = A, O.height = "auto";
+                                O.aspectRatio = y, O.height = "auto";
                             }
                             static get MIN_SIZE() {
                                 return 16;
                             }
                         };
-                        c = new WeakMap(), o = new WeakMap(), r = new WeakMap(), T = new WeakMap(), S = new WeakMap(), w = new WeakMap(), C = new WeakMap(), P = new WeakMap(), b = new WeakMap(), k = new WeakMap(), F = new WeakMap(), x = new WeakMap(), y = new WeakMap(), p = new WeakMap(), E = new WeakSet(), Ht = function([f, v], A, O) {
-                            [A, O] = this.screenToPageTranslation(A, O), this.x += A / f, this.y += O / v, this.fixAndSetPosition();
-                        }, M = new WeakSet(), Ut = function() {
-                            const [f, v] = this.parentDimensions, {
-                                _borderLineWidth: A
-                            } = d, O = A / f, H = A / v;
+                        a = new WeakMap(), h = new WeakMap(), o = new WeakMap(), F = new WeakMap(), R = new WeakMap(), w = new WeakMap(), T = new WeakMap(), P = new WeakMap(), m = new WeakMap(), C = new WeakMap(), x = new WeakMap(), E = new WeakMap(), S = new WeakMap(), g = new WeakMap(), v = new WeakSet(), Be = function([d, b], y, O) {
+                            [y, O] = this.screenToPageTranslation(y, O), this.x += y / d, this.y += O / b, this.fixAndSetPosition();
+                        }, M = new WeakSet(), Ue = function() {
+                            const [d, b] = this.parentDimensions, {
+                                _borderLineWidth: y
+                            } = l, O = y / d, B = y / b;
                             switch (this.rotation) {
                                 case 90:
-                                    return [-O, H];
+                                    return [-O, B];
                                 case 180:
-                                    return [O, H];
+                                    return [O, B];
                                 case 270:
-                                    return [O, -H];
+                                    return [O, -B];
                                 default:
-                                    return [-O, -H];
+                                    return [-O, -B];
                             }
-                        }, N = new WeakSet(), jt = function(f, v, A) {
-                            switch (A) {
+                        }, N = new WeakSet(), je = function(d, b, y) {
+                            switch (y) {
                                 case 90:
-                                    return [v, -f];
+                                    return [b, -d];
                                 case 180:
-                                    return [-f, -v];
+                                    return [-d, -b];
                                 case 270:
-                                    return [-v, f];
+                                    return [-b, d];
                                 default:
-                                    return [f, v];
+                                    return [d, b];
                             }
-                        }, X = new WeakSet(), Gt = function(f) {
-                            switch (f) {
+                        }, X = new WeakSet(), qe = function(d) {
+                            switch (d) {
                                 case 90: {
-                                    const [v, A] = this.pageDimensions;
-                                    return [0, -v / A, A / v, 0];
+                                    const [b, y] = this.pageDimensions;
+                                    return [0, -b / y, y / b, 0];
                                 }
                                 case 180:
                                     return [-1, 0, 0, -1];
                                 case 270: {
-                                    const [v, A] = this.pageDimensions;
-                                    return [0, v / A, -A / v, 0];
+                                    const [b, y] = this.pageDimensions;
+                                    return [0, b / y, -y / b, 0];
                                 }
                                 default:
                                     return [1, 0, 0, 1];
                             }
                         }, I = new WeakSet(), Sn = function() {
-                            if (a(this, C))
+                            if (r(this, T))
                                 return;
-                            oe(this, C, document.createElement("div")), a(this, C).classList.add("resizers");
-                            const f = ["topLeft", "topRight", "bottomRight", "bottomLeft"];
-                            this._willKeepAspectRatio || f.push("topMiddle", "middleRight", "bottomMiddle", "middleLeft");
-                            for (const v of f) {
-                                const A = document.createElement("div");
-                                a(this, C).append(A), A.classList.add("resizer", v), A.addEventListener("pointerdown", K(this, ee, wn).bind(this, v)), A.addEventListener("contextmenu", l.noContextMenu);
-                            }
-                            this.div.prepend(a(this, C));
-                        }, ee = new WeakSet(), wn = function(f, v) {
-                            v.preventDefault();
+                            ot(this, T, document.createElement("div")), r(this, T).classList.add("resizers");
+                            const d = ["topLeft", "topRight", "bottomRight", "bottomLeft"];
+                            this._willKeepAspectRatio || d.push("topMiddle", "middleRight", "bottomMiddle", "middleLeft");
+                            for (const b of d) {
+                                const y = document.createElement("div");
+                                r(this, T).append(y), y.classList.add("resizer", b), y.addEventListener("pointerdown", J(this, G, wn).bind(this, b)), y.addEventListener("contextmenu", p.noContextMenu);
+                            }
+                            this.div.prepend(r(this, T));
+                        }, G = new WeakSet(), wn = function(d, b) {
+                            b.preventDefault();
                             const {
-                                isMac: A
+                                isMac: y
                             } = s.FeatureTest.platform;
-                            if (v.button !== 0 || v.ctrlKey && A)
+                            if (b.button !== 0 || b.ctrlKey && y)
                                 return;
-                            const O = K(this, q, Tn).bind(this, f),
-                                H = this._isDraggable;
+                            const O = J(this, H, En).bind(this, d),
+                                B = this._isDraggable;
                             this._isDraggable = !1;
                             const z = {
                                 passive: !0,
                                 capture: !0
                             };
                             window.addEventListener("pointermove", O, z);
-                            const ae = this.x,
+                            const it = this.x,
                                 Z = this.y,
-                                ce = this.width,
-                                ue = this.height,
-                                me = this.parent.div.style.cursor,
-                                fe = this.div.style.cursor;
-                            this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(v.target).cursor;
-                            const Pe = () => {
-                                this._isDraggable = H, window.removeEventListener("pointerup", Pe), window.removeEventListener("blur", Pe), window.removeEventListener("pointermove", O, z), this.parent.div.style.cursor = me, this.div.style.cursor = fe;
-                                const Fe = this.x,
-                                    Ee = this.y,
-                                    De = this.width,
-                                    _e = this.height;
-                                Fe === ae && Ee === Z && De === ce && _e === ue || this.addCommands({
+                                lt = this.width,
+                                ht = this.height,
+                                mt = this.parent.div.style.cursor,
+                                ft = this.div.style.cursor;
+                            this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(b.target).cursor;
+                            const kt = () => {
+                                this._isDraggable = B, window.removeEventListener("pointerup", kt), window.removeEventListener("blur", kt), window.removeEventListener("pointermove", O, z), this.parent.div.style.cursor = mt, this.div.style.cursor = ft;
+                                const Rt = this.x,
+                                    St = this.y,
+                                    It = this.width,
+                                    _t = this.height;
+                                Rt === it && St === Z && It === lt && _t === ht || this.addCommands({
                                     cmd: () => {
-                                        this.width = De, this.height = _e, this.x = Fe, this.y = Ee;
-                                        const [ie, se] = this.parentDimensions;
-                                        this.setDims(ie * De, se * _e), this.fixAndSetPosition();
+                                        this.width = It, this.height = _t, this.x = Rt, this.y = St;
+                                        const [rt, at] = this.parentDimensions;
+                                        this.setDims(rt * It, at * _t), this.fixAndSetPosition();
                                     },
                                     undo: () => {
-                                        this.width = ce, this.height = ue, this.x = ae, this.y = Z;
-                                        const [ie, se] = this.parentDimensions;
-                                        this.setDims(ie * ce, se * ue), this.fixAndSetPosition();
+                                        this.width = lt, this.height = ht, this.x = it, this.y = Z;
+                                        const [rt, at] = this.parentDimensions;
+                                        this.setDims(rt * lt, at * ht), this.fixAndSetPosition();
                                     },
                                     mustExec: !0
                                 });
                             };
-                            window.addEventListener("pointerup", Pe), window.addEventListener("blur", Pe);
-                        }, q = new WeakSet(), Tn = function(f, v) {
-                            const [A, O] = this.parentDimensions, H = this.x, z = this.y, ae = this.width, Z = this.height, ce = d.MIN_SIZE / A, ue = d.MIN_SIZE / O, me = (ve) => Math.round(ve * 1e4) / 1e4, fe = K(this, X, Gt).call(this, this.rotation), Pe = (ve, Se) => [fe[0] * ve + fe[2] * Se, fe[1] * ve + fe[3] * Se], Fe = K(this, X, Gt).call(this, 360 - this.rotation), Ee = (ve, Se) => [Fe[0] * ve + Fe[2] * Se, Fe[1] * ve + Fe[3] * Se];
-                            let De, _e, ie = !1,
-                                se = !1;
-                            switch (f) {
+                            window.addEventListener("pointerup", kt), window.addEventListener("blur", kt);
+                        }, H = new WeakSet(), En = function(d, b) {
+                            const [y, O] = this.parentDimensions, B = this.x, z = this.y, it = this.width, Z = this.height, lt = l.MIN_SIZE / y, ht = l.MIN_SIZE / O, mt = (At) => Math.round(At * 1e4) / 1e4, ft = J(this, X, qe).call(this, this.rotation), kt = (At, wt) => [ft[0] * At + ft[2] * wt, ft[1] * At + ft[3] * wt], Rt = J(this, X, qe).call(this, 360 - this.rotation), St = (At, wt) => [Rt[0] * At + Rt[2] * wt, Rt[1] * At + Rt[3] * wt];
+                            let It, _t, rt = !1,
+                                at = !1;
+                            switch (d) {
                                 case "topLeft":
-                                    ie = !0, De = (ve, Se) => [0, 0], _e = (ve, Se) => [ve, Se];
+                                    rt = !0, It = (At, wt) => [0, 0], _t = (At, wt) => [At, wt];
                                     break;
                                 case "topMiddle":
-                                    De = (ve, Se) => [ve / 2, 0], _e = (ve, Se) => [ve / 2, Se];
+                                    It = (At, wt) => [At / 2, 0], _t = (At, wt) => [At / 2, wt];
                                     break;
                                 case "topRight":
-                                    ie = !0, De = (ve, Se) => [ve, 0], _e = (ve, Se) => [0, Se];
+                                    rt = !0, It = (At, wt) => [At, 0], _t = (At, wt) => [0, wt];
                                     break;
                                 case "middleRight":
-                                    se = !0, De = (ve, Se) => [ve, Se / 2], _e = (ve, Se) => [0, Se / 2];
+                                    at = !0, It = (At, wt) => [At, wt / 2], _t = (At, wt) => [0, wt / 2];
                                     break;
                                 case "bottomRight":
-                                    ie = !0, De = (ve, Se) => [ve, Se], _e = (ve, Se) => [0, 0];
+                                    rt = !0, It = (At, wt) => [At, wt], _t = (At, wt) => [0, 0];
                                     break;
                                 case "bottomMiddle":
-                                    De = (ve, Se) => [ve / 2, Se], _e = (ve, Se) => [ve / 2, 0];
+                                    It = (At, wt) => [At / 2, wt], _t = (At, wt) => [At / 2, 0];
                                     break;
                                 case "bottomLeft":
-                                    ie = !0, De = (ve, Se) => [0, Se], _e = (ve, Se) => [ve, 0];
+                                    rt = !0, It = (At, wt) => [0, wt], _t = (At, wt) => [At, 0];
                                     break;
                                 case "middleLeft":
-                                    se = !0, De = (ve, Se) => [0, Se / 2], _e = (ve, Se) => [ve, Se / 2];
+                                    at = !0, It = (At, wt) => [0, wt / 2], _t = (At, wt) => [At, wt / 2];
                                     break;
                             }
-                            const ge = De(ae, Z),
-                                Ce = _e(ae, Z);
-                            let xe = Pe(...Ce);
-                            const He = me(H + xe[0]),
-                                We = me(z + xe[1]);
-                            let je = 1,
-                                ze = 1,
-                                [Xe, Ge] = this.screenToPageTranslation(v.movementX, v.movementY);
-                            if ([Xe, Ge] = Ee(Xe / A, Ge / O), ie) {
-                                const ve = Math.hypot(ae, Z);
-                                je = ze = Math.max(Math.min(Math.hypot(Ce[0] - ge[0] - Xe, Ce[1] - ge[1] - Ge) / ve, 1 / ae, 1 / Z), ce / ae, ue / Z);
+                            const pt = It(it, Z),
+                                Ct = _t(it, Z);
+                            let Tt = kt(...Ct);
+                            const Bt = mt(B + Tt[0]),
+                                Wt = mt(z + Tt[1]);
+                            let jt = 1,
+                                zt = 1,
+                                [Gt, qt] = this.screenToPageTranslation(b.movementX, b.movementY);
+                            if ([Gt, qt] = St(Gt / y, qt / O), rt) {
+                                const At = Math.hypot(it, Z);
+                                jt = zt = Math.max(Math.min(Math.hypot(Ct[0] - pt[0] - Gt, Ct[1] - pt[1] - qt) / At, 1 / it, 1 / Z), lt / it, ht / Z);
                             } else
-                                se ? je = Math.max(ce, Math.min(1, Math.abs(Ce[0] - ge[0] - Xe))) / ae : ze = Math.max(ue, Math.min(1, Math.abs(Ce[1] - ge[1] - Ge))) / Z;
-                            const Ye = me(ae * je),
-                                de = me(Z * ze);
-                            xe = Pe(..._e(Ye, de));
-                            const ne = He - xe[0],
-                                J = We - xe[1];
-                            this.width = Ye, this.height = de, this.x = ne, this.y = J, this.setDims(A * Ye, O * de), this.fixAndSetPosition();
-                        }, pe = new WeakSet(), Wt = async function() {
-                            var A;
-                            const f = a(this, r);
-                            if (!f)
+                                at ? jt = Math.max(lt, Math.min(1, Math.abs(Ct[0] - pt[0] - Gt))) / it : zt = Math.max(ht, Math.min(1, Math.abs(Ct[1] - pt[1] - qt))) / Z;
+                            const Vt = mt(it * jt),
+                                ut = mt(Z * zt);
+                            Tt = kt(..._t(Vt, ut));
+                            const nt = Bt - Tt[0],
+                                Q = Wt - Tt[1];
+                            this.width = Vt, this.height = ut, this.x = nt, this.y = Q, this.setDims(y * Vt, O * ut), this.fixAndSetPosition();
+                        }, dt = new WeakSet(), We = async function() {
+                            var y;
+                            const d = r(this, o);
+                            if (!d)
                                 return;
-                            if (!a(this, c) && !a(this, o)) {
-                                f.classList.remove("done"), (A = a(this, T)) == null || A.remove();
+                            if (!r(this, a) && !r(this, h)) {
+                                d.classList.remove("done"), (y = r(this, F)) == null || y.remove();
                                 return;
                             }
-                            d._l10nPromise.get("editor_alt_text_edit_button_label").then((O) => {
-                                f.setAttribute("aria-label", O);
+                            l._l10nPromise.get("editor_alt_text_edit_button_label").then((O) => {
+                                d.setAttribute("aria-label", O);
                             });
-                            let v = a(this, T);
-                            if (!v) {
-                                oe(this, T, v = document.createElement("span")), v.className = "tooltip", v.setAttribute("role", "tooltip");
-                                const O = v.id = `alt-text-tooltip-${this.id}`;
-                                f.setAttribute("aria-describedby", O);
-                                const H = 100;
-                                f.addEventListener("mouseenter", () => {
-                                    oe(this, S, setTimeout(() => {
-                                        oe(this, S, null), a(this, T).classList.add("show"), this._uiManager._eventBus.dispatch("reporttelemetry", {
+                            let b = r(this, F);
+                            if (!b) {
+                                ot(this, F, b = document.createElement("span")), b.className = "tooltip", b.setAttribute("role", "tooltip");
+                                const O = b.id = `alt-text-tooltip-${this.id}`;
+                                d.setAttribute("aria-describedby", O);
+                                const B = 100;
+                                d.addEventListener("mouseenter", () => {
+                                    ot(this, R, setTimeout(() => {
+                                        ot(this, R, null), r(this, F).classList.add("show"), this._uiManager._eventBus.dispatch("reporttelemetry", {
                                             source: this,
                                             details: {
                                                 type: "editing",
                                                 subtype: this.editorType,
                                                 data: {
                                                     action: "alt_text_tooltip"
                                                 }
                                             }
                                         });
-                                    }, H));
-                                }), f.addEventListener("mouseleave", () => {
+                                    }, B));
+                                }), d.addEventListener("mouseleave", () => {
                                     var z;
-                                    clearTimeout(a(this, S)), oe(this, S, null), (z = a(this, T)) == null || z.classList.remove("show");
+                                    clearTimeout(r(this, R)), ot(this, R, null), (z = r(this, F)) == null || z.classList.remove("show");
                                 });
                             }
-                            f.classList.add("done"), v.innerText = a(this, o) ? await d._l10nPromise.get("editor_alt_text_decorative_tooltip") : a(this, c), v.parentNode || f.append(v);
-                        }, be = new WeakSet(), Cn = function(f) {
+                            d.classList.add("done"), b.innerText = r(this, h) ? await l._l10nPromise.get("editor_alt_text_decorative_tooltip") : r(this, a), b.parentNode || d.append(b);
+                        }, gt = new WeakSet(), Cn = function(d) {
                             if (!this._isDraggable)
                                 return;
-                            const v = this._uiManager.isSelected(this);
+                            const b = this._uiManager.isSelected(this);
                             this._uiManager.setUpDragSession();
-                            let A, O;
-                            v && (A = {
+                            let y, O;
+                            b && (y = {
                                 passive: !0,
                                 capture: !0
                             }, O = (z) => {
-                                const [ae, Z] = this.screenToPageTranslation(z.movementX, z.movementY);
-                                this._uiManager.dragSelectedEditors(ae, Z);
-                            }, window.addEventListener("pointermove", O, A));
-                            const H = () => {
-                                if (window.removeEventListener("pointerup", H), window.removeEventListener("blur", H), v && window.removeEventListener("pointermove", O, A), oe(this, k, !1), !this._uiManager.endDragSession()) {
+                                const [it, Z] = this.screenToPageTranslation(z.movementX, z.movementY);
+                                this._uiManager.dragSelectedEditors(it, Z);
+                            }, window.addEventListener("pointermove", O, y));
+                            const B = () => {
+                                if (window.removeEventListener("pointerup", B), window.removeEventListener("blur", B), b && window.removeEventListener("pointermove", O, y), ot(this, C, !1), !this._uiManager.endDragSession()) {
                                     const {
                                         isMac: z
                                     } = s.FeatureTest.platform;
-                                    f.ctrlKey && !z || f.shiftKey || f.metaKey && z ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
+                                    d.ctrlKey && !z || d.shiftKey || d.metaKey && z ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
                                 }
                             };
-                            window.addEventListener("pointerup", H), window.addEventListener("blur", H);
-                        }, W(d, N), nt(d, "_borderLineWidth", -1), nt(d, "_colorManager", new n.ColorManager()), nt(d, "_zIndex", 1), nt(d, "SMALL_EDITOR_SIZE", 0);
-                        let h = d;
-                        e.AnnotationEditor = h;
-                        class _ extends h {
-                            constructor(f) {
-                                super(f), this.annotationElementId = f.annotationElementId, this.deleted = !0;
+                            window.addEventListener("pointerup", B), window.addEventListener("blur", B);
+                        }, W(l, N), ee(l, "_borderLineWidth", -1), ee(l, "_colorManager", new e.ColorManager()), ee(l, "_zIndex", 1), ee(l, "SMALL_EDITOR_SIZE", 0);
+                        let f = l;
+                        t.AnnotationEditor = f;
+                        class A extends f {
+                            constructor(d) {
+                                super(d), this.annotationElementId = d.annotationElementId, this.deleted = !0;
                             }
                             serialize() {
                                 return {
                                     id: this.annotationElementId,
                                     deleted: !0,
                                     pageIndex: this.pageIndex
                                 };
                             }
                         }
                     },
                     /* 5 */
                     /***/
-                    (t, e, i) => {
-                        var w, C, P, b, k, qt, y, p, E, $, M, Pn, D, X, G, I, B, ee, Y, q, le, pe, we, be, R, d, g, f, v, A, O, H, z, ae, Z, ce, ue, me, fe, Pe, Fe, Ee, De, _e, ie, se, ge, xn, xe, zt, We, Xt, ze, Ct, Ge, Vt, de, Yt, J, at, Se, mt, et, kn, Te, Rn, ke, Kt, Be, bt, Ae, Jt;
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        var w, T, P, m, C, He, S, g, v, $, M, kn, D, X, Y, I, U, G, V, H, st, dt, yt, gt, k, l, u, d, b, y, O, B, z, it, Z, lt, ht, mt, ft, kt, Rt, St, It, _t, rt, at, pt, Tn, Tt, ze, Wt, Ge, zt, Ce, qt, Xe, ut, Ve, Q, re, wt, _e, Qt, Pn, Et, Fn, Pt, Ye, Nt, me, vt, Ke;
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.KeyboardManager = e.CommandManager = e.ColorManager = e.AnnotationEditorUIManager = void 0, e.bindEvents = l, e.opacityToHex = h;
-                        var n = i(1),
-                            s = i(6);
+                        }), t.KeyboardManager = t.CommandManager = t.ColorManager = t.AnnotationEditorUIManager = void 0, t.bindEvents = p, t.opacityToHex = f;
+                        var e = n(1),
+                            s = n(6);
 
-                        function l(U, u, L) {
-                            for (const j of L)
-                                u.addEventListener(j, U[j].bind(U));
+                        function p(j, c, L) {
+                            for (const q of L)
+                                c.addEventListener(q, j[q].bind(j));
                         }
 
-                        function h(U) {
-                            return Math.round(Math.min(255, Math.max(1, 255 * U))).toString(16).padStart(2, "0");
+                        function f(j) {
+                            return Math.round(Math.min(255, Math.max(1, 255 * j))).toString(16).padStart(2, "0");
                         }
-                        class _ {
+                        class A {
                             constructor() {
                                 W(this, w, 0);
                             }
                             getId() {
-                                return `${n.AnnotationEditorPrefix}${_t(this, w)._++}`;
+                                return `${e.AnnotationEditorPrefix}${ge(this, w)._++}`;
                             }
                         }
                         w = new WeakMap();
-                        const x = class x {
+                        const E = class E {
                             constructor() {
-                                W(this, k);
-                                W(this, C, (0, n.getUuid)());
+                                W(this, C);
+                                W(this, T, (0, e.getUuid)());
                                 W(this, P, 0);
-                                W(this, b, null);
+                                W(this, m, null);
                             }
                             static get _isSVGFittingCanvas() {
-                                const u = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>',
-                                    j = new OffscreenCanvas(1, 3).getContext("2d"),
-                                    V = new Image();
-                                V.src = u;
-                                const Q = V.decode().then(() => (j.drawImage(V, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(j.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
-                                return (0, n.shadow)(this, "_isSVGFittingCanvas", Q);
+                                const c = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>',
+                                    q = new OffscreenCanvas(1, 3).getContext("2d"),
+                                    K = new Image();
+                                K.src = c;
+                                const tt = K.decode().then(() => (q.drawImage(K, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(q.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
+                                return (0, e.shadow)(this, "_isSVGFittingCanvas", tt);
                             }
-                            async getFromFile(u) {
+                            async getFromFile(c) {
                                 const {
                                     lastModified: L,
-                                    name: j,
-                                    size: V,
-                                    type: Q
-                                } = u;
-                                return K(this, k, qt).call(this, `${L}_${j}_${V}_${Q}`, u);
-                            }
-                            async getFromUrl(u) {
-                                return K(this, k, qt).call(this, u, u);
-                            }
-                            async getFromId(u) {
-                                a(this, b) || oe(this, b, /* @__PURE__ */ new Map());
-                                const L = a(this, b).get(u);
+                                    name: q,
+                                    size: K,
+                                    type: tt
+                                } = c;
+                                return J(this, C, He).call(this, `${L}_${q}_${K}_${tt}`, c);
+                            }
+                            async getFromUrl(c) {
+                                return J(this, C, He).call(this, c, c);
+                            }
+                            async getFromId(c) {
+                                r(this, m) || ot(this, m, /* @__PURE__ */ new Map());
+                                const L = r(this, m).get(c);
                                 return L ? L.bitmap ? (L.refCounter += 1, L) : L.file ? this.getFromFile(L.file) : this.getFromUrl(L.url) : null;
                             }
-                            getSvgUrl(u) {
-                                const L = a(this, b).get(u);
+                            getSvgUrl(c) {
+                                const L = r(this, m).get(c);
                                 return L != null && L.isSvg ? L.svgUrl : null;
                             }
-                            deleteId(u) {
-                                a(this, b) || oe(this, b, /* @__PURE__ */ new Map());
-                                const L = a(this, b).get(u);
+                            deleteId(c) {
+                                r(this, m) || ot(this, m, /* @__PURE__ */ new Map());
+                                const L = r(this, m).get(c);
                                 L && (L.refCounter -= 1, L.refCounter === 0 && (L.bitmap = null));
                             }
-                            isValidId(u) {
-                                return u.startsWith(`image_${a(this, C)}_`);
+                            isValidId(c) {
+                                return c.startsWith(`image_${r(this, T)}_`);
                             }
                         };
-                        C = new WeakMap(), P = new WeakMap(), b = new WeakMap(), k = new WeakSet(), qt = async function(u, L) {
-                            a(this, b) || oe(this, b, /* @__PURE__ */ new Map());
-                            let j = a(this, b).get(u);
-                            if (j === null)
+                        T = new WeakMap(), P = new WeakMap(), m = new WeakMap(), C = new WeakSet(), He = async function(c, L) {
+                            r(this, m) || ot(this, m, /* @__PURE__ */ new Map());
+                            let q = r(this, m).get(c);
+                            if (q === null)
                                 return null;
-                            if (j != null && j.bitmap)
-                                return j.refCounter += 1, j;
+                            if (q != null && q.bitmap)
+                                return q.refCounter += 1, q;
                             try {
-                                j || (j = {
+                                q || (q = {
                                     bitmap: null,
-                                    id: `image_${a(this, C)}_${_t(this, P)._++}`,
+                                    id: `image_${r(this, T)}_${ge(this, P)._++}`,
                                     refCounter: 0,
                                     isSvg: !1
                                 });
-                                let V;
+                                let K;
                                 if (typeof L == "string") {
-                                    j.url = L;
-                                    const Q = await fetch(L);
-                                    if (!Q.ok)
-                                        throw new Error(Q.statusText);
-                                    V = await Q.blob();
+                                    q.url = L;
+                                    const tt = await fetch(L);
+                                    if (!tt.ok)
+                                        throw new Error(tt.statusText);
+                                    K = await tt.blob();
                                 } else
-                                    V = j.file = L;
-                                if (V.type === "image/svg+xml") {
-                                    const Q = x._isSVGFittingCanvas,
-                                        he = new FileReader(),
-                                        ye = new Image(),
-                                        Me = new Promise((Re, qe) => {
-                                            ye.onload = () => {
-                                                j.bitmap = ye, j.isSvg = !0, Re();
-                                            }, he.onload = async () => {
-                                                const Ie = j.svgUrl = he.result;
-                                                ye.src = await Q ? `${Ie}#svgView(preserveAspectRatio(none))` : Ie;
-                                            }, ye.onerror = he.onerror = qe;
+                                    K = q.file = L;
+                                if (K.type === "image/svg+xml") {
+                                    const tt = E._isSVGFittingCanvas,
+                                        ct = new FileReader(),
+                                        bt = new Image(),
+                                        Mt = new Promise((Ft, Ht) => {
+                                            bt.onload = () => {
+                                                q.bitmap = bt, q.isSvg = !0, Ft();
+                                            }, ct.onload = async () => {
+                                                const xt = q.svgUrl = ct.result;
+                                                bt.src = await tt ? `${xt}#svgView(preserveAspectRatio(none))` : xt;
+                                            }, bt.onerror = ct.onerror = Ht;
                                         });
-                                    he.readAsDataURL(V), await Me;
+                                    ct.readAsDataURL(K), await Mt;
                                 } else
-                                    j.bitmap = await createImageBitmap(V);
-                                j.refCounter = 1;
-                            } catch (V) {
-                                console.error(V), j = null;
+                                    q.bitmap = await createImageBitmap(K);
+                                q.refCounter = 1;
+                            } catch (K) {
+                                console.error(K), q = null;
                             }
-                            return a(this, b).set(u, j), j && a(this, b).set(j.id, j), j;
+                            return r(this, m).set(c, q), q && r(this, m).set(q.id, q), q;
                         };
-                        let c = x;
-                        class o {
-                            constructor(u = 128) {
-                                W(this, y, []);
-                                W(this, p, !1);
-                                W(this, E, void 0);
+                        let a = E;
+                        class h {
+                            constructor(c = 128) {
+                                W(this, S, []);
+                                W(this, g, !1);
+                                W(this, v, void 0);
                                 W(this, $, -1);
-                                oe(this, E, u);
+                                ot(this, v, c);
                             }
                             add({
-                                cmd: u,
+                                cmd: c,
                                 undo: L,
-                                mustExec: j,
-                                type: V = NaN,
-                                overwriteIfSameType: Q = !1,
-                                keepUndo: he = !1
+                                mustExec: q,
+                                type: K = NaN,
+                                overwriteIfSameType: tt = !1,
+                                keepUndo: ct = !1
                             }) {
-                                if (j && u(), a(this, p))
+                                if (q && c(), r(this, g))
                                     return;
-                                const ye = {
-                                    cmd: u,
+                                const bt = {
+                                    cmd: c,
                                     undo: L,
-                                    type: V
+                                    type: K
                                 };
-                                if (a(this, $) === -1) {
-                                    a(this, y).length > 0 && (a(this, y).length = 0), oe(this, $, 0), a(this, y).push(ye);
+                                if (r(this, $) === -1) {
+                                    r(this, S).length > 0 && (r(this, S).length = 0), ot(this, $, 0), r(this, S).push(bt);
                                     return;
                                 }
-                                if (Q && a(this, y)[a(this, $)].type === V) {
-                                    he && (ye.undo = a(this, y)[a(this, $)].undo), a(this, y)[a(this, $)] = ye;
+                                if (tt && r(this, S)[r(this, $)].type === K) {
+                                    ct && (bt.undo = r(this, S)[r(this, $)].undo), r(this, S)[r(this, $)] = bt;
                                     return;
                                 }
-                                const Me = a(this, $) + 1;
-                                Me === a(this, E) ? a(this, y).splice(0, 1) : (oe(this, $, Me), Me < a(this, y).length && a(this, y).splice(Me)), a(this, y).push(ye);
+                                const Mt = r(this, $) + 1;
+                                Mt === r(this, v) ? r(this, S).splice(0, 1) : (ot(this, $, Mt), Mt < r(this, S).length && r(this, S).splice(Mt)), r(this, S).push(bt);
                             }
                             undo() {
-                                a(this, $) !== -1 && (oe(this, p, !0), a(this, y)[a(this, $)].undo(), oe(this, p, !1), oe(this, $, a(this, $) - 1));
+                                r(this, $) !== -1 && (ot(this, g, !0), r(this, S)[r(this, $)].undo(), ot(this, g, !1), ot(this, $, r(this, $) - 1));
                             }
                             redo() {
-                                a(this, $) < a(this, y).length - 1 && (oe(this, $, a(this, $) + 1), oe(this, p, !0), a(this, y)[a(this, $)].cmd(), oe(this, p, !1));
+                                r(this, $) < r(this, S).length - 1 && (ot(this, $, r(this, $) + 1), ot(this, g, !0), r(this, S)[r(this, $)].cmd(), ot(this, g, !1));
                             }
                             hasSomethingToUndo() {
-                                return a(this, $) !== -1;
+                                return r(this, $) !== -1;
                             }
                             hasSomethingToRedo() {
-                                return a(this, $) < a(this, y).length - 1;
+                                return r(this, $) < r(this, S).length - 1;
                             }
                             destroy() {
-                                oe(this, y, null);
+                                ot(this, S, null);
                             }
                         }
-                        y = new WeakMap(), p = new WeakMap(), E = new WeakMap(), $ = new WeakMap(), e.CommandManager = o;
-                        class r {
-                            constructor(u) {
+                        S = new WeakMap(), g = new WeakMap(), v = new WeakMap(), $ = new WeakMap(), t.CommandManager = h;
+                        class o {
+                            constructor(c) {
                                 W(this, M);
                                 this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
                                 const {
                                     isMac: L
-                                } = n.FeatureTest.platform;
-                                for (const [j, V, Q = {}] of u)
-                                    for (const he of j) {
-                                        const ye = he.startsWith("mac+");
-                                        L && ye ? (this.callbacks.set(he.slice(4), {
-                                            callback: V,
-                                            options: Q
-                                        }), this.allKeys.add(he.split("+").at(-1))) : !L && !ye && (this.callbacks.set(he, {
-                                            callback: V,
-                                            options: Q
-                                        }), this.allKeys.add(he.split("+").at(-1)));
+                                } = e.FeatureTest.platform;
+                                for (const [q, K, tt = {}] of c)
+                                    for (const ct of q) {
+                                        const bt = ct.startsWith("mac+");
+                                        L && bt ? (this.callbacks.set(ct.slice(4), {
+                                            callback: K,
+                                            options: tt
+                                        }), this.allKeys.add(ct.split("+").at(-1))) : !L && !bt && (this.callbacks.set(ct, {
+                                            callback: K,
+                                            options: tt
+                                        }), this.allKeys.add(ct.split("+").at(-1)));
                                     }
                             }
-                            exec(u, L) {
+                            exec(c, L) {
                                 if (!this.allKeys.has(L.key))
                                     return;
-                                const j = this.callbacks.get(K(this, M, Pn).call(this, L));
-                                if (!j)
+                                const q = this.callbacks.get(J(this, M, kn).call(this, L));
+                                if (!q)
                                     return;
                                 const {
-                                    callback: V,
+                                    callback: K,
                                     options: {
-                                        bubbles: Q = !1,
-                                        args: he = [],
-                                        checker: ye = null
+                                        bubbles: tt = !1,
+                                        args: ct = [],
+                                        checker: bt = null
                                     }
-                                } = j;
-                                ye && !ye(u, L) || (V.bind(u, ...he)(), Q || (L.stopPropagation(), L.preventDefault()));
+                                } = q;
+                                bt && !bt(c, L) || (K.bind(c, ...ct)(), tt || (L.stopPropagation(), L.preventDefault()));
                             }
                         }
-                        M = new WeakSet(), Pn = function(u) {
-                            u.altKey && this.buffer.push("alt"), u.ctrlKey && this.buffer.push("ctrl"), u.metaKey && this.buffer.push("meta"), u.shiftKey && this.buffer.push("shift"), this.buffer.push(u.key);
+                        M = new WeakSet(), kn = function(c) {
+                            c.altKey && this.buffer.push("alt"), c.ctrlKey && this.buffer.push("ctrl"), c.metaKey && this.buffer.push("meta"), c.shiftKey && this.buffer.push("shift"), this.buffer.push(c.key);
                             const L = this.buffer.join("+");
                             return this.buffer.length = 0, L;
-                        }, e.KeyboardManager = r;
+                        }, t.KeyboardManager = o;
                         const N = class N {
                             get _colors() {
-                                const u = /* @__PURE__ */ new Map([
+                                const c = /* @__PURE__ */ new Map([
                                     ["CanvasText", null],
                                     ["Canvas", null]
                                 ]);
-                                return (0, s.getColorValues)(u), (0, n.shadow)(this, "_colors", u);
+                                return (0, s.getColorValues)(c), (0, e.shadow)(this, "_colors", c);
                             }
-                            convert(u) {
-                                const L = (0, s.getRGB)(u);
+                            convert(c) {
+                                const L = (0, s.getRGB)(c);
                                 if (!window.matchMedia("(forced-colors: active)").matches)
                                     return L;
-                                for (const [j, V] of this._colors)
-                                    if (V.every((Q, he) => Q === L[he]))
-                                        return N._colorsMapping.get(j);
+                                for (const [q, K] of this._colors)
+                                    if (K.every((tt, ct) => tt === L[ct]))
+                                        return N._colorsMapping.get(q);
                                 return L;
                             }
-                            getHexCode(u) {
-                                const L = this._colors.get(u);
-                                return L ? n.Util.makeHexColor(...L) : u;
+                            getHexCode(c) {
+                                const L = this._colors.get(c);
+                                return L ? e.Util.makeHexColor(...L) : c;
                             }
                         };
-                        nt(N, "_colorsMapping", /* @__PURE__ */ new Map([
+                        ee(N, "_colorsMapping", /* @__PURE__ */ new Map([
                             ["CanvasText", [0, 0, 0]],
                             ["Canvas", [255, 255, 255]]
                         ]));
-                        let T = N;
-                        e.ColorManager = T;
-                        const Oe = class Oe {
-                            constructor(u, L, j, V, Q, he) {
-                                W(this, ge);
-                                W(this, xe);
-                                W(this, We);
-                                W(this, ze);
-                                W(this, Ge);
-                                W(this, de);
-                                W(this, J);
-                                W(this, Se);
-                                W(this, et);
-                                W(this, Te);
-                                W(this, ke);
-                                W(this, Be);
-                                W(this, Ae);
+                        let F = N;
+                        t.ColorManager = F;
+                        const Lt = class Lt {
+                            constructor(c, L, q, K, tt, ct) {
+                                W(this, pt);
+                                W(this, Tt);
+                                W(this, Wt);
+                                W(this, zt);
+                                W(this, qt);
+                                W(this, ut);
+                                W(this, Q);
+                                W(this, wt);
+                                W(this, Qt);
+                                W(this, Et);
+                                W(this, Pt);
+                                W(this, Nt);
+                                W(this, vt);
                                 W(this, D, null);
                                 W(this, X, /* @__PURE__ */ new Map());
-                                W(this, G, /* @__PURE__ */ new Map());
+                                W(this, Y, /* @__PURE__ */ new Map());
                                 W(this, I, null);
-                                W(this, B, null);
-                                W(this, ee, new o());
-                                W(this, Y, 0);
-                                W(this, q, /* @__PURE__ */ new Set());
-                                W(this, le, null);
-                                W(this, pe, null);
-                                W(this, we, /* @__PURE__ */ new Set());
-                                W(this, be, null);
-                                W(this, R, new _());
-                                W(this, d, !1);
-                                W(this, g, !1);
-                                W(this, f, null);
-                                W(this, v, n.AnnotationEditorType.NONE);
-                                W(this, A, /* @__PURE__ */ new Set());
+                                W(this, U, null);
+                                W(this, G, new h());
+                                W(this, V, 0);
+                                W(this, H, /* @__PURE__ */ new Set());
+                                W(this, st, null);
+                                W(this, dt, null);
+                                W(this, yt, /* @__PURE__ */ new Set());
+                                W(this, gt, null);
+                                W(this, k, new A());
+                                W(this, l, !1);
+                                W(this, u, !1);
+                                W(this, d, null);
+                                W(this, b, e.AnnotationEditorType.NONE);
+                                W(this, y, /* @__PURE__ */ new Set());
                                 W(this, O, null);
-                                W(this, H, this.blur.bind(this));
+                                W(this, B, this.blur.bind(this));
                                 W(this, z, this.focus.bind(this));
-                                W(this, ae, this.copy.bind(this));
+                                W(this, it, this.copy.bind(this));
                                 W(this, Z, this.cut.bind(this));
-                                W(this, ce, this.paste.bind(this));
-                                W(this, ue, this.keydown.bind(this));
-                                W(this, me, this.onEditingAction.bind(this));
-                                W(this, fe, this.onPageChanging.bind(this));
-                                W(this, Pe, this.onScaleChanging.bind(this));
-                                W(this, Fe, this.onRotationChanging.bind(this));
-                                W(this, Ee, {
+                                W(this, lt, this.paste.bind(this));
+                                W(this, ht, this.keydown.bind(this));
+                                W(this, mt, this.onEditingAction.bind(this));
+                                W(this, ft, this.onPageChanging.bind(this));
+                                W(this, kt, this.onScaleChanging.bind(this));
+                                W(this, Rt, this.onRotationChanging.bind(this));
+                                W(this, St, {
                                     isEditing: !1,
                                     isEmpty: !0,
                                     hasSomethingToUndo: !1,
                                     hasSomethingToRedo: !1,
                                     hasSelectedEditor: !1
                                 });
-                                W(this, De, [0, 0]);
-                                W(this, _e, null);
-                                W(this, ie, null);
-                                W(this, se, null);
-                                oe(this, ie, u), oe(this, se, L), oe(this, I, j), this._eventBus = V, this._eventBus._on("editingaction", a(this, me)), this._eventBus._on("pagechanging", a(this, fe)), this._eventBus._on("scalechanging", a(this, Pe)), this._eventBus._on("rotationchanging", a(this, Fe)), oe(this, B, Q.annotationStorage), oe(this, be, Q.filterFactory), oe(this, O, he), this.viewParameters = {
+                                W(this, It, [0, 0]);
+                                W(this, _t, null);
+                                W(this, rt, null);
+                                W(this, at, null);
+                                ot(this, rt, c), ot(this, at, L), ot(this, I, q), this._eventBus = K, this._eventBus._on("editingaction", r(this, mt)), this._eventBus._on("pagechanging", r(this, ft)), this._eventBus._on("scalechanging", r(this, kt)), this._eventBus._on("rotationchanging", r(this, Rt)), ot(this, U, tt.annotationStorage), ot(this, gt, tt.filterFactory), ot(this, O, ct), this.viewParameters = {
                                     realScale: s.PixelsPerInch.PDF_TO_CSS_UNITS,
                                     rotation: 0
                                 };
                             }
                             static get _keyboardManager() {
-                                const u = Oe.prototype,
-                                    L = (Q) => {
+                                const c = Lt.prototype,
+                                    L = (tt) => {
                                         const {
-                                            activeElement: he
+                                            activeElement: ct
                                         } = document;
-                                        return he && a(Q, ie).contains(he) && Q.hasSomethingToControl();
+                                        return ct && r(tt, rt).contains(ct) && tt.hasSomethingToControl();
                                     },
-                                    j = this.TRANSLATE_SMALL,
-                                    V = this.TRANSLATE_BIG;
-                                return (0, n.shadow)(this, "_keyboardManager", new r([
+                                    q = this.TRANSLATE_SMALL,
+                                    K = this.TRANSLATE_BIG;
+                                return (0, e.shadow)(this, "_keyboardManager", new o([
                                     [
-                                        ["ctrl+a", "mac+meta+a"], u.selectAll
+                                        ["ctrl+a", "mac+meta+a"], c.selectAll
                                     ],
                                     [
-                                        ["ctrl+z", "mac+meta+z"], u.undo
+                                        ["ctrl+z", "mac+meta+z"], c.undo
                                     ],
                                     [
-                                        ["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], u.redo
+                                        ["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], c.redo
                                     ],
                                     [
-                                        ["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], u.delete
+                                        ["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], c.delete
                                     ],
                                     [
-                                        ["Escape", "mac+Escape"], u.unselectAll
+                                        ["Escape", "mac+Escape"], c.unselectAll
                                     ],
                                     [
-                                        ["ArrowLeft", "mac+ArrowLeft"], u.translateSelectedEditors, {
-                                            args: [-j, 0],
+                                        ["ArrowLeft", "mac+ArrowLeft"], c.translateSelectedEditors, {
+                                            args: [-q, 0],
                                             checker: L
                                         }
                                     ],
                                     [
-                                        ["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], u.translateSelectedEditors, {
-                                            args: [-V, 0],
+                                        ["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], c.translateSelectedEditors, {
+                                            args: [-K, 0],
                                             checker: L
                                         }
                                     ],
                                     [
-                                        ["ArrowRight", "mac+ArrowRight"], u.translateSelectedEditors, {
-                                            args: [j, 0],
+                                        ["ArrowRight", "mac+ArrowRight"], c.translateSelectedEditors, {
+                                            args: [q, 0],
                                             checker: L
                                         }
                                     ],
                                     [
-                                        ["ctrl+ArrowRight", "mac+shift+ArrowRight"], u.translateSelectedEditors, {
-                                            args: [V, 0],
+                                        ["ctrl+ArrowRight", "mac+shift+ArrowRight"], c.translateSelectedEditors, {
+                                            args: [K, 0],
                                             checker: L
                                         }
                                     ],
                                     [
-                                        ["ArrowUp", "mac+ArrowUp"], u.translateSelectedEditors, {
-                                            args: [0, -j],
+                                        ["ArrowUp", "mac+ArrowUp"], c.translateSelectedEditors, {
+                                            args: [0, -q],
                                             checker: L
                                         }
                                     ],
                                     [
-                                        ["ctrl+ArrowUp", "mac+shift+ArrowUp"], u.translateSelectedEditors, {
-                                            args: [0, -V],
+                                        ["ctrl+ArrowUp", "mac+shift+ArrowUp"], c.translateSelectedEditors, {
+                                            args: [0, -K],
                                             checker: L
                                         }
                                     ],
                                     [
-                                        ["ArrowDown", "mac+ArrowDown"], u.translateSelectedEditors, {
-                                            args: [0, j],
+                                        ["ArrowDown", "mac+ArrowDown"], c.translateSelectedEditors, {
+                                            args: [0, q],
                                             checker: L
                                         }
                                     ],
                                     [
-                                        ["ctrl+ArrowDown", "mac+shift+ArrowDown"], u.translateSelectedEditors, {
-                                            args: [0, V],
+                                        ["ctrl+ArrowDown", "mac+shift+ArrowDown"], c.translateSelectedEditors, {
+                                            args: [0, K],
                                             checker: L
                                         }
                                     ]
                                 ]));
                             }
                             destroy() {
-                                K(this, ze, Ct).call(this), K(this, xe, zt).call(this), this._eventBus._off("editingaction", a(this, me)), this._eventBus._off("pagechanging", a(this, fe)), this._eventBus._off("scalechanging", a(this, Pe)), this._eventBus._off("rotationchanging", a(this, Fe));
-                                for (const u of a(this, G).values())
-                                    u.destroy();
-                                a(this, G).clear(), a(this, X).clear(), a(this, we).clear(), oe(this, D, null), a(this, A).clear(), a(this, ee).destroy(), a(this, I).destroy();
+                                J(this, zt, Ce).call(this), J(this, Tt, ze).call(this), this._eventBus._off("editingaction", r(this, mt)), this._eventBus._off("pagechanging", r(this, ft)), this._eventBus._off("scalechanging", r(this, kt)), this._eventBus._off("rotationchanging", r(this, Rt));
+                                for (const c of r(this, Y).values())
+                                    c.destroy();
+                                r(this, Y).clear(), r(this, X).clear(), r(this, yt).clear(), ot(this, D, null), r(this, y).clear(), r(this, G).destroy(), r(this, I).destroy();
                             }
                             get hcmFilter() {
-                                return (0, n.shadow)(this, "hcmFilter", a(this, O) ? a(this, be).addHCMFilter(a(this, O).foreground, a(this, O).background) : "none");
+                                return (0, e.shadow)(this, "hcmFilter", r(this, O) ? r(this, gt).addHCMFilter(r(this, O).foreground, r(this, O).background) : "none");
                             }
                             get direction() {
-                                return (0, n.shadow)(this, "direction", getComputedStyle(a(this, ie)).direction);
+                                return (0, e.shadow)(this, "direction", getComputedStyle(r(this, rt)).direction);
                             }
-                            editAltText(u) {
+                            editAltText(c) {
                                 var L;
-                                (L = a(this, I)) == null || L.editAltText(this, u);
+                                (L = r(this, I)) == null || L.editAltText(this, c);
                             }
                             onPageChanging({
-                                pageNumber: u
+                                pageNumber: c
                             }) {
-                                oe(this, Y, u - 1);
+                                ot(this, V, c - 1);
                             }
                             focusMainContainer() {
-                                a(this, ie).focus();
+                                r(this, rt).focus();
                             }
-                            findParent(u, L) {
-                                for (const j of a(this, G).values()) {
+                            findParent(c, L) {
+                                for (const q of r(this, Y).values()) {
                                     const {
-                                        x: V,
-                                        y: Q,
-                                        width: he,
-                                        height: ye
-                                    } = j.div.getBoundingClientRect();
-                                    if (u >= V && u <= V + he && L >= Q && L <= Q + ye)
-                                        return j;
+                                        x: K,
+                                        y: tt,
+                                        width: ct,
+                                        height: bt
+                                    } = q.div.getBoundingClientRect();
+                                    if (c >= K && c <= K + ct && L >= tt && L <= tt + bt)
+                                        return q;
                                 }
                                 return null;
                             }
-                            disableUserSelect(u = !1) {
-                                a(this, se).classList.toggle("noUserSelect", u);
+                            disableUserSelect(c = !1) {
+                                r(this, at).classList.toggle("noUserSelect", c);
                             }
-                            addShouldRescale(u) {
-                                a(this, we).add(u);
+                            addShouldRescale(c) {
+                                r(this, yt).add(c);
                             }
-                            removeShouldRescale(u) {
-                                a(this, we).delete(u);
+                            removeShouldRescale(c) {
+                                r(this, yt).delete(c);
                             }
                             onScaleChanging({
-                                scale: u
+                                scale: c
                             }) {
-                                this.commitOrRemove(), this.viewParameters.realScale = u * s.PixelsPerInch.PDF_TO_CSS_UNITS;
-                                for (const L of a(this, we))
+                                this.commitOrRemove(), this.viewParameters.realScale = c * s.PixelsPerInch.PDF_TO_CSS_UNITS;
+                                for (const L of r(this, yt))
                                     L.onScaleChanging();
                             }
                             onRotationChanging({
-                                pagesRotation: u
+                                pagesRotation: c
                             }) {
-                                this.commitOrRemove(), this.viewParameters.rotation = u;
+                                this.commitOrRemove(), this.viewParameters.rotation = c;
                             }
-                            addToAnnotationStorage(u) {
-                                !u.isEmpty() && a(this, B) && !a(this, B).has(u.id) && a(this, B).setValue(u.id, u);
+                            addToAnnotationStorage(c) {
+                                !c.isEmpty() && r(this, U) && !r(this, U).has(c.id) && r(this, U).setValue(c.id, c);
                             }
                             blur() {
                                 if (!this.hasSelection)
                                     return;
                                 const {
-                                    activeElement: u
+                                    activeElement: c
                                 } = document;
-                                for (const L of a(this, A))
-                                    if (L.div.contains(u)) {
-                                        oe(this, f, [L, u]), L._focusEventsAllowed = !1;
+                                for (const L of r(this, y))
+                                    if (L.div.contains(c)) {
+                                        ot(this, d, [L, c]), L._focusEventsAllowed = !1;
                                         break;
                                     }
                             }
                             focus() {
-                                if (!a(this, f))
+                                if (!r(this, d))
                                     return;
-                                const [u, L] = a(this, f);
-                                oe(this, f, null), L.addEventListener("focusin", () => {
-                                    u._focusEventsAllowed = !0;
+                                const [c, L] = r(this, d);
+                                ot(this, d, null), L.addEventListener("focusin", () => {
+                                    c._focusEventsAllowed = !0;
                                 }, {
                                     once: !0
                                 }), L.focus();
                             }
                             addEditListeners() {
-                                K(this, We, Xt).call(this), K(this, Ge, Vt).call(this);
+                                J(this, Wt, Ge).call(this), J(this, qt, Xe).call(this);
                             }
                             removeEditListeners() {
-                                K(this, ze, Ct).call(this), K(this, de, Yt).call(this);
+                                J(this, zt, Ce).call(this), J(this, ut, Ve).call(this);
                             }
-                            copy(u) {
-                                var j;
-                                if (u.preventDefault(), (j = a(this, D)) == null || j.commitOrRemove(), !this.hasSelection)
+                            copy(c) {
+                                var q;
+                                if (c.preventDefault(), (q = r(this, D)) == null || q.commitOrRemove(), !this.hasSelection)
                                     return;
                                 const L = [];
-                                for (const V of a(this, A)) {
-                                    const Q = V.serialize(!0);
-                                    Q && L.push(Q);
+                                for (const K of r(this, y)) {
+                                    const tt = K.serialize(!0);
+                                    tt && L.push(tt);
                                 }
-                                L.length !== 0 && u.clipboardData.setData("application/pdfjs", JSON.stringify(L));
+                                L.length !== 0 && c.clipboardData.setData("application/pdfjs", JSON.stringify(L));
                             }
-                            cut(u) {
-                                this.copy(u), this.delete();
+                            cut(c) {
+                                this.copy(c), this.delete();
                             }
-                            paste(u) {
-                                u.preventDefault();
+                            paste(c) {
+                                c.preventDefault();
                                 const {
                                     clipboardData: L
-                                } = u;
-                                for (const Q of L.items)
-                                    for (const he of a(this, pe))
-                                        if (he.isHandlingMimeForPasting(Q.type)) {
-                                            he.paste(Q, this.currentLayer);
+                                } = c;
+                                for (const tt of L.items)
+                                    for (const ct of r(this, dt))
+                                        if (ct.isHandlingMimeForPasting(tt.type)) {
+                                            ct.paste(tt, this.currentLayer);
                                             return;
                                         }
-                                let j = L.getData("application/pdfjs");
-                                if (!j)
+                                let q = L.getData("application/pdfjs");
+                                if (!q)
                                     return;
                                 try {
-                                    j = JSON.parse(j);
-                                } catch (Q) {
-                                    (0, n.warn)(`paste: "${Q.message}".`);
+                                    q = JSON.parse(q);
+                                } catch (tt) {
+                                    (0, e.warn)(`paste: "${tt.message}".`);
                                     return;
                                 }
-                                if (!Array.isArray(j))
+                                if (!Array.isArray(q))
                                     return;
                                 this.unselectAll();
-                                const V = this.currentLayer;
+                                const K = this.currentLayer;
                                 try {
-                                    const Q = [];
-                                    for (const Me of j) {
-                                        const Re = V.deserialize(Me);
-                                        if (!Re)
+                                    const tt = [];
+                                    for (const Mt of q) {
+                                        const Ft = K.deserialize(Mt);
+                                        if (!Ft)
                                             return;
-                                        Q.push(Re);
+                                        tt.push(Ft);
                                     }
-                                    const he = () => {
-                                            for (const Me of Q)
-                                                K(this, ke, Kt).call(this, Me);
-                                            K(this, Ae, Jt).call(this, Q);
+                                    const ct = () => {
+                                            for (const Mt of tt)
+                                                J(this, Pt, Ye).call(this, Mt);
+                                            J(this, vt, Ke).call(this, tt);
                                         },
-                                        ye = () => {
-                                            for (const Me of Q)
-                                                Me.remove();
+                                        bt = () => {
+                                            for (const Mt of tt)
+                                                Mt.remove();
                                         };
                                     this.addCommands({
-                                        cmd: he,
-                                        undo: ye,
+                                        cmd: ct,
+                                        undo: bt,
                                         mustExec: !0
                                     });
-                                } catch (Q) {
-                                    (0, n.warn)(`paste: "${Q.message}".`);
+                                } catch (tt) {
+                                    (0, e.warn)(`paste: "${tt.message}".`);
                                 }
                             }
-                            keydown(u) {
+                            keydown(c) {
                                 var L;
-                                (L = this.getActive()) != null && L.shouldGetKeyboardEvents() || Oe._keyboardManager.exec(this, u);
+                                (L = this.getActive()) != null && L.shouldGetKeyboardEvents() || Lt._keyboardManager.exec(this, c);
                             }
-                            onEditingAction(u) {
-                                ["undo", "redo", "delete", "selectAll"].includes(u.name) && this[u.name]();
+                            onEditingAction(c) {
+                                ["undo", "redo", "delete", "selectAll"].includes(c.name) && this[c.name]();
                             }
-                            setEditingState(u) {
-                                u ? (K(this, ge, xn).call(this), K(this, We, Xt).call(this), K(this, Ge, Vt).call(this), K(this, J, at).call(this, {
-                                    isEditing: a(this, v) !== n.AnnotationEditorType.NONE,
-                                    isEmpty: K(this, Be, bt).call(this),
-                                    hasSomethingToUndo: a(this, ee).hasSomethingToUndo(),
-                                    hasSomethingToRedo: a(this, ee).hasSomethingToRedo(),
+                            setEditingState(c) {
+                                c ? (J(this, pt, Tn).call(this), J(this, Wt, Ge).call(this), J(this, qt, Xe).call(this), J(this, Q, re).call(this, {
+                                    isEditing: r(this, b) !== e.AnnotationEditorType.NONE,
+                                    isEmpty: J(this, Nt, me).call(this),
+                                    hasSomethingToUndo: r(this, G).hasSomethingToUndo(),
+                                    hasSomethingToRedo: r(this, G).hasSomethingToRedo(),
                                     hasSelectedEditor: !1
-                                })) : (K(this, xe, zt).call(this), K(this, ze, Ct).call(this), K(this, de, Yt).call(this), K(this, J, at).call(this, {
+                                })) : (J(this, Tt, ze).call(this), J(this, zt, Ce).call(this), J(this, ut, Ve).call(this), J(this, Q, re).call(this, {
                                     isEditing: !1
                                 }), this.disableUserSelect(!1));
                             }
-                            registerEditorTypes(u) {
-                                if (!a(this, pe)) {
-                                    oe(this, pe, u);
-                                    for (const L of a(this, pe))
-                                        K(this, Se, mt).call(this, L.defaultPropertiesToUpdate);
+                            registerEditorTypes(c) {
+                                if (!r(this, dt)) {
+                                    ot(this, dt, c);
+                                    for (const L of r(this, dt))
+                                        J(this, wt, _e).call(this, L.defaultPropertiesToUpdate);
                                 }
                             }
                             getId() {
-                                return a(this, R).getId();
+                                return r(this, k).getId();
                             }
                             get currentLayer() {
-                                return a(this, G).get(a(this, Y));
+                                return r(this, Y).get(r(this, V));
                             }
-                            getLayer(u) {
-                                return a(this, G).get(u);
+                            getLayer(c) {
+                                return r(this, Y).get(c);
                             }
                             get currentPageIndex() {
-                                return a(this, Y);
+                                return r(this, V);
                             }
-                            addLayer(u) {
-                                a(this, G).set(u.pageIndex, u), a(this, d) ? u.enable() : u.disable();
+                            addLayer(c) {
+                                r(this, Y).set(c.pageIndex, c), r(this, l) ? c.enable() : c.disable();
                             }
-                            removeLayer(u) {
-                                a(this, G).delete(u.pageIndex);
+                            removeLayer(c) {
+                                r(this, Y).delete(c.pageIndex);
                             }
-                            updateMode(u, L = null) {
-                                if (a(this, v) !== u) {
-                                    if (oe(this, v, u), u === n.AnnotationEditorType.NONE) {
-                                        this.setEditingState(!1), K(this, Te, Rn).call(this);
+                            updateMode(c, L = null) {
+                                if (r(this, b) !== c) {
+                                    if (ot(this, b, c), c === e.AnnotationEditorType.NONE) {
+                                        this.setEditingState(!1), J(this, Et, Fn).call(this);
                                         return;
                                     }
-                                    this.setEditingState(!0), K(this, et, kn).call(this), this.unselectAll();
-                                    for (const j of a(this, G).values())
-                                        j.updateMode(u);
+                                    this.setEditingState(!0), J(this, Qt, Pn).call(this), this.unselectAll();
+                                    for (const q of r(this, Y).values())
+                                        q.updateMode(c);
                                     if (L) {
-                                        for (const j of a(this, X).values())
-                                            if (j.annotationElementId === L) {
-                                                this.setSelected(j), j.enterInEditMode();
+                                        for (const q of r(this, X).values())
+                                            if (q.annotationElementId === L) {
+                                                this.setSelected(q), q.enterInEditMode();
                                                 break;
                                             }
                                     }
                                 }
                             }
-                            updateToolbar(u) {
-                                u !== a(this, v) && this._eventBus.dispatch("switchannotationeditormode", {
+                            updateToolbar(c) {
+                                c !== r(this, b) && this._eventBus.dispatch("switchannotationeditormode", {
                                     source: this,
-                                    mode: u
+                                    mode: c
                                 });
                             }
-                            updateParams(u, L) {
-                                if (a(this, pe)) {
-                                    if (u === n.AnnotationEditorParamsType.CREATE) {
-                                        this.currentLayer.addNewEditor(u);
+                            updateParams(c, L) {
+                                if (r(this, dt)) {
+                                    if (c === e.AnnotationEditorParamsType.CREATE) {
+                                        this.currentLayer.addNewEditor(c);
                                         return;
                                     }
-                                    for (const j of a(this, A))
-                                        j.updateParams(u, L);
-                                    for (const j of a(this, pe))
-                                        j.updateDefaultParams(u, L);
+                                    for (const q of r(this, y))
+                                        q.updateParams(c, L);
+                                    for (const q of r(this, dt))
+                                        q.updateDefaultParams(c, L);
                                 }
                             }
-                            enableWaiting(u = !1) {
-                                if (a(this, g) !== u) {
-                                    oe(this, g, u);
-                                    for (const L of a(this, G).values())
-                                        u ? L.disableClick() : L.enableClick(), L.div.classList.toggle("waiting", u);
+                            enableWaiting(c = !1) {
+                                if (r(this, u) !== c) {
+                                    ot(this, u, c);
+                                    for (const L of r(this, Y).values())
+                                        c ? L.disableClick() : L.enableClick(), L.div.classList.toggle("waiting", c);
                                 }
                             }
-                            getEditors(u) {
+                            getEditors(c) {
                                 const L = [];
-                                for (const j of a(this, X).values())
-                                    j.pageIndex === u && L.push(j);
+                                for (const q of r(this, X).values())
+                                    q.pageIndex === c && L.push(q);
                                 return L;
                             }
-                            getEditor(u) {
-                                return a(this, X).get(u);
+                            getEditor(c) {
+                                return r(this, X).get(c);
                             }
-                            addEditor(u) {
-                                a(this, X).set(u.id, u);
+                            addEditor(c) {
+                                r(this, X).set(c.id, c);
                             }
-                            removeEditor(u) {
+                            removeEditor(c) {
                                 var L;
-                                a(this, X).delete(u.id), this.unselect(u), (!u.annotationElementId || !a(this, q).has(u.annotationElementId)) && ((L = a(this, B)) == null || L.remove(u.id));
+                                r(this, X).delete(c.id), this.unselect(c), (!c.annotationElementId || !r(this, H).has(c.annotationElementId)) && ((L = r(this, U)) == null || L.remove(c.id));
                             }
-                            addDeletedAnnotationElement(u) {
-                                a(this, q).add(u.annotationElementId), u.deleted = !0;
+                            addDeletedAnnotationElement(c) {
+                                r(this, H).add(c.annotationElementId), c.deleted = !0;
                             }
-                            isDeletedAnnotationElement(u) {
-                                return a(this, q).has(u);
+                            isDeletedAnnotationElement(c) {
+                                return r(this, H).has(c);
                             }
-                            removeDeletedAnnotationElement(u) {
-                                a(this, q).delete(u.annotationElementId), u.deleted = !1;
+                            removeDeletedAnnotationElement(c) {
+                                r(this, H).delete(c.annotationElementId), c.deleted = !1;
                             }
-                            setActiveEditor(u) {
-                                a(this, D) !== u && (oe(this, D, u), u && K(this, Se, mt).call(this, u.propertiesToUpdate));
+                            setActiveEditor(c) {
+                                r(this, D) !== c && (ot(this, D, c), c && J(this, wt, _e).call(this, c.propertiesToUpdate));
                             }
-                            toggleSelected(u) {
-                                if (a(this, A).has(u)) {
-                                    a(this, A).delete(u), u.unselect(), K(this, J, at).call(this, {
+                            toggleSelected(c) {
+                                if (r(this, y).has(c)) {
+                                    r(this, y).delete(c), c.unselect(), J(this, Q, re).call(this, {
                                         hasSelectedEditor: this.hasSelection
                                     });
                                     return;
                                 }
-                                a(this, A).add(u), u.select(), K(this, Se, mt).call(this, u.propertiesToUpdate), K(this, J, at).call(this, {
+                                r(this, y).add(c), c.select(), J(this, wt, _e).call(this, c.propertiesToUpdate), J(this, Q, re).call(this, {
                                     hasSelectedEditor: !0
                                 });
                             }
-                            setSelected(u) {
-                                for (const L of a(this, A))
-                                    L !== u && L.unselect();
-                                a(this, A).clear(), a(this, A).add(u), u.select(), K(this, Se, mt).call(this, u.propertiesToUpdate), K(this, J, at).call(this, {
+                            setSelected(c) {
+                                for (const L of r(this, y))
+                                    L !== c && L.unselect();
+                                r(this, y).clear(), r(this, y).add(c), c.select(), J(this, wt, _e).call(this, c.propertiesToUpdate), J(this, Q, re).call(this, {
                                     hasSelectedEditor: !0
                                 });
                             }
-                            isSelected(u) {
-                                return a(this, A).has(u);
+                            isSelected(c) {
+                                return r(this, y).has(c);
                             }
-                            unselect(u) {
-                                u.unselect(), a(this, A).delete(u), K(this, J, at).call(this, {
+                            unselect(c) {
+                                c.unselect(), r(this, y).delete(c), J(this, Q, re).call(this, {
                                     hasSelectedEditor: this.hasSelection
                                 });
                             }
                             get hasSelection() {
-                                return a(this, A).size !== 0;
+                                return r(this, y).size !== 0;
                             }
                             undo() {
-                                a(this, ee).undo(), K(this, J, at).call(this, {
-                                    hasSomethingToUndo: a(this, ee).hasSomethingToUndo(),
+                                r(this, G).undo(), J(this, Q, re).call(this, {
+                                    hasSomethingToUndo: r(this, G).hasSomethingToUndo(),
                                     hasSomethingToRedo: !0,
-                                    isEmpty: K(this, Be, bt).call(this)
+                                    isEmpty: J(this, Nt, me).call(this)
                                 });
                             }
                             redo() {
-                                a(this, ee).redo(), K(this, J, at).call(this, {
+                                r(this, G).redo(), J(this, Q, re).call(this, {
                                     hasSomethingToUndo: !0,
-                                    hasSomethingToRedo: a(this, ee).hasSomethingToRedo(),
-                                    isEmpty: K(this, Be, bt).call(this)
+                                    hasSomethingToRedo: r(this, G).hasSomethingToRedo(),
+                                    isEmpty: J(this, Nt, me).call(this)
                                 });
                             }
-                            addCommands(u) {
-                                a(this, ee).add(u), K(this, J, at).call(this, {
+                            addCommands(c) {
+                                r(this, G).add(c), J(this, Q, re).call(this, {
                                     hasSomethingToUndo: !0,
                                     hasSomethingToRedo: !1,
-                                    isEmpty: K(this, Be, bt).call(this)
+                                    isEmpty: J(this, Nt, me).call(this)
                                 });
                             }
                             delete() {
                                 if (this.commitOrRemove(), !this.hasSelection)
                                     return;
-                                const u = [...a(this, A)],
+                                const c = [...r(this, y)],
                                     L = () => {
-                                        for (const V of u)
-                                            V.remove();
+                                        for (const K of c)
+                                            K.remove();
                                     },
-                                    j = () => {
-                                        for (const V of u)
-                                            K(this, ke, Kt).call(this, V);
+                                    q = () => {
+                                        for (const K of c)
+                                            J(this, Pt, Ye).call(this, K);
                                     };
                                 this.addCommands({
                                     cmd: L,
-                                    undo: j,
+                                    undo: q,
                                     mustExec: !0
                                 });
                             }
                             commitOrRemove() {
-                                var u;
-                                (u = a(this, D)) == null || u.commitOrRemove();
+                                var c;
+                                (c = r(this, D)) == null || c.commitOrRemove();
                             }
                             hasSomethingToControl() {
-                                return a(this, D) || this.hasSelection;
+                                return r(this, D) || this.hasSelection;
                             }
                             selectAll() {
-                                for (const u of a(this, A))
-                                    u.commit();
-                                K(this, Ae, Jt).call(this, a(this, X).values());
+                                for (const c of r(this, y))
+                                    c.commit();
+                                J(this, vt, Ke).call(this, r(this, X).values());
                             }
                             unselectAll() {
-                                if (a(this, D)) {
-                                    a(this, D).commitOrRemove();
+                                if (r(this, D)) {
+                                    r(this, D).commitOrRemove();
                                     return;
                                 }
                                 if (this.hasSelection) {
-                                    for (const u of a(this, A))
-                                        u.unselect();
-                                    a(this, A).clear(), K(this, J, at).call(this, {
+                                    for (const c of r(this, y))
+                                        c.unselect();
+                                    r(this, y).clear(), J(this, Q, re).call(this, {
                                         hasSelectedEditor: !1
                                     });
                                 }
                             }
-                            translateSelectedEditors(u, L, j = !1) {
-                                if (j || this.commitOrRemove(), !this.hasSelection)
+                            translateSelectedEditors(c, L, q = !1) {
+                                if (q || this.commitOrRemove(), !this.hasSelection)
                                     return;
-                                a(this, De)[0] += u, a(this, De)[1] += L;
-                                const [V, Q] = a(this, De), he = [...a(this, A)], ye = 1e3;
-                                a(this, _e) && clearTimeout(a(this, _e)), oe(this, _e, setTimeout(() => {
-                                    oe(this, _e, null), a(this, De)[0] = a(this, De)[1] = 0, this.addCommands({
+                                r(this, It)[0] += c, r(this, It)[1] += L;
+                                const [K, tt] = r(this, It), ct = [...r(this, y)], bt = 1e3;
+                                r(this, _t) && clearTimeout(r(this, _t)), ot(this, _t, setTimeout(() => {
+                                    ot(this, _t, null), r(this, It)[0] = r(this, It)[1] = 0, this.addCommands({
                                         cmd: () => {
-                                            for (const Me of he)
-                                                a(this, X).has(Me.id) && Me.translateInPage(V, Q);
+                                            for (const Mt of ct)
+                                                r(this, X).has(Mt.id) && Mt.translateInPage(K, tt);
                                         },
                                         undo: () => {
-                                            for (const Me of he)
-                                                a(this, X).has(Me.id) && Me.translateInPage(-V, -Q);
+                                            for (const Mt of ct)
+                                                r(this, X).has(Mt.id) && Mt.translateInPage(-K, -tt);
                                         },
                                         mustExec: !1
                                     });
-                                }, ye));
-                                for (const Me of he)
-                                    Me.translateInPage(u, L);
+                                }, bt));
+                                for (const Mt of ct)
+                                    Mt.translateInPage(c, L);
                             }
                             setUpDragSession() {
                                 if (this.hasSelection) {
-                                    this.disableUserSelect(!0), oe(this, le, /* @__PURE__ */ new Map());
-                                    for (const u of a(this, A))
-                                        a(this, le).set(u, {
-                                            savedX: u.x,
-                                            savedY: u.y,
-                                            savedPageIndex: u.pageIndex,
+                                    this.disableUserSelect(!0), ot(this, st, /* @__PURE__ */ new Map());
+                                    for (const c of r(this, y))
+                                        r(this, st).set(c, {
+                                            savedX: c.x,
+                                            savedY: c.y,
+                                            savedPageIndex: c.pageIndex,
                                             newX: 0,
                                             newY: 0,
                                             newPageIndex: -1
                                         });
                                 }
                             }
                             endDragSession() {
-                                if (!a(this, le))
+                                if (!r(this, st))
                                     return !1;
                                 this.disableUserSelect(!1);
-                                const u = a(this, le);
-                                oe(this, le, null);
+                                const c = r(this, st);
+                                ot(this, st, null);
                                 let L = !1;
                                 for (const [{
-                                        x: V,
-                                        y: Q,
-                                        pageIndex: he
-                                    }, ye] of u)
-                                    ye.newX = V, ye.newY = Q, ye.newPageIndex = he, L || (L = V !== ye.savedX || Q !== ye.savedY || he !== ye.savedPageIndex);
+                                        x: K,
+                                        y: tt,
+                                        pageIndex: ct
+                                    }, bt] of c)
+                                    bt.newX = K, bt.newY = tt, bt.newPageIndex = ct, L || (L = K !== bt.savedX || tt !== bt.savedY || ct !== bt.savedPageIndex);
                                 if (!L)
                                     return !1;
-                                const j = (V, Q, he, ye) => {
-                                    if (a(this, X).has(V.id)) {
-                                        const Me = a(this, G).get(ye);
-                                        Me ? V._setParentAndPosition(Me, Q, he) : (V.pageIndex = ye, V.x = Q, V.y = he);
+                                const q = (K, tt, ct, bt) => {
+                                    if (r(this, X).has(K.id)) {
+                                        const Mt = r(this, Y).get(bt);
+                                        Mt ? K._setParentAndPosition(Mt, tt, ct) : (K.pageIndex = bt, K.x = tt, K.y = ct);
                                     }
                                 };
                                 return this.addCommands({
                                     cmd: () => {
-                                        for (const [V, {
-                                                newX: Q,
-                                                newY: he,
-                                                newPageIndex: ye
-                                            }] of u)
-                                            j(V, Q, he, ye);
+                                        for (const [K, {
+                                                newX: tt,
+                                                newY: ct,
+                                                newPageIndex: bt
+                                            }] of c)
+                                            q(K, tt, ct, bt);
                                     },
                                     undo: () => {
-                                        for (const [V, {
-                                                savedX: Q,
-                                                savedY: he,
-                                                savedPageIndex: ye
-                                            }] of u)
-                                            j(V, Q, he, ye);
+                                        for (const [K, {
+                                                savedX: tt,
+                                                savedY: ct,
+                                                savedPageIndex: bt
+                                            }] of c)
+                                            q(K, tt, ct, bt);
                                     },
                                     mustExec: !0
                                 }), !0;
                             }
-                            dragSelectedEditors(u, L) {
-                                if (a(this, le))
-                                    for (const j of a(this, le).keys())
-                                        j.drag(u, L);
-                            }
-                            rebuild(u) {
-                                if (u.parent === null) {
-                                    const L = this.getLayer(u.pageIndex);
-                                    L ? (L.changeParent(u), L.addOrRebuild(u)) : (this.addEditor(u), this.addToAnnotationStorage(u), u.rebuild());
+                            dragSelectedEditors(c, L) {
+                                if (r(this, st))
+                                    for (const q of r(this, st).keys())
+                                        q.drag(c, L);
+                            }
+                            rebuild(c) {
+                                if (c.parent === null) {
+                                    const L = this.getLayer(c.pageIndex);
+                                    L ? (L.changeParent(c), L.addOrRebuild(c)) : (this.addEditor(c), this.addToAnnotationStorage(c), c.rebuild());
                                 } else
-                                    u.parent.addOrRebuild(u);
+                                    c.parent.addOrRebuild(c);
                             }
-                            isActive(u) {
-                                return a(this, D) === u;
+                            isActive(c) {
+                                return r(this, D) === c;
                             }
                             getActive() {
-                                return a(this, D);
+                                return r(this, D);
                             }
                             getMode() {
-                                return a(this, v);
+                                return r(this, b);
                             }
                             get imageManager() {
-                                return (0, n.shadow)(this, "imageManager", new c());
+                                return (0, e.shadow)(this, "imageManager", new a());
                             }
                         };
-                        D = new WeakMap(), X = new WeakMap(), G = new WeakMap(), I = new WeakMap(), B = new WeakMap(), ee = new WeakMap(), Y = new WeakMap(), q = new WeakMap(), le = new WeakMap(), pe = new WeakMap(), we = new WeakMap(), be = new WeakMap(), R = new WeakMap(), d = new WeakMap(), g = new WeakMap(), f = new WeakMap(), v = new WeakMap(), A = new WeakMap(), O = new WeakMap(), H = new WeakMap(), z = new WeakMap(), ae = new WeakMap(), Z = new WeakMap(), ce = new WeakMap(), ue = new WeakMap(), me = new WeakMap(), fe = new WeakMap(), Pe = new WeakMap(), Fe = new WeakMap(), Ee = new WeakMap(), De = new WeakMap(), _e = new WeakMap(), ie = new WeakMap(), se = new WeakMap(), ge = new WeakSet(), xn = function() {
-                            window.addEventListener("focus", a(this, z)), window.addEventListener("blur", a(this, H));
-                        }, xe = new WeakSet(), zt = function() {
-                            window.removeEventListener("focus", a(this, z)), window.removeEventListener("blur", a(this, H));
-                        }, We = new WeakSet(), Xt = function() {
-                            window.addEventListener("keydown", a(this, ue), {
+                        D = new WeakMap(), X = new WeakMap(), Y = new WeakMap(), I = new WeakMap(), U = new WeakMap(), G = new WeakMap(), V = new WeakMap(), H = new WeakMap(), st = new WeakMap(), dt = new WeakMap(), yt = new WeakMap(), gt = new WeakMap(), k = new WeakMap(), l = new WeakMap(), u = new WeakMap(), d = new WeakMap(), b = new WeakMap(), y = new WeakMap(), O = new WeakMap(), B = new WeakMap(), z = new WeakMap(), it = new WeakMap(), Z = new WeakMap(), lt = new WeakMap(), ht = new WeakMap(), mt = new WeakMap(), ft = new WeakMap(), kt = new WeakMap(), Rt = new WeakMap(), St = new WeakMap(), It = new WeakMap(), _t = new WeakMap(), rt = new WeakMap(), at = new WeakMap(), pt = new WeakSet(), Tn = function() {
+                            window.addEventListener("focus", r(this, z)), window.addEventListener("blur", r(this, B));
+                        }, Tt = new WeakSet(), ze = function() {
+                            window.removeEventListener("focus", r(this, z)), window.removeEventListener("blur", r(this, B));
+                        }, Wt = new WeakSet(), Ge = function() {
+                            window.addEventListener("keydown", r(this, ht), {
                                 capture: !0
                             });
-                        }, ze = new WeakSet(), Ct = function() {
-                            window.removeEventListener("keydown", a(this, ue), {
+                        }, zt = new WeakSet(), Ce = function() {
+                            window.removeEventListener("keydown", r(this, ht), {
                                 capture: !0
                             });
-                        }, Ge = new WeakSet(), Vt = function() {
-                            document.addEventListener("copy", a(this, ae)), document.addEventListener("cut", a(this, Z)), document.addEventListener("paste", a(this, ce));
-                        }, de = new WeakSet(), Yt = function() {
-                            document.removeEventListener("copy", a(this, ae)), document.removeEventListener("cut", a(this, Z)), document.removeEventListener("paste", a(this, ce));
-                        }, J = new WeakSet(), at = function(u) {
-                            Object.entries(u).some(([j, V]) => a(this, Ee)[j] !== V) && this._eventBus.dispatch("annotationeditorstateschanged", {
+                        }, qt = new WeakSet(), Xe = function() {
+                            document.addEventListener("copy", r(this, it)), document.addEventListener("cut", r(this, Z)), document.addEventListener("paste", r(this, lt));
+                        }, ut = new WeakSet(), Ve = function() {
+                            document.removeEventListener("copy", r(this, it)), document.removeEventListener("cut", r(this, Z)), document.removeEventListener("paste", r(this, lt));
+                        }, Q = new WeakSet(), re = function(c) {
+                            Object.entries(c).some(([q, K]) => r(this, St)[q] !== K) && this._eventBus.dispatch("annotationeditorstateschanged", {
                                 source: this,
-                                details: Object.assign(a(this, Ee), u)
+                                details: Object.assign(r(this, St), c)
                             });
-                        }, Se = new WeakSet(), mt = function(u) {
+                        }, wt = new WeakSet(), _e = function(c) {
                             this._eventBus.dispatch("annotationeditorparamschanged", {
                                 source: this,
-                                details: u
+                                details: c
                             });
-                        }, et = new WeakSet(), kn = function() {
-                            if (!a(this, d)) {
-                                oe(this, d, !0);
-                                for (const u of a(this, G).values())
-                                    u.enable();
-                            }
-                        }, Te = new WeakSet(), Rn = function() {
-                            if (this.unselectAll(), a(this, d)) {
-                                oe(this, d, !1);
-                                for (const u of a(this, G).values())
-                                    u.disable();
-                            }
-                        }, ke = new WeakSet(), Kt = function(u) {
-                            const L = a(this, G).get(u.pageIndex);
-                            L ? L.addOrRebuild(u) : this.addEditor(u);
-                        }, Be = new WeakSet(), bt = function() {
-                            if (a(this, X).size === 0)
+                        }, Qt = new WeakSet(), Pn = function() {
+                            if (!r(this, l)) {
+                                ot(this, l, !0);
+                                for (const c of r(this, Y).values())
+                                    c.enable();
+                            }
+                        }, Et = new WeakSet(), Fn = function() {
+                            if (this.unselectAll(), r(this, l)) {
+                                ot(this, l, !1);
+                                for (const c of r(this, Y).values())
+                                    c.disable();
+                            }
+                        }, Pt = new WeakSet(), Ye = function(c) {
+                            const L = r(this, Y).get(c.pageIndex);
+                            L ? L.addOrRebuild(c) : this.addEditor(c);
+                        }, Nt = new WeakSet(), me = function() {
+                            if (r(this, X).size === 0)
                                 return !0;
-                            if (a(this, X).size === 1)
-                                for (const u of a(this, X).values())
-                                    return u.isEmpty();
+                            if (r(this, X).size === 1)
+                                for (const c of r(this, X).values())
+                                    return c.isEmpty();
                             return !1;
-                        }, Ae = new WeakSet(), Jt = function(u) {
-                            a(this, A).clear();
-                            for (const L of u)
-                                L.isEmpty() || (a(this, A).add(L), L.select());
-                            K(this, J, at).call(this, {
+                        }, vt = new WeakSet(), Ke = function(c) {
+                            r(this, y).clear();
+                            for (const L of c)
+                                L.isEmpty() || (r(this, y).add(L), L.select());
+                            J(this, Q, re).call(this, {
                                 hasSelectedEditor: !0
                             });
-                        }, nt(Oe, "TRANSLATE_SMALL", 1), nt(Oe, "TRANSLATE_BIG", 10);
-                        let S = Oe;
-                        e.AnnotationEditorUIManager = S;
+                        }, ee(Lt, "TRANSLATE_SMALL", 1), ee(Lt, "TRANSLATE_BIG", 10);
+                        let R = Lt;
+                        t.AnnotationEditorUIManager = R;
                     },
                     /* 6 */
                     /***/
-                    (t, e, i) => {
-                        var Y, q, le, pe, we, be, R, d, g, f, v, A, dt, H, ft, ae, Zt, ce, Pt, me, xt, Pe, yt, Ee, vt;
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        var V, H, st, dt, yt, gt, k, l, u, d, b, y, de, B, ue, it, Je, lt, ke, mt, Te, kt, be, St, ye;
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.StatTimer = e.RenderingCancelledException = e.PixelsPerInch = e.PageViewport = e.PDFDateString = e.DOMStandardFontDataFactory = e.DOMSVGFactory = e.DOMFilterFactory = e.DOMCanvasFactory = e.DOMCMapReaderFactory = void 0, e.deprecated = $, e.getColorValues = X, e.getCurrentTransform = G, e.getCurrentTransformInverse = I, e.getFilenameFromUrl = k, e.getPdfFilenameFromUrl = F, e.getRGB = D, e.getXfaPageViewport = N, e.isDataScheme = P, e.isPdfFile = b, e.isValidFetchUrl = y, e.loadScript = E, e.noContextMenu = p, e.setLayerDimensions = B;
-                        var n = i(7),
-                            s = i(1);
-                        const l = "http://www.w3.org/2000/svg",
-                            ee = class ee {};
-                        nt(ee, "CSS", 96), nt(ee, "PDF", 72), nt(ee, "PDF_TO_CSS_UNITS", ee.CSS / ee.PDF);
-                        let h = ee;
-                        e.PixelsPerInch = h;
-                        class _ extends n.BaseFilterFactory {
+                        }), t.StatTimer = t.RenderingCancelledException = t.PixelsPerInch = t.PageViewport = t.PDFDateString = t.DOMStandardFontDataFactory = t.DOMSVGFactory = t.DOMFilterFactory = t.DOMCanvasFactory = t.DOMCMapReaderFactory = void 0, t.deprecated = $, t.getColorValues = X, t.getCurrentTransform = Y, t.getCurrentTransformInverse = I, t.getFilenameFromUrl = C, t.getPdfFilenameFromUrl = x, t.getRGB = D, t.getXfaPageViewport = N, t.isDataScheme = P, t.isPdfFile = m, t.isValidFetchUrl = S, t.loadScript = v, t.noContextMenu = g, t.setLayerDimensions = U;
+                        var e = n(7),
+                            s = n(1);
+                        const p = "http://www.w3.org/2000/svg",
+                            G = class G {};
+                        ee(G, "CSS", 96), ee(G, "PDF", 72), ee(G, "PDF_TO_CSS_UNITS", G.CSS / G.PDF);
+                        let f = G;
+                        t.PixelsPerInch = f;
+                        class A extends e.BaseFilterFactory {
                             constructor({
-                                docId: se,
-                                ownerDocument: ge = globalThis.document
+                                docId: at,
+                                ownerDocument: pt = globalThis.document
                             } = {}) {
                                 super();
-                                W(this, A);
-                                W(this, H);
-                                W(this, ae);
-                                W(this, ce);
-                                W(this, me);
-                                W(this, Pe);
-                                W(this, Ee);
-                                W(this, Y, void 0);
-                                W(this, q, void 0);
-                                W(this, le, void 0);
-                                W(this, pe, void 0);
-                                W(this, we, void 0);
-                                W(this, be, void 0);
-                                W(this, R, void 0);
+                                W(this, y);
+                                W(this, B);
+                                W(this, it);
+                                W(this, lt);
+                                W(this, mt);
+                                W(this, kt);
+                                W(this, St);
+                                W(this, V, void 0);
+                                W(this, H, void 0);
+                                W(this, st, void 0);
+                                W(this, dt, void 0);
+                                W(this, yt, void 0);
+                                W(this, gt, void 0);
+                                W(this, k, void 0);
+                                W(this, l, void 0);
+                                W(this, u, void 0);
                                 W(this, d, void 0);
-                                W(this, g, void 0);
-                                W(this, f, void 0);
-                                W(this, v, 0);
-                                oe(this, le, se), oe(this, pe, ge);
+                                W(this, b, 0);
+                                ot(this, st, at), ot(this, dt, pt);
                             }
-                            addFilter(se) {
-                                if (!se)
+                            addFilter(at) {
+                                if (!at)
                                     return "none";
-                                let ge = a(this, A, dt).get(se);
-                                if (ge)
-                                    return ge;
-                                let Ce, xe, He, We;
-                                if (se.length === 1) {
-                                    const Ge = se[0],
-                                        Ye = new Array(256);
-                                    for (let de = 0; de < 256; de++)
-                                        Ye[de] = Ge[de] / 255;
-                                    We = Ce = xe = He = Ye.join(",");
+                                let pt = r(this, y, de).get(at);
+                                if (pt)
+                                    return pt;
+                                let Ct, Tt, Bt, Wt;
+                                if (at.length === 1) {
+                                    const qt = at[0],
+                                        Vt = new Array(256);
+                                    for (let ut = 0; ut < 256; ut++)
+                                        Vt[ut] = qt[ut] / 255;
+                                    Wt = Ct = Tt = Bt = Vt.join(",");
                                 } else {
-                                    const [Ge, Ye, de] = se, ne = new Array(256), J = new Array(256), ve = new Array(256);
-                                    for (let Se = 0; Se < 256; Se++)
-                                        ne[Se] = Ge[Se] / 255, J[Se] = Ye[Se] / 255, ve[Se] = de[Se] / 255;
-                                    Ce = ne.join(","), xe = J.join(","), He = ve.join(","), We = `${Ce}${xe}${He}`;
-                                }
-                                if (ge = a(this, A, dt).get(We), ge)
-                                    return a(this, A, dt).set(se, ge), ge;
-                                const je = `g_${a(this, le)}_transfer_map_${_t(this, v)._++}`,
-                                    ze = `url(#${je})`;
-                                a(this, A, dt).set(se, ze), a(this, A, dt).set(We, ze);
-                                const Xe = K(this, ce, Pt).call(this, je);
-                                return K(this, Pe, yt).call(this, Ce, xe, He, Xe), ze;
-                            }
-                            addHCMFilter(se, ge) {
-                                var Ye;
-                                const Ce = `${se}-${ge}`;
-                                if (a(this, be) === Ce)
-                                    return a(this, R);
-                                if (oe(this, be, Ce), oe(this, R, "none"), (Ye = a(this, we)) == null || Ye.remove(), !se || !ge)
-                                    return a(this, R);
-                                const xe = K(this, Ee, vt).call(this, se);
-                                se = s.Util.makeHexColor(...xe);
-                                const He = K(this, Ee, vt).call(this, ge);
-                                if (ge = s.Util.makeHexColor(...He), a(this, H, ft).style.color = "", se === "#000000" && ge === "#ffffff" || se === ge)
-                                    return a(this, R);
-                                const We = new Array(256);
-                                for (let de = 0; de <= 255; de++) {
-                                    const ne = de / 255;
-                                    We[de] = ne <= 0.03928 ? ne / 12.92 : ((ne + 0.055) / 1.055) ** 2.4;
-                                }
-                                const je = We.join(","),
-                                    ze = `g_${a(this, le)}_hcm_filter`,
-                                    Xe = oe(this, d, K(this, ce, Pt).call(this, ze));
-                                K(this, Pe, yt).call(this, je, je, je, Xe), K(this, ae, Zt).call(this, Xe);
-                                const Ge = (de, ne) => {
-                                    const J = xe[de] / 255,
-                                        ve = He[de] / 255,
-                                        Se = new Array(ne + 1);
-                                    for (let tt = 0; tt <= ne; tt++)
-                                        Se[tt] = J + tt / ne * (ve - J);
-                                    return Se.join(",");
+                                    const [qt, Vt, ut] = at, nt = new Array(256), Q = new Array(256), At = new Array(256);
+                                    for (let wt = 0; wt < 256; wt++)
+                                        nt[wt] = qt[wt] / 255, Q[wt] = Vt[wt] / 255, At[wt] = ut[wt] / 255;
+                                    Ct = nt.join(","), Tt = Q.join(","), Bt = At.join(","), Wt = `${Ct}${Tt}${Bt}`;
+                                }
+                                if (pt = r(this, y, de).get(Wt), pt)
+                                    return r(this, y, de).set(at, pt), pt;
+                                const jt = `g_${r(this, st)}_transfer_map_${ge(this, b)._++}`,
+                                    zt = `url(#${jt})`;
+                                r(this, y, de).set(at, zt), r(this, y, de).set(Wt, zt);
+                                const Gt = J(this, lt, ke).call(this, jt);
+                                return J(this, kt, be).call(this, Ct, Tt, Bt, Gt), zt;
+                            }
+                            addHCMFilter(at, pt) {
+                                var Vt;
+                                const Ct = `${at}-${pt}`;
+                                if (r(this, gt) === Ct)
+                                    return r(this, k);
+                                if (ot(this, gt, Ct), ot(this, k, "none"), (Vt = r(this, yt)) == null || Vt.remove(), !at || !pt)
+                                    return r(this, k);
+                                const Tt = J(this, St, ye).call(this, at);
+                                at = s.Util.makeHexColor(...Tt);
+                                const Bt = J(this, St, ye).call(this, pt);
+                                if (pt = s.Util.makeHexColor(...Bt), r(this, B, ue).style.color = "", at === "#000000" && pt === "#ffffff" || at === pt)
+                                    return r(this, k);
+                                const Wt = new Array(256);
+                                for (let ut = 0; ut <= 255; ut++) {
+                                    const nt = ut / 255;
+                                    Wt[ut] = nt <= 0.03928 ? nt / 12.92 : ((nt + 0.055) / 1.055) ** 2.4;
+                                }
+                                const jt = Wt.join(","),
+                                    zt = `g_${r(this, st)}_hcm_filter`,
+                                    Gt = ot(this, l, J(this, lt, ke).call(this, zt));
+                                J(this, kt, be).call(this, jt, jt, jt, Gt), J(this, it, Je).call(this, Gt);
+                                const qt = (ut, nt) => {
+                                    const Q = Tt[ut] / 255,
+                                        At = Bt[ut] / 255,
+                                        wt = new Array(nt + 1);
+                                    for (let te = 0; te <= nt; te++)
+                                        wt[te] = Q + te / nt * (At - Q);
+                                    return wt.join(",");
                                 };
-                                return K(this, Pe, yt).call(this, Ge(0, 5), Ge(1, 5), Ge(2, 5), Xe), oe(this, R, `url(#${ze})`), a(this, R);
+                                return J(this, kt, be).call(this, qt(0, 5), qt(1, 5), qt(2, 5), Gt), ot(this, k, `url(#${zt})`), r(this, k);
                             }
-                            addHighlightHCMFilter(se, ge, Ce, xe) {
-                                var ve;
-                                const He = `${se}-${ge}-${Ce}-${xe}`;
-                                if (a(this, g) === He)
-                                    return a(this, f);
-                                if (oe(this, g, He), oe(this, f, "none"), (ve = a(this, d)) == null || ve.remove(), !se || !ge)
-                                    return a(this, f);
-                                const [We, je] = [se, ge].map(K(this, Ee, vt).bind(this));
-                                let ze = Math.round(0.2126 * We[0] + 0.7152 * We[1] + 0.0722 * We[2]),
-                                    Xe = Math.round(0.2126 * je[0] + 0.7152 * je[1] + 0.0722 * je[2]),
-                                    [Ge, Ye] = [Ce, xe].map(K(this, Ee, vt).bind(this));
-                                Xe < ze && ([ze, Xe, Ge, Ye] = [Xe, ze, Ye, Ge]), a(this, H, ft).style.color = "";
-                                const de = (Se, tt, et) => {
-                                        const te = new Array(256),
-                                            Te = (Xe - ze) / et,
-                                            Ne = Se / 255,
-                                            ke = (tt - Se) / (255 * et);
-                                        let $e = 0;
-                                        for (let Be = 0; Be <= et; Be++) {
-                                            const Ze = Math.round(ze + Be * Te),
-                                                Ae = Ne + Be * ke;
-                                            for (let Ke = $e; Ke <= Ze; Ke++)
-                                                te[Ke] = Ae;
-                                            $e = Ze + 1;
+                            addHighlightHCMFilter(at, pt, Ct, Tt) {
+                                var At;
+                                const Bt = `${at}-${pt}-${Ct}-${Tt}`;
+                                if (r(this, u) === Bt)
+                                    return r(this, d);
+                                if (ot(this, u, Bt), ot(this, d, "none"), (At = r(this, l)) == null || At.remove(), !at || !pt)
+                                    return r(this, d);
+                                const [Wt, jt] = [at, pt].map(J(this, St, ye).bind(this));
+                                let zt = Math.round(0.2126 * Wt[0] + 0.7152 * Wt[1] + 0.0722 * Wt[2]),
+                                    Gt = Math.round(0.2126 * jt[0] + 0.7152 * jt[1] + 0.0722 * jt[2]),
+                                    [qt, Vt] = [Ct, Tt].map(J(this, St, ye).bind(this));
+                                Gt < zt && ([zt, Gt, qt, Vt] = [Gt, zt, Vt, qt]), r(this, B, ue).style.color = "";
+                                const ut = (wt, te, Qt) => {
+                                        const et = new Array(256),
+                                            Et = (Gt - zt) / Qt,
+                                            Ot = wt / 255,
+                                            Pt = (te - wt) / (255 * Qt);
+                                        let $t = 0;
+                                        for (let Nt = 0; Nt <= Qt; Nt++) {
+                                            const Jt = Math.round(zt + Nt * Et),
+                                                vt = Ot + Nt * Pt;
+                                            for (let Yt = $t; Yt <= Jt; Yt++)
+                                                et[Yt] = vt;
+                                            $t = Jt + 1;
                                         }
-                                        for (let Be = $e; Be < 256; Be++)
-                                            te[Be] = te[$e - 1];
-                                        return te.join(",");
+                                        for (let Nt = $t; Nt < 256; Nt++)
+                                            et[Nt] = et[$t - 1];
+                                        return et.join(",");
                                     },
-                                    ne = `g_${a(this, le)}_hcm_highlight_filter`,
-                                    J = oe(this, d, K(this, ce, Pt).call(this, ne));
-                                return K(this, ae, Zt).call(this, J), K(this, Pe, yt).call(this, de(Ge[0], Ye[0], 5), de(Ge[1], Ye[1], 5), de(Ge[2], Ye[2], 5), J), oe(this, f, `url(#${ne})`), a(this, f);
-                            }
-                            destroy(se = !1) {
-                                se && (a(this, R) || a(this, f)) || (a(this, q) && (a(this, q).parentNode.parentNode.remove(), oe(this, q, null)), a(this, Y) && (a(this, Y).clear(), oe(this, Y, null)), oe(this, v, 0));
+                                    nt = `g_${r(this, st)}_hcm_highlight_filter`,
+                                    Q = ot(this, l, J(this, lt, ke).call(this, nt));
+                                return J(this, it, Je).call(this, Q), J(this, kt, be).call(this, ut(qt[0], Vt[0], 5), ut(qt[1], Vt[1], 5), ut(qt[2], Vt[2], 5), Q), ot(this, d, `url(#${nt})`), r(this, d);
+                            }
+                            destroy(at = !1) {
+                                at && (r(this, k) || r(this, d)) || (r(this, H) && (r(this, H).parentNode.parentNode.remove(), ot(this, H, null)), r(this, V) && (r(this, V).clear(), ot(this, V, null)), ot(this, b, 0));
                             }
                         }
-                        Y = new WeakMap(), q = new WeakMap(), le = new WeakMap(), pe = new WeakMap(), we = new WeakMap(), be = new WeakMap(), R = new WeakMap(), d = new WeakMap(), g = new WeakMap(), f = new WeakMap(), v = new WeakMap(), A = new WeakSet(), dt = function() {
-                            return a(this, Y) || oe(this, Y, /* @__PURE__ */ new Map());
-                        }, H = new WeakSet(), ft = function() {
-                            if (!a(this, q)) {
-                                const se = a(this, pe).createElement("div"),
+                        V = new WeakMap(), H = new WeakMap(), st = new WeakMap(), dt = new WeakMap(), yt = new WeakMap(), gt = new WeakMap(), k = new WeakMap(), l = new WeakMap(), u = new WeakMap(), d = new WeakMap(), b = new WeakMap(), y = new WeakSet(), de = function() {
+                            return r(this, V) || ot(this, V, /* @__PURE__ */ new Map());
+                        }, B = new WeakSet(), ue = function() {
+                            if (!r(this, H)) {
+                                const at = r(this, dt).createElement("div"),
                                     {
-                                        style: ge
-                                    } = se;
-                                ge.visibility = "hidden", ge.contain = "strict", ge.width = ge.height = 0, ge.position = "absolute", ge.top = ge.left = 0, ge.zIndex = -1;
-                                const Ce = a(this, pe).createElementNS(l, "svg");
-                                Ce.setAttribute("width", 0), Ce.setAttribute("height", 0), oe(this, q, a(this, pe).createElementNS(l, "defs")), se.append(Ce), Ce.append(a(this, q)), a(this, pe).body.append(se);
-                            }
-                            return a(this, q);
-                        }, ae = new WeakSet(), Zt = function(se) {
-                            const ge = a(this, pe).createElementNS(l, "feColorMatrix");
-                            ge.setAttribute("type", "matrix"), ge.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), se.append(ge);
-                        }, ce = new WeakSet(), Pt = function(se) {
-                            const ge = a(this, pe).createElementNS(l, "filter");
-                            return ge.setAttribute("color-interpolation-filters", "sRGB"), ge.setAttribute("id", se), a(this, H, ft).append(ge), ge;
-                        }, me = new WeakSet(), xt = function(se, ge, Ce) {
-                            const xe = a(this, pe).createElementNS(l, ge);
-                            xe.setAttribute("type", "discrete"), xe.setAttribute("tableValues", Ce), se.append(xe);
-                        }, Pe = new WeakSet(), yt = function(se, ge, Ce, xe) {
-                            const He = a(this, pe).createElementNS(l, "feComponentTransfer");
-                            xe.append(He), K(this, me, xt).call(this, He, "feFuncR", se), K(this, me, xt).call(this, He, "feFuncG", ge), K(this, me, xt).call(this, He, "feFuncB", Ce);
-                        }, Ee = new WeakSet(), vt = function(se) {
-                            return a(this, H, ft).style.color = se, D(getComputedStyle(a(this, H, ft)).getPropertyValue("color"));
-                        }, e.DOMFilterFactory = _;
-                        class c extends n.BaseCanvasFactory {
+                                        style: pt
+                                    } = at;
+                                pt.visibility = "hidden", pt.contain = "strict", pt.width = pt.height = 0, pt.position = "absolute", pt.top = pt.left = 0, pt.zIndex = -1;
+                                const Ct = r(this, dt).createElementNS(p, "svg");
+                                Ct.setAttribute("width", 0), Ct.setAttribute("height", 0), ot(this, H, r(this, dt).createElementNS(p, "defs")), at.append(Ct), Ct.append(r(this, H)), r(this, dt).body.append(at);
+                            }
+                            return r(this, H);
+                        }, it = new WeakSet(), Je = function(at) {
+                            const pt = r(this, dt).createElementNS(p, "feColorMatrix");
+                            pt.setAttribute("type", "matrix"), pt.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), at.append(pt);
+                        }, lt = new WeakSet(), ke = function(at) {
+                            const pt = r(this, dt).createElementNS(p, "filter");
+                            return pt.setAttribute("color-interpolation-filters", "sRGB"), pt.setAttribute("id", at), r(this, B, ue).append(pt), pt;
+                        }, mt = new WeakSet(), Te = function(at, pt, Ct) {
+                            const Tt = r(this, dt).createElementNS(p, pt);
+                            Tt.setAttribute("type", "discrete"), Tt.setAttribute("tableValues", Ct), at.append(Tt);
+                        }, kt = new WeakSet(), be = function(at, pt, Ct, Tt) {
+                            const Bt = r(this, dt).createElementNS(p, "feComponentTransfer");
+                            Tt.append(Bt), J(this, mt, Te).call(this, Bt, "feFuncR", at), J(this, mt, Te).call(this, Bt, "feFuncG", pt), J(this, mt, Te).call(this, Bt, "feFuncB", Ct);
+                        }, St = new WeakSet(), ye = function(at) {
+                            return r(this, B, ue).style.color = at, D(getComputedStyle(r(this, B, ue)).getPropertyValue("color"));
+                        }, t.DOMFilterFactory = A;
+                        class a extends e.BaseCanvasFactory {
                             constructor({
-                                ownerDocument: ie = globalThis.document
+                                ownerDocument: rt = globalThis.document
                             } = {}) {
-                                super(), this._document = ie;
+                                super(), this._document = rt;
                             }
-                            _createCanvas(ie, se) {
-                                const ge = this._document.createElement("canvas");
-                                return ge.width = ie, ge.height = se, ge;
-                            }
-                        }
-                        e.DOMCanvasFactory = c;
-                        async function o(_e, ie = !1) {
-                            if (y(_e, document.baseURI)) {
-                                const se = await fetch(_e);
-                                if (!se.ok)
-                                    throw new Error(se.statusText);
-                                return ie ? new Uint8Array(await se.arrayBuffer()) : (0, s.stringToBytes)(await se.text());
-                            }
-                            return new Promise((se, ge) => {
-                                const Ce = new XMLHttpRequest();
-                                Ce.open("GET", _e, !0), ie && (Ce.responseType = "arraybuffer"), Ce.onreadystatechange = () => {
-                                    if (Ce.readyState === XMLHttpRequest.DONE) {
-                                        if (Ce.status === 200 || Ce.status === 0) {
-                                            let xe;
-                                            if (ie && Ce.response ? xe = new Uint8Array(Ce.response) : !ie && Ce.responseText && (xe = (0, s.stringToBytes)(Ce.responseText)), xe) {
-                                                se(xe);
+                            _createCanvas(rt, at) {
+                                const pt = this._document.createElement("canvas");
+                                return pt.width = rt, pt.height = at, pt;
+                            }
+                        }
+                        t.DOMCanvasFactory = a;
+                        async function h(_t, rt = !1) {
+                            if (S(_t, document.baseURI)) {
+                                const at = await fetch(_t);
+                                if (!at.ok)
+                                    throw new Error(at.statusText);
+                                return rt ? new Uint8Array(await at.arrayBuffer()) : (0, s.stringToBytes)(await at.text());
+                            }
+                            return new Promise((at, pt) => {
+                                const Ct = new XMLHttpRequest();
+                                Ct.open("GET", _t, !0), rt && (Ct.responseType = "arraybuffer"), Ct.onreadystatechange = () => {
+                                    if (Ct.readyState === XMLHttpRequest.DONE) {
+                                        if (Ct.status === 200 || Ct.status === 0) {
+                                            let Tt;
+                                            if (rt && Ct.response ? Tt = new Uint8Array(Ct.response) : !rt && Ct.responseText && (Tt = (0, s.stringToBytes)(Ct.responseText)), Tt) {
+                                                at(Tt);
                                                 return;
                                             }
                                         }
-                                        ge(new Error(Ce.statusText));
+                                        pt(new Error(Ct.statusText));
                                     }
-                                }, Ce.send(null);
+                                }, Ct.send(null);
                             });
                         }
-                        class r extends n.BaseCMapReaderFactory {
-                            _fetchData(ie, se) {
-                                return o(ie, this.isCompressed).then((ge) => ({
-                                    cMapData: ge,
-                                    compressionType: se
+                        class o extends e.BaseCMapReaderFactory {
+                            _fetchData(rt, at) {
+                                return h(rt, this.isCompressed).then((pt) => ({
+                                    cMapData: pt,
+                                    compressionType: at
                                 }));
                             }
                         }
-                        e.DOMCMapReaderFactory = r;
-                        class T extends n.BaseStandardFontDataFactory {
-                            _fetchData(ie) {
-                                return o(ie, !0);
+                        t.DOMCMapReaderFactory = o;
+                        class F extends e.BaseStandardFontDataFactory {
+                            _fetchData(rt) {
+                                return h(rt, !0);
                             }
                         }
-                        e.DOMStandardFontDataFactory = T;
-                        class S extends n.BaseSVGFactory {
-                            _createSVG(ie) {
-                                return document.createElementNS(l, ie);
+                        t.DOMStandardFontDataFactory = F;
+                        class R extends e.BaseSVGFactory {
+                            _createSVG(rt) {
+                                return document.createElementNS(p, rt);
                             }
                         }
-                        e.DOMSVGFactory = S;
+                        t.DOMSVGFactory = R;
                         class w {
                             constructor({
-                                viewBox: ie,
-                                scale: se,
-                                rotation: ge,
-                                offsetX: Ce = 0,
-                                offsetY: xe = 0,
-                                dontFlip: He = !1
+                                viewBox: rt,
+                                scale: at,
+                                rotation: pt,
+                                offsetX: Ct = 0,
+                                offsetY: Tt = 0,
+                                dontFlip: Bt = !1
                             }) {
-                                this.viewBox = ie, this.scale = se, this.rotation = ge, this.offsetX = Ce, this.offsetY = xe;
-                                const We = (ie[2] + ie[0]) / 2,
-                                    je = (ie[3] + ie[1]) / 2;
-                                let ze, Xe, Ge, Ye;
-                                switch (ge %= 360, ge < 0 && (ge += 360), ge) {
+                                this.viewBox = rt, this.scale = at, this.rotation = pt, this.offsetX = Ct, this.offsetY = Tt;
+                                const Wt = (rt[2] + rt[0]) / 2,
+                                    jt = (rt[3] + rt[1]) / 2;
+                                let zt, Gt, qt, Vt;
+                                switch (pt %= 360, pt < 0 && (pt += 360), pt) {
                                     case 180:
-                                        ze = -1, Xe = 0, Ge = 0, Ye = 1;
+                                        zt = -1, Gt = 0, qt = 0, Vt = 1;
                                         break;
                                     case 90:
-                                        ze = 0, Xe = 1, Ge = 1, Ye = 0;
+                                        zt = 0, Gt = 1, qt = 1, Vt = 0;
                                         break;
                                     case 270:
-                                        ze = 0, Xe = -1, Ge = -1, Ye = 0;
+                                        zt = 0, Gt = -1, qt = -1, Vt = 0;
                                         break;
                                     case 0:
-                                        ze = 1, Xe = 0, Ge = 0, Ye = -1;
+                                        zt = 1, Gt = 0, qt = 0, Vt = -1;
                                         break;
                                     default:
                                         throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
                                 }
-                                He && (Ge = -Ge, Ye = -Ye);
-                                let de, ne, J, ve;
-                                ze === 0 ? (de = Math.abs(je - ie[1]) * se + Ce, ne = Math.abs(We - ie[0]) * se + xe, J = (ie[3] - ie[1]) * se, ve = (ie[2] - ie[0]) * se) : (de = Math.abs(We - ie[0]) * se + Ce, ne = Math.abs(je - ie[1]) * se + xe, J = (ie[2] - ie[0]) * se, ve = (ie[3] - ie[1]) * se), this.transform = [ze * se, Xe * se, Ge * se, Ye * se, de - ze * se * We - Ge * se * je, ne - Xe * se * We - Ye * se * je], this.width = J, this.height = ve;
+                                Bt && (qt = -qt, Vt = -Vt);
+                                let ut, nt, Q, At;
+                                zt === 0 ? (ut = Math.abs(jt - rt[1]) * at + Ct, nt = Math.abs(Wt - rt[0]) * at + Tt, Q = (rt[3] - rt[1]) * at, At = (rt[2] - rt[0]) * at) : (ut = Math.abs(Wt - rt[0]) * at + Ct, nt = Math.abs(jt - rt[1]) * at + Tt, Q = (rt[2] - rt[0]) * at, At = (rt[3] - rt[1]) * at), this.transform = [zt * at, Gt * at, qt * at, Vt * at, ut - zt * at * Wt - qt * at * jt, nt - Gt * at * Wt - Vt * at * jt], this.width = Q, this.height = At;
                             }
                             get rawDims() {
                                 const {
-                                    viewBox: ie
+                                    viewBox: rt
                                 } = this;
                                 return (0, s.shadow)(this, "rawDims", {
-                                    pageWidth: ie[2] - ie[0],
-                                    pageHeight: ie[3] - ie[1],
-                                    pageX: ie[0],
-                                    pageY: ie[1]
+                                    pageWidth: rt[2] - rt[0],
+                                    pageHeight: rt[3] - rt[1],
+                                    pageX: rt[0],
+                                    pageY: rt[1]
                                 });
                             }
                             clone({
-                                scale: ie = this.scale,
-                                rotation: se = this.rotation,
-                                offsetX: ge = this.offsetX,
-                                offsetY: Ce = this.offsetY,
-                                dontFlip: xe = !1
+                                scale: rt = this.scale,
+                                rotation: at = this.rotation,
+                                offsetX: pt = this.offsetX,
+                                offsetY: Ct = this.offsetY,
+                                dontFlip: Tt = !1
                             } = {}) {
                                 return new w({
                                     viewBox: this.viewBox.slice(),
-                                    scale: ie,
-                                    rotation: se,
-                                    offsetX: ge,
-                                    offsetY: Ce,
-                                    dontFlip: xe
+                                    scale: rt,
+                                    rotation: at,
+                                    offsetX: pt,
+                                    offsetY: Ct,
+                                    dontFlip: Tt
                                 });
                             }
-                            convertToViewportPoint(ie, se) {
-                                return s.Util.applyTransform([ie, se], this.transform);
+                            convertToViewportPoint(rt, at) {
+                                return s.Util.applyTransform([rt, at], this.transform);
                             }
-                            convertToViewportRectangle(ie) {
-                                const se = s.Util.applyTransform([ie[0], ie[1]], this.transform),
-                                    ge = s.Util.applyTransform([ie[2], ie[3]], this.transform);
-                                return [se[0], se[1], ge[0], ge[1]];
+                            convertToViewportRectangle(rt) {
+                                const at = s.Util.applyTransform([rt[0], rt[1]], this.transform),
+                                    pt = s.Util.applyTransform([rt[2], rt[3]], this.transform);
+                                return [at[0], at[1], pt[0], pt[1]];
                             }
-                            convertToPdfPoint(ie, se) {
-                                return s.Util.applyInverseTransform([ie, se], this.transform);
+                            convertToPdfPoint(rt, at) {
+                                return s.Util.applyInverseTransform([rt, at], this.transform);
                             }
                         }
-                        e.PageViewport = w;
-                        class C extends s.BaseException {
-                            constructor(ie, se = 0) {
-                                super(ie, "RenderingCancelledException"), this.extraDelay = se;
+                        t.PageViewport = w;
+                        class T extends s.BaseException {
+                            constructor(rt, at = 0) {
+                                super(rt, "RenderingCancelledException"), this.extraDelay = at;
                             }
                         }
-                        e.RenderingCancelledException = C;
+                        t.RenderingCancelledException = T;
 
-                        function P(_e) {
-                            const ie = _e.length;
-                            let se = 0;
-                            for (; se < ie && _e[se].trim() === "";)
-                                se++;
-                            return _e.substring(se, se + 5).toLowerCase() === "data:";
+                        function P(_t) {
+                            const rt = _t.length;
+                            let at = 0;
+                            for (; at < rt && _t[at].trim() === "";)
+                                at++;
+                            return _t.substring(at, at + 5).toLowerCase() === "data:";
                         }
 
-                        function b(_e) {
-                            return typeof _e == "string" && /\.pdf$/i.test(_e);
+                        function m(_t) {
+                            return typeof _t == "string" && /\.pdf$/i.test(_t);
                         }
 
-                        function k(_e, ie = !1) {
-                            return ie || ([_e] = _e.split(/[#?]/, 1)), _e.substring(_e.lastIndexOf("/") + 1);
+                        function C(_t, rt = !1) {
+                            return rt || ([_t] = _t.split(/[#?]/, 1)), _t.substring(_t.lastIndexOf("/") + 1);
                         }
 
-                        function F(_e, ie = "document.pdf") {
-                            if (typeof _e != "string")
-                                return ie;
-                            if (P(_e))
-                                return (0, s.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), ie;
-                            const se = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/,
-                                ge = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i,
-                                Ce = se.exec(_e);
-                            let xe = ge.exec(Ce[1]) || ge.exec(Ce[2]) || ge.exec(Ce[3]);
-                            if (xe && (xe = xe[0], xe.includes("%")))
+                        function x(_t, rt = "document.pdf") {
+                            if (typeof _t != "string")
+                                return rt;
+                            if (P(_t))
+                                return (0, s.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), rt;
+                            const at = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/,
+                                pt = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i,
+                                Ct = at.exec(_t);
+                            let Tt = pt.exec(Ct[1]) || pt.exec(Ct[2]) || pt.exec(Ct[3]);
+                            if (Tt && (Tt = Tt[0], Tt.includes("%")))
                                 try {
-                                    xe = ge.exec(decodeURIComponent(xe))[0];
+                                    Tt = pt.exec(decodeURIComponent(Tt))[0];
                                 } catch {}
-                            return xe || ie;
+                            return Tt || rt;
                         }
-                        class x {
+                        class E {
                             constructor() {
-                                nt(this, "started", /* @__PURE__ */ Object.create(null));
-                                nt(this, "times", []);
+                                ee(this, "started", /* @__PURE__ */ Object.create(null));
+                                ee(this, "times", []);
                             }
-                            time(ie) {
-                                ie in this.started && (0, s.warn)(`Timer is already running for ${ie}`), this.started[ie] = Date.now();
+                            time(rt) {
+                                rt in this.started && (0, s.warn)(`Timer is already running for ${rt}`), this.started[rt] = Date.now();
                             }
-                            timeEnd(ie) {
-                                ie in this.started || (0, s.warn)(`Timer has not been started for ${ie}`), this.times.push({
-                                    name: ie,
-                                    start: this.started[ie],
+                            timeEnd(rt) {
+                                rt in this.started || (0, s.warn)(`Timer has not been started for ${rt}`), this.times.push({
+                                    name: rt,
+                                    start: this.started[rt],
                                     end: Date.now()
-                                }), delete this.started[ie];
+                                }), delete this.started[rt];
                             }
                             toString() {
-                                const ie = [];
-                                let se = 0;
+                                const rt = [];
+                                let at = 0;
                                 for (const {
-                                        name: ge
+                                        name: pt
                                     }
                                     of this.times)
-                                    se = Math.max(ge.length, se);
+                                    at = Math.max(pt.length, at);
                                 for (const {
-                                        name: ge,
-                                        start: Ce,
-                                        end: xe
+                                        name: pt,
+                                        start: Ct,
+                                        end: Tt
                                     }
                                     of this.times)
-                                    ie.push(`${ge.padEnd(se)} ${xe - Ce}ms
+                                    rt.push(`${pt.padEnd(at)} ${Tt - Ct}ms
 `);
-                                return ie.join("");
+                                return rt.join("");
                             }
                         }
-                        e.StatTimer = x;
+                        t.StatTimer = E;
 
-                        function y(_e, ie) {
+                        function S(_t, rt) {
                             try {
                                 const {
-                                    protocol: se
-                                } = ie ? new URL(_e, ie) : new URL(_e);
-                                return se === "http:" || se === "https:";
+                                    protocol: at
+                                } = rt ? new URL(_t, rt) : new URL(_t);
+                                return at === "http:" || at === "https:";
                             } catch {
                                 return !1;
                             }
                         }
 
-                        function p(_e) {
-                            _e.preventDefault();
+                        function g(_t) {
+                            _t.preventDefault();
                         }
 
-                        function E(_e, ie = !1) {
-                            return new Promise((se, ge) => {
-                                const Ce = document.createElement("script");
-                                Ce.src = _e, Ce.onload = function(xe) {
-                                    ie && Ce.remove(), se(xe);
-                                }, Ce.onerror = function() {
-                                    ge(new Error(`Cannot load script at: ${Ce.src}`));
-                                }, (document.head || document.documentElement).append(Ce);
+                        function v(_t, rt = !1) {
+                            return new Promise((at, pt) => {
+                                const Ct = document.createElement("script");
+                                Ct.src = _t, Ct.onload = function(Tt) {
+                                    rt && Ct.remove(), at(Tt);
+                                }, Ct.onerror = function() {
+                                    pt(new Error(`Cannot load script at: ${Ct.src}`));
+                                }, (document.head || document.documentElement).append(Ct);
                             });
                         }
 
-                        function $(_e) {
-                            console.log("Deprecated API usage: " + _e);
+                        function $(_t) {
+                            console.log("Deprecated API usage: " + _t);
                         }
                         let M;
-                        class m {
-                            static toDateObject(ie) {
-                                if (!ie || typeof ie != "string")
+                        class _ {
+                            static toDateObject(rt) {
+                                if (!rt || typeof rt != "string")
                                     return null;
                                 M || (M = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
-                                const se = M.exec(ie);
-                                if (!se)
+                                const at = M.exec(rt);
+                                if (!at)
                                     return null;
-                                const ge = parseInt(se[1], 10);
-                                let Ce = parseInt(se[2], 10);
-                                Ce = Ce >= 1 && Ce <= 12 ? Ce - 1 : 0;
-                                let xe = parseInt(se[3], 10);
-                                xe = xe >= 1 && xe <= 31 ? xe : 1;
-                                let He = parseInt(se[4], 10);
-                                He = He >= 0 && He <= 23 ? He : 0;
-                                let We = parseInt(se[5], 10);
-                                We = We >= 0 && We <= 59 ? We : 0;
-                                let je = parseInt(se[6], 10);
-                                je = je >= 0 && je <= 59 ? je : 0;
-                                const ze = se[7] || "Z";
-                                let Xe = parseInt(se[8], 10);
-                                Xe = Xe >= 0 && Xe <= 23 ? Xe : 0;
-                                let Ge = parseInt(se[9], 10) || 0;
-                                return Ge = Ge >= 0 && Ge <= 59 ? Ge : 0, ze === "-" ? (He += Xe, We += Ge) : ze === "+" && (He -= Xe, We -= Ge), new Date(Date.UTC(ge, Ce, xe, He, We, je));
-                            }
-                        }
-                        e.PDFDateString = m;
-
-                        function N(_e, {
-                            scale: ie = 1,
-                            rotation: se = 0
+                                const pt = parseInt(at[1], 10);
+                                let Ct = parseInt(at[2], 10);
+                                Ct = Ct >= 1 && Ct <= 12 ? Ct - 1 : 0;
+                                let Tt = parseInt(at[3], 10);
+                                Tt = Tt >= 1 && Tt <= 31 ? Tt : 1;
+                                let Bt = parseInt(at[4], 10);
+                                Bt = Bt >= 0 && Bt <= 23 ? Bt : 0;
+                                let Wt = parseInt(at[5], 10);
+                                Wt = Wt >= 0 && Wt <= 59 ? Wt : 0;
+                                let jt = parseInt(at[6], 10);
+                                jt = jt >= 0 && jt <= 59 ? jt : 0;
+                                const zt = at[7] || "Z";
+                                let Gt = parseInt(at[8], 10);
+                                Gt = Gt >= 0 && Gt <= 23 ? Gt : 0;
+                                let qt = parseInt(at[9], 10) || 0;
+                                return qt = qt >= 0 && qt <= 59 ? qt : 0, zt === "-" ? (Bt += Gt, Wt += qt) : zt === "+" && (Bt -= Gt, Wt -= qt), new Date(Date.UTC(pt, Ct, Tt, Bt, Wt, jt));
+                            }
+                        }
+                        t.PDFDateString = _;
+
+                        function N(_t, {
+                            scale: rt = 1,
+                            rotation: at = 0
                         }) {
                             const {
-                                width: ge,
-                                height: Ce
-                            } = _e.attributes.style, xe = [0, 0, parseInt(ge), parseInt(Ce)];
+                                width: pt,
+                                height: Ct
+                            } = _t.attributes.style, Tt = [0, 0, parseInt(pt), parseInt(Ct)];
                             return new w({
-                                viewBox: xe,
-                                scale: ie,
-                                rotation: se
+                                viewBox: Tt,
+                                scale: rt,
+                                rotation: at
                             });
                         }
 
-                        function D(_e) {
-                            if (_e.startsWith("#")) {
-                                const ie = parseInt(_e.slice(1), 16);
-                                return [(ie & 16711680) >> 16, (ie & 65280) >> 8, ie & 255];
+                        function D(_t) {
+                            if (_t.startsWith("#")) {
+                                const rt = parseInt(_t.slice(1), 16);
+                                return [(rt & 16711680) >> 16, (rt & 65280) >> 8, rt & 255];
                             }
-                            return _e.startsWith("rgb(") ? _e.slice(4, -1).split(",").map((ie) => parseInt(ie)) : _e.startsWith("rgba(") ? _e.slice(5, -1).split(",").map((ie) => parseInt(ie)).slice(0, 3) : ((0, s.warn)(`Not a valid color format: "${_e}"`), [0, 0, 0]);
+                            return _t.startsWith("rgb(") ? _t.slice(4, -1).split(",").map((rt) => parseInt(rt)) : _t.startsWith("rgba(") ? _t.slice(5, -1).split(",").map((rt) => parseInt(rt)).slice(0, 3) : ((0, s.warn)(`Not a valid color format: "${_t}"`), [0, 0, 0]);
                         }
 
-                        function X(_e) {
-                            const ie = document.createElement("span");
-                            ie.style.visibility = "hidden", document.body.append(ie);
-                            for (const se of _e.keys()) {
-                                ie.style.color = se;
-                                const ge = window.getComputedStyle(ie).color;
-                                _e.set(se, D(ge));
+                        function X(_t) {
+                            const rt = document.createElement("span");
+                            rt.style.visibility = "hidden", document.body.append(rt);
+                            for (const at of _t.keys()) {
+                                rt.style.color = at;
+                                const pt = window.getComputedStyle(rt).color;
+                                _t.set(at, D(pt));
                             }
-                            ie.remove();
+                            rt.remove();
                         }
 
-                        function G(_e) {
+                        function Y(_t) {
                             const {
-                                a: ie,
-                                b: se,
-                                c: ge,
-                                d: Ce,
-                                e: xe,
-                                f: He
-                            } = _e.getTransform();
-                            return [ie, se, ge, Ce, xe, He];
+                                a: rt,
+                                b: at,
+                                c: pt,
+                                d: Ct,
+                                e: Tt,
+                                f: Bt
+                            } = _t.getTransform();
+                            return [rt, at, pt, Ct, Tt, Bt];
                         }
 
-                        function I(_e) {
+                        function I(_t) {
                             const {
-                                a: ie,
-                                b: se,
-                                c: ge,
-                                d: Ce,
-                                e: xe,
-                                f: He
-                            } = _e.getTransform().invertSelf();
-                            return [ie, se, ge, Ce, xe, He];
+                                a: rt,
+                                b: at,
+                                c: pt,
+                                d: Ct,
+                                e: Tt,
+                                f: Bt
+                            } = _t.getTransform().invertSelf();
+                            return [rt, at, pt, Ct, Tt, Bt];
                         }
 
-                        function B(_e, ie, se = !1, ge = !0) {
-                            if (ie instanceof w) {
+                        function U(_t, rt, at = !1, pt = !0) {
+                            if (rt instanceof w) {
                                 const {
-                                    pageWidth: Ce,
-                                    pageHeight: xe
-                                } = ie.rawDims, {
-                                    style: He
-                                } = _e, We = s.FeatureTest.isCSSRoundSupported, je = `var(--scale-factor) * ${Ce}px`, ze = `var(--scale-factor) * ${xe}px`, Xe = We ? `round(${je}, 1px)` : `calc(${je})`, Ge = We ? `round(${ze}, 1px)` : `calc(${ze})`;
-                                !se || ie.rotation % 180 === 0 ? (He.width = Xe, He.height = Ge) : (He.width = Ge, He.height = Xe);
+                                    pageWidth: Ct,
+                                    pageHeight: Tt
+                                } = rt.rawDims, {
+                                    style: Bt
+                                } = _t, Wt = s.FeatureTest.isCSSRoundSupported, jt = `var(--scale-factor) * ${Ct}px`, zt = `var(--scale-factor) * ${Tt}px`, Gt = Wt ? `round(${jt}, 1px)` : `calc(${jt})`, qt = Wt ? `round(${zt}, 1px)` : `calc(${zt})`;
+                                !at || rt.rotation % 180 === 0 ? (Bt.width = Gt, Bt.height = qt) : (Bt.width = qt, Bt.height = Gt);
                             }
-                            ge && _e.setAttribute("data-main-rotation", ie.rotation);
+                            pt && _t.setAttribute("data-main-rotation", rt.rotation);
                         }
                     },
                     /* 7 */
                     /***/
-                    (t, e, i) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.BaseStandardFontDataFactory = e.BaseSVGFactory = e.BaseFilterFactory = e.BaseCanvasFactory = e.BaseCMapReaderFactory = void 0;
-                        var n = i(1);
+                        }), t.BaseStandardFontDataFactory = t.BaseSVGFactory = t.BaseFilterFactory = t.BaseCanvasFactory = t.BaseCMapReaderFactory = void 0;
+                        var e = n(1);
                         class s {
                             constructor() {
-                                this.constructor === s && (0, n.unreachable)("Cannot initialize BaseFilterFactory.");
+                                this.constructor === s && (0, e.unreachable)("Cannot initialize BaseFilterFactory.");
                             }
-                            addFilter(r) {
+                            addFilter(o) {
                                 return "none";
                             }
-                            addHCMFilter(r, T) {
+                            addHCMFilter(o, F) {
                                 return "none";
                             }
-                            addHighlightHCMFilter(r, T, S, w) {
+                            addHighlightHCMFilter(o, F, R, w) {
                                 return "none";
                             }
-                            destroy(r = !1) {}
+                            destroy(o = !1) {}
                         }
-                        e.BaseFilterFactory = s;
-                        class l {
+                        t.BaseFilterFactory = s;
+                        class p {
                             constructor() {
-                                this.constructor === l && (0, n.unreachable)("Cannot initialize BaseCanvasFactory.");
+                                this.constructor === p && (0, e.unreachable)("Cannot initialize BaseCanvasFactory.");
                             }
-                            create(r, T) {
-                                if (r <= 0 || T <= 0)
+                            create(o, F) {
+                                if (o <= 0 || F <= 0)
                                     throw new Error("Invalid canvas size");
-                                const S = this._createCanvas(r, T);
+                                const R = this._createCanvas(o, F);
                                 return {
-                                    canvas: S,
-                                    context: S.getContext("2d")
+                                    canvas: R,
+                                    context: R.getContext("2d")
                                 };
                             }
-                            reset(r, T, S) {
-                                if (!r.canvas)
+                            reset(o, F, R) {
+                                if (!o.canvas)
                                     throw new Error("Canvas is not specified");
-                                if (T <= 0 || S <= 0)
+                                if (F <= 0 || R <= 0)
                                     throw new Error("Invalid canvas size");
-                                r.canvas.width = T, r.canvas.height = S;
+                                o.canvas.width = F, o.canvas.height = R;
                             }
-                            destroy(r) {
-                                if (!r.canvas)
+                            destroy(o) {
+                                if (!o.canvas)
                                     throw new Error("Canvas is not specified");
-                                r.canvas.width = 0, r.canvas.height = 0, r.canvas = null, r.context = null;
+                                o.canvas.width = 0, o.canvas.height = 0, o.canvas = null, o.context = null;
                             }
-                            _createCanvas(r, T) {
-                                (0, n.unreachable)("Abstract method `_createCanvas` called.");
+                            _createCanvas(o, F) {
+                                (0, e.unreachable)("Abstract method `_createCanvas` called.");
                             }
                         }
-                        e.BaseCanvasFactory = l;
-                        class h {
+                        t.BaseCanvasFactory = p;
+                        class f {
                             constructor({
-                                baseUrl: r = null,
-                                isCompressed: T = !0
+                                baseUrl: o = null,
+                                isCompressed: F = !0
                             }) {
-                                this.constructor === h && (0, n.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = r, this.isCompressed = T;
+                                this.constructor === f && (0, e.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = o, this.isCompressed = F;
                             }
                             async fetch({
-                                name: r
+                                name: o
                             }) {
                                 if (!this.baseUrl)
                                     throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
-                                if (!r)
+                                if (!o)
                                     throw new Error("CMap name must be specified.");
-                                const T = this.baseUrl + r + (this.isCompressed ? ".bcmap" : ""),
-                                    S = this.isCompressed ? n.CMapCompressionType.BINARY : n.CMapCompressionType.NONE;
-                                return this._fetchData(T, S).catch((w) => {
-                                    throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${T}`);
+                                const F = this.baseUrl + o + (this.isCompressed ? ".bcmap" : ""),
+                                    R = this.isCompressed ? e.CMapCompressionType.BINARY : e.CMapCompressionType.NONE;
+                                return this._fetchData(F, R).catch((w) => {
+                                    throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${F}`);
                                 });
                             }
-                            _fetchData(r, T) {
-                                (0, n.unreachable)("Abstract method `_fetchData` called.");
+                            _fetchData(o, F) {
+                                (0, e.unreachable)("Abstract method `_fetchData` called.");
                             }
                         }
-                        e.BaseCMapReaderFactory = h;
-                        class _ {
+                        t.BaseCMapReaderFactory = f;
+                        class A {
                             constructor({
-                                baseUrl: r = null
+                                baseUrl: o = null
                             }) {
-                                this.constructor === _ && (0, n.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = r;
+                                this.constructor === A && (0, e.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = o;
                             }
                             async fetch({
-                                filename: r
+                                filename: o
                             }) {
                                 if (!this.baseUrl)
                                     throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
-                                if (!r)
+                                if (!o)
                                     throw new Error("Font filename must be specified.");
-                                const T = `${this.baseUrl}${r}`;
-                                return this._fetchData(T).catch((S) => {
-                                    throw new Error(`Unable to load font data at: ${T}`);
+                                const F = `${this.baseUrl}${o}`;
+                                return this._fetchData(F).catch((R) => {
+                                    throw new Error(`Unable to load font data at: ${F}`);
                                 });
                             }
-                            _fetchData(r) {
-                                (0, n.unreachable)("Abstract method `_fetchData` called.");
+                            _fetchData(o) {
+                                (0, e.unreachable)("Abstract method `_fetchData` called.");
                             }
                         }
-                        e.BaseStandardFontDataFactory = _;
-                        class c {
+                        t.BaseStandardFontDataFactory = A;
+                        class a {
                             constructor() {
-                                this.constructor === c && (0, n.unreachable)("Cannot initialize BaseSVGFactory.");
+                                this.constructor === a && (0, e.unreachable)("Cannot initialize BaseSVGFactory.");
                             }
-                            create(r, T, S = !1) {
-                                if (r <= 0 || T <= 0)
+                            create(o, F, R = !1) {
+                                if (o <= 0 || F <= 0)
                                     throw new Error("Invalid SVG dimensions");
                                 const w = this._createSVG("svg:svg");
-                                return w.setAttribute("version", "1.1"), S || (w.setAttribute("width", `${r}px`), w.setAttribute("height", `${T}px`)), w.setAttribute("preserveAspectRatio", "none"), w.setAttribute("viewBox", `0 0 ${r} ${T}`), w;
+                                return w.setAttribute("version", "1.1"), R || (w.setAttribute("width", `${o}px`), w.setAttribute("height", `${F}px`)), w.setAttribute("preserveAspectRatio", "none"), w.setAttribute("viewBox", `0 0 ${o} ${F}`), w;
                             }
-                            createElement(r) {
-                                if (typeof r != "string")
+                            createElement(o) {
+                                if (typeof o != "string")
                                     throw new Error("Invalid SVG element type");
-                                return this._createSVG(r);
+                                return this._createSVG(o);
                             }
-                            _createSVG(r) {
-                                (0, n.unreachable)("Abstract method `_createSVG` called.");
+                            _createSVG(o) {
+                                (0, e.unreachable)("Abstract method `_createSVG` called.");
                             }
                         }
-                        e.BaseSVGFactory = c;
+                        t.BaseSVGFactory = a;
                     },
                     /* 8 */
                     /***/
-                    (t, e, i) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.MurmurHash3_64 = void 0;
-                        var n = i(1);
+                        }), t.MurmurHash3_64 = void 0;
+                        var e = n(1);
                         const s = 3285377520,
-                            l = 4294901760,
-                            h = 65535;
-                        class _ {
-                            constructor(o) {
-                                this.h1 = o ? o & 4294967295 : s, this.h2 = o ? o & 4294967295 : s;
-                            }
-                            update(o) {
-                                let r, T;
-                                if (typeof o == "string") {
-                                    r = new Uint8Array(o.length * 2), T = 0;
-                                    for (let $ = 0, M = o.length; $ < M; $++) {
-                                        const m = o.charCodeAt($);
-                                        m <= 255 ? r[T++] = m : (r[T++] = m >>> 8, r[T++] = m & 255);
+                            p = 4294901760,
+                            f = 65535;
+                        class A {
+                            constructor(h) {
+                                this.h1 = h ? h & 4294967295 : s, this.h2 = h ? h & 4294967295 : s;
+                            }
+                            update(h) {
+                                let o, F;
+                                if (typeof h == "string") {
+                                    o = new Uint8Array(h.length * 2), F = 0;
+                                    for (let $ = 0, M = h.length; $ < M; $++) {
+                                        const _ = h.charCodeAt($);
+                                        _ <= 255 ? o[F++] = _ : (o[F++] = _ >>> 8, o[F++] = _ & 255);
                                     }
-                                } else if ((0, n.isArrayBuffer)(o))
-                                    r = o.slice(), T = r.byteLength;
+                                } else if ((0, e.isArrayBuffer)(h))
+                                    o = h.slice(), F = o.byteLength;
                                 else
                                     throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
-                                const S = T >> 2,
-                                    w = T - S * 4,
-                                    C = new Uint32Array(r.buffer, 0, S);
+                                const R = F >> 2,
+                                    w = F - R * 4,
+                                    T = new Uint32Array(o.buffer, 0, R);
                                 let P = 0,
-                                    b = 0,
-                                    k = this.h1,
-                                    F = this.h2;
-                                const x = 3432918353,
-                                    y = 461845907,
-                                    p = x & h,
-                                    E = y & h;
-                                for (let $ = 0; $ < S; $++)
-                                    $ & 1 ? (P = C[$], P = P * x & l | P * p & h, P = P << 15 | P >>> 17, P = P * y & l | P * E & h, k ^= P, k = k << 13 | k >>> 19, k = k * 5 + 3864292196) : (b = C[$], b = b * x & l | b * p & h, b = b << 15 | b >>> 17, b = b * y & l | b * E & h, F ^= b, F = F << 13 | F >>> 19, F = F * 5 + 3864292196);
+                                    m = 0,
+                                    C = this.h1,
+                                    x = this.h2;
+                                const E = 3432918353,
+                                    S = 461845907,
+                                    g = E & f,
+                                    v = S & f;
+                                for (let $ = 0; $ < R; $++)
+                                    $ & 1 ? (P = T[$], P = P * E & p | P * g & f, P = P << 15 | P >>> 17, P = P * S & p | P * v & f, C ^= P, C = C << 13 | C >>> 19, C = C * 5 + 3864292196) : (m = T[$], m = m * E & p | m * g & f, m = m << 15 | m >>> 17, m = m * S & p | m * v & f, x ^= m, x = x << 13 | x >>> 19, x = x * 5 + 3864292196);
                                 switch (P = 0, w) {
                                     case 3:
-                                        P ^= r[S * 4 + 2] << 16;
+                                        P ^= o[R * 4 + 2] << 16;
                                     case 2:
-                                        P ^= r[S * 4 + 1] << 8;
+                                        P ^= o[R * 4 + 1] << 8;
                                     case 1:
-                                        P ^= r[S * 4], P = P * x & l | P * p & h, P = P << 15 | P >>> 17, P = P * y & l | P * E & h, S & 1 ? k ^= P : F ^= P;
+                                        P ^= o[R * 4], P = P * E & p | P * g & f, P = P << 15 | P >>> 17, P = P * S & p | P * v & f, R & 1 ? C ^= P : x ^= P;
                                 }
-                                this.h1 = k, this.h2 = F;
+                                this.h1 = C, this.h2 = x;
                             }
                             hexdigest() {
-                                let o = this.h1,
-                                    r = this.h2;
-                                return o ^= r >>> 1, o = o * 3981806797 & l | o * 36045 & h, r = r * 4283543511 & l | ((r << 16 | o >>> 16) * 2950163797 & l) >>> 16, o ^= r >>> 1, o = o * 444984403 & l | o * 60499 & h, r = r * 3301882366 & l | ((r << 16 | o >>> 16) * 3120437893 & l) >>> 16, o ^= r >>> 1, (o >>> 0).toString(16).padStart(8, "0") + (r >>> 0).toString(16).padStart(8, "0");
+                                let h = this.h1,
+                                    o = this.h2;
+                                return h ^= o >>> 1, h = h * 3981806797 & p | h * 36045 & f, o = o * 4283543511 & p | ((o << 16 | h >>> 16) * 2950163797 & p) >>> 16, h ^= o >>> 1, h = h * 444984403 & p | h * 60499 & f, o = o * 3301882366 & p | ((o << 16 | h >>> 16) * 3120437893 & p) >>> 16, h ^= o >>> 1, (h >>> 0).toString(16).padStart(8, "0") + (o >>> 0).toString(16).padStart(8, "0");
                             }
                         }
-                        e.MurmurHash3_64 = _;
+                        t.MurmurHash3_64 = A;
                     },
                     /* 9 */
                     /***/
-                    (t, e, i) => {
-                        var h;
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        var f;
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.FontLoader = e.FontFaceObject = void 0;
-                        var n = i(1);
+                        }), t.FontLoader = t.FontFaceObject = void 0;
+                        var e = n(1);
                         class s {
                             constructor({
-                                ownerDocument: c = globalThis.document,
-                                styleElement: o = null
+                                ownerDocument: a = globalThis.document,
+                                styleElement: h = null
                             }) {
-                                W(this, h, /* @__PURE__ */ new Set());
-                                this._document = c, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
+                                W(this, f, /* @__PURE__ */ new Set());
+                                this._document = a, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
                             }
-                            addNativeFontFace(c) {
-                                this.nativeFontFaces.add(c), this._document.fonts.add(c);
+                            addNativeFontFace(a) {
+                                this.nativeFontFaces.add(a), this._document.fonts.add(a);
                             }
-                            removeNativeFontFace(c) {
-                                this.nativeFontFaces.delete(c), this._document.fonts.delete(c);
+                            removeNativeFontFace(a) {
+                                this.nativeFontFaces.delete(a), this._document.fonts.delete(a);
                             }
-                            insertRule(c) {
+                            insertRule(a) {
                                 this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
-                                const o = this.styleElement.sheet;
-                                o.insertRule(c, o.cssRules.length);
+                                const h = this.styleElement.sheet;
+                                h.insertRule(a, h.cssRules.length);
                             }
                             clear() {
-                                for (const c of this.nativeFontFaces)
-                                    this._document.fonts.delete(c);
-                                this.nativeFontFaces.clear(), a(this, h).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
-                            }
-                            async loadSystemFont(c) {
-                                if (!(!c || a(this, h).has(c.loadedName))) {
-                                    if ((0, n.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
+                                for (const a of this.nativeFontFaces)
+                                    this._document.fonts.delete(a);
+                                this.nativeFontFaces.clear(), r(this, f).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
+                            }
+                            async loadSystemFont(a) {
+                                if (!(!a || r(this, f).has(a.loadedName))) {
+                                    if ((0, e.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
                                         const {
-                                            loadedName: o,
-                                            src: r,
-                                            style: T
-                                        } = c, S = new FontFace(o, r, T);
-                                        this.addNativeFontFace(S);
+                                            loadedName: h,
+                                            src: o,
+                                            style: F
+                                        } = a, R = new FontFace(h, o, F);
+                                        this.addNativeFontFace(R);
                                         try {
-                                            await S.load(), a(this, h).add(o);
+                                            await R.load(), r(this, f).add(h);
                                         } catch {
-                                            (0, n.warn)(`Cannot load system font: ${c.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(S);
+                                            (0, e.warn)(`Cannot load system font: ${a.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(R);
                                         }
                                         return;
                                     }
-                                    (0, n.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
+                                    (0, e.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
                                 }
                             }
-                            async bind(c) {
-                                if (c.attached || c.missingFile && !c.systemFontInfo)
+                            async bind(a) {
+                                if (a.attached || a.missingFile && !a.systemFontInfo)
                                     return;
-                                if (c.attached = !0, c.systemFontInfo) {
-                                    await this.loadSystemFont(c.systemFontInfo);
+                                if (a.attached = !0, a.systemFontInfo) {
+                                    await this.loadSystemFont(a.systemFontInfo);
                                     return;
                                 }
                                 if (this.isFontLoadingAPISupported) {
-                                    const r = c.createNativeFontFace();
-                                    if (r) {
-                                        this.addNativeFontFace(r);
+                                    const o = a.createNativeFontFace();
+                                    if (o) {
+                                        this.addNativeFontFace(o);
                                         try {
-                                            await r.loaded;
-                                        } catch (T) {
-                                            throw (0, n.warn)(`Failed to load font '${r.family}': '${T}'.`), c.disableFontFace = !0, T;
+                                            await o.loaded;
+                                        } catch (F) {
+                                            throw (0, e.warn)(`Failed to load font '${o.family}': '${F}'.`), a.disableFontFace = !0, F;
                                         }
                                     }
                                     return;
                                 }
-                                const o = c.createFontFaceRule();
-                                if (o) {
-                                    if (this.insertRule(o), this.isSyncFontLoadingSupported)
+                                const h = a.createFontFaceRule();
+                                if (h) {
+                                    if (this.insertRule(h), this.isSyncFontLoadingSupported)
                                         return;
-                                    await new Promise((r) => {
-                                        const T = this._queueLoadingCallback(r);
-                                        this._prepareFontLoadEvent(c, T);
+                                    await new Promise((o) => {
+                                        const F = this._queueLoadingCallback(o);
+                                        this._prepareFontLoadEvent(a, F);
                                     });
                                 }
                             }
                             get isFontLoadingAPISupported() {
-                                var o;
-                                const c = !!((o = this._document) != null && o.fonts);
-                                return (0, n.shadow)(this, "isFontLoadingAPISupported", c);
+                                var h;
+                                const a = !!((h = this._document) != null && h.fonts);
+                                return (0, e.shadow)(this, "isFontLoadingAPISupported", a);
                             }
                             get isSyncFontLoadingSupported() {
-                                let c = !1;
-                                return (n.isNodeJS || typeof navigator < "u" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (c = !0), (0, n.shadow)(this, "isSyncFontLoadingSupported", c);
+                                let a = !1;
+                                return (e.isNodeJS || typeof navigator < "u" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (a = !0), (0, e.shadow)(this, "isSyncFontLoadingSupported", a);
                             }
-                            _queueLoadingCallback(c) {
-                                function o() {
-                                    for ((0, n.assert)(!T.done, "completeRequest() cannot be called twice."), T.done = !0; r.length > 0 && r[0].done;) {
-                                        const S = r.shift();
-                                        setTimeout(S.callback, 0);
+                            _queueLoadingCallback(a) {
+                                function h() {
+                                    for ((0, e.assert)(!F.done, "completeRequest() cannot be called twice."), F.done = !0; o.length > 0 && o[0].done;) {
+                                        const R = o.shift();
+                                        setTimeout(R.callback, 0);
                                     }
                                 }
                                 const {
-                                    loadingRequests: r
-                                } = this, T = {
+                                    loadingRequests: o
+                                } = this, F = {
                                     done: !1,
-                                    complete: o,
-                                    callback: c
+                                    complete: h,
+                                    callback: a
                                 };
-                                return r.push(T), T;
+                                return o.push(F), F;
                             }
                             get _loadTestFont() {
-                                const c = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
-                                return (0, n.shadow)(this, "_loadTestFont", c);
+                                const a = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
+                                return (0, e.shadow)(this, "_loadTestFont", a);
                             }
-                            _prepareFontLoadEvent(c, o) {
-                                function r(D, X) {
+                            _prepareFontLoadEvent(a, h) {
+                                function o(D, X) {
                                     return D.charCodeAt(X) << 24 | D.charCodeAt(X + 1) << 16 | D.charCodeAt(X + 2) << 8 | D.charCodeAt(X + 3) & 255;
                                 }
 
-                                function T(D, X, G, I) {
-                                    const B = D.substring(0, X),
-                                        ee = D.substring(X + G);
-                                    return B + I + ee;
-                                }
-                                let S, w;
-                                const C = this._document.createElement("canvas");
-                                C.width = 1, C.height = 1;
-                                const P = C.getContext("2d");
-                                let b = 0;
-
-                                function k(D, X) {
-                                    if (++b > 30) {
-                                        (0, n.warn)("Load test font never loaded."), X();
+                                function F(D, X, Y, I) {
+                                    const U = D.substring(0, X),
+                                        G = D.substring(X + Y);
+                                    return U + I + G;
+                                }
+                                let R, w;
+                                const T = this._document.createElement("canvas");
+                                T.width = 1, T.height = 1;
+                                const P = T.getContext("2d");
+                                let m = 0;
+
+                                function C(D, X) {
+                                    if (++m > 30) {
+                                        (0, e.warn)("Load test font never loaded."), X();
                                         return;
                                     }
                                     if (P.font = "30px " + D, P.fillText(".", 0, 20), P.getImageData(0, 0, 1, 1).data[3] > 0) {
                                         X();
                                         return;
                                     }
-                                    setTimeout(k.bind(null, D, X));
+                                    setTimeout(C.bind(null, D, X));
                                 }
-                                const F = `lt${Date.now()}${this.loadTestFontId++}`;
-                                let x = this._loadTestFont;
-                                x = T(x, 976, F.length, F);
-                                const p = 16,
-                                    E = 1482184792;
-                                let $ = r(x, p);
-                                for (S = 0, w = F.length - 3; S < w; S += 4)
-                                    $ = $ - E + r(F, S) | 0;
-                                S < F.length && ($ = $ - E + r(F + "XXX", S) | 0), x = T(x, p, 4, (0, n.string32)($));
-                                const M = `url(data:font/opentype;base64,${btoa(x)});`,
-                                    m = `@font-face {font-family:"${F}";src:${M}}`;
-                                this.insertRule(m);
+                                const x = `lt${Date.now()}${this.loadTestFontId++}`;
+                                let E = this._loadTestFont;
+                                E = F(E, 976, x.length, x);
+                                const g = 16,
+                                    v = 1482184792;
+                                let $ = o(E, g);
+                                for (R = 0, w = x.length - 3; R < w; R += 4)
+                                    $ = $ - v + o(x, R) | 0;
+                                R < x.length && ($ = $ - v + o(x + "XXX", R) | 0), E = F(E, g, 4, (0, e.string32)($));
+                                const M = `url(data:font/opentype;base64,${btoa(E)});`,
+                                    _ = `@font-face {font-family:"${x}";src:${M}}`;
+                                this.insertRule(_);
                                 const N = this._document.createElement("div");
                                 N.style.visibility = "hidden", N.style.width = N.style.height = "10px", N.style.position = "absolute", N.style.top = N.style.left = "0px";
-                                for (const D of [c.loadedName, F]) {
+                                for (const D of [a.loadedName, x]) {
                                     const X = this._document.createElement("span");
                                     X.textContent = "Hi", X.style.fontFamily = D, N.append(X);
                                 }
-                                this._document.body.append(N), k(F, () => {
-                                    N.remove(), o.complete();
+                                this._document.body.append(N), C(x, () => {
+                                    N.remove(), h.complete();
                                 });
                             }
                         }
-                        h = new WeakMap(), e.FontLoader = s;
-                        class l {
-                            constructor(c, {
-                                isEvalSupported: o = !0,
-                                disableFontFace: r = !1,
-                                ignoreErrors: T = !1,
-                                inspectFont: S = null
+                        f = new WeakMap(), t.FontLoader = s;
+                        class p {
+                            constructor(a, {
+                                isEvalSupported: h = !0,
+                                disableFontFace: o = !1,
+                                ignoreErrors: F = !1,
+                                inspectFont: R = null
                             }) {
                                 this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
-                                for (const w in c)
-                                    this[w] = c[w];
-                                this.isEvalSupported = o !== !1, this.disableFontFace = r === !0, this.ignoreErrors = T === !0, this._inspectFont = S;
+                                for (const w in a)
+                                    this[w] = a[w];
+                                this.isEvalSupported = h !== !1, this.disableFontFace = o === !0, this.ignoreErrors = F === !0, this._inspectFont = R;
                             }
                             createNativeFontFace() {
-                                var o;
+                                var h;
                                 if (!this.data || this.disableFontFace)
                                     return null;
-                                let c;
+                                let a;
                                 if (!this.cssFontInfo)
-                                    c = new FontFace(this.loadedName, this.data, {});
+                                    a = new FontFace(this.loadedName, this.data, {});
                                 else {
-                                    const r = {
+                                    const o = {
                                         weight: this.cssFontInfo.fontWeight
                                     };
-                                    this.cssFontInfo.italicAngle && (r.style = `oblique ${this.cssFontInfo.italicAngle}deg`), c = new FontFace(this.cssFontInfo.fontFamily, this.data, r);
+                                    this.cssFontInfo.italicAngle && (o.style = `oblique ${this.cssFontInfo.italicAngle}deg`), a = new FontFace(this.cssFontInfo.fontFamily, this.data, o);
                                 }
-                                return (o = this._inspectFont) == null || o.call(this, this), c;
+                                return (h = this._inspectFont) == null || h.call(this, this), a;
                             }
                             createFontFaceRule() {
-                                var T;
+                                var F;
                                 if (!this.data || this.disableFontFace)
                                     return null;
-                                const c = (0, n.bytesToString)(this.data),
-                                    o = `url(data:${this.mimetype};base64,${btoa(c)});`;
-                                let r;
+                                const a = (0, e.bytesToString)(this.data),
+                                    h = `url(data:${this.mimetype};base64,${btoa(a)});`;
+                                let o;
                                 if (!this.cssFontInfo)
-                                    r = `@font-face {font-family:"${this.loadedName}";src:${o}}`;
+                                    o = `@font-face {font-family:"${this.loadedName}";src:${h}}`;
                                 else {
-                                    let S = `font-weight: ${this.cssFontInfo.fontWeight};`;
-                                    this.cssFontInfo.italicAngle && (S += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), r = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${S}src:${o}}`;
+                                    let R = `font-weight: ${this.cssFontInfo.fontWeight};`;
+                                    this.cssFontInfo.italicAngle && (R += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), o = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${R}src:${h}}`;
                                 }
-                                return (T = this._inspectFont) == null || T.call(this, this, o), r;
+                                return (F = this._inspectFont) == null || F.call(this, this, h), o;
                             }
-                            getPathGenerator(c, o) {
-                                if (this.compiledGlyphs[o] !== void 0)
-                                    return this.compiledGlyphs[o];
-                                let r;
+                            getPathGenerator(a, h) {
+                                if (this.compiledGlyphs[h] !== void 0)
+                                    return this.compiledGlyphs[h];
+                                let o;
                                 try {
-                                    r = c.get(this.loadedName + "_path_" + o);
-                                } catch (T) {
+                                    o = a.get(this.loadedName + "_path_" + h);
+                                } catch (F) {
                                     if (!this.ignoreErrors)
-                                        throw T;
-                                    return (0, n.warn)(`getPathGenerator - ignoring character: "${T}".`), this.compiledGlyphs[o] = function(S, w) {};
+                                        throw F;
+                                    return (0, e.warn)(`getPathGenerator - ignoring character: "${F}".`), this.compiledGlyphs[h] = function(R, w) {};
                                 }
-                                if (this.isEvalSupported && n.FeatureTest.isEvalSupported) {
-                                    const T = [];
-                                    for (const S of r) {
-                                        const w = S.args !== void 0 ? S.args.join(",") : "";
-                                        T.push("c.", S.cmd, "(", w, `);
+                                if (this.isEvalSupported && e.FeatureTest.isEvalSupported) {
+                                    const F = [];
+                                    for (const R of o) {
+                                        const w = R.args !== void 0 ? R.args.join(",") : "";
+                                        F.push("c.", R.cmd, "(", w, `);
 `);
                                     }
-                                    return this.compiledGlyphs[o] = new Function("c", "size", T.join(""));
+                                    return this.compiledGlyphs[h] = new Function("c", "size", F.join(""));
                                 }
-                                return this.compiledGlyphs[o] = function(T, S) {
-                                    for (const w of r)
-                                        w.cmd === "scale" && (w.args = [S, -S]), T[w.cmd].apply(T, w.args);
+                                return this.compiledGlyphs[h] = function(F, R) {
+                                    for (const w of o)
+                                        w.cmd === "scale" && (w.args = [R, -R]), F[w.cmd].apply(F, w.args);
                                 };
                             }
                         }
-                        e.FontFaceObject = l;
+                        t.FontFaceObject = p;
                     },
                     /* 10 */
                     /***/
-                    (t, e, i) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.NodeStandardFontDataFactory = e.NodeFilterFactory = e.NodeCanvasFactory = e.NodeCMapReaderFactory = void 0;
-                        var n = i(7);
-                        i(1);
-                        const s = function(o) {
-                            return new Promise((r, T) => {
-                                require$$5.readFile(o, (w, C) => {
-                                    if (w || !C) {
-                                        T(new Error(w));
+                        }), t.NodeStandardFontDataFactory = t.NodeFilterFactory = t.NodeCanvasFactory = t.NodeCMapReaderFactory = void 0;
+                        var e = n(7);
+                        n(1);
+                        const s = function(h) {
+                            return new Promise((o, F) => {
+                                require$$5.readFile(h, (w, T) => {
+                                    if (w || !T) {
+                                        F(new Error(w));
                                         return;
                                     }
-                                    r(new Uint8Array(C));
+                                    o(new Uint8Array(T));
                                 });
                             });
                         };
-                        class l extends n.BaseFilterFactory {}
-                        e.NodeFilterFactory = l;
-                        class h extends n.BaseCanvasFactory {
-                            _createCanvas(r, T) {
-                                return require$$5.createCanvas(r, T);
+                        class p extends e.BaseFilterFactory {}
+                        t.NodeFilterFactory = p;
+                        class f extends e.BaseCanvasFactory {
+                            _createCanvas(o, F) {
+                                return require$$5.createCanvas(o, F);
                             }
                         }
-                        e.NodeCanvasFactory = h;
-                        class _ extends n.BaseCMapReaderFactory {
-                            _fetchData(r, T) {
-                                return s(r).then((S) => ({
-                                    cMapData: S,
-                                    compressionType: T
+                        t.NodeCanvasFactory = f;
+                        class A extends e.BaseCMapReaderFactory {
+                            _fetchData(o, F) {
+                                return s(o).then((R) => ({
+                                    cMapData: R,
+                                    compressionType: F
                                 }));
                             }
                         }
-                        e.NodeCMapReaderFactory = _;
-                        class c extends n.BaseStandardFontDataFactory {
-                            _fetchData(r) {
-                                return s(r);
+                        t.NodeCMapReaderFactory = A;
+                        class a extends e.BaseStandardFontDataFactory {
+                            _fetchData(o) {
+                                return s(o);
                             }
                         }
-                        e.NodeStandardFontDataFactory = c;
+                        t.NodeStandardFontDataFactory = a;
                     },
                     /* 11 */
                     /***/
-                    (t, e, i) => {
-                        var q, Qt, pe, en;
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        var H, Ze, dt, Qe;
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.CanvasGraphics = void 0;
-                        var n = i(1),
-                            s = i(6),
-                            l = i(12),
-                            h = i(13);
-                        const _ = 16,
-                            c = 100,
-                            o = 4096,
-                            r = 15,
-                            T = 10,
-                            S = 1e3,
+                        }), t.CanvasGraphics = void 0;
+                        var e = n(1),
+                            s = n(6),
+                            p = n(12),
+                            f = n(13);
+                        const A = 16,
+                            a = 100,
+                            h = 4096,
+                            o = 15,
+                            F = 10,
+                            R = 1e3,
                             w = 16;
 
-                        function C(R, d) {
-                            if (R._removeMirroring)
+                        function T(k, l) {
+                            if (k._removeMirroring)
                                 throw new Error("Context is already forwarding operations.");
-                            R.__originalSave = R.save, R.__originalRestore = R.restore, R.__originalRotate = R.rotate, R.__originalScale = R.scale, R.__originalTranslate = R.translate, R.__originalTransform = R.transform, R.__originalSetTransform = R.setTransform, R.__originalResetTransform = R.resetTransform, R.__originalClip = R.clip, R.__originalMoveTo = R.moveTo, R.__originalLineTo = R.lineTo, R.__originalBezierCurveTo = R.bezierCurveTo, R.__originalRect = R.rect, R.__originalClosePath = R.closePath, R.__originalBeginPath = R.beginPath, R._removeMirroring = () => {
-                                R.save = R.__originalSave, R.restore = R.__originalRestore, R.rotate = R.__originalRotate, R.scale = R.__originalScale, R.translate = R.__originalTranslate, R.transform = R.__originalTransform, R.setTransform = R.__originalSetTransform, R.resetTransform = R.__originalResetTransform, R.clip = R.__originalClip, R.moveTo = R.__originalMoveTo, R.lineTo = R.__originalLineTo, R.bezierCurveTo = R.__originalBezierCurveTo, R.rect = R.__originalRect, R.closePath = R.__originalClosePath, R.beginPath = R.__originalBeginPath, delete R._removeMirroring;
-                            }, R.save = function() {
-                                d.save(), this.__originalSave();
-                            }, R.restore = function() {
-                                d.restore(), this.__originalRestore();
-                            }, R.translate = function(f, v) {
-                                d.translate(f, v), this.__originalTranslate(f, v);
-                            }, R.scale = function(f, v) {
-                                d.scale(f, v), this.__originalScale(f, v);
-                            }, R.transform = function(f, v, A, O, H, z) {
-                                d.transform(f, v, A, O, H, z), this.__originalTransform(f, v, A, O, H, z);
-                            }, R.setTransform = function(f, v, A, O, H, z) {
-                                d.setTransform(f, v, A, O, H, z), this.__originalSetTransform(f, v, A, O, H, z);
-                            }, R.resetTransform = function() {
-                                d.resetTransform(), this.__originalResetTransform();
-                            }, R.rotate = function(f) {
-                                d.rotate(f), this.__originalRotate(f);
-                            }, R.clip = function(f) {
-                                d.clip(f), this.__originalClip(f);
-                            }, R.moveTo = function(g, f) {
-                                d.moveTo(g, f), this.__originalMoveTo(g, f);
-                            }, R.lineTo = function(g, f) {
-                                d.lineTo(g, f), this.__originalLineTo(g, f);
-                            }, R.bezierCurveTo = function(g, f, v, A, O, H) {
-                                d.bezierCurveTo(g, f, v, A, O, H), this.__originalBezierCurveTo(g, f, v, A, O, H);
-                            }, R.rect = function(g, f, v, A) {
-                                d.rect(g, f, v, A), this.__originalRect(g, f, v, A);
-                            }, R.closePath = function() {
-                                d.closePath(), this.__originalClosePath();
-                            }, R.beginPath = function() {
-                                d.beginPath(), this.__originalBeginPath();
+                            k.__originalSave = k.save, k.__originalRestore = k.restore, k.__originalRotate = k.rotate, k.__originalScale = k.scale, k.__originalTranslate = k.translate, k.__originalTransform = k.transform, k.__originalSetTransform = k.setTransform, k.__originalResetTransform = k.resetTransform, k.__originalClip = k.clip, k.__originalMoveTo = k.moveTo, k.__originalLineTo = k.lineTo, k.__originalBezierCurveTo = k.bezierCurveTo, k.__originalRect = k.rect, k.__originalClosePath = k.closePath, k.__originalBeginPath = k.beginPath, k._removeMirroring = () => {
+                                k.save = k.__originalSave, k.restore = k.__originalRestore, k.rotate = k.__originalRotate, k.scale = k.__originalScale, k.translate = k.__originalTranslate, k.transform = k.__originalTransform, k.setTransform = k.__originalSetTransform, k.resetTransform = k.__originalResetTransform, k.clip = k.__originalClip, k.moveTo = k.__originalMoveTo, k.lineTo = k.__originalLineTo, k.bezierCurveTo = k.__originalBezierCurveTo, k.rect = k.__originalRect, k.closePath = k.__originalClosePath, k.beginPath = k.__originalBeginPath, delete k._removeMirroring;
+                            }, k.save = function() {
+                                l.save(), this.__originalSave();
+                            }, k.restore = function() {
+                                l.restore(), this.__originalRestore();
+                            }, k.translate = function(d, b) {
+                                l.translate(d, b), this.__originalTranslate(d, b);
+                            }, k.scale = function(d, b) {
+                                l.scale(d, b), this.__originalScale(d, b);
+                            }, k.transform = function(d, b, y, O, B, z) {
+                                l.transform(d, b, y, O, B, z), this.__originalTransform(d, b, y, O, B, z);
+                            }, k.setTransform = function(d, b, y, O, B, z) {
+                                l.setTransform(d, b, y, O, B, z), this.__originalSetTransform(d, b, y, O, B, z);
+                            }, k.resetTransform = function() {
+                                l.resetTransform(), this.__originalResetTransform();
+                            }, k.rotate = function(d) {
+                                l.rotate(d), this.__originalRotate(d);
+                            }, k.clip = function(d) {
+                                l.clip(d), this.__originalClip(d);
+                            }, k.moveTo = function(u, d) {
+                                l.moveTo(u, d), this.__originalMoveTo(u, d);
+                            }, k.lineTo = function(u, d) {
+                                l.lineTo(u, d), this.__originalLineTo(u, d);
+                            }, k.bezierCurveTo = function(u, d, b, y, O, B) {
+                                l.bezierCurveTo(u, d, b, y, O, B), this.__originalBezierCurveTo(u, d, b, y, O, B);
+                            }, k.rect = function(u, d, b, y) {
+                                l.rect(u, d, b, y), this.__originalRect(u, d, b, y);
+                            }, k.closePath = function() {
+                                l.closePath(), this.__originalClosePath();
+                            }, k.beginPath = function() {
+                                l.beginPath(), this.__originalBeginPath();
                             };
                         }
                         class P {
-                            constructor(d) {
-                                this.canvasFactory = d, this.cache = /* @__PURE__ */ Object.create(null);
+                            constructor(l) {
+                                this.canvasFactory = l, this.cache = /* @__PURE__ */ Object.create(null);
                             }
-                            getCanvas(d, g, f) {
-                                let v;
-                                return this.cache[d] !== void 0 ? (v = this.cache[d], this.canvasFactory.reset(v, g, f)) : (v = this.canvasFactory.create(g, f), this.cache[d] = v), v;
+                            getCanvas(l, u, d) {
+                                let b;
+                                return this.cache[l] !== void 0 ? (b = this.cache[l], this.canvasFactory.reset(b, u, d)) : (b = this.canvasFactory.create(u, d), this.cache[l] = b), b;
                             }
-                            delete(d) {
-                                delete this.cache[d];
+                            delete(l) {
+                                delete this.cache[l];
                             }
                             clear() {
-                                for (const d in this.cache) {
-                                    const g = this.cache[d];
-                                    this.canvasFactory.destroy(g), delete this.cache[d];
+                                for (const l in this.cache) {
+                                    const u = this.cache[l];
+                                    this.canvasFactory.destroy(u), delete this.cache[l];
                                 }
                             }
                         }
 
-                        function b(R, d, g, f, v, A, O, H, z, ae) {
-                            const [Z, ce, ue, me, fe, Pe] = (0, s.getCurrentTransform)(R);
-                            if (ce === 0 && ue === 0) {
-                                const De = O * Z + fe,
-                                    _e = Math.round(De),
-                                    ie = H * me + Pe,
-                                    se = Math.round(ie),
-                                    ge = (O + z) * Z + fe,
-                                    Ce = Math.abs(Math.round(ge) - _e) || 1,
-                                    xe = (H + ae) * me + Pe,
-                                    He = Math.abs(Math.round(xe) - se) || 1;
-                                return R.setTransform(Math.sign(Z), 0, 0, Math.sign(me), _e, se), R.drawImage(d, g, f, v, A, 0, 0, Ce, He), R.setTransform(Z, ce, ue, me, fe, Pe), [Ce, He];
-                            }
-                            if (Z === 0 && me === 0) {
-                                const De = H * ue + fe,
-                                    _e = Math.round(De),
-                                    ie = O * ce + Pe,
-                                    se = Math.round(ie),
-                                    ge = (H + ae) * ue + fe,
-                                    Ce = Math.abs(Math.round(ge) - _e) || 1,
-                                    xe = (O + z) * ce + Pe,
-                                    He = Math.abs(Math.round(xe) - se) || 1;
-                                return R.setTransform(0, Math.sign(ce), Math.sign(ue), 0, _e, se), R.drawImage(d, g, f, v, A, 0, 0, He, Ce), R.setTransform(Z, ce, ue, me, fe, Pe), [He, Ce];
-                            }
-                            R.drawImage(d, g, f, v, A, O, H, z, ae);
-                            const Fe = Math.hypot(Z, ce),
-                                Ee = Math.hypot(ue, me);
-                            return [Fe * z, Ee * ae];
+                        function m(k, l, u, d, b, y, O, B, z, it) {
+                            const [Z, lt, ht, mt, ft, kt] = (0, s.getCurrentTransform)(k);
+                            if (lt === 0 && ht === 0) {
+                                const It = O * Z + ft,
+                                    _t = Math.round(It),
+                                    rt = B * mt + kt,
+                                    at = Math.round(rt),
+                                    pt = (O + z) * Z + ft,
+                                    Ct = Math.abs(Math.round(pt) - _t) || 1,
+                                    Tt = (B + it) * mt + kt,
+                                    Bt = Math.abs(Math.round(Tt) - at) || 1;
+                                return k.setTransform(Math.sign(Z), 0, 0, Math.sign(mt), _t, at), k.drawImage(l, u, d, b, y, 0, 0, Ct, Bt), k.setTransform(Z, lt, ht, mt, ft, kt), [Ct, Bt];
+                            }
+                            if (Z === 0 && mt === 0) {
+                                const It = B * ht + ft,
+                                    _t = Math.round(It),
+                                    rt = O * lt + kt,
+                                    at = Math.round(rt),
+                                    pt = (B + it) * ht + ft,
+                                    Ct = Math.abs(Math.round(pt) - _t) || 1,
+                                    Tt = (O + z) * lt + kt,
+                                    Bt = Math.abs(Math.round(Tt) - at) || 1;
+                                return k.setTransform(0, Math.sign(lt), Math.sign(ht), 0, _t, at), k.drawImage(l, u, d, b, y, 0, 0, Bt, Ct), k.setTransform(Z, lt, ht, mt, ft, kt), [Bt, Ct];
+                            }
+                            k.drawImage(l, u, d, b, y, O, B, z, it);
+                            const Rt = Math.hypot(Z, lt),
+                                St = Math.hypot(ht, mt);
+                            return [Rt * z, St * it];
                         }
 
-                        function k(R) {
+                        function C(k) {
                             const {
-                                width: d,
-                                height: g
-                            } = R;
-                            if (d > S || g > S)
+                                width: l,
+                                height: u
+                            } = k;
+                            if (l > R || u > R)
                                 return null;
-                            const f = 1e3,
-                                v = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]),
-                                A = d + 1;
-                            let O = new Uint8Array(A * (g + 1)),
-                                H, z, ae;
-                            const Z = d + 7 & -8;
-                            let ce = new Uint8Array(Z * g),
-                                ue = 0;
-                            for (const Ee of R.data) {
-                                let De = 128;
-                                for (; De > 0;)
-                                    ce[ue++] = Ee & De ? 0 : 255, De >>= 1;
-                            }
-                            let me = 0;
-                            for (ue = 0, ce[ue] !== 0 && (O[0] = 1, ++me), z = 1; z < d; z++)
-                                ce[ue] !== ce[ue + 1] && (O[z] = ce[ue] ? 2 : 1, ++me), ue++;
-                            for (ce[ue] !== 0 && (O[z] = 2, ++me), H = 1; H < g; H++) {
-                                ue = H * Z, ae = H * A, ce[ue - Z] !== ce[ue] && (O[ae] = ce[ue] ? 1 : 8, ++me);
-                                let Ee = (ce[ue] ? 4 : 0) + (ce[ue - Z] ? 8 : 0);
-                                for (z = 1; z < d; z++)
-                                    Ee = (Ee >> 2) + (ce[ue + 1] ? 4 : 0) + (ce[ue - Z + 1] ? 8 : 0), v[Ee] && (O[ae + z] = v[Ee], ++me), ue++;
-                                if (ce[ue - Z] !== ce[ue] && (O[ae + z] = ce[ue] ? 2 : 4, ++me), me > f)
+                            const d = 1e3,
+                                b = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]),
+                                y = l + 1;
+                            let O = new Uint8Array(y * (u + 1)),
+                                B, z, it;
+                            const Z = l + 7 & -8;
+                            let lt = new Uint8Array(Z * u),
+                                ht = 0;
+                            for (const St of k.data) {
+                                let It = 128;
+                                for (; It > 0;)
+                                    lt[ht++] = St & It ? 0 : 255, It >>= 1;
+                            }
+                            let mt = 0;
+                            for (ht = 0, lt[ht] !== 0 && (O[0] = 1, ++mt), z = 1; z < l; z++)
+                                lt[ht] !== lt[ht + 1] && (O[z] = lt[ht] ? 2 : 1, ++mt), ht++;
+                            for (lt[ht] !== 0 && (O[z] = 2, ++mt), B = 1; B < u; B++) {
+                                ht = B * Z, it = B * y, lt[ht - Z] !== lt[ht] && (O[it] = lt[ht] ? 1 : 8, ++mt);
+                                let St = (lt[ht] ? 4 : 0) + (lt[ht - Z] ? 8 : 0);
+                                for (z = 1; z < l; z++)
+                                    St = (St >> 2) + (lt[ht + 1] ? 4 : 0) + (lt[ht - Z + 1] ? 8 : 0), b[St] && (O[it + z] = b[St], ++mt), ht++;
+                                if (lt[ht - Z] !== lt[ht] && (O[it + z] = lt[ht] ? 2 : 4, ++mt), mt > d)
                                     return null;
                             }
-                            for (ue = Z * (g - 1), ae = H * A, ce[ue] !== 0 && (O[ae] = 8, ++me), z = 1; z < d; z++)
-                                ce[ue] !== ce[ue + 1] && (O[ae + z] = ce[ue] ? 4 : 8, ++me), ue++;
-                            if (ce[ue] !== 0 && (O[ae + z] = 4, ++me), me > f)
+                            for (ht = Z * (u - 1), it = B * y, lt[ht] !== 0 && (O[it] = 8, ++mt), z = 1; z < l; z++)
+                                lt[ht] !== lt[ht + 1] && (O[it + z] = lt[ht] ? 4 : 8, ++mt), ht++;
+                            if (lt[ht] !== 0 && (O[it + z] = 4, ++mt), mt > d)
                                 return null;
-                            const fe = new Int32Array([0, A, -1, 0, -A, 0, 0, 0, 1]),
-                                Pe = new Path2D();
-                            for (H = 0; me && H <= g; H++) {
-                                let Ee = H * A;
-                                const De = Ee + d;
-                                for (; Ee < De && !O[Ee];)
-                                    Ee++;
-                                if (Ee === De)
+                            const ft = new Int32Array([0, y, -1, 0, -y, 0, 0, 0, 1]),
+                                kt = new Path2D();
+                            for (B = 0; mt && B <= u; B++) {
+                                let St = B * y;
+                                const It = St + l;
+                                for (; St < It && !O[St];)
+                                    St++;
+                                if (St === It)
                                     continue;
-                                Pe.moveTo(Ee % A, H);
-                                const _e = Ee;
-                                let ie = O[Ee];
+                                kt.moveTo(St % y, B);
+                                const _t = St;
+                                let rt = O[St];
                                 do {
-                                    const se = fe[ie];
+                                    const at = ft[rt];
                                     do
-                                        Ee += se;
-                                    while (!O[Ee]);
-                                    const ge = O[Ee];
-                                    ge !== 5 && ge !== 10 ? (ie = ge, O[Ee] = 0) : (ie = ge & 51 * ie >> 4, O[Ee] &= ie >> 2 | ie << 2), Pe.lineTo(Ee % A, Ee / A | 0), O[Ee] || --me;
-                                } while (_e !== Ee);
-                                --H;
-                            }
-                            return ce = null, O = null,
-                                function(Ee) {
-                                    Ee.save(), Ee.scale(1 / d, -1 / g), Ee.translate(0, -g), Ee.fill(Pe), Ee.beginPath(), Ee.restore();
+                                        St += at;
+                                    while (!O[St]);
+                                    const pt = O[St];
+                                    pt !== 5 && pt !== 10 ? (rt = pt, O[St] = 0) : (rt = pt & 51 * rt >> 4, O[St] &= rt >> 2 | rt << 2), kt.lineTo(St % y, St / y | 0), O[St] || --mt;
+                                } while (_t !== St);
+                                --B;
+                            }
+                            return lt = null, O = null,
+                                function(St) {
+                                    St.save(), St.scale(1 / l, -1 / u), St.translate(0, -u), St.fill(kt), St.beginPath(), St.restore();
                                 };
                         }
-                        class F {
-                            constructor(d, g) {
-                                this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = n.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = n.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = n.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, d, g]);
+                        class x {
+                            constructor(l, u) {
+                                this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = e.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = e.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = e.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, l, u]);
                             }
                             clone() {
-                                const d = Object.create(this);
-                                return d.clipBox = this.clipBox.slice(), d;
+                                const l = Object.create(this);
+                                return l.clipBox = this.clipBox.slice(), l;
                             }
-                            setCurrentPoint(d, g) {
-                                this.x = d, this.y = g;
+                            setCurrentPoint(l, u) {
+                                this.x = l, this.y = u;
                             }
-                            updatePathMinMax(d, g, f) {
-                                [g, f] = n.Util.applyTransform([g, f], d), this.minX = Math.min(this.minX, g), this.minY = Math.min(this.minY, f), this.maxX = Math.max(this.maxX, g), this.maxY = Math.max(this.maxY, f);
+                            updatePathMinMax(l, u, d) {
+                                [u, d] = e.Util.applyTransform([u, d], l), this.minX = Math.min(this.minX, u), this.minY = Math.min(this.minY, d), this.maxX = Math.max(this.maxX, u), this.maxY = Math.max(this.maxY, d);
                             }
-                            updateRectMinMax(d, g) {
-                                const f = n.Util.applyTransform(g, d),
-                                    v = n.Util.applyTransform(g.slice(2), d);
-                                this.minX = Math.min(this.minX, f[0], v[0]), this.minY = Math.min(this.minY, f[1], v[1]), this.maxX = Math.max(this.maxX, f[0], v[0]), this.maxY = Math.max(this.maxY, f[1], v[1]);
+                            updateRectMinMax(l, u) {
+                                const d = e.Util.applyTransform(u, l),
+                                    b = e.Util.applyTransform(u.slice(2), l);
+                                this.minX = Math.min(this.minX, d[0], b[0]), this.minY = Math.min(this.minY, d[1], b[1]), this.maxX = Math.max(this.maxX, d[0], b[0]), this.maxY = Math.max(this.maxY, d[1], b[1]);
                             }
-                            updateScalingPathMinMax(d, g) {
-                                n.Util.scaleMinMax(d, g), this.minX = Math.min(this.minX, g[0]), this.maxX = Math.max(this.maxX, g[1]), this.minY = Math.min(this.minY, g[2]), this.maxY = Math.max(this.maxY, g[3]);
+                            updateScalingPathMinMax(l, u) {
+                                e.Util.scaleMinMax(l, u), this.minX = Math.min(this.minX, u[0]), this.maxX = Math.max(this.maxX, u[1]), this.minY = Math.min(this.minY, u[2]), this.maxY = Math.max(this.maxY, u[3]);
                             }
-                            updateCurvePathMinMax(d, g, f, v, A, O, H, z, ae, Z) {
-                                const ce = n.Util.bezierBoundingBox(g, f, v, A, O, H, z, ae);
+                            updateCurvePathMinMax(l, u, d, b, y, O, B, z, it, Z) {
+                                const lt = e.Util.bezierBoundingBox(u, d, b, y, O, B, z, it);
                                 if (Z) {
-                                    Z[0] = Math.min(Z[0], ce[0], ce[2]), Z[1] = Math.max(Z[1], ce[0], ce[2]), Z[2] = Math.min(Z[2], ce[1], ce[3]), Z[3] = Math.max(Z[3], ce[1], ce[3]);
+                                    Z[0] = Math.min(Z[0], lt[0], lt[2]), Z[1] = Math.max(Z[1], lt[0], lt[2]), Z[2] = Math.min(Z[2], lt[1], lt[3]), Z[3] = Math.max(Z[3], lt[1], lt[3]);
                                     return;
                                 }
-                                this.updateRectMinMax(d, ce);
+                                this.updateRectMinMax(l, lt);
                             }
-                            getPathBoundingBox(d = l.PathType.FILL, g = null) {
-                                const f = [this.minX, this.minY, this.maxX, this.maxY];
-                                if (d === l.PathType.STROKE) {
-                                    g || (0, n.unreachable)("Stroke bounding box must include transform.");
-                                    const v = n.Util.singularValueDecompose2dScale(g),
-                                        A = v[0] * this.lineWidth / 2,
-                                        O = v[1] * this.lineWidth / 2;
-                                    f[0] -= A, f[1] -= O, f[2] += A, f[3] += O;
+                            getPathBoundingBox(l = p.PathType.FILL, u = null) {
+                                const d = [this.minX, this.minY, this.maxX, this.maxY];
+                                if (l === p.PathType.STROKE) {
+                                    u || (0, e.unreachable)("Stroke bounding box must include transform.");
+                                    const b = e.Util.singularValueDecompose2dScale(u),
+                                        y = b[0] * this.lineWidth / 2,
+                                        O = b[1] * this.lineWidth / 2;
+                                    d[0] -= y, d[1] -= O, d[2] += y, d[3] += O;
                                 }
-                                return f;
+                                return d;
                             }
                             updateClipFromPath() {
-                                const d = n.Util.intersect(this.clipBox, this.getPathBoundingBox());
-                                this.startNewPathAndClipBox(d || [0, 0, 0, 0]);
+                                const l = e.Util.intersect(this.clipBox, this.getPathBoundingBox());
+                                this.startNewPathAndClipBox(l || [0, 0, 0, 0]);
                             }
                             isEmptyClip() {
                                 return this.minX === 1 / 0;
                             }
-                            startNewPathAndClipBox(d) {
-                                this.clipBox = d, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
+                            startNewPathAndClipBox(l) {
+                                this.clipBox = l, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
                             }
-                            getClippedPathBoundingBox(d = l.PathType.FILL, g = null) {
-                                return n.Util.intersect(this.clipBox, this.getPathBoundingBox(d, g));
+                            getClippedPathBoundingBox(l = p.PathType.FILL, u = null) {
+                                return e.Util.intersect(this.clipBox, this.getPathBoundingBox(l, u));
                             }
                         }
 
-                        function x(R, d) {
-                            if (typeof ImageData < "u" && d instanceof ImageData) {
-                                R.putImageData(d, 0, 0);
+                        function E(k, l) {
+                            if (typeof ImageData < "u" && l instanceof ImageData) {
+                                k.putImageData(l, 0, 0);
                                 return;
                             }
-                            const g = d.height,
-                                f = d.width,
-                                v = g % w,
-                                A = (g - v) / w,
-                                O = v === 0 ? A : A + 1,
-                                H = R.createImageData(f, w);
+                            const u = l.height,
+                                d = l.width,
+                                b = u % w,
+                                y = (u - b) / w,
+                                O = b === 0 ? y : y + 1,
+                                B = k.createImageData(d, w);
                             let z = 0,
-                                ae;
-                            const Z = d.data,
-                                ce = H.data;
-                            let ue, me, fe, Pe;
-                            if (d.kind === n.ImageKind.GRAYSCALE_1BPP) {
-                                const Fe = Z.byteLength,
-                                    Ee = new Uint32Array(ce.buffer, 0, ce.byteLength >> 2),
-                                    De = Ee.length,
-                                    _e = f + 7 >> 3,
-                                    ie = 4294967295,
-                                    se = n.FeatureTest.isLittleEndian ? 4278190080 : 255;
-                                for (ue = 0; ue < O; ue++) {
-                                    for (fe = ue < A ? w : v, ae = 0, me = 0; me < fe; me++) {
-                                        const ge = Fe - z;
-                                        let Ce = 0;
-                                        const xe = ge > _e ? f : ge * 8 - 7,
-                                            He = xe & -8;
-                                        let We = 0,
-                                            je = 0;
-                                        for (; Ce < He; Ce += 8)
-                                            je = Z[z++], Ee[ae++] = je & 128 ? ie : se, Ee[ae++] = je & 64 ? ie : se, Ee[ae++] = je & 32 ? ie : se, Ee[ae++] = je & 16 ? ie : se, Ee[ae++] = je & 8 ? ie : se, Ee[ae++] = je & 4 ? ie : se, Ee[ae++] = je & 2 ? ie : se, Ee[ae++] = je & 1 ? ie : se;
-                                        for (; Ce < xe; Ce++)
-                                            We === 0 && (je = Z[z++], We = 128), Ee[ae++] = je & We ? ie : se, We >>= 1;
-                                    }
-                                    for (; ae < De;)
-                                        Ee[ae++] = 0;
-                                    R.putImageData(H, 0, ue * w);
-                                }
-                            } else if (d.kind === n.ImageKind.RGBA_32BPP) {
-                                for (me = 0, Pe = f * w * 4, ue = 0; ue < A; ue++)
-                                    ce.set(Z.subarray(z, z + Pe)), z += Pe, R.putImageData(H, 0, me), me += w;
-                                ue < O && (Pe = f * v * 4, ce.set(Z.subarray(z, z + Pe)), R.putImageData(H, 0, me));
-                            } else if (d.kind === n.ImageKind.RGB_24BPP)
-                                for (fe = w, Pe = f * fe, ue = 0; ue < O; ue++) {
-                                    for (ue >= A && (fe = v, Pe = f * fe), ae = 0, me = Pe; me--;)
-                                        ce[ae++] = Z[z++], ce[ae++] = Z[z++], ce[ae++] = Z[z++], ce[ae++] = 255;
-                                    R.putImageData(H, 0, ue * w);
+                                it;
+                            const Z = l.data,
+                                lt = B.data;
+                            let ht, mt, ft, kt;
+                            if (l.kind === e.ImageKind.GRAYSCALE_1BPP) {
+                                const Rt = Z.byteLength,
+                                    St = new Uint32Array(lt.buffer, 0, lt.byteLength >> 2),
+                                    It = St.length,
+                                    _t = d + 7 >> 3,
+                                    rt = 4294967295,
+                                    at = e.FeatureTest.isLittleEndian ? 4278190080 : 255;
+                                for (ht = 0; ht < O; ht++) {
+                                    for (ft = ht < y ? w : b, it = 0, mt = 0; mt < ft; mt++) {
+                                        const pt = Rt - z;
+                                        let Ct = 0;
+                                        const Tt = pt > _t ? d : pt * 8 - 7,
+                                            Bt = Tt & -8;
+                                        let Wt = 0,
+                                            jt = 0;
+                                        for (; Ct < Bt; Ct += 8)
+                                            jt = Z[z++], St[it++] = jt & 128 ? rt : at, St[it++] = jt & 64 ? rt : at, St[it++] = jt & 32 ? rt : at, St[it++] = jt & 16 ? rt : at, St[it++] = jt & 8 ? rt : at, St[it++] = jt & 4 ? rt : at, St[it++] = jt & 2 ? rt : at, St[it++] = jt & 1 ? rt : at;
+                                        for (; Ct < Tt; Ct++)
+                                            Wt === 0 && (jt = Z[z++], Wt = 128), St[it++] = jt & Wt ? rt : at, Wt >>= 1;
+                                    }
+                                    for (; it < It;)
+                                        St[it++] = 0;
+                                    k.putImageData(B, 0, ht * w);
+                                }
+                            } else if (l.kind === e.ImageKind.RGBA_32BPP) {
+                                for (mt = 0, kt = d * w * 4, ht = 0; ht < y; ht++)
+                                    lt.set(Z.subarray(z, z + kt)), z += kt, k.putImageData(B, 0, mt), mt += w;
+                                ht < O && (kt = d * b * 4, lt.set(Z.subarray(z, z + kt)), k.putImageData(B, 0, mt));
+                            } else if (l.kind === e.ImageKind.RGB_24BPP)
+                                for (ft = w, kt = d * ft, ht = 0; ht < O; ht++) {
+                                    for (ht >= y && (ft = b, kt = d * ft), it = 0, mt = kt; mt--;)
+                                        lt[it++] = Z[z++], lt[it++] = Z[z++], lt[it++] = Z[z++], lt[it++] = 255;
+                                    k.putImageData(B, 0, ht * w);
                                 }
                             else
-                                throw new Error(`bad image kind: ${d.kind}`);
+                                throw new Error(`bad image kind: ${l.kind}`);
                         }
 
-                        function y(R, d) {
-                            if (d.bitmap) {
-                                R.drawImage(d.bitmap, 0, 0);
+                        function S(k, l) {
+                            if (l.bitmap) {
+                                k.drawImage(l.bitmap, 0, 0);
                                 return;
                             }
-                            const g = d.height,
-                                f = d.width,
-                                v = g % w,
-                                A = (g - v) / w,
-                                O = v === 0 ? A : A + 1,
-                                H = R.createImageData(f, w);
+                            const u = l.height,
+                                d = l.width,
+                                b = u % w,
+                                y = (u - b) / w,
+                                O = b === 0 ? y : y + 1,
+                                B = k.createImageData(d, w);
                             let z = 0;
-                            const ae = d.data,
-                                Z = H.data;
-                            for (let ce = 0; ce < O; ce++) {
-                                const ue = ce < A ? w : v;
+                            const it = l.data,
+                                Z = B.data;
+                            for (let lt = 0; lt < O; lt++) {
+                                const ht = lt < y ? w : b;
                                 ({
                                     srcPos: z
-                                } = (0, h.convertBlackAndWhiteToRGBA)({
-                                    src: ae,
+                                } = (0, f.convertBlackAndWhiteToRGBA)({
+                                    src: it,
                                     srcPos: z,
                                     dest: Z,
-                                    width: f,
-                                    height: ue,
+                                    width: d,
+                                    height: ht,
                                     nonBlackColor: 0
-                                })), R.putImageData(H, 0, ce * w);
+                                })), k.putImageData(B, 0, lt * w);
                             }
                         }
 
-                        function p(R, d) {
-                            const g = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
-                            for (const f of g)
-                                R[f] !== void 0 && (d[f] = R[f]);
-                            R.setLineDash !== void 0 && (d.setLineDash(R.getLineDash()), d.lineDashOffset = R.lineDashOffset);
+                        function g(k, l) {
+                            const u = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
+                            for (const d of u)
+                                k[d] !== void 0 && (l[d] = k[d]);
+                            k.setLineDash !== void 0 && (l.setLineDash(k.getLineDash()), l.lineDashOffset = k.lineDashOffset);
                         }
 
-                        function E(R) {
-                            if (R.strokeStyle = R.fillStyle = "#000000", R.fillRule = "nonzero", R.globalAlpha = 1, R.lineWidth = 1, R.lineCap = "butt", R.lineJoin = "miter", R.miterLimit = 10, R.globalCompositeOperation = "source-over", R.font = "10px sans-serif", R.setLineDash !== void 0 && (R.setLineDash([]), R.lineDashOffset = 0), !n.isNodeJS) {
+                        function v(k) {
+                            if (k.strokeStyle = k.fillStyle = "#000000", k.fillRule = "nonzero", k.globalAlpha = 1, k.lineWidth = 1, k.lineCap = "butt", k.lineJoin = "miter", k.miterLimit = 10, k.globalCompositeOperation = "source-over", k.font = "10px sans-serif", k.setLineDash !== void 0 && (k.setLineDash([]), k.lineDashOffset = 0), !e.isNodeJS) {
                                 const {
-                                    filter: d
-                                } = R;
-                                d !== "none" && d !== "" && (R.filter = "none");
+                                    filter: l
+                                } = k;
+                                l !== "none" && l !== "" && (k.filter = "none");
                             }
                         }
 
-                        function $(R, d, g, f) {
-                            const v = R.length;
-                            for (let A = 3; A < v; A += 4) {
-                                const O = R[A];
+                        function $(k, l, u, d) {
+                            const b = k.length;
+                            for (let y = 3; y < b; y += 4) {
+                                const O = k[y];
                                 if (O === 0)
-                                    R[A - 3] = d, R[A - 2] = g, R[A - 1] = f;
+                                    k[y - 3] = l, k[y - 2] = u, k[y - 1] = d;
                                 else if (O < 255) {
-                                    const H = 255 - O;
-                                    R[A - 3] = R[A - 3] * O + d * H >> 8, R[A - 2] = R[A - 2] * O + g * H >> 8, R[A - 1] = R[A - 1] * O + f * H >> 8;
+                                    const B = 255 - O;
+                                    k[y - 3] = k[y - 3] * O + l * B >> 8, k[y - 2] = k[y - 2] * O + u * B >> 8, k[y - 1] = k[y - 1] * O + d * B >> 8;
                                 }
                             }
                         }
 
-                        function M(R, d, g) {
-                            const f = R.length,
-                                v = 1 / 255;
-                            for (let A = 3; A < f; A += 4) {
-                                const O = g ? g[R[A]] : R[A];
-                                d[A] = d[A] * O * v | 0;
+                        function M(k, l, u) {
+                            const d = k.length,
+                                b = 1 / 255;
+                            for (let y = 3; y < d; y += 4) {
+                                const O = u ? u[k[y]] : k[y];
+                                l[y] = l[y] * O * b | 0;
                             }
                         }
 
-                        function m(R, d, g) {
-                            const f = R.length;
-                            for (let v = 3; v < f; v += 4) {
-                                const A = R[v - 3] * 77 + R[v - 2] * 152 + R[v - 1] * 28;
-                                d[v] = g ? d[v] * g[A >> 8] >> 8 : d[v] * A >> 16;
+                        function _(k, l, u) {
+                            const d = k.length;
+                            for (let b = 3; b < d; b += 4) {
+                                const y = k[b - 3] * 77 + k[b - 2] * 152 + k[b - 1] * 28;
+                                l[b] = u ? l[b] * u[y >> 8] >> 8 : l[b] * y >> 16;
                             }
                         }
 
-                        function N(R, d, g, f, v, A, O, H, z, ae, Z) {
-                            const ce = !!A,
-                                ue = ce ? A[0] : 0,
-                                me = ce ? A[1] : 0,
-                                fe = ce ? A[2] : 0,
-                                Pe = v === "Luminosity" ? m : M,
-                                Ee = Math.min(f, Math.ceil(1048576 / g));
-                            for (let De = 0; De < f; De += Ee) {
-                                const _e = Math.min(Ee, f - De),
-                                    ie = R.getImageData(H - ae, De + (z - Z), g, _e),
-                                    se = d.getImageData(H, De + z, g, _e);
-                                ce && $(ie.data, ue, me, fe), Pe(ie.data, se.data, O), d.putImageData(se, H, De + z);
+                        function N(k, l, u, d, b, y, O, B, z, it, Z) {
+                            const lt = !!y,
+                                ht = lt ? y[0] : 0,
+                                mt = lt ? y[1] : 0,
+                                ft = lt ? y[2] : 0,
+                                kt = b === "Luminosity" ? _ : M,
+                                St = Math.min(d, Math.ceil(1048576 / u));
+                            for (let It = 0; It < d; It += St) {
+                                const _t = Math.min(St, d - It),
+                                    rt = k.getImageData(B - it, It + (z - Z), u, _t),
+                                    at = l.getImageData(B, It + z, u, _t);
+                                lt && $(rt.data, ht, mt, ft), kt(rt.data, at.data, O), l.putImageData(at, B, It + z);
                             }
                         }
 
-                        function D(R, d, g, f) {
-                            const v = f[0],
-                                A = f[1],
-                                O = f[2] - v,
-                                H = f[3] - A;
-                            O === 0 || H === 0 || (N(d.context, g, O, H, d.subtype, d.backdrop, d.transferMap, v, A, d.offsetX, d.offsetY), R.save(), R.globalAlpha = 1, R.globalCompositeOperation = "source-over", R.setTransform(1, 0, 0, 1, 0, 0), R.drawImage(g.canvas, 0, 0), R.restore());
+                        function D(k, l, u, d) {
+                            const b = d[0],
+                                y = d[1],
+                                O = d[2] - b,
+                                B = d[3] - y;
+                            O === 0 || B === 0 || (N(l.context, u, O, B, l.subtype, l.backdrop, l.transferMap, b, y, l.offsetX, l.offsetY), k.save(), k.globalAlpha = 1, k.globalCompositeOperation = "source-over", k.setTransform(1, 0, 0, 1, 0, 0), k.drawImage(u.canvas, 0, 0), k.restore());
                         }
 
-                        function X(R, d) {
-                            const g = n.Util.singularValueDecompose2dScale(R);
-                            g[0] = Math.fround(g[0]), g[1] = Math.fround(g[1]);
-                            const f = Math.fround((globalThis.devicePixelRatio || 1) * s.PixelsPerInch.PDF_TO_CSS_UNITS);
-                            return d !== void 0 ? d : g[0] <= f || g[1] <= f;
+                        function X(k, l) {
+                            const u = e.Util.singularValueDecompose2dScale(k);
+                            u[0] = Math.fround(u[0]), u[1] = Math.fround(u[1]);
+                            const d = Math.fround((globalThis.devicePixelRatio || 1) * s.PixelsPerInch.PDF_TO_CSS_UNITS);
+                            return l !== void 0 ? l : u[0] <= d || u[1] <= d;
                         }
-                        const G = ["butt", "round", "square"],
+                        const Y = ["butt", "round", "square"],
                             I = ["miter", "round", "bevel"],
-                            B = {},
-                            ee = {},
-                            be = class be {
-                                constructor(d, g, f, v, A, {
+                            U = {},
+                            G = {},
+                            gt = class gt {
+                                constructor(l, u, d, b, y, {
                                     optionalContentConfig: O,
-                                    markedContentStack: H = null
-                                }, z, ae) {
-                                    W(this, q);
-                                    W(this, pe);
-                                    this.ctx = d, this.current = new F(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = g, this.objs = f, this.canvasFactory = v, this.filterFactory = A, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = H || [], this.optionalContentConfig = O, this.cachedCanvases = new P(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = z, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = ae, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
+                                    markedContentStack: B = null
+                                }, z, it) {
+                                    W(this, H);
+                                    W(this, dt);
+                                    this.ctx = l, this.current = new x(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = u, this.objs = d, this.canvasFactory = b, this.filterFactory = y, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = B || [], this.optionalContentConfig = O, this.cachedCanvases = new P(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = z, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = it, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
                                 }
-                                getObject(d, g = null) {
-                                    return typeof d == "string" ? d.startsWith("g_") ? this.commonObjs.get(d) : this.objs.get(d) : g;
+                                getObject(l, u = null) {
+                                    return typeof l == "string" ? l.startsWith("g_") ? this.commonObjs.get(l) : this.objs.get(l) : u;
                                 }
                                 beginDrawing({
-                                    transform: d,
-                                    viewport: g,
-                                    transparency: f = !1,
-                                    background: v = null
+                                    transform: l,
+                                    viewport: u,
+                                    transparency: d = !1,
+                                    background: b = null
                                 }) {
-                                    const A = this.ctx.canvas.width,
+                                    const y = this.ctx.canvas.width,
                                         O = this.ctx.canvas.height,
-                                        H = this.ctx.fillStyle;
-                                    if (this.ctx.fillStyle = v || "#ffffff", this.ctx.fillRect(0, 0, A, O), this.ctx.fillStyle = H, f) {
-                                        const z = this.cachedCanvases.getCanvas("transparent", A, O);
+                                        B = this.ctx.fillStyle;
+                                    if (this.ctx.fillStyle = b || "#ffffff", this.ctx.fillRect(0, 0, y, O), this.ctx.fillStyle = B, d) {
+                                        const z = this.cachedCanvases.getCanvas("transparent", y, O);
                                         this.compositeCtx = this.ctx, this.transparentCanvas = z.canvas, this.ctx = z.context, this.ctx.save(), this.ctx.transform(...(0, s.getCurrentTransform)(this.compositeCtx));
                                     }
-                                    this.ctx.save(), E(this.ctx), d && (this.ctx.transform(...d), this.outputScaleX = d[0], this.outputScaleY = d[0]), this.ctx.transform(...g.transform), this.viewportScale = g.scale, this.baseTransform = (0, s.getCurrentTransform)(this.ctx);
+                                    this.ctx.save(), v(this.ctx), l && (this.ctx.transform(...l), this.outputScaleX = l[0], this.outputScaleY = l[0]), this.ctx.transform(...u.transform), this.viewportScale = u.scale, this.baseTransform = (0, s.getCurrentTransform)(this.ctx);
                                 }
-                                executeOperatorList(d, g, f, v) {
-                                    const A = d.argsArray,
-                                        O = d.fnArray;
-                                    let H = g || 0;
-                                    const z = A.length;
-                                    if (z === H)
-                                        return H;
-                                    const ae = z - H > T && typeof f == "function",
-                                        Z = ae ? Date.now() + r : 0;
-                                    let ce = 0;
-                                    const ue = this.commonObjs,
-                                        me = this.objs;
-                                    let fe;
+                                executeOperatorList(l, u, d, b) {
+                                    const y = l.argsArray,
+                                        O = l.fnArray;
+                                    let B = u || 0;
+                                    const z = y.length;
+                                    if (z === B)
+                                        return B;
+                                    const it = z - B > F && typeof d == "function",
+                                        Z = it ? Date.now() + o : 0;
+                                    let lt = 0;
+                                    const ht = this.commonObjs,
+                                        mt = this.objs;
+                                    let ft;
                                     for (;;) {
-                                        if (v !== void 0 && H === v.nextBreakPoint)
-                                            return v.breakIt(H, f), H;
-                                        if (fe = O[H], fe !== n.OPS.dependency)
-                                            this[fe].apply(this, A[H]);
+                                        if (b !== void 0 && B === b.nextBreakPoint)
+                                            return b.breakIt(B, d), B;
+                                        if (ft = O[B], ft !== e.OPS.dependency)
+                                            this[ft].apply(this, y[B]);
                                         else
-                                            for (const Pe of A[H]) {
-                                                const Fe = Pe.startsWith("g_") ? ue : me;
-                                                if (!Fe.has(Pe))
-                                                    return Fe.get(Pe, f), H;
+                                            for (const kt of y[B]) {
+                                                const Rt = kt.startsWith("g_") ? ht : mt;
+                                                if (!Rt.has(kt))
+                                                    return Rt.get(kt, d), B;
                                             }
-                                        if (H++, H === z)
-                                            return H;
-                                        if (ae && ++ce > T) {
+                                        if (B++, B === z)
+                                            return B;
+                                        if (it && ++lt > F) {
                                             if (Date.now() > Z)
-                                                return f(), H;
-                                            ce = 0;
+                                                return d(), B;
+                                            lt = 0;
                                         }
                                     }
                                 }
                                 endDrawing() {
-                                    K(this, q, Qt).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
-                                    for (const d of this._cachedBitmapsMap.values()) {
-                                        for (const g of d.values())
-                                            typeof HTMLCanvasElement < "u" && g instanceof HTMLCanvasElement && (g.width = g.height = 0);
-                                        d.clear();
-                                    }
-                                    this._cachedBitmapsMap.clear(), K(this, pe, en).call(this);
-                                }
-                                _scaleImage(d, g) {
-                                    const f = d.width,
-                                        v = d.height;
-                                    let A = Math.max(Math.hypot(g[0], g[1]), 1),
-                                        O = Math.max(Math.hypot(g[2], g[3]), 1),
-                                        H = f,
-                                        z = v,
-                                        ae = "prescale1",
-                                        Z, ce;
-                                    for (; A > 2 && H > 1 || O > 2 && z > 1;) {
-                                        let ue = H,
-                                            me = z;
-                                        A > 2 && H > 1 && (ue = H >= 16384 ? Math.floor(H / 2) - 1 || 1 : Math.ceil(H / 2), A /= H / ue), O > 2 && z > 1 && (me = z >= 16384 ? Math.floor(z / 2) - 1 || 1 : Math.ceil(z) / 2, O /= z / me), Z = this.cachedCanvases.getCanvas(ae, ue, me), ce = Z.context, ce.clearRect(0, 0, ue, me), ce.drawImage(d, 0, 0, H, z, 0, 0, ue, me), d = Z.canvas, H = ue, z = me, ae = ae === "prescale1" ? "prescale2" : "prescale1";
+                                    J(this, H, Ze).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
+                                    for (const l of this._cachedBitmapsMap.values()) {
+                                        for (const u of l.values())
+                                            typeof HTMLCanvasElement < "u" && u instanceof HTMLCanvasElement && (u.width = u.height = 0);
+                                        l.clear();
+                                    }
+                                    this._cachedBitmapsMap.clear(), J(this, dt, Qe).call(this);
+                                }
+                                _scaleImage(l, u) {
+                                    const d = l.width,
+                                        b = l.height;
+                                    let y = Math.max(Math.hypot(u[0], u[1]), 1),
+                                        O = Math.max(Math.hypot(u[2], u[3]), 1),
+                                        B = d,
+                                        z = b,
+                                        it = "prescale1",
+                                        Z, lt;
+                                    for (; y > 2 && B > 1 || O > 2 && z > 1;) {
+                                        let ht = B,
+                                            mt = z;
+                                        y > 2 && B > 1 && (ht = B >= 16384 ? Math.floor(B / 2) - 1 || 1 : Math.ceil(B / 2), y /= B / ht), O > 2 && z > 1 && (mt = z >= 16384 ? Math.floor(z / 2) - 1 || 1 : Math.ceil(z) / 2, O /= z / mt), Z = this.cachedCanvases.getCanvas(it, ht, mt), lt = Z.context, lt.clearRect(0, 0, ht, mt), lt.drawImage(l, 0, 0, B, z, 0, 0, ht, mt), l = Z.canvas, B = ht, z = mt, it = it === "prescale1" ? "prescale2" : "prescale1";
                                     }
                                     return {
-                                        img: d,
-                                        paintWidth: H,
+                                        img: l,
+                                        paintWidth: B,
                                         paintHeight: z
                                     };
                                 }
-                                _createMaskCanvas(d) {
-                                    const g = this.ctx,
+                                _createMaskCanvas(l) {
+                                    const u = this.ctx,
                                         {
-                                            width: f,
-                                            height: v
-                                        } = d,
-                                        A = this.current.fillColor,
+                                            width: d,
+                                            height: b
+                                        } = l,
+                                        y = this.current.fillColor,
                                         O = this.current.patternFill,
-                                        H = (0, s.getCurrentTransform)(g);
-                                    let z, ae, Z, ce;
-                                    if ((d.bitmap || d.data) && d.count > 1) {
-                                        const Ce = d.bitmap || d.data.buffer;
-                                        ae = JSON.stringify(O ? H : [H.slice(0, 4), A]), z = this._cachedBitmapsMap.get(Ce), z || (z = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(Ce, z));
-                                        const xe = z.get(ae);
-                                        if (xe && !O) {
-                                            const He = Math.round(Math.min(H[0], H[2]) + H[4]),
-                                                We = Math.round(Math.min(H[1], H[3]) + H[5]);
+                                        B = (0, s.getCurrentTransform)(u);
+                                    let z, it, Z, lt;
+                                    if ((l.bitmap || l.data) && l.count > 1) {
+                                        const Ct = l.bitmap || l.data.buffer;
+                                        it = JSON.stringify(O ? B : [B.slice(0, 4), y]), z = this._cachedBitmapsMap.get(Ct), z || (z = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(Ct, z));
+                                        const Tt = z.get(it);
+                                        if (Tt && !O) {
+                                            const Bt = Math.round(Math.min(B[0], B[2]) + B[4]),
+                                                Wt = Math.round(Math.min(B[1], B[3]) + B[5]);
                                             return {
-                                                canvas: xe,
-                                                offsetX: He,
-                                                offsetY: We
+                                                canvas: Tt,
+                                                offsetX: Bt,
+                                                offsetY: Wt
                                             };
                                         }
-                                        Z = xe;
+                                        Z = Tt;
                                     }
-                                    Z || (ce = this.cachedCanvases.getCanvas("maskCanvas", f, v), y(ce.context, d));
-                                    let ue = n.Util.transform(H, [1 / f, 0, 0, -1 / v, 0, 0]);
-                                    ue = n.Util.transform(ue, [1, 0, 0, 1, 0, -v]);
-                                    const me = n.Util.applyTransform([0, 0], ue),
-                                        fe = n.Util.applyTransform([f, v], ue),
-                                        Pe = n.Util.normalizeRect([me[0], me[1], fe[0], fe[1]]),
-                                        Fe = Math.round(Pe[2] - Pe[0]) || 1,
-                                        Ee = Math.round(Pe[3] - Pe[1]) || 1,
-                                        De = this.cachedCanvases.getCanvas("fillCanvas", Fe, Ee),
-                                        _e = De.context,
-                                        ie = Math.min(me[0], fe[0]),
-                                        se = Math.min(me[1], fe[1]);
-                                    _e.translate(-ie, -se), _e.transform(...ue), Z || (Z = this._scaleImage(ce.canvas, (0, s.getCurrentTransformInverse)(_e)), Z = Z.img, z && O && z.set(ae, Z)), _e.imageSmoothingEnabled = X((0, s.getCurrentTransform)(_e), d.interpolate), b(_e, Z, 0, 0, Z.width, Z.height, 0, 0, f, v), _e.globalCompositeOperation = "source-in";
-                                    const ge = n.Util.transform((0, s.getCurrentTransformInverse)(_e), [1, 0, 0, 1, -ie, -se]);
-                                    return _e.fillStyle = O ? A.getPattern(g, this, ge, l.PathType.FILL) : A, _e.fillRect(0, 0, f, v), z && !O && (this.cachedCanvases.delete("fillCanvas"), z.set(ae, De.canvas)), {
-                                        canvas: De.canvas,
-                                        offsetX: Math.round(ie),
-                                        offsetY: Math.round(se)
+                                    Z || (lt = this.cachedCanvases.getCanvas("maskCanvas", d, b), S(lt.context, l));
+                                    let ht = e.Util.transform(B, [1 / d, 0, 0, -1 / b, 0, 0]);
+                                    ht = e.Util.transform(ht, [1, 0, 0, 1, 0, -b]);
+                                    const mt = e.Util.applyTransform([0, 0], ht),
+                                        ft = e.Util.applyTransform([d, b], ht),
+                                        kt = e.Util.normalizeRect([mt[0], mt[1], ft[0], ft[1]]),
+                                        Rt = Math.round(kt[2] - kt[0]) || 1,
+                                        St = Math.round(kt[3] - kt[1]) || 1,
+                                        It = this.cachedCanvases.getCanvas("fillCanvas", Rt, St),
+                                        _t = It.context,
+                                        rt = Math.min(mt[0], ft[0]),
+                                        at = Math.min(mt[1], ft[1]);
+                                    _t.translate(-rt, -at), _t.transform(...ht), Z || (Z = this._scaleImage(lt.canvas, (0, s.getCurrentTransformInverse)(_t)), Z = Z.img, z && O && z.set(it, Z)), _t.imageSmoothingEnabled = X((0, s.getCurrentTransform)(_t), l.interpolate), m(_t, Z, 0, 0, Z.width, Z.height, 0, 0, d, b), _t.globalCompositeOperation = "source-in";
+                                    const pt = e.Util.transform((0, s.getCurrentTransformInverse)(_t), [1, 0, 0, 1, -rt, -at]);
+                                    return _t.fillStyle = O ? y.getPattern(u, this, pt, p.PathType.FILL) : y, _t.fillRect(0, 0, d, b), z && !O && (this.cachedCanvases.delete("fillCanvas"), z.set(it, It.canvas)), {
+                                        canvas: It.canvas,
+                                        offsetX: Math.round(rt),
+                                        offsetY: Math.round(at)
                                     };
                                 }
-                                setLineWidth(d) {
-                                    d !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = d, this.ctx.lineWidth = d;
+                                setLineWidth(l) {
+                                    l !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = l, this.ctx.lineWidth = l;
                                 }
-                                setLineCap(d) {
-                                    this.ctx.lineCap = G[d];
+                                setLineCap(l) {
+                                    this.ctx.lineCap = Y[l];
                                 }
-                                setLineJoin(d) {
-                                    this.ctx.lineJoin = I[d];
+                                setLineJoin(l) {
+                                    this.ctx.lineJoin = I[l];
                                 }
-                                setMiterLimit(d) {
-                                    this.ctx.miterLimit = d;
-                                }
-                                setDash(d, g) {
-                                    const f = this.ctx;
-                                    f.setLineDash !== void 0 && (f.setLineDash(d), f.lineDashOffset = g);
-                                }
-                                setRenderingIntent(d) {}
-                                setFlatness(d) {}
-                                setGState(d) {
-                                    for (const [g, f] of d)
-                                        switch (g) {
+                                setMiterLimit(l) {
+                                    this.ctx.miterLimit = l;
+                                }
+                                setDash(l, u) {
+                                    const d = this.ctx;
+                                    d.setLineDash !== void 0 && (d.setLineDash(l), d.lineDashOffset = u);
+                                }
+                                setRenderingIntent(l) {}
+                                setFlatness(l) {}
+                                setGState(l) {
+                                    for (const [u, d] of l)
+                                        switch (u) {
                                             case "LW":
-                                                this.setLineWidth(f);
+                                                this.setLineWidth(d);
                                                 break;
                                             case "LC":
-                                                this.setLineCap(f);
+                                                this.setLineCap(d);
                                                 break;
                                             case "LJ":
-                                                this.setLineJoin(f);
+                                                this.setLineJoin(d);
                                                 break;
                                             case "ML":
-                                                this.setMiterLimit(f);
+                                                this.setMiterLimit(d);
                                                 break;
                                             case "D":
-                                                this.setDash(f[0], f[1]);
+                                                this.setDash(d[0], d[1]);
                                                 break;
                                             case "RI":
-                                                this.setRenderingIntent(f);
+                                                this.setRenderingIntent(d);
                                                 break;
                                             case "FL":
-                                                this.setFlatness(f);
+                                                this.setFlatness(d);
                                                 break;
                                             case "Font":
-                                                this.setFont(f[0], f[1]);
+                                                this.setFont(d[0], d[1]);
                                                 break;
                                             case "CA":
-                                                this.current.strokeAlpha = f;
+                                                this.current.strokeAlpha = d;
                                                 break;
                                             case "ca":
-                                                this.current.fillAlpha = f, this.ctx.globalAlpha = f;
+                                                this.current.fillAlpha = d, this.ctx.globalAlpha = d;
                                                 break;
                                             case "BM":
-                                                this.ctx.globalCompositeOperation = f;
+                                                this.ctx.globalCompositeOperation = d;
                                                 break;
                                             case "SMask":
-                                                this.current.activeSMask = f ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
+                                                this.current.activeSMask = d ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
                                                 break;
                                             case "TR":
-                                                this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(f);
+                                                this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(d);
                                                 break;
                                         }
                                 }
                                 get inSMaskMode() {
                                     return !!this.suspendedCtx;
                                 }
                                 checkSMaskState() {
-                                    const d = this.inSMaskMode;
-                                    this.current.activeSMask && !d ? this.beginSMaskMode() : !this.current.activeSMask && d && this.endSMaskMode();
+                                    const l = this.inSMaskMode;
+                                    this.current.activeSMask && !l ? this.beginSMaskMode() : !this.current.activeSMask && l && this.endSMaskMode();
                                 }
                                 beginSMaskMode() {
                                     if (this.inSMaskMode)
                                         throw new Error("beginSMaskMode called while already in smask mode");
-                                    const d = this.ctx.canvas.width,
-                                        g = this.ctx.canvas.height,
-                                        f = "smaskGroupAt" + this.groupLevel,
-                                        v = this.cachedCanvases.getCanvas(f, d, g);
-                                    this.suspendedCtx = this.ctx, this.ctx = v.context;
-                                    const A = this.ctx;
-                                    A.setTransform(...(0, s.getCurrentTransform)(this.suspendedCtx)), p(this.suspendedCtx, A), C(A, this.suspendedCtx), this.setGState([
+                                    const l = this.ctx.canvas.width,
+                                        u = this.ctx.canvas.height,
+                                        d = "smaskGroupAt" + this.groupLevel,
+                                        b = this.cachedCanvases.getCanvas(d, l, u);
+                                    this.suspendedCtx = this.ctx, this.ctx = b.context;
+                                    const y = this.ctx;
+                                    y.setTransform(...(0, s.getCurrentTransform)(this.suspendedCtx)), g(this.suspendedCtx, y), T(y, this.suspendedCtx), this.setGState([
                                         ["BM", "source-over"],
                                         ["ca", 1],
                                         ["CA", 1]
                                     ]);
                                 }
                                 endSMaskMode() {
                                     if (!this.inSMaskMode)
                                         throw new Error("endSMaskMode called while not in smask mode");
-                                    this.ctx._removeMirroring(), p(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
+                                    this.ctx._removeMirroring(), g(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
                                 }
-                                compose(d) {
+                                compose(l) {
                                     if (!this.current.activeSMask)
                                         return;
-                                    d ? (d[0] = Math.floor(d[0]), d[1] = Math.floor(d[1]), d[2] = Math.ceil(d[2]), d[3] = Math.ceil(d[3])) : d = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
-                                    const g = this.current.activeSMask,
-                                        f = this.suspendedCtx;
-                                    D(f, g, this.ctx, d), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
+                                    l ? (l[0] = Math.floor(l[0]), l[1] = Math.floor(l[1]), l[2] = Math.ceil(l[2]), l[3] = Math.ceil(l[3])) : l = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
+                                    const u = this.current.activeSMask,
+                                        d = this.suspendedCtx;
+                                    D(d, u, this.ctx, l), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
                                 }
                                 save() {
-                                    this.inSMaskMode ? (p(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
-                                    const d = this.current;
-                                    this.stateStack.push(d), this.current = d.clone();
+                                    this.inSMaskMode ? (g(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
+                                    const l = this.current;
+                                    this.stateStack.push(l), this.current = l.clone();
                                 }
                                 restore() {
-                                    this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), p(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
+                                    this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), g(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
                                 }
-                                transform(d, g, f, v, A, O) {
-                                    this.ctx.transform(d, g, f, v, A, O), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
+                                transform(l, u, d, b, y, O) {
+                                    this.ctx.transform(l, u, d, b, y, O), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
                                 }
-                                constructPath(d, g, f) {
-                                    const v = this.ctx,
-                                        A = this.current;
-                                    let O = A.x,
-                                        H = A.y,
-                                        z, ae;
-                                    const Z = (0, s.getCurrentTransform)(v),
-                                        ce = Z[0] === 0 && Z[3] === 0 || Z[1] === 0 && Z[2] === 0,
-                                        ue = ce ? f.slice(0) : null;
-                                    for (let me = 0, fe = 0, Pe = d.length; me < Pe; me++)
-                                        switch (d[me] | 0) {
-                                            case n.OPS.rectangle:
-                                                O = g[fe++], H = g[fe++];
-                                                const Fe = g[fe++],
-                                                    Ee = g[fe++],
-                                                    De = O + Fe,
-                                                    _e = H + Ee;
-                                                v.moveTo(O, H), Fe === 0 || Ee === 0 ? v.lineTo(De, _e) : (v.lineTo(De, H), v.lineTo(De, _e), v.lineTo(O, _e)), ce || A.updateRectMinMax(Z, [O, H, De, _e]), v.closePath();
+                                constructPath(l, u, d) {
+                                    const b = this.ctx,
+                                        y = this.current;
+                                    let O = y.x,
+                                        B = y.y,
+                                        z, it;
+                                    const Z = (0, s.getCurrentTransform)(b),
+                                        lt = Z[0] === 0 && Z[3] === 0 || Z[1] === 0 && Z[2] === 0,
+                                        ht = lt ? d.slice(0) : null;
+                                    for (let mt = 0, ft = 0, kt = l.length; mt < kt; mt++)
+                                        switch (l[mt] | 0) {
+                                            case e.OPS.rectangle:
+                                                O = u[ft++], B = u[ft++];
+                                                const Rt = u[ft++],
+                                                    St = u[ft++],
+                                                    It = O + Rt,
+                                                    _t = B + St;
+                                                b.moveTo(O, B), Rt === 0 || St === 0 ? b.lineTo(It, _t) : (b.lineTo(It, B), b.lineTo(It, _t), b.lineTo(O, _t)), lt || y.updateRectMinMax(Z, [O, B, It, _t]), b.closePath();
                                                 break;
-                                            case n.OPS.moveTo:
-                                                O = g[fe++], H = g[fe++], v.moveTo(O, H), ce || A.updatePathMinMax(Z, O, H);
+                                            case e.OPS.moveTo:
+                                                O = u[ft++], B = u[ft++], b.moveTo(O, B), lt || y.updatePathMinMax(Z, O, B);
                                                 break;
-                                            case n.OPS.lineTo:
-                                                O = g[fe++], H = g[fe++], v.lineTo(O, H), ce || A.updatePathMinMax(Z, O, H);
+                                            case e.OPS.lineTo:
+                                                O = u[ft++], B = u[ft++], b.lineTo(O, B), lt || y.updatePathMinMax(Z, O, B);
                                                 break;
-                                            case n.OPS.curveTo:
-                                                z = O, ae = H, O = g[fe + 4], H = g[fe + 5], v.bezierCurveTo(g[fe], g[fe + 1], g[fe + 2], g[fe + 3], O, H), A.updateCurvePathMinMax(Z, z, ae, g[fe], g[fe + 1], g[fe + 2], g[fe + 3], O, H, ue), fe += 6;
+                                            case e.OPS.curveTo:
+                                                z = O, it = B, O = u[ft + 4], B = u[ft + 5], b.bezierCurveTo(u[ft], u[ft + 1], u[ft + 2], u[ft + 3], O, B), y.updateCurvePathMinMax(Z, z, it, u[ft], u[ft + 1], u[ft + 2], u[ft + 3], O, B, ht), ft += 6;
                                                 break;
-                                            case n.OPS.curveTo2:
-                                                z = O, ae = H, v.bezierCurveTo(O, H, g[fe], g[fe + 1], g[fe + 2], g[fe + 3]), A.updateCurvePathMinMax(Z, z, ae, O, H, g[fe], g[fe + 1], g[fe + 2], g[fe + 3], ue), O = g[fe + 2], H = g[fe + 3], fe += 4;
+                                            case e.OPS.curveTo2:
+                                                z = O, it = B, b.bezierCurveTo(O, B, u[ft], u[ft + 1], u[ft + 2], u[ft + 3]), y.updateCurvePathMinMax(Z, z, it, O, B, u[ft], u[ft + 1], u[ft + 2], u[ft + 3], ht), O = u[ft + 2], B = u[ft + 3], ft += 4;
                                                 break;
-                                            case n.OPS.curveTo3:
-                                                z = O, ae = H, O = g[fe + 2], H = g[fe + 3], v.bezierCurveTo(g[fe], g[fe + 1], O, H, O, H), A.updateCurvePathMinMax(Z, z, ae, g[fe], g[fe + 1], O, H, O, H, ue), fe += 4;
+                                            case e.OPS.curveTo3:
+                                                z = O, it = B, O = u[ft + 2], B = u[ft + 3], b.bezierCurveTo(u[ft], u[ft + 1], O, B, O, B), y.updateCurvePathMinMax(Z, z, it, u[ft], u[ft + 1], O, B, O, B, ht), ft += 4;
                                                 break;
-                                            case n.OPS.closePath:
-                                                v.closePath();
+                                            case e.OPS.closePath:
+                                                b.closePath();
                                                 break;
                                         }
-                                    ce && A.updateScalingPathMinMax(Z, ue), A.setCurrentPoint(O, H);
+                                    lt && y.updateScalingPathMinMax(Z, ht), y.setCurrentPoint(O, B);
                                 }
                                 closePath() {
                                     this.ctx.closePath();
                                 }
-                                stroke(d = !0) {
-                                    const g = this.ctx,
-                                        f = this.current.strokeColor;
-                                    g.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof f == "object" && (f != null && f.getPattern) ? (g.save(), g.strokeStyle = f.getPattern(g, this, (0, s.getCurrentTransformInverse)(g), l.PathType.STROKE), this.rescaleAndStroke(!1), g.restore()) : this.rescaleAndStroke(!0)), d && this.consumePath(this.current.getClippedPathBoundingBox()), g.globalAlpha = this.current.fillAlpha;
+                                stroke(l = !0) {
+                                    const u = this.ctx,
+                                        d = this.current.strokeColor;
+                                    u.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof d == "object" && (d != null && d.getPattern) ? (u.save(), u.strokeStyle = d.getPattern(u, this, (0, s.getCurrentTransformInverse)(u), p.PathType.STROKE), this.rescaleAndStroke(!1), u.restore()) : this.rescaleAndStroke(!0)), l && this.consumePath(this.current.getClippedPathBoundingBox()), u.globalAlpha = this.current.fillAlpha;
                                 }
                                 closeStroke() {
                                     this.closePath(), this.stroke();
                                 }
-                                fill(d = !0) {
-                                    const g = this.ctx,
-                                        f = this.current.fillColor,
-                                        v = this.current.patternFill;
-                                    let A = !1;
-                                    v && (g.save(), g.fillStyle = f.getPattern(g, this, (0, s.getCurrentTransformInverse)(g), l.PathType.FILL), A = !0);
+                                fill(l = !0) {
+                                    const u = this.ctx,
+                                        d = this.current.fillColor,
+                                        b = this.current.patternFill;
+                                    let y = !1;
+                                    b && (u.save(), u.fillStyle = d.getPattern(u, this, (0, s.getCurrentTransformInverse)(u), p.PathType.FILL), y = !0);
                                     const O = this.current.getClippedPathBoundingBox();
-                                    this.contentVisible && O !== null && (this.pendingEOFill ? (g.fill("evenodd"), this.pendingEOFill = !1) : g.fill()), A && g.restore(), d && this.consumePath(O);
+                                    this.contentVisible && O !== null && (this.pendingEOFill ? (u.fill("evenodd"), this.pendingEOFill = !1) : u.fill()), y && u.restore(), l && this.consumePath(O);
                                 }
                                 eoFill() {
                                     this.pendingEOFill = !0, this.fill();
                                 }
                                 fillStroke() {
                                     this.fill(!1), this.stroke(!1), this.consumePath();
                                 }
@@ -13678,1660 +10275,1660 @@
                                 closeEOFillStroke() {
                                     this.pendingEOFill = !0, this.closePath(), this.fillStroke();
                                 }
                                 endPath() {
                                     this.consumePath();
                                 }
                                 clip() {
-                                    this.pendingClip = B;
+                                    this.pendingClip = U;
                                 }
                                 eoClip() {
-                                    this.pendingClip = ee;
+                                    this.pendingClip = G;
                                 }
                                 beginText() {
-                                    this.current.textMatrix = n.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
+                                    this.current.textMatrix = e.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
                                 }
                                 endText() {
-                                    const d = this.pendingTextPaths,
-                                        g = this.ctx;
-                                    if (d === void 0) {
-                                        g.beginPath();
+                                    const l = this.pendingTextPaths,
+                                        u = this.ctx;
+                                    if (l === void 0) {
+                                        u.beginPath();
                                         return;
                                     }
-                                    g.save(), g.beginPath();
-                                    for (const f of d)
-                                        g.setTransform(...f.transform), g.translate(f.x, f.y), f.addToPath(g, f.fontSize);
-                                    g.restore(), g.clip(), g.beginPath(), delete this.pendingTextPaths;
+                                    u.save(), u.beginPath();
+                                    for (const d of l)
+                                        u.setTransform(...d.transform), u.translate(d.x, d.y), d.addToPath(u, d.fontSize);
+                                    u.restore(), u.clip(), u.beginPath(), delete this.pendingTextPaths;
                                 }
-                                setCharSpacing(d) {
-                                    this.current.charSpacing = d;
+                                setCharSpacing(l) {
+                                    this.current.charSpacing = l;
                                 }
-                                setWordSpacing(d) {
-                                    this.current.wordSpacing = d;
+                                setWordSpacing(l) {
+                                    this.current.wordSpacing = l;
                                 }
-                                setHScale(d) {
-                                    this.current.textHScale = d / 100;
+                                setHScale(l) {
+                                    this.current.textHScale = l / 100;
                                 }
-                                setLeading(d) {
-                                    this.current.leading = -d;
+                                setLeading(l) {
+                                    this.current.leading = -l;
                                 }
-                                setFont(d, g) {
+                                setFont(l, u) {
                                     var Z;
-                                    const f = this.commonObjs.get(d),
-                                        v = this.current;
-                                    if (!f)
-                                        throw new Error(`Can't find font for ${d}`);
-                                    if (v.fontMatrix = f.fontMatrix || n.FONT_IDENTITY_MATRIX, (v.fontMatrix[0] === 0 || v.fontMatrix[3] === 0) && (0, n.warn)("Invalid font matrix for font " + d), g < 0 ? (g = -g, v.fontDirection = -1) : v.fontDirection = 1, this.current.font = f, this.current.fontSize = g, f.isType3Font)
+                                    const d = this.commonObjs.get(l),
+                                        b = this.current;
+                                    if (!d)
+                                        throw new Error(`Can't find font for ${l}`);
+                                    if (b.fontMatrix = d.fontMatrix || e.FONT_IDENTITY_MATRIX, (b.fontMatrix[0] === 0 || b.fontMatrix[3] === 0) && (0, e.warn)("Invalid font matrix for font " + l), u < 0 ? (u = -u, b.fontDirection = -1) : b.fontDirection = 1, this.current.font = d, this.current.fontSize = u, d.isType3Font)
                                         return;
-                                    const A = f.loadedName || "sans-serif",
-                                        O = ((Z = f.systemFontInfo) == null ? void 0 : Z.css) || `"${A}", ${f.fallbackName}`;
-                                    let H = "normal";
-                                    f.black ? H = "900" : f.bold && (H = "bold");
-                                    const z = f.italic ? "italic" : "normal";
-                                    let ae = g;
-                                    g < _ ? ae = _ : g > c && (ae = c), this.current.fontSizeScale = g / ae, this.ctx.font = `${z} ${H} ${ae}px ${O}`;
-                                }
-                                setTextRenderingMode(d) {
-                                    this.current.textRenderingMode = d;
-                                }
-                                setTextRise(d) {
-                                    this.current.textRise = d;
+                                    const y = d.loadedName || "sans-serif",
+                                        O = ((Z = d.systemFontInfo) == null ? void 0 : Z.css) || `"${y}", ${d.fallbackName}`;
+                                    let B = "normal";
+                                    d.black ? B = "900" : d.bold && (B = "bold");
+                                    const z = d.italic ? "italic" : "normal";
+                                    let it = u;
+                                    u < A ? it = A : u > a && (it = a), this.current.fontSizeScale = u / it, this.ctx.font = `${z} ${B} ${it}px ${O}`;
+                                }
+                                setTextRenderingMode(l) {
+                                    this.current.textRenderingMode = l;
+                                }
+                                setTextRise(l) {
+                                    this.current.textRise = l;
                                 }
-                                moveText(d, g) {
-                                    this.current.x = this.current.lineX += d, this.current.y = this.current.lineY += g;
+                                moveText(l, u) {
+                                    this.current.x = this.current.lineX += l, this.current.y = this.current.lineY += u;
                                 }
-                                setLeadingMoveText(d, g) {
-                                    this.setLeading(-g), this.moveText(d, g);
+                                setLeadingMoveText(l, u) {
+                                    this.setLeading(-u), this.moveText(l, u);
                                 }
-                                setTextMatrix(d, g, f, v, A, O) {
-                                    this.current.textMatrix = [d, g, f, v, A, O], this.current.textMatrixScale = Math.hypot(d, g), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
+                                setTextMatrix(l, u, d, b, y, O) {
+                                    this.current.textMatrix = [l, u, d, b, y, O], this.current.textMatrixScale = Math.hypot(l, u), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
                                 }
                                 nextLine() {
                                     this.moveText(0, this.current.leading);
                                 }
-                                paintChar(d, g, f, v) {
-                                    const A = this.ctx,
+                                paintChar(l, u, d, b) {
+                                    const y = this.ctx,
                                         O = this.current,
-                                        H = O.font,
+                                        B = O.font,
                                         z = O.textRenderingMode,
-                                        ae = O.fontSize / O.fontSizeScale,
-                                        Z = z & n.TextRenderingMode.FILL_STROKE_MASK,
-                                        ce = !!(z & n.TextRenderingMode.ADD_TO_PATH_FLAG),
-                                        ue = O.patternFill && !H.missingFile;
-                                    let me;
-                                    (H.disableFontFace || ce || ue) && (me = H.getPathGenerator(this.commonObjs, d)), H.disableFontFace || ue ? (A.save(), A.translate(g, f), A.beginPath(), me(A, ae), v && A.setTransform(...v), (Z === n.TextRenderingMode.FILL || Z === n.TextRenderingMode.FILL_STROKE) && A.fill(), (Z === n.TextRenderingMode.STROKE || Z === n.TextRenderingMode.FILL_STROKE) && A.stroke(), A.restore()) : ((Z === n.TextRenderingMode.FILL || Z === n.TextRenderingMode.FILL_STROKE) && A.fillText(d, g, f), (Z === n.TextRenderingMode.STROKE || Z === n.TextRenderingMode.FILL_STROKE) && A.strokeText(d, g, f)), ce && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
-                                        transform: (0, s.getCurrentTransform)(A),
-                                        x: g,
-                                        y: f,
-                                        fontSize: ae,
-                                        addToPath: me
+                                        it = O.fontSize / O.fontSizeScale,
+                                        Z = z & e.TextRenderingMode.FILL_STROKE_MASK,
+                                        lt = !!(z & e.TextRenderingMode.ADD_TO_PATH_FLAG),
+                                        ht = O.patternFill && !B.missingFile;
+                                    let mt;
+                                    (B.disableFontFace || lt || ht) && (mt = B.getPathGenerator(this.commonObjs, l)), B.disableFontFace || ht ? (y.save(), y.translate(u, d), y.beginPath(), mt(y, it), b && y.setTransform(...b), (Z === e.TextRenderingMode.FILL || Z === e.TextRenderingMode.FILL_STROKE) && y.fill(), (Z === e.TextRenderingMode.STROKE || Z === e.TextRenderingMode.FILL_STROKE) && y.stroke(), y.restore()) : ((Z === e.TextRenderingMode.FILL || Z === e.TextRenderingMode.FILL_STROKE) && y.fillText(l, u, d), (Z === e.TextRenderingMode.STROKE || Z === e.TextRenderingMode.FILL_STROKE) && y.strokeText(l, u, d)), lt && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
+                                        transform: (0, s.getCurrentTransform)(y),
+                                        x: u,
+                                        y: d,
+                                        fontSize: it,
+                                        addToPath: mt
                                     });
                                 }
                                 get isFontSubpixelAAEnabled() {
                                     const {
-                                        context: d
+                                        context: l
                                     } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
-                                    d.scale(1.5, 1), d.fillText("I", 0, 10);
-                                    const g = d.getImageData(0, 0, 10, 10).data;
-                                    let f = !1;
-                                    for (let v = 3; v < g.length; v += 4)
-                                        if (g[v] > 0 && g[v] < 255) {
-                                            f = !0;
+                                    l.scale(1.5, 1), l.fillText("I", 0, 10);
+                                    const u = l.getImageData(0, 0, 10, 10).data;
+                                    let d = !1;
+                                    for (let b = 3; b < u.length; b += 4)
+                                        if (u[b] > 0 && u[b] < 255) {
+                                            d = !0;
                                             break;
                                         }
-                                    return (0, n.shadow)(this, "isFontSubpixelAAEnabled", f);
+                                    return (0, e.shadow)(this, "isFontSubpixelAAEnabled", d);
                                 }
-                                showText(d) {
-                                    const g = this.current,
-                                        f = g.font;
-                                    if (f.isType3Font)
-                                        return this.showType3Text(d);
-                                    const v = g.fontSize;
-                                    if (v === 0)
+                                showText(l) {
+                                    const u = this.current,
+                                        d = u.font;
+                                    if (d.isType3Font)
+                                        return this.showType3Text(l);
+                                    const b = u.fontSize;
+                                    if (b === 0)
                                         return;
-                                    const A = this.ctx,
-                                        O = g.fontSizeScale,
-                                        H = g.charSpacing,
-                                        z = g.wordSpacing,
-                                        ae = g.fontDirection,
-                                        Z = g.textHScale * ae,
-                                        ce = d.length,
-                                        ue = f.vertical,
-                                        me = ue ? 1 : -1,
-                                        fe = f.defaultVMetrics,
-                                        Pe = v * g.fontMatrix[0],
-                                        Fe = g.textRenderingMode === n.TextRenderingMode.FILL && !f.disableFontFace && !g.patternFill;
-                                    A.save(), A.transform(...g.textMatrix), A.translate(g.x, g.y + g.textRise), ae > 0 ? A.scale(Z, -1) : A.scale(Z, 1);
-                                    let Ee;
-                                    if (g.patternFill) {
-                                        A.save();
-                                        const ge = g.fillColor.getPattern(A, this, (0, s.getCurrentTransformInverse)(A), l.PathType.FILL);
-                                        Ee = (0, s.getCurrentTransform)(A), A.restore(), A.fillStyle = ge;
-                                    }
-                                    let De = g.lineWidth;
-                                    const _e = g.textMatrixScale;
-                                    if (_e === 0 || De === 0) {
-                                        const ge = g.textRenderingMode & n.TextRenderingMode.FILL_STROKE_MASK;
-                                        (ge === n.TextRenderingMode.STROKE || ge === n.TextRenderingMode.FILL_STROKE) && (De = this.getSinglePixelWidth());
+                                    const y = this.ctx,
+                                        O = u.fontSizeScale,
+                                        B = u.charSpacing,
+                                        z = u.wordSpacing,
+                                        it = u.fontDirection,
+                                        Z = u.textHScale * it,
+                                        lt = l.length,
+                                        ht = d.vertical,
+                                        mt = ht ? 1 : -1,
+                                        ft = d.defaultVMetrics,
+                                        kt = b * u.fontMatrix[0],
+                                        Rt = u.textRenderingMode === e.TextRenderingMode.FILL && !d.disableFontFace && !u.patternFill;
+                                    y.save(), y.transform(...u.textMatrix), y.translate(u.x, u.y + u.textRise), it > 0 ? y.scale(Z, -1) : y.scale(Z, 1);
+                                    let St;
+                                    if (u.patternFill) {
+                                        y.save();
+                                        const pt = u.fillColor.getPattern(y, this, (0, s.getCurrentTransformInverse)(y), p.PathType.FILL);
+                                        St = (0, s.getCurrentTransform)(y), y.restore(), y.fillStyle = pt;
+                                    }
+                                    let It = u.lineWidth;
+                                    const _t = u.textMatrixScale;
+                                    if (_t === 0 || It === 0) {
+                                        const pt = u.textRenderingMode & e.TextRenderingMode.FILL_STROKE_MASK;
+                                        (pt === e.TextRenderingMode.STROKE || pt === e.TextRenderingMode.FILL_STROKE) && (It = this.getSinglePixelWidth());
                                     } else
-                                        De /= _e;
-                                    if (O !== 1 && (A.scale(O, O), De /= O), A.lineWidth = De, f.isInvalidPDFjsFont) {
-                                        const ge = [];
-                                        let Ce = 0;
-                                        for (const xe of d)
-                                            ge.push(xe.unicode), Ce += xe.width;
-                                        A.fillText(ge.join(""), 0, 0), g.x += Ce * Pe * Z, A.restore(), this.compose();
+                                        It /= _t;
+                                    if (O !== 1 && (y.scale(O, O), It /= O), y.lineWidth = It, d.isInvalidPDFjsFont) {
+                                        const pt = [];
+                                        let Ct = 0;
+                                        for (const Tt of l)
+                                            pt.push(Tt.unicode), Ct += Tt.width;
+                                        y.fillText(pt.join(""), 0, 0), u.x += Ct * kt * Z, y.restore(), this.compose();
                                         return;
                                     }
-                                    let ie = 0,
-                                        se;
-                                    for (se = 0; se < ce; ++se) {
-                                        const ge = d[se];
-                                        if (typeof ge == "number") {
-                                            ie += me * ge * v / 1e3;
+                                    let rt = 0,
+                                        at;
+                                    for (at = 0; at < lt; ++at) {
+                                        const pt = l[at];
+                                        if (typeof pt == "number") {
+                                            rt += mt * pt * b / 1e3;
                                             continue;
                                         }
-                                        let Ce = !1;
-                                        const xe = (ge.isSpace ? z : 0) + H,
-                                            He = ge.fontChar,
-                                            We = ge.accent;
-                                        let je, ze, Xe = ge.width;
-                                        if (ue) {
-                                            const Ye = ge.vmetric || fe,
-                                                de = -(ge.vmetric ? Ye[1] : Xe * 0.5) * Pe,
-                                                ne = Ye[2] * Pe;
-                                            Xe = Ye ? -Ye[0] : Xe, je = de / O, ze = (ie + ne) / O;
+                                        let Ct = !1;
+                                        const Tt = (pt.isSpace ? z : 0) + B,
+                                            Bt = pt.fontChar,
+                                            Wt = pt.accent;
+                                        let jt, zt, Gt = pt.width;
+                                        if (ht) {
+                                            const Vt = pt.vmetric || ft,
+                                                ut = -(pt.vmetric ? Vt[1] : Gt * 0.5) * kt,
+                                                nt = Vt[2] * kt;
+                                            Gt = Vt ? -Vt[0] : Gt, jt = ut / O, zt = (rt + nt) / O;
                                         } else
-                                            je = ie / O, ze = 0;
-                                        if (f.remeasure && Xe > 0) {
-                                            const Ye = A.measureText(He).width * 1e3 / v * O;
-                                            if (Xe < Ye && this.isFontSubpixelAAEnabled) {
-                                                const de = Xe / Ye;
-                                                Ce = !0, A.save(), A.scale(de, 1), je /= de;
+                                            jt = rt / O, zt = 0;
+                                        if (d.remeasure && Gt > 0) {
+                                            const Vt = y.measureText(Bt).width * 1e3 / b * O;
+                                            if (Gt < Vt && this.isFontSubpixelAAEnabled) {
+                                                const ut = Gt / Vt;
+                                                Ct = !0, y.save(), y.scale(ut, 1), jt /= ut;
                                             } else
-                                                Xe !== Ye && (je += (Xe - Ye) / 2e3 * v / O);
+                                                Gt !== Vt && (jt += (Gt - Vt) / 2e3 * b / O);
                                         }
-                                        if (this.contentVisible && (ge.isInFont || f.missingFile)) {
-                                            if (Fe && !We)
-                                                A.fillText(He, je, ze);
-                                            else if (this.paintChar(He, je, ze, Ee), We) {
-                                                const Ye = je + v * We.offset.x / O,
-                                                    de = ze - v * We.offset.y / O;
-                                                this.paintChar(We.fontChar, Ye, de, Ee);
+                                        if (this.contentVisible && (pt.isInFont || d.missingFile)) {
+                                            if (Rt && !Wt)
+                                                y.fillText(Bt, jt, zt);
+                                            else if (this.paintChar(Bt, jt, zt, St), Wt) {
+                                                const Vt = jt + b * Wt.offset.x / O,
+                                                    ut = zt - b * Wt.offset.y / O;
+                                                this.paintChar(Wt.fontChar, Vt, ut, St);
                                             }
                                         }
-                                        const Ge = ue ? Xe * Pe - xe * ae : Xe * Pe + xe * ae;
-                                        ie += Ge, Ce && A.restore();
+                                        const qt = ht ? Gt * kt - Tt * it : Gt * kt + Tt * it;
+                                        rt += qt, Ct && y.restore();
                                     }
-                                    ue ? g.y -= ie : g.x += ie * Z, A.restore(), this.compose();
+                                    ht ? u.y -= rt : u.x += rt * Z, y.restore(), this.compose();
                                 }
-                                showType3Text(d) {
-                                    const g = this.ctx,
-                                        f = this.current,
-                                        v = f.font,
-                                        A = f.fontSize,
-                                        O = f.fontDirection,
-                                        H = v.vertical ? 1 : -1,
-                                        z = f.charSpacing,
-                                        ae = f.wordSpacing,
-                                        Z = f.textHScale * O,
-                                        ce = f.fontMatrix || n.FONT_IDENTITY_MATRIX,
-                                        ue = d.length,
-                                        me = f.textRenderingMode === n.TextRenderingMode.INVISIBLE;
-                                    let fe, Pe, Fe, Ee;
-                                    if (!(me || A === 0)) {
-                                        for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, g.save(), g.transform(...f.textMatrix), g.translate(f.x, f.y), g.scale(Z, O), fe = 0; fe < ue; ++fe) {
-                                            if (Pe = d[fe], typeof Pe == "number") {
-                                                Ee = H * Pe * A / 1e3, this.ctx.translate(Ee, 0), f.x += Ee * Z;
+                                showType3Text(l) {
+                                    const u = this.ctx,
+                                        d = this.current,
+                                        b = d.font,
+                                        y = d.fontSize,
+                                        O = d.fontDirection,
+                                        B = b.vertical ? 1 : -1,
+                                        z = d.charSpacing,
+                                        it = d.wordSpacing,
+                                        Z = d.textHScale * O,
+                                        lt = d.fontMatrix || e.FONT_IDENTITY_MATRIX,
+                                        ht = l.length,
+                                        mt = d.textRenderingMode === e.TextRenderingMode.INVISIBLE;
+                                    let ft, kt, Rt, St;
+                                    if (!(mt || y === 0)) {
+                                        for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, u.save(), u.transform(...d.textMatrix), u.translate(d.x, d.y), u.scale(Z, O), ft = 0; ft < ht; ++ft) {
+                                            if (kt = l[ft], typeof kt == "number") {
+                                                St = B * kt * y / 1e3, this.ctx.translate(St, 0), d.x += St * Z;
                                                 continue;
                                             }
-                                            const De = (Pe.isSpace ? ae : 0) + z,
-                                                _e = v.charProcOperatorList[Pe.operatorListId];
-                                            if (!_e) {
-                                                (0, n.warn)(`Type3 character "${Pe.operatorListId}" is not available.`);
+                                            const It = (kt.isSpace ? it : 0) + z,
+                                                _t = b.charProcOperatorList[kt.operatorListId];
+                                            if (!_t) {
+                                                (0, e.warn)(`Type3 character "${kt.operatorListId}" is not available.`);
                                                 continue;
                                             }
-                                            this.contentVisible && (this.processingType3 = Pe, this.save(), g.scale(A, A), g.transform(...ce), this.executeOperatorList(_e), this.restore()), Fe = n.Util.applyTransform([Pe.width, 0], ce)[0] * A + De, g.translate(Fe, 0), f.x += Fe * Z;
+                                            this.contentVisible && (this.processingType3 = kt, this.save(), u.scale(y, y), u.transform(...lt), this.executeOperatorList(_t), this.restore()), Rt = e.Util.applyTransform([kt.width, 0], lt)[0] * y + It, u.translate(Rt, 0), d.x += Rt * Z;
                                         }
-                                        g.restore(), this.processingType3 = null;
+                                        u.restore(), this.processingType3 = null;
                                     }
                                 }
-                                setCharWidth(d, g) {}
-                                setCharWidthAndBounds(d, g, f, v, A, O) {
-                                    this.ctx.rect(f, v, A - f, O - v), this.ctx.clip(), this.endPath();
-                                }
-                                getColorN_Pattern(d) {
-                                    let g;
-                                    if (d[0] === "TilingPattern") {
-                                        const f = d[1],
-                                            v = this.baseTransform || (0, s.getCurrentTransform)(this.ctx),
-                                            A = {
-                                                createCanvasGraphics: (O) => new be(O, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
+                                setCharWidth(l, u) {}
+                                setCharWidthAndBounds(l, u, d, b, y, O) {
+                                    this.ctx.rect(d, b, y - d, O - b), this.ctx.clip(), this.endPath();
+                                }
+                                getColorN_Pattern(l) {
+                                    let u;
+                                    if (l[0] === "TilingPattern") {
+                                        const d = l[1],
+                                            b = this.baseTransform || (0, s.getCurrentTransform)(this.ctx),
+                                            y = {
+                                                createCanvasGraphics: (O) => new gt(O, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                                                     optionalContentConfig: this.optionalContentConfig,
                                                     markedContentStack: this.markedContentStack
                                                 })
                                             };
-                                        g = new l.TilingPattern(d, f, this.ctx, A, v);
+                                        u = new p.TilingPattern(l, d, this.ctx, y, b);
                                     } else
-                                        g = this._getPattern(d[1], d[2]);
-                                    return g;
+                                        u = this._getPattern(l[1], l[2]);
+                                    return u;
                                 }
                                 setStrokeColorN() {
                                     this.current.strokeColor = this.getColorN_Pattern(arguments);
                                 }
                                 setFillColorN() {
                                     this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
                                 }
-                                setStrokeRGBColor(d, g, f) {
-                                    const v = n.Util.makeHexColor(d, g, f);
-                                    this.ctx.strokeStyle = v, this.current.strokeColor = v;
-                                }
-                                setFillRGBColor(d, g, f) {
-                                    const v = n.Util.makeHexColor(d, g, f);
-                                    this.ctx.fillStyle = v, this.current.fillColor = v, this.current.patternFill = !1;
-                                }
-                                _getPattern(d, g = null) {
-                                    let f;
-                                    return this.cachedPatterns.has(d) ? f = this.cachedPatterns.get(d) : (f = (0, l.getShadingPattern)(this.getObject(d)), this.cachedPatterns.set(d, f)), g && (f.matrix = g), f;
+                                setStrokeRGBColor(l, u, d) {
+                                    const b = e.Util.makeHexColor(l, u, d);
+                                    this.ctx.strokeStyle = b, this.current.strokeColor = b;
+                                }
+                                setFillRGBColor(l, u, d) {
+                                    const b = e.Util.makeHexColor(l, u, d);
+                                    this.ctx.fillStyle = b, this.current.fillColor = b, this.current.patternFill = !1;
+                                }
+                                _getPattern(l, u = null) {
+                                    let d;
+                                    return this.cachedPatterns.has(l) ? d = this.cachedPatterns.get(l) : (d = (0, p.getShadingPattern)(this.getObject(l)), this.cachedPatterns.set(l, d)), u && (d.matrix = u), d;
                                 }
-                                shadingFill(d) {
+                                shadingFill(l) {
                                     if (!this.contentVisible)
                                         return;
-                                    const g = this.ctx;
+                                    const u = this.ctx;
                                     this.save();
-                                    const f = this._getPattern(d);
-                                    g.fillStyle = f.getPattern(g, this, (0, s.getCurrentTransformInverse)(g), l.PathType.SHADING);
-                                    const v = (0, s.getCurrentTransformInverse)(g);
-                                    if (v) {
+                                    const d = this._getPattern(l);
+                                    u.fillStyle = d.getPattern(u, this, (0, s.getCurrentTransformInverse)(u), p.PathType.SHADING);
+                                    const b = (0, s.getCurrentTransformInverse)(u);
+                                    if (b) {
                                         const {
-                                            width: A,
+                                            width: y,
                                             height: O
-                                        } = g.canvas, [H, z, ae, Z] = n.Util.getAxialAlignedBoundingBox([0, 0, A, O], v);
-                                        this.ctx.fillRect(H, z, ae - H, Z - z);
+                                        } = u.canvas, [B, z, it, Z] = e.Util.getAxialAlignedBoundingBox([0, 0, y, O], b);
+                                        this.ctx.fillRect(B, z, it - B, Z - z);
                                     } else
                                         this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                                     this.compose(this.current.getClippedPathBoundingBox()), this.restore();
                                 }
                                 beginInlineImage() {
-                                    (0, n.unreachable)("Should not call beginInlineImage");
+                                    (0, e.unreachable)("Should not call beginInlineImage");
                                 }
                                 beginImageData() {
-                                    (0, n.unreachable)("Should not call beginImageData");
+                                    (0, e.unreachable)("Should not call beginImageData");
                                 }
-                                paintFormXObjectBegin(d, g) {
-                                    if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(d) && d.length === 6 && this.transform(...d), this.baseTransform = (0, s.getCurrentTransform)(this.ctx), g)) {
-                                        const f = g[2] - g[0],
-                                            v = g[3] - g[1];
-                                        this.ctx.rect(g[0], g[1], f, v), this.current.updateRectMinMax((0, s.getCurrentTransform)(this.ctx), g), this.clip(), this.endPath();
+                                paintFormXObjectBegin(l, u) {
+                                    if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(l) && l.length === 6 && this.transform(...l), this.baseTransform = (0, s.getCurrentTransform)(this.ctx), u)) {
+                                        const d = u[2] - u[0],
+                                            b = u[3] - u[1];
+                                        this.ctx.rect(u[0], u[1], d, b), this.current.updateRectMinMax((0, s.getCurrentTransform)(this.ctx), u), this.clip(), this.endPath();
                                     }
                                 }
                                 paintFormXObjectEnd() {
                                     this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
                                 }
-                                beginGroup(d) {
+                                beginGroup(l) {
                                     if (!this.contentVisible)
                                         return;
                                     this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
-                                    const g = this.ctx;
-                                    d.isolated || (0, n.info)("TODO: Support non-isolated groups."), d.knockout && (0, n.warn)("Knockout groups not supported.");
-                                    const f = (0, s.getCurrentTransform)(g);
-                                    if (d.matrix && g.transform(...d.matrix), !d.bbox)
+                                    const u = this.ctx;
+                                    l.isolated || (0, e.info)("TODO: Support non-isolated groups."), l.knockout && (0, e.warn)("Knockout groups not supported.");
+                                    const d = (0, s.getCurrentTransform)(u);
+                                    if (l.matrix && u.transform(...l.matrix), !l.bbox)
                                         throw new Error("Bounding box is required.");
-                                    let v = n.Util.getAxialAlignedBoundingBox(d.bbox, (0, s.getCurrentTransform)(g));
-                                    const A = [0, 0, g.canvas.width, g.canvas.height];
-                                    v = n.Util.intersect(v, A) || [0, 0, 0, 0];
-                                    const O = Math.floor(v[0]),
-                                        H = Math.floor(v[1]);
-                                    let z = Math.max(Math.ceil(v[2]) - O, 1),
-                                        ae = Math.max(Math.ceil(v[3]) - H, 1),
+                                    let b = e.Util.getAxialAlignedBoundingBox(l.bbox, (0, s.getCurrentTransform)(u));
+                                    const y = [0, 0, u.canvas.width, u.canvas.height];
+                                    b = e.Util.intersect(b, y) || [0, 0, 0, 0];
+                                    const O = Math.floor(b[0]),
+                                        B = Math.floor(b[1]);
+                                    let z = Math.max(Math.ceil(b[2]) - O, 1),
+                                        it = Math.max(Math.ceil(b[3]) - B, 1),
                                         Z = 1,
-                                        ce = 1;
-                                    z > o && (Z = z / o, z = o), ae > o && (ce = ae / o, ae = o), this.current.startNewPathAndClipBox([0, 0, z, ae]);
-                                    let ue = "groupAt" + this.groupLevel;
-                                    d.smask && (ue += "_smask_" + this.smaskCounter++ % 2);
-                                    const me = this.cachedCanvases.getCanvas(ue, z, ae),
-                                        fe = me.context;
-                                    fe.scale(1 / Z, 1 / ce), fe.translate(-O, -H), fe.transform(...f), d.smask ? this.smaskStack.push({
-                                        canvas: me.canvas,
-                                        context: fe,
+                                        lt = 1;
+                                    z > h && (Z = z / h, z = h), it > h && (lt = it / h, it = h), this.current.startNewPathAndClipBox([0, 0, z, it]);
+                                    let ht = "groupAt" + this.groupLevel;
+                                    l.smask && (ht += "_smask_" + this.smaskCounter++ % 2);
+                                    const mt = this.cachedCanvases.getCanvas(ht, z, it),
+                                        ft = mt.context;
+                                    ft.scale(1 / Z, 1 / lt), ft.translate(-O, -B), ft.transform(...d), l.smask ? this.smaskStack.push({
+                                        canvas: mt.canvas,
+                                        context: ft,
                                         offsetX: O,
-                                        offsetY: H,
+                                        offsetY: B,
                                         scaleX: Z,
-                                        scaleY: ce,
-                                        subtype: d.smask.subtype,
-                                        backdrop: d.smask.backdrop,
-                                        transferMap: d.smask.transferMap || null,
+                                        scaleY: lt,
+                                        subtype: l.smask.subtype,
+                                        backdrop: l.smask.backdrop,
+                                        transferMap: l.smask.transferMap || null,
                                         startTransformInverse: null
-                                    }) : (g.setTransform(1, 0, 0, 1, 0, 0), g.translate(O, H), g.scale(Z, ce), g.save()), p(g, fe), this.ctx = fe, this.setGState([
+                                    }) : (u.setTransform(1, 0, 0, 1, 0, 0), u.translate(O, B), u.scale(Z, lt), u.save()), g(u, ft), this.ctx = ft, this.setGState([
                                         ["BM", "source-over"],
                                         ["ca", 1],
                                         ["CA", 1]
-                                    ]), this.groupStack.push(g), this.groupLevel++;
+                                    ]), this.groupStack.push(u), this.groupLevel++;
                                 }
-                                endGroup(d) {
+                                endGroup(l) {
                                     if (!this.contentVisible)
                                         return;
                                     this.groupLevel--;
-                                    const g = this.ctx,
-                                        f = this.groupStack.pop();
-                                    if (this.ctx = f, this.ctx.imageSmoothingEnabled = !1, d.smask)
+                                    const u = this.ctx,
+                                        d = this.groupStack.pop();
+                                    if (this.ctx = d, this.ctx.imageSmoothingEnabled = !1, l.smask)
                                         this.tempSMask = this.smaskStack.pop(), this.restore();
                                     else {
                                         this.ctx.restore();
-                                        const v = (0, s.getCurrentTransform)(this.ctx);
-                                        this.restore(), this.ctx.save(), this.ctx.setTransform(...v);
-                                        const A = n.Util.getAxialAlignedBoundingBox([0, 0, g.canvas.width, g.canvas.height], v);
-                                        this.ctx.drawImage(g.canvas, 0, 0), this.ctx.restore(), this.compose(A);
+                                        const b = (0, s.getCurrentTransform)(this.ctx);
+                                        this.restore(), this.ctx.save(), this.ctx.setTransform(...b);
+                                        const y = e.Util.getAxialAlignedBoundingBox([0, 0, u.canvas.width, u.canvas.height], b);
+                                        this.ctx.drawImage(u.canvas, 0, 0), this.ctx.restore(), this.compose(y);
                                     }
                                 }
-                                beginAnnotation(d, g, f, v, A) {
-                                    if (K(this, q, Qt).call(this), E(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(g) && g.length === 4) {
-                                        const O = g[2] - g[0],
-                                            H = g[3] - g[1];
-                                        if (A && this.annotationCanvasMap) {
-                                            f = f.slice(), f[4] -= g[0], f[5] -= g[1], g = g.slice(), g[0] = g[1] = 0, g[2] = O, g[3] = H;
-                                            const [z, ae] = n.Util.singularValueDecompose2dScale((0, s.getCurrentTransform)(this.ctx)), {
+                                beginAnnotation(l, u, d, b, y) {
+                                    if (J(this, H, Ze).call(this), v(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(u) && u.length === 4) {
+                                        const O = u[2] - u[0],
+                                            B = u[3] - u[1];
+                                        if (y && this.annotationCanvasMap) {
+                                            d = d.slice(), d[4] -= u[0], d[5] -= u[1], u = u.slice(), u[0] = u[1] = 0, u[2] = O, u[3] = B;
+                                            const [z, it] = e.Util.singularValueDecompose2dScale((0, s.getCurrentTransform)(this.ctx)), {
                                                 viewportScale: Z
-                                            } = this, ce = Math.ceil(O * this.outputScaleX * Z), ue = Math.ceil(H * this.outputScaleY * Z);
-                                            this.annotationCanvas = this.canvasFactory.create(ce, ue);
+                                            } = this, lt = Math.ceil(O * this.outputScaleX * Z), ht = Math.ceil(B * this.outputScaleY * Z);
+                                            this.annotationCanvas = this.canvasFactory.create(lt, ht);
                                             const {
-                                                canvas: me,
-                                                context: fe
+                                                canvas: mt,
+                                                context: ft
                                             } = this.annotationCanvas;
-                                            this.annotationCanvasMap.set(d, me), this.annotationCanvas.savedCtx = this.ctx, this.ctx = fe, this.ctx.save(), this.ctx.setTransform(z, 0, 0, -ae, 0, H * ae), E(this.ctx);
+                                            this.annotationCanvasMap.set(l, mt), this.annotationCanvas.savedCtx = this.ctx, this.ctx = ft, this.ctx.save(), this.ctx.setTransform(z, 0, 0, -it, 0, B * it), v(this.ctx);
                                         } else
-                                            E(this.ctx), this.ctx.rect(g[0], g[1], O, H), this.ctx.clip(), this.endPath();
+                                            v(this.ctx), this.ctx.rect(u[0], u[1], O, B), this.ctx.clip(), this.endPath();
                                     }
-                                    this.current = new F(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...f), this.transform(...v);
+                                    this.current = new x(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...d), this.transform(...b);
                                 }
                                 endAnnotation() {
-                                    this.annotationCanvas && (this.ctx.restore(), K(this, pe, en).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
+                                    this.annotationCanvas && (this.ctx.restore(), J(this, dt, Qe).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
                                 }
-                                paintImageMaskXObject(d) {
+                                paintImageMaskXObject(l) {
                                     if (!this.contentVisible)
                                         return;
-                                    const g = d.count;
-                                    d = this.getObject(d.data, d), d.count = g;
-                                    const f = this.ctx,
-                                        v = this.processingType3;
-                                    if (v && (v.compiled === void 0 && (v.compiled = k(d)), v.compiled)) {
-                                        v.compiled(f);
+                                    const u = l.count;
+                                    l = this.getObject(l.data, l), l.count = u;
+                                    const d = this.ctx,
+                                        b = this.processingType3;
+                                    if (b && (b.compiled === void 0 && (b.compiled = C(l)), b.compiled)) {
+                                        b.compiled(d);
                                         return;
                                     }
-                                    const A = this._createMaskCanvas(d),
-                                        O = A.canvas;
-                                    f.save(), f.setTransform(1, 0, 0, 1, 0, 0), f.drawImage(O, A.offsetX, A.offsetY), f.restore(), this.compose();
+                                    const y = this._createMaskCanvas(l),
+                                        O = y.canvas;
+                                    d.save(), d.setTransform(1, 0, 0, 1, 0, 0), d.drawImage(O, y.offsetX, y.offsetY), d.restore(), this.compose();
                                 }
-                                paintImageMaskXObjectRepeat(d, g, f = 0, v = 0, A, O) {
+                                paintImageMaskXObjectRepeat(l, u, d = 0, b = 0, y, O) {
                                     if (!this.contentVisible)
                                         return;
-                                    d = this.getObject(d.data, d);
-                                    const H = this.ctx;
-                                    H.save();
-                                    const z = (0, s.getCurrentTransform)(H);
-                                    H.transform(g, f, v, A, 0, 0);
-                                    const ae = this._createMaskCanvas(d);
-                                    H.setTransform(1, 0, 0, 1, ae.offsetX - z[4], ae.offsetY - z[5]);
-                                    for (let Z = 0, ce = O.length; Z < ce; Z += 2) {
-                                        const ue = n.Util.transform(z, [g, f, v, A, O[Z], O[Z + 1]]),
-                                            [me, fe] = n.Util.applyTransform([0, 0], ue);
-                                        H.drawImage(ae.canvas, me, fe);
+                                    l = this.getObject(l.data, l);
+                                    const B = this.ctx;
+                                    B.save();
+                                    const z = (0, s.getCurrentTransform)(B);
+                                    B.transform(u, d, b, y, 0, 0);
+                                    const it = this._createMaskCanvas(l);
+                                    B.setTransform(1, 0, 0, 1, it.offsetX - z[4], it.offsetY - z[5]);
+                                    for (let Z = 0, lt = O.length; Z < lt; Z += 2) {
+                                        const ht = e.Util.transform(z, [u, d, b, y, O[Z], O[Z + 1]]),
+                                            [mt, ft] = e.Util.applyTransform([0, 0], ht);
+                                        B.drawImage(it.canvas, mt, ft);
                                     }
-                                    H.restore(), this.compose();
+                                    B.restore(), this.compose();
                                 }
-                                paintImageMaskXObjectGroup(d) {
+                                paintImageMaskXObjectGroup(l) {
                                     if (!this.contentVisible)
                                         return;
-                                    const g = this.ctx,
-                                        f = this.current.fillColor,
-                                        v = this.current.patternFill;
-                                    for (const A of d) {
+                                    const u = this.ctx,
+                                        d = this.current.fillColor,
+                                        b = this.current.patternFill;
+                                    for (const y of l) {
                                         const {
                                             data: O,
-                                            width: H,
+                                            width: B,
                                             height: z,
-                                            transform: ae
-                                        } = A, Z = this.cachedCanvases.getCanvas("maskCanvas", H, z), ce = Z.context;
-                                        ce.save();
-                                        const ue = this.getObject(O, A);
-                                        y(ce, ue), ce.globalCompositeOperation = "source-in", ce.fillStyle = v ? f.getPattern(ce, this, (0, s.getCurrentTransformInverse)(g), l.PathType.FILL) : f, ce.fillRect(0, 0, H, z), ce.restore(), g.save(), g.transform(...ae), g.scale(1, -1), b(g, Z.canvas, 0, 0, H, z, 0, -1, 1, 1), g.restore();
+                                            transform: it
+                                        } = y, Z = this.cachedCanvases.getCanvas("maskCanvas", B, z), lt = Z.context;
+                                        lt.save();
+                                        const ht = this.getObject(O, y);
+                                        S(lt, ht), lt.globalCompositeOperation = "source-in", lt.fillStyle = b ? d.getPattern(lt, this, (0, s.getCurrentTransformInverse)(u), p.PathType.FILL) : d, lt.fillRect(0, 0, B, z), lt.restore(), u.save(), u.transform(...it), u.scale(1, -1), m(u, Z.canvas, 0, 0, B, z, 0, -1, 1, 1), u.restore();
                                     }
                                     this.compose();
                                 }
-                                paintImageXObject(d) {
+                                paintImageXObject(l) {
                                     if (!this.contentVisible)
                                         return;
-                                    const g = this.getObject(d);
-                                    if (!g) {
-                                        (0, n.warn)("Dependent image isn't ready yet");
+                                    const u = this.getObject(l);
+                                    if (!u) {
+                                        (0, e.warn)("Dependent image isn't ready yet");
                                         return;
                                     }
-                                    this.paintInlineImageXObject(g);
+                                    this.paintInlineImageXObject(u);
                                 }
-                                paintImageXObjectRepeat(d, g, f, v) {
+                                paintImageXObjectRepeat(l, u, d, b) {
                                     if (!this.contentVisible)
                                         return;
-                                    const A = this.getObject(d);
-                                    if (!A) {
-                                        (0, n.warn)("Dependent image isn't ready yet");
+                                    const y = this.getObject(l);
+                                    if (!y) {
+                                        (0, e.warn)("Dependent image isn't ready yet");
                                         return;
                                     }
-                                    const O = A.width,
-                                        H = A.height,
+                                    const O = y.width,
+                                        B = y.height,
                                         z = [];
-                                    for (let ae = 0, Z = v.length; ae < Z; ae += 2)
+                                    for (let it = 0, Z = b.length; it < Z; it += 2)
                                         z.push({
-                                            transform: [g, 0, 0, f, v[ae], v[ae + 1]],
+                                            transform: [u, 0, 0, d, b[it], b[it + 1]],
                                             x: 0,
                                             y: 0,
                                             w: O,
-                                            h: H
+                                            h: B
                                         });
-                                    this.paintInlineImageXObjectGroup(A, z);
+                                    this.paintInlineImageXObjectGroup(y, z);
                                 }
-                                applyTransferMapsToCanvas(d) {
-                                    return this.current.transferMaps !== "none" && (d.filter = this.current.transferMaps, d.drawImage(d.canvas, 0, 0), d.filter = "none"), d.canvas;
+                                applyTransferMapsToCanvas(l) {
+                                    return this.current.transferMaps !== "none" && (l.filter = this.current.transferMaps, l.drawImage(l.canvas, 0, 0), l.filter = "none"), l.canvas;
                                 }
-                                applyTransferMapsToBitmap(d) {
+                                applyTransferMapsToBitmap(l) {
                                     if (this.current.transferMaps === "none")
-                                        return d.bitmap;
+                                        return l.bitmap;
                                     const {
-                                        bitmap: g,
-                                        width: f,
-                                        height: v
-                                    } = d, A = this.cachedCanvases.getCanvas("inlineImage", f, v), O = A.context;
-                                    return O.filter = this.current.transferMaps, O.drawImage(g, 0, 0), O.filter = "none", A.canvas;
+                                        bitmap: u,
+                                        width: d,
+                                        height: b
+                                    } = l, y = this.cachedCanvases.getCanvas("inlineImage", d, b), O = y.context;
+                                    return O.filter = this.current.transferMaps, O.drawImage(u, 0, 0), O.filter = "none", y.canvas;
                                 }
-                                paintInlineImageXObject(d) {
+                                paintInlineImageXObject(l) {
                                     if (!this.contentVisible)
                                         return;
-                                    const g = d.width,
-                                        f = d.height,
-                                        v = this.ctx;
-                                    if (this.save(), !n.isNodeJS) {
+                                    const u = l.width,
+                                        d = l.height,
+                                        b = this.ctx;
+                                    if (this.save(), !e.isNodeJS) {
                                         const {
-                                            filter: H
-                                        } = v;
-                                        H !== "none" && H !== "" && (v.filter = "none");
-                                    }
-                                    v.scale(1 / g, -1 / f);
-                                    let A;
-                                    if (d.bitmap)
-                                        A = this.applyTransferMapsToBitmap(d);
-                                    else if (typeof HTMLElement == "function" && d instanceof HTMLElement || !d.data)
-                                        A = d;
+                                            filter: B
+                                        } = b;
+                                        B !== "none" && B !== "" && (b.filter = "none");
+                                    }
+                                    b.scale(1 / u, -1 / d);
+                                    let y;
+                                    if (l.bitmap)
+                                        y = this.applyTransferMapsToBitmap(l);
+                                    else if (typeof HTMLElement == "function" && l instanceof HTMLElement || !l.data)
+                                        y = l;
                                     else {
-                                        const z = this.cachedCanvases.getCanvas("inlineImage", g, f).context;
-                                        x(z, d), A = this.applyTransferMapsToCanvas(z);
+                                        const z = this.cachedCanvases.getCanvas("inlineImage", u, d).context;
+                                        E(z, l), y = this.applyTransferMapsToCanvas(z);
                                     }
-                                    const O = this._scaleImage(A, (0, s.getCurrentTransformInverse)(v));
-                                    v.imageSmoothingEnabled = X((0, s.getCurrentTransform)(v), d.interpolate), b(v, O.img, 0, 0, O.paintWidth, O.paintHeight, 0, -f, g, f), this.compose(), this.restore();
+                                    const O = this._scaleImage(y, (0, s.getCurrentTransformInverse)(b));
+                                    b.imageSmoothingEnabled = X((0, s.getCurrentTransform)(b), l.interpolate), m(b, O.img, 0, 0, O.paintWidth, O.paintHeight, 0, -d, u, d), this.compose(), this.restore();
                                 }
-                                paintInlineImageXObjectGroup(d, g) {
+                                paintInlineImageXObjectGroup(l, u) {
                                     if (!this.contentVisible)
                                         return;
-                                    const f = this.ctx;
-                                    let v;
-                                    if (d.bitmap)
-                                        v = d.bitmap;
+                                    const d = this.ctx;
+                                    let b;
+                                    if (l.bitmap)
+                                        b = l.bitmap;
                                     else {
-                                        const A = d.width,
-                                            O = d.height,
-                                            z = this.cachedCanvases.getCanvas("inlineImage", A, O).context;
-                                        x(z, d), v = this.applyTransferMapsToCanvas(z);
+                                        const y = l.width,
+                                            O = l.height,
+                                            z = this.cachedCanvases.getCanvas("inlineImage", y, O).context;
+                                        E(z, l), b = this.applyTransferMapsToCanvas(z);
                                     }
-                                    for (const A of g)
-                                        f.save(), f.transform(...A.transform), f.scale(1, -1), b(f, v, A.x, A.y, A.w, A.h, 0, -1, 1, 1), f.restore();
+                                    for (const y of u)
+                                        d.save(), d.transform(...y.transform), d.scale(1, -1), m(d, b, y.x, y.y, y.w, y.h, 0, -1, 1, 1), d.restore();
                                     this.compose();
                                 }
                                 paintSolidColorImageMask() {
                                     this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
                                 }
-                                markPoint(d) {}
-                                markPointProps(d, g) {}
-                                beginMarkedContent(d) {
+                                markPoint(l) {}
+                                markPointProps(l, u) {}
+                                beginMarkedContent(l) {
                                     this.markedContentStack.push({
                                         visible: !0
                                     });
                                 }
-                                beginMarkedContentProps(d, g) {
-                                    d === "OC" ? this.markedContentStack.push({
-                                        visible: this.optionalContentConfig.isVisible(g)
+                                beginMarkedContentProps(l, u) {
+                                    l === "OC" ? this.markedContentStack.push({
+                                        visible: this.optionalContentConfig.isVisible(u)
                                     }) : this.markedContentStack.push({
                                         visible: !0
                                     }), this.contentVisible = this.isContentVisible();
                                 }
                                 endMarkedContent() {
                                     this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
                                 }
                                 beginCompat() {}
                                 endCompat() {}
-                                consumePath(d) {
-                                    const g = this.current.isEmptyClip();
-                                    this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(d);
-                                    const f = this.ctx;
-                                    this.pendingClip && (g || (this.pendingClip === ee ? f.clip("evenodd") : f.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), f.beginPath();
+                                consumePath(l) {
+                                    const u = this.current.isEmptyClip();
+                                    this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(l);
+                                    const d = this.ctx;
+                                    this.pendingClip && (u || (this.pendingClip === G ? d.clip("evenodd") : d.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), d.beginPath();
                                 }
                                 getSinglePixelWidth() {
                                     if (!this._cachedGetSinglePixelWidth) {
-                                        const d = (0, s.getCurrentTransform)(this.ctx);
-                                        if (d[1] === 0 && d[2] === 0)
-                                            this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(d[0]), Math.abs(d[3]));
+                                        const l = (0, s.getCurrentTransform)(this.ctx);
+                                        if (l[1] === 0 && l[2] === 0)
+                                            this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(l[0]), Math.abs(l[3]));
                                         else {
-                                            const g = Math.abs(d[0] * d[3] - d[2] * d[1]),
-                                                f = Math.hypot(d[0], d[2]),
-                                                v = Math.hypot(d[1], d[3]);
-                                            this._cachedGetSinglePixelWidth = Math.max(f, v) / g;
+                                            const u = Math.abs(l[0] * l[3] - l[2] * l[1]),
+                                                d = Math.hypot(l[0], l[2]),
+                                                b = Math.hypot(l[1], l[3]);
+                                            this._cachedGetSinglePixelWidth = Math.max(d, b) / u;
                                         }
                                     }
                                     return this._cachedGetSinglePixelWidth;
                                 }
                                 getScaleForStroking() {
                                     if (this._cachedScaleForStroking[0] === -1) {
                                         const {
-                                            lineWidth: d
+                                            lineWidth: l
                                         } = this.current, {
-                                            a: g,
-                                            b: f,
-                                            c: v,
-                                            d: A
+                                            a: u,
+                                            b: d,
+                                            c: b,
+                                            d: y
                                         } = this.ctx.getTransform();
-                                        let O, H;
-                                        if (f === 0 && v === 0) {
-                                            const z = Math.abs(g),
-                                                ae = Math.abs(A);
-                                            if (z === ae)
-                                                if (d === 0)
-                                                    O = H = 1 / z;
+                                        let O, B;
+                                        if (d === 0 && b === 0) {
+                                            const z = Math.abs(u),
+                                                it = Math.abs(y);
+                                            if (z === it)
+                                                if (l === 0)
+                                                    O = B = 1 / z;
                                                 else {
-                                                    const Z = z * d;
-                                                    O = H = Z < 1 ? 1 / Z : 1;
+                                                    const Z = z * l;
+                                                    O = B = Z < 1 ? 1 / Z : 1;
                                                 }
-                                            else if (d === 0)
-                                                O = 1 / z, H = 1 / ae;
+                                            else if (l === 0)
+                                                O = 1 / z, B = 1 / it;
                                             else {
-                                                const Z = z * d,
-                                                    ce = ae * d;
-                                                O = Z < 1 ? 1 / Z : 1, H = ce < 1 ? 1 / ce : 1;
+                                                const Z = z * l,
+                                                    lt = it * l;
+                                                O = Z < 1 ? 1 / Z : 1, B = lt < 1 ? 1 / lt : 1;
                                             }
                                         } else {
-                                            const z = Math.abs(g * A - f * v),
-                                                ae = Math.hypot(g, f),
-                                                Z = Math.hypot(v, A);
-                                            if (d === 0)
-                                                O = Z / z, H = ae / z;
+                                            const z = Math.abs(u * y - d * b),
+                                                it = Math.hypot(u, d),
+                                                Z = Math.hypot(b, y);
+                                            if (l === 0)
+                                                O = Z / z, B = it / z;
                                             else {
-                                                const ce = d * z;
-                                                O = Z > ce ? Z / ce : 1, H = ae > ce ? ae / ce : 1;
+                                                const lt = l * z;
+                                                O = Z > lt ? Z / lt : 1, B = it > lt ? it / lt : 1;
                                             }
                                         }
-                                        this._cachedScaleForStroking[0] = O, this._cachedScaleForStroking[1] = H;
+                                        this._cachedScaleForStroking[0] = O, this._cachedScaleForStroking[1] = B;
                                     }
                                     return this._cachedScaleForStroking;
                                 }
-                                rescaleAndStroke(d) {
+                                rescaleAndStroke(l) {
                                     const {
-                                        ctx: g
+                                        ctx: u
                                     } = this, {
-                                        lineWidth: f
-                                    } = this.current, [v, A] = this.getScaleForStroking();
-                                    if (g.lineWidth = f || 1, v === 1 && A === 1) {
-                                        g.stroke();
+                                        lineWidth: d
+                                    } = this.current, [b, y] = this.getScaleForStroking();
+                                    if (u.lineWidth = d || 1, b === 1 && y === 1) {
+                                        u.stroke();
                                         return;
                                     }
-                                    const O = g.getLineDash();
-                                    if (d && g.save(), g.scale(v, A), O.length > 0) {
-                                        const H = Math.max(v, A);
-                                        g.setLineDash(O.map((z) => z / H)), g.lineDashOffset /= H;
+                                    const O = u.getLineDash();
+                                    if (l && u.save(), u.scale(b, y), O.length > 0) {
+                                        const B = Math.max(b, y);
+                                        u.setLineDash(O.map((z) => z / B)), u.lineDashOffset /= B;
                                     }
-                                    g.stroke(), d && g.restore();
+                                    u.stroke(), l && u.restore();
                                 }
                                 isContentVisible() {
-                                    for (let d = this.markedContentStack.length - 1; d >= 0; d--)
-                                        if (!this.markedContentStack[d].visible)
+                                    for (let l = this.markedContentStack.length - 1; l >= 0; l--)
+                                        if (!this.markedContentStack[l].visible)
                                             return !1;
                                     return !0;
                                 }
                             };
-                        q = new WeakSet(), Qt = function() {
+                        H = new WeakSet(), Ze = function() {
                             for (; this.stateStack.length || this.inSMaskMode;)
                                 this.restore();
                             this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
-                        }, pe = new WeakSet(), en = function() {
+                        }, dt = new WeakSet(), Qe = function() {
                             if (this.pageColors) {
-                                const d = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
-                                if (d !== "none") {
-                                    const g = this.ctx.filter;
-                                    this.ctx.filter = d, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = g;
+                                const l = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
+                                if (l !== "none") {
+                                    const u = this.ctx.filter;
+                                    this.ctx.filter = l, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = u;
                                 }
                             }
                         };
-                        let Y = be;
-                        e.CanvasGraphics = Y;
-                        for (const R in n.OPS)
-                            Y.prototype[R] !== void 0 && (Y.prototype[n.OPS[R]] = Y.prototype[R]);
+                        let V = gt;
+                        t.CanvasGraphics = V;
+                        for (const k in e.OPS)
+                            V.prototype[k] !== void 0 && (V.prototype[e.OPS[k]] = V.prototype[k]);
                     },
                     /* 12 */
                     /***/
-                    (t, e, i) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.TilingPattern = e.PathType = void 0, e.getShadingPattern = w;
-                        var n = i(1),
-                            s = i(6);
-                        const l = {
+                        }), t.TilingPattern = t.PathType = void 0, t.getShadingPattern = w;
+                        var e = n(1),
+                            s = n(6);
+                        const p = {
                             FILL: "Fill",
                             STROKE: "Stroke",
                             SHADING: "Shading"
                         };
-                        e.PathType = l;
+                        t.PathType = p;
 
-                        function h(k, F) {
-                            if (!F)
+                        function f(C, x) {
+                            if (!x)
                                 return;
-                            const x = F[2] - F[0],
-                                y = F[3] - F[1],
-                                p = new Path2D();
-                            p.rect(F[0], F[1], x, y), k.clip(p);
+                            const E = x[2] - x[0],
+                                S = x[3] - x[1],
+                                g = new Path2D();
+                            g.rect(x[0], x[1], E, S), C.clip(g);
                         }
-                        class _ {
+                        class A {
                             constructor() {
-                                this.constructor === _ && (0, n.unreachable)("Cannot initialize BaseShadingPattern.");
+                                this.constructor === A && (0, e.unreachable)("Cannot initialize BaseShadingPattern.");
                             }
                             getPattern() {
-                                (0, n.unreachable)("Abstract method `getPattern` called.");
+                                (0, e.unreachable)("Abstract method `getPattern` called.");
                             }
                         }
-                        class c extends _ {
-                            constructor(F) {
-                                super(), this._type = F[1], this._bbox = F[2], this._colorStops = F[3], this._p0 = F[4], this._p1 = F[5], this._r0 = F[6], this._r1 = F[7], this.matrix = null;
+                        class a extends A {
+                            constructor(x) {
+                                super(), this._type = x[1], this._bbox = x[2], this._colorStops = x[3], this._p0 = x[4], this._p1 = x[5], this._r0 = x[6], this._r1 = x[7], this.matrix = null;
                             }
-                            _createGradient(F) {
-                                let x;
-                                this._type === "axial" ? x = F.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (x = F.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
-                                for (const y of this._colorStops)
-                                    x.addColorStop(y[0], y[1]);
-                                return x;
-                            }
-                            getPattern(F, x, y, p) {
+                            _createGradient(x) {
                                 let E;
-                                if (p === l.STROKE || p === l.FILL) {
-                                    const $ = x.current.getClippedPathBoundingBox(p, (0, s.getCurrentTransform)(F)) || [0, 0, 0, 0],
+                                this._type === "axial" ? E = x.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (E = x.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
+                                for (const S of this._colorStops)
+                                    E.addColorStop(S[0], S[1]);
+                                return E;
+                            }
+                            getPattern(x, E, S, g) {
+                                let v;
+                                if (g === p.STROKE || g === p.FILL) {
+                                    const $ = E.current.getClippedPathBoundingBox(g, (0, s.getCurrentTransform)(x)) || [0, 0, 0, 0],
                                         M = Math.ceil($[2] - $[0]) || 1,
-                                        m = Math.ceil($[3] - $[1]) || 1,
-                                        N = x.cachedCanvases.getCanvas("pattern", M, m, !0),
+                                        _ = Math.ceil($[3] - $[1]) || 1,
+                                        N = E.cachedCanvases.getCanvas("pattern", M, _, !0),
                                         D = N.context;
-                                    D.clearRect(0, 0, D.canvas.width, D.canvas.height), D.beginPath(), D.rect(0, 0, D.canvas.width, D.canvas.height), D.translate(-$[0], -$[1]), y = n.Util.transform(y, [1, 0, 0, 1, $[0], $[1]]), D.transform(...x.baseTransform), this.matrix && D.transform(...this.matrix), h(D, this._bbox), D.fillStyle = this._createGradient(D), D.fill(), E = F.createPattern(N.canvas, "no-repeat");
-                                    const X = new DOMMatrix(y);
-                                    E.setTransform(X);
+                                    D.clearRect(0, 0, D.canvas.width, D.canvas.height), D.beginPath(), D.rect(0, 0, D.canvas.width, D.canvas.height), D.translate(-$[0], -$[1]), S = e.Util.transform(S, [1, 0, 0, 1, $[0], $[1]]), D.transform(...E.baseTransform), this.matrix && D.transform(...this.matrix), f(D, this._bbox), D.fillStyle = this._createGradient(D), D.fill(), v = x.createPattern(N.canvas, "no-repeat");
+                                    const X = new DOMMatrix(S);
+                                    v.setTransform(X);
                                 } else
-                                    h(F, this._bbox), E = this._createGradient(F);
-                                return E;
+                                    f(x, this._bbox), v = this._createGradient(x);
+                                return v;
                             }
                         }
 
-                        function o(k, F, x, y, p, E, $, M) {
-                            const m = F.coords,
-                                N = F.colors,
-                                D = k.data,
-                                X = k.width * 4;
-                            let G;
-                            m[x + 1] > m[y + 1] && (G = x, x = y, y = G, G = E, E = $, $ = G), m[y + 1] > m[p + 1] && (G = y, y = p, p = G, G = $, $ = M, M = G), m[x + 1] > m[y + 1] && (G = x, x = y, y = G, G = E, E = $, $ = G);
-                            const I = (m[x] + F.offsetX) * F.scaleX,
-                                B = (m[x + 1] + F.offsetY) * F.scaleY,
-                                ee = (m[y] + F.offsetX) * F.scaleX,
-                                Y = (m[y + 1] + F.offsetY) * F.scaleY,
-                                q = (m[p] + F.offsetX) * F.scaleX,
-                                le = (m[p + 1] + F.offsetY) * F.scaleY;
-                            if (B >= le)
+                        function h(C, x, E, S, g, v, $, M) {
+                            const _ = x.coords,
+                                N = x.colors,
+                                D = C.data,
+                                X = C.width * 4;
+                            let Y;
+                            _[E + 1] > _[S + 1] && (Y = E, E = S, S = Y, Y = v, v = $, $ = Y), _[S + 1] > _[g + 1] && (Y = S, S = g, g = Y, Y = $, $ = M, M = Y), _[E + 1] > _[S + 1] && (Y = E, E = S, S = Y, Y = v, v = $, $ = Y);
+                            const I = (_[E] + x.offsetX) * x.scaleX,
+                                U = (_[E + 1] + x.offsetY) * x.scaleY,
+                                G = (_[S] + x.offsetX) * x.scaleX,
+                                V = (_[S + 1] + x.offsetY) * x.scaleY,
+                                H = (_[g] + x.offsetX) * x.scaleX,
+                                st = (_[g + 1] + x.offsetY) * x.scaleY;
+                            if (U >= st)
                                 return;
-                            const pe = N[E],
-                                we = N[E + 1],
-                                be = N[E + 2],
-                                R = N[$],
-                                d = N[$ + 1],
-                                g = N[$ + 2],
-                                f = N[M],
-                                v = N[M + 1],
-                                A = N[M + 2],
-                                O = Math.round(B),
-                                H = Math.round(le);
-                            let z, ae, Z, ce, ue, me, fe, Pe;
-                            for (let Fe = O; Fe <= H; Fe++) {
-                                if (Fe < Y) {
-                                    const se = Fe < B ? 0 : (B - Fe) / (B - Y);
-                                    z = I - (I - ee) * se, ae = pe - (pe - R) * se, Z = we - (we - d) * se, ce = be - (be - g) * se;
+                            const dt = N[v],
+                                yt = N[v + 1],
+                                gt = N[v + 2],
+                                k = N[$],
+                                l = N[$ + 1],
+                                u = N[$ + 2],
+                                d = N[M],
+                                b = N[M + 1],
+                                y = N[M + 2],
+                                O = Math.round(U),
+                                B = Math.round(st);
+                            let z, it, Z, lt, ht, mt, ft, kt;
+                            for (let Rt = O; Rt <= B; Rt++) {
+                                if (Rt < V) {
+                                    const at = Rt < U ? 0 : (U - Rt) / (U - V);
+                                    z = I - (I - G) * at, it = dt - (dt - k) * at, Z = yt - (yt - l) * at, lt = gt - (gt - u) * at;
                                 } else {
-                                    let se;
-                                    Fe > le ? se = 1 : Y === le ? se = 0 : se = (Y - Fe) / (Y - le), z = ee - (ee - q) * se, ae = R - (R - f) * se, Z = d - (d - v) * se, ce = g - (g - A) * se;
+                                    let at;
+                                    Rt > st ? at = 1 : V === st ? at = 0 : at = (V - Rt) / (V - st), z = G - (G - H) * at, it = k - (k - d) * at, Z = l - (l - b) * at, lt = u - (u - y) * at;
                                 }
-                                let Ee;
-                                Fe < B ? Ee = 0 : Fe > le ? Ee = 1 : Ee = (B - Fe) / (B - le), ue = I - (I - q) * Ee, me = pe - (pe - f) * Ee, fe = we - (we - v) * Ee, Pe = be - (be - A) * Ee;
-                                const De = Math.round(Math.min(z, ue)),
-                                    _e = Math.round(Math.max(z, ue));
-                                let ie = X * Fe + De * 4;
-                                for (let se = De; se <= _e; se++)
-                                    Ee = (z - se) / (z - ue), Ee < 0 ? Ee = 0 : Ee > 1 && (Ee = 1), D[ie++] = ae - (ae - me) * Ee | 0, D[ie++] = Z - (Z - fe) * Ee | 0, D[ie++] = ce - (ce - Pe) * Ee | 0, D[ie++] = 255;
+                                let St;
+                                Rt < U ? St = 0 : Rt > st ? St = 1 : St = (U - Rt) / (U - st), ht = I - (I - H) * St, mt = dt - (dt - d) * St, ft = yt - (yt - b) * St, kt = gt - (gt - y) * St;
+                                const It = Math.round(Math.min(z, ht)),
+                                    _t = Math.round(Math.max(z, ht));
+                                let rt = X * Rt + It * 4;
+                                for (let at = It; at <= _t; at++)
+                                    St = (z - at) / (z - ht), St < 0 ? St = 0 : St > 1 && (St = 1), D[rt++] = it - (it - mt) * St | 0, D[rt++] = Z - (Z - ft) * St | 0, D[rt++] = lt - (lt - kt) * St | 0, D[rt++] = 255;
                             }
                         }
 
-                        function r(k, F, x) {
-                            const y = F.coords,
-                                p = F.colors;
-                            let E, $;
-                            switch (F.type) {
+                        function o(C, x, E) {
+                            const S = x.coords,
+                                g = x.colors;
+                            let v, $;
+                            switch (x.type) {
                                 case "lattice":
-                                    const M = F.verticesPerRow,
-                                        m = Math.floor(y.length / M) - 1,
+                                    const M = x.verticesPerRow,
+                                        _ = Math.floor(S.length / M) - 1,
                                         N = M - 1;
-                                    for (E = 0; E < m; E++) {
-                                        let D = E * M;
+                                    for (v = 0; v < _; v++) {
+                                        let D = v * M;
                                         for (let X = 0; X < N; X++, D++)
-                                            o(k, x, y[D], y[D + 1], y[D + M], p[D], p[D + 1], p[D + M]), o(k, x, y[D + M + 1], y[D + 1], y[D + M], p[D + M + 1], p[D + 1], p[D + M]);
+                                            h(C, E, S[D], S[D + 1], S[D + M], g[D], g[D + 1], g[D + M]), h(C, E, S[D + M + 1], S[D + 1], S[D + M], g[D + M + 1], g[D + 1], g[D + M]);
                                     }
                                     break;
                                 case "triangles":
-                                    for (E = 0, $ = y.length; E < $; E += 3)
-                                        o(k, x, y[E], y[E + 1], y[E + 2], p[E], p[E + 1], p[E + 2]);
+                                    for (v = 0, $ = S.length; v < $; v += 3)
+                                        h(C, E, S[v], S[v + 1], S[v + 2], g[v], g[v + 1], g[v + 2]);
                                     break;
                                 default:
                                     throw new Error("illegal figure");
                             }
                         }
-                        class T extends _ {
-                            constructor(F) {
-                                super(), this._coords = F[2], this._colors = F[3], this._figures = F[4], this._bounds = F[5], this._bbox = F[7], this._background = F[8], this.matrix = null;
+                        class F extends A {
+                            constructor(x) {
+                                super(), this._coords = x[2], this._colors = x[3], this._figures = x[4], this._bounds = x[5], this._bbox = x[7], this._background = x[8], this.matrix = null;
                             }
-                            _createMeshCanvas(F, x, y) {
+                            _createMeshCanvas(x, E, S) {
                                 const M = Math.floor(this._bounds[0]),
-                                    m = Math.floor(this._bounds[1]),
+                                    _ = Math.floor(this._bounds[1]),
                                     N = Math.ceil(this._bounds[2]) - M,
-                                    D = Math.ceil(this._bounds[3]) - m,
-                                    X = Math.min(Math.ceil(Math.abs(N * F[0] * 1.1)), 3e3),
-                                    G = Math.min(Math.ceil(Math.abs(D * F[1] * 1.1)), 3e3),
+                                    D = Math.ceil(this._bounds[3]) - _,
+                                    X = Math.min(Math.ceil(Math.abs(N * x[0] * 1.1)), 3e3),
+                                    Y = Math.min(Math.ceil(Math.abs(D * x[1] * 1.1)), 3e3),
                                     I = N / X,
-                                    B = D / G,
-                                    ee = {
+                                    U = D / Y,
+                                    G = {
                                         coords: this._coords,
                                         colors: this._colors,
                                         offsetX: -M,
-                                        offsetY: -m,
+                                        offsetY: -_,
                                         scaleX: 1 / I,
-                                        scaleY: 1 / B
+                                        scaleY: 1 / U
                                     },
-                                    Y = X + 2 * 2,
-                                    q = G + 2 * 2,
-                                    le = y.getCanvas("mesh", Y, q, !1),
-                                    pe = le.context,
-                                    we = pe.createImageData(X, G);
-                                if (x) {
-                                    const R = we.data;
-                                    for (let d = 0, g = R.length; d < g; d += 4)
-                                        R[d] = x[0], R[d + 1] = x[1], R[d + 2] = x[2], R[d + 3] = 255;
-                                }
-                                for (const R of this._figures)
-                                    r(we, R, ee);
-                                return pe.putImageData(we, 2, 2), {
-                                    canvas: le.canvas,
+                                    V = X + 2 * 2,
+                                    H = Y + 2 * 2,
+                                    st = S.getCanvas("mesh", V, H, !1),
+                                    dt = st.context,
+                                    yt = dt.createImageData(X, Y);
+                                if (E) {
+                                    const k = yt.data;
+                                    for (let l = 0, u = k.length; l < u; l += 4)
+                                        k[l] = E[0], k[l + 1] = E[1], k[l + 2] = E[2], k[l + 3] = 255;
+                                }
+                                for (const k of this._figures)
+                                    o(yt, k, G);
+                                return dt.putImageData(yt, 2, 2), {
+                                    canvas: st.canvas,
                                     offsetX: M - 2 * I,
-                                    offsetY: m - 2 * B,
+                                    offsetY: _ - 2 * U,
                                     scaleX: I,
-                                    scaleY: B
+                                    scaleY: U
                                 };
                             }
-                            getPattern(F, x, y, p) {
-                                h(F, this._bbox);
-                                let E;
-                                if (p === l.SHADING)
-                                    E = n.Util.singularValueDecompose2dScale((0, s.getCurrentTransform)(F));
-                                else if (E = n.Util.singularValueDecompose2dScale(x.baseTransform), this.matrix) {
-                                    const M = n.Util.singularValueDecompose2dScale(this.matrix);
-                                    E = [E[0] * M[0], E[1] * M[1]];
+                            getPattern(x, E, S, g) {
+                                f(x, this._bbox);
+                                let v;
+                                if (g === p.SHADING)
+                                    v = e.Util.singularValueDecompose2dScale((0, s.getCurrentTransform)(x));
+                                else if (v = e.Util.singularValueDecompose2dScale(E.baseTransform), this.matrix) {
+                                    const M = e.Util.singularValueDecompose2dScale(this.matrix);
+                                    v = [v[0] * M[0], v[1] * M[1]];
                                 }
-                                const $ = this._createMeshCanvas(E, p === l.SHADING ? null : this._background, x.cachedCanvases);
-                                return p !== l.SHADING && (F.setTransform(...x.baseTransform), this.matrix && F.transform(...this.matrix)), F.translate($.offsetX, $.offsetY), F.scale($.scaleX, $.scaleY), F.createPattern($.canvas, "no-repeat");
+                                const $ = this._createMeshCanvas(v, g === p.SHADING ? null : this._background, E.cachedCanvases);
+                                return g !== p.SHADING && (x.setTransform(...E.baseTransform), this.matrix && x.transform(...this.matrix)), x.translate($.offsetX, $.offsetY), x.scale($.scaleX, $.scaleY), x.createPattern($.canvas, "no-repeat");
                             }
                         }
-                        class S extends _ {
+                        class R extends A {
                             getPattern() {
                                 return "hotpink";
                             }
                         }
 
-                        function w(k) {
-                            switch (k[0]) {
+                        function w(C) {
+                            switch (C[0]) {
                                 case "RadialAxial":
-                                    return new c(k);
+                                    return new a(C);
                                 case "Mesh":
-                                    return new T(k);
+                                    return new F(C);
                                 case "Dummy":
-                                    return new S();
+                                    return new R();
                             }
-                            throw new Error(`Unknown IR type: ${k[0]}`);
+                            throw new Error(`Unknown IR type: ${C[0]}`);
                         }
-                        const C = {
+                        const T = {
                                 COLORED: 1,
                                 UNCOLORED: 2
                             },
-                            b = class b {
-                                constructor(F, x, y, p, E) {
-                                    this.operatorList = F[2], this.matrix = F[3] || [1, 0, 0, 1, 0, 0], this.bbox = F[4], this.xstep = F[5], this.ystep = F[6], this.paintType = F[7], this.tilingType = F[8], this.color = x, this.ctx = y, this.canvasGraphicsFactory = p, this.baseTransform = E;
-                                }
-                                createPatternCanvas(F) {
-                                    const x = this.operatorList,
-                                        y = this.bbox,
-                                        p = this.xstep,
-                                        E = this.ystep,
+                            m = class m {
+                                constructor(x, E, S, g, v) {
+                                    this.operatorList = x[2], this.matrix = x[3] || [1, 0, 0, 1, 0, 0], this.bbox = x[4], this.xstep = x[5], this.ystep = x[6], this.paintType = x[7], this.tilingType = x[8], this.color = E, this.ctx = S, this.canvasGraphicsFactory = g, this.baseTransform = v;
+                                }
+                                createPatternCanvas(x) {
+                                    const E = this.operatorList,
+                                        S = this.bbox,
+                                        g = this.xstep,
+                                        v = this.ystep,
                                         $ = this.paintType,
                                         M = this.tilingType,
-                                        m = this.color,
+                                        _ = this.color,
                                         N = this.canvasGraphicsFactory;
-                                    (0, n.info)("TilingType: " + M);
-                                    const D = y[0],
-                                        X = y[1],
-                                        G = y[2],
-                                        I = y[3],
-                                        B = n.Util.singularValueDecompose2dScale(this.matrix),
-                                        ee = n.Util.singularValueDecompose2dScale(this.baseTransform),
-                                        Y = [B[0] * ee[0], B[1] * ee[1]],
-                                        q = this.getSizeAndScale(p, this.ctx.canvas.width, Y[0]),
-                                        le = this.getSizeAndScale(E, this.ctx.canvas.height, Y[1]),
-                                        pe = F.cachedCanvases.getCanvas("pattern", q.size, le.size, !0),
-                                        we = pe.context,
-                                        be = N.createCanvasGraphics(we);
-                                    be.groupLevel = F.groupLevel, this.setFillAndStrokeStyleToContext(be, $, m);
-                                    let R = D,
-                                        d = X,
-                                        g = G,
-                                        f = I;
-                                    return D < 0 && (R = 0, g += Math.abs(D)), X < 0 && (d = 0, f += Math.abs(X)), we.translate(-(q.scale * R), -(le.scale * d)), be.transform(q.scale, 0, 0, le.scale, 0, 0), we.save(), this.clipBbox(be, R, d, g, f), be.baseTransform = (0, s.getCurrentTransform)(be.ctx), be.executeOperatorList(x), be.endDrawing(), {
-                                        canvas: pe.canvas,
-                                        scaleX: q.scale,
-                                        scaleY: le.scale,
-                                        offsetX: R,
-                                        offsetY: d
+                                    (0, e.info)("TilingType: " + M);
+                                    const D = S[0],
+                                        X = S[1],
+                                        Y = S[2],
+                                        I = S[3],
+                                        U = e.Util.singularValueDecompose2dScale(this.matrix),
+                                        G = e.Util.singularValueDecompose2dScale(this.baseTransform),
+                                        V = [U[0] * G[0], U[1] * G[1]],
+                                        H = this.getSizeAndScale(g, this.ctx.canvas.width, V[0]),
+                                        st = this.getSizeAndScale(v, this.ctx.canvas.height, V[1]),
+                                        dt = x.cachedCanvases.getCanvas("pattern", H.size, st.size, !0),
+                                        yt = dt.context,
+                                        gt = N.createCanvasGraphics(yt);
+                                    gt.groupLevel = x.groupLevel, this.setFillAndStrokeStyleToContext(gt, $, _);
+                                    let k = D,
+                                        l = X,
+                                        u = Y,
+                                        d = I;
+                                    return D < 0 && (k = 0, u += Math.abs(D)), X < 0 && (l = 0, d += Math.abs(X)), yt.translate(-(H.scale * k), -(st.scale * l)), gt.transform(H.scale, 0, 0, st.scale, 0, 0), yt.save(), this.clipBbox(gt, k, l, u, d), gt.baseTransform = (0, s.getCurrentTransform)(gt.ctx), gt.executeOperatorList(E), gt.endDrawing(), {
+                                        canvas: dt.canvas,
+                                        scaleX: H.scale,
+                                        scaleY: st.scale,
+                                        offsetX: k,
+                                        offsetY: l
                                     };
                                 }
-                                getSizeAndScale(F, x, y) {
-                                    F = Math.abs(F);
-                                    const p = Math.max(b.MAX_PATTERN_SIZE, x);
-                                    let E = Math.ceil(F * y);
-                                    return E >= p ? E = p : y = E / F, {
-                                        scale: y,
-                                        size: E
+                                getSizeAndScale(x, E, S) {
+                                    x = Math.abs(x);
+                                    const g = Math.max(m.MAX_PATTERN_SIZE, E);
+                                    let v = Math.ceil(x * S);
+                                    return v >= g ? v = g : S = v / x, {
+                                        scale: S,
+                                        size: v
                                     };
                                 }
-                                clipBbox(F, x, y, p, E) {
-                                    const $ = p - x,
-                                        M = E - y;
-                                    F.ctx.rect(x, y, $, M), F.current.updateRectMinMax((0, s.getCurrentTransform)(F.ctx), [x, y, p, E]), F.clip(), F.endPath();
-                                }
-                                setFillAndStrokeStyleToContext(F, x, y) {
-                                    const p = F.ctx,
-                                        E = F.current;
-                                    switch (x) {
-                                        case C.COLORED:
+                                clipBbox(x, E, S, g, v) {
+                                    const $ = g - E,
+                                        M = v - S;
+                                    x.ctx.rect(E, S, $, M), x.current.updateRectMinMax((0, s.getCurrentTransform)(x.ctx), [E, S, g, v]), x.clip(), x.endPath();
+                                }
+                                setFillAndStrokeStyleToContext(x, E, S) {
+                                    const g = x.ctx,
+                                        v = x.current;
+                                    switch (E) {
+                                        case T.COLORED:
                                             const $ = this.ctx;
-                                            p.fillStyle = $.fillStyle, p.strokeStyle = $.strokeStyle, E.fillColor = $.fillStyle, E.strokeColor = $.strokeStyle;
+                                            g.fillStyle = $.fillStyle, g.strokeStyle = $.strokeStyle, v.fillColor = $.fillStyle, v.strokeColor = $.strokeStyle;
                                             break;
-                                        case C.UNCOLORED:
-                                            const M = n.Util.makeHexColor(y[0], y[1], y[2]);
-                                            p.fillStyle = M, p.strokeStyle = M, E.fillColor = M, E.strokeColor = M;
+                                        case T.UNCOLORED:
+                                            const M = e.Util.makeHexColor(S[0], S[1], S[2]);
+                                            g.fillStyle = M, g.strokeStyle = M, v.fillColor = M, v.strokeColor = M;
                                             break;
                                         default:
-                                            throw new n.FormatError(`Unsupported paint type: ${x}`);
+                                            throw new e.FormatError(`Unsupported paint type: ${E}`);
                                     }
                                 }
-                                getPattern(F, x, y, p) {
-                                    let E = y;
-                                    p !== l.SHADING && (E = n.Util.transform(E, x.baseTransform), this.matrix && (E = n.Util.transform(E, this.matrix)));
-                                    const $ = this.createPatternCanvas(x);
-                                    let M = new DOMMatrix(E);
+                                getPattern(x, E, S, g) {
+                                    let v = S;
+                                    g !== p.SHADING && (v = e.Util.transform(v, E.baseTransform), this.matrix && (v = e.Util.transform(v, this.matrix)));
+                                    const $ = this.createPatternCanvas(E);
+                                    let M = new DOMMatrix(v);
                                     M = M.translate($.offsetX, $.offsetY), M = M.scale(1 / $.scaleX, 1 / $.scaleY);
-                                    const m = F.createPattern($.canvas, "repeat");
-                                    return m.setTransform(M), m;
+                                    const _ = x.createPattern($.canvas, "repeat");
+                                    return _.setTransform(M), _;
                                 }
                             };
-                        nt(b, "MAX_PATTERN_SIZE", 3e3);
-                        let P = b;
-                        e.TilingPattern = P;
+                        ee(m, "MAX_PATTERN_SIZE", 3e3);
+                        let P = m;
+                        t.TilingPattern = P;
                     },
                     /* 13 */
                     /***/
-                    (t, e, i) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.convertBlackAndWhiteToRGBA = l, e.convertToRGBA = s, e.grayToRGBA = _;
-                        var n = i(1);
+                        }), t.convertBlackAndWhiteToRGBA = p, t.convertToRGBA = s, t.grayToRGBA = A;
+                        var e = n(1);
 
-                        function s(c) {
-                            switch (c.kind) {
-                                case n.ImageKind.GRAYSCALE_1BPP:
-                                    return l(c);
-                                case n.ImageKind.RGB_24BPP:
-                                    return h(c);
+                        function s(a) {
+                            switch (a.kind) {
+                                case e.ImageKind.GRAYSCALE_1BPP:
+                                    return p(a);
+                                case e.ImageKind.RGB_24BPP:
+                                    return f(a);
                             }
                             return null;
                         }
 
-                        function l({
-                            src: c,
-                            srcPos: o = 0,
-                            dest: r,
-                            width: T,
-                            height: S,
+                        function p({
+                            src: a,
+                            srcPos: h = 0,
+                            dest: o,
+                            width: F,
+                            height: R,
                             nonBlackColor: w = 4294967295,
-                            inverseDecode: C = !1
+                            inverseDecode: T = !1
                         }) {
-                            const P = n.FeatureTest.isLittleEndian ? 4278190080 : 255,
-                                [b, k] = C ? [w, P] : [P, w],
-                                F = T >> 3,
-                                x = T & 7,
-                                y = c.length;
-                            r = new Uint32Array(r.buffer);
-                            let p = 0;
-                            for (let E = 0; E < S; E++) {
-                                for (const M = o + F; o < M; o++) {
-                                    const m = o < y ? c[o] : 255;
-                                    r[p++] = m & 128 ? k : b, r[p++] = m & 64 ? k : b, r[p++] = m & 32 ? k : b, r[p++] = m & 16 ? k : b, r[p++] = m & 8 ? k : b, r[p++] = m & 4 ? k : b, r[p++] = m & 2 ? k : b, r[p++] = m & 1 ? k : b;
+                            const P = e.FeatureTest.isLittleEndian ? 4278190080 : 255,
+                                [m, C] = T ? [w, P] : [P, w],
+                                x = F >> 3,
+                                E = F & 7,
+                                S = a.length;
+                            o = new Uint32Array(o.buffer);
+                            let g = 0;
+                            for (let v = 0; v < R; v++) {
+                                for (const M = h + x; h < M; h++) {
+                                    const _ = h < S ? a[h] : 255;
+                                    o[g++] = _ & 128 ? C : m, o[g++] = _ & 64 ? C : m, o[g++] = _ & 32 ? C : m, o[g++] = _ & 16 ? C : m, o[g++] = _ & 8 ? C : m, o[g++] = _ & 4 ? C : m, o[g++] = _ & 2 ? C : m, o[g++] = _ & 1 ? C : m;
                                 }
-                                if (x === 0)
+                                if (E === 0)
                                     continue;
-                                const $ = o < y ? c[o++] : 255;
-                                for (let M = 0; M < x; M++)
-                                    r[p++] = $ & 1 << 7 - M ? k : b;
+                                const $ = h < S ? a[h++] : 255;
+                                for (let M = 0; M < E; M++)
+                                    o[g++] = $ & 1 << 7 - M ? C : m;
                             }
                             return {
-                                srcPos: o,
-                                destPos: p
+                                srcPos: h,
+                                destPos: g
                             };
                         }
 
-                        function h({
-                            src: c,
-                            srcPos: o = 0,
-                            dest: r,
-                            destPos: T = 0,
-                            width: S,
+                        function f({
+                            src: a,
+                            srcPos: h = 0,
+                            dest: o,
+                            destPos: F = 0,
+                            width: R,
                             height: w
                         }) {
-                            let C = 0;
-                            const P = c.length >> 2,
-                                b = new Uint32Array(c.buffer, o, P);
-                            if (n.FeatureTest.isLittleEndian) {
-                                for (; C < P - 2; C += 3, T += 4) {
-                                    const k = b[C],
-                                        F = b[C + 1],
-                                        x = b[C + 2];
-                                    r[T] = k | 4278190080, r[T + 1] = k >>> 24 | F << 8 | 4278190080, r[T + 2] = F >>> 16 | x << 16 | 4278190080, r[T + 3] = x >>> 8 | 4278190080;
+                            let T = 0;
+                            const P = a.length >> 2,
+                                m = new Uint32Array(a.buffer, h, P);
+                            if (e.FeatureTest.isLittleEndian) {
+                                for (; T < P - 2; T += 3, F += 4) {
+                                    const C = m[T],
+                                        x = m[T + 1],
+                                        E = m[T + 2];
+                                    o[F] = C | 4278190080, o[F + 1] = C >>> 24 | x << 8 | 4278190080, o[F + 2] = x >>> 16 | E << 16 | 4278190080, o[F + 3] = E >>> 8 | 4278190080;
                                 }
-                                for (let k = C * 4, F = c.length; k < F; k += 3)
-                                    r[T++] = c[k] | c[k + 1] << 8 | c[k + 2] << 16 | 4278190080;
+                                for (let C = T * 4, x = a.length; C < x; C += 3)
+                                    o[F++] = a[C] | a[C + 1] << 8 | a[C + 2] << 16 | 4278190080;
                             } else {
-                                for (; C < P - 2; C += 3, T += 4) {
-                                    const k = b[C],
-                                        F = b[C + 1],
-                                        x = b[C + 2];
-                                    r[T] = k | 255, r[T + 1] = k << 24 | F >>> 8 | 255, r[T + 2] = F << 16 | x >>> 16 | 255, r[T + 3] = x << 8 | 255;
+                                for (; T < P - 2; T += 3, F += 4) {
+                                    const C = m[T],
+                                        x = m[T + 1],
+                                        E = m[T + 2];
+                                    o[F] = C | 255, o[F + 1] = C << 24 | x >>> 8 | 255, o[F + 2] = x << 16 | E >>> 16 | 255, o[F + 3] = E << 8 | 255;
                                 }
-                                for (let k = C * 4, F = c.length; k < F; k += 3)
-                                    r[T++] = c[k] << 24 | c[k + 1] << 16 | c[k + 2] << 8 | 255;
+                                for (let C = T * 4, x = a.length; C < x; C += 3)
+                                    o[F++] = a[C] << 24 | a[C + 1] << 16 | a[C + 2] << 8 | 255;
                             }
                             return {
-                                srcPos: o,
-                                destPos: T
+                                srcPos: h,
+                                destPos: F
                             };
                         }
 
-                        function _(c, o) {
-                            if (n.FeatureTest.isLittleEndian)
-                                for (let r = 0, T = c.length; r < T; r++)
-                                    o[r] = c[r] * 65793 | 4278190080;
+                        function A(a, h) {
+                            if (e.FeatureTest.isLittleEndian)
+                                for (let o = 0, F = a.length; o < F; o++)
+                                    h[o] = a[o] * 65793 | 4278190080;
                             else
-                                for (let r = 0, T = c.length; r < T; r++)
-                                    o[r] = c[r] * 16843008 | 255;
+                                for (let o = 0, F = a.length; o < F; o++)
+                                    h[o] = a[o] * 16843008 | 255;
                         }
                     },
                     /* 14 */
                     /***/
-                    (t, e) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.GlobalWorkerOptions = void 0;
-                        const i = /* @__PURE__ */ Object.create(null);
-                        e.GlobalWorkerOptions = i, i.workerPort = null, i.workerSrc = "";
+                        }), t.GlobalWorkerOptions = void 0;
+                        const n = /* @__PURE__ */ Object.create(null);
+                        t.GlobalWorkerOptions = n, n.workerPort = null, n.workerSrc = "";
                     },
                     /* 15 */
                     /***/
-                    (t, e, i) => {
-                        var c, Mn, r, Fn, S, kt;
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        var a, Mn, o, Rn, R, Pe;
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.MessageHandler = void 0;
-                        var n = i(1);
+                        }), t.MessageHandler = void 0;
+                        var e = n(1);
                         const s = {
                                 UNKNOWN: 0,
                                 DATA: 1,
                                 ERROR: 2
                             },
-                            l = {
+                            p = {
                                 UNKNOWN: 0,
                                 CANCEL: 1,
                                 CANCEL_COMPLETE: 2,
                                 CLOSE: 3,
                                 ENQUEUE: 4,
                                 ERROR: 5,
                                 PULL: 6,
                                 PULL_COMPLETE: 7,
                                 START_COMPLETE: 8
                             };
 
-                        function h(C) {
-                            switch (C instanceof Error || typeof C == "object" && C !== null || (0, n.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), C.name) {
+                        function f(T) {
+                            switch (T instanceof Error || typeof T == "object" && T !== null || (0, e.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), T.name) {
                                 case "AbortException":
-                                    return new n.AbortException(C.message);
+                                    return new e.AbortException(T.message);
                                 case "MissingPDFException":
-                                    return new n.MissingPDFException(C.message);
+                                    return new e.MissingPDFException(T.message);
                                 case "PasswordException":
-                                    return new n.PasswordException(C.message, C.code);
+                                    return new e.PasswordException(T.message, T.code);
                                 case "UnexpectedResponseException":
-                                    return new n.UnexpectedResponseException(C.message, C.status);
+                                    return new e.UnexpectedResponseException(T.message, T.status);
                                 case "UnknownErrorException":
-                                    return new n.UnknownErrorException(C.message, C.details);
+                                    return new e.UnknownErrorException(T.message, T.details);
                                 default:
-                                    return new n.UnknownErrorException(C.message, C.toString());
+                                    return new e.UnknownErrorException(T.message, T.toString());
                             }
                         }
-                        class _ {
-                            constructor(P, b, k) {
-                                W(this, c);
-                                W(this, r);
-                                W(this, S);
-                                this.sourceName = P, this.targetName = b, this.comObj = k, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (F) => {
-                                    const x = F.data;
-                                    if (x.targetName !== this.sourceName)
+                        class A {
+                            constructor(P, m, C) {
+                                W(this, a);
+                                W(this, o);
+                                W(this, R);
+                                this.sourceName = P, this.targetName = m, this.comObj = C, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (x) => {
+                                    const E = x.data;
+                                    if (E.targetName !== this.sourceName)
                                         return;
-                                    if (x.stream) {
-                                        K(this, r, Fn).call(this, x);
+                                    if (E.stream) {
+                                        J(this, o, Rn).call(this, E);
                                         return;
                                     }
-                                    if (x.callback) {
-                                        const p = x.callbackId,
-                                            E = this.callbackCapabilities[p];
-                                        if (!E)
-                                            throw new Error(`Cannot resolve callback ${p}`);
-                                        if (delete this.callbackCapabilities[p], x.callback === s.DATA)
-                                            E.resolve(x.data);
-                                        else if (x.callback === s.ERROR)
-                                            E.reject(h(x.reason));
+                                    if (E.callback) {
+                                        const g = E.callbackId,
+                                            v = this.callbackCapabilities[g];
+                                        if (!v)
+                                            throw new Error(`Cannot resolve callback ${g}`);
+                                        if (delete this.callbackCapabilities[g], E.callback === s.DATA)
+                                            v.resolve(E.data);
+                                        else if (E.callback === s.ERROR)
+                                            v.reject(f(E.reason));
                                         else
                                             throw new Error("Unexpected callback case");
                                         return;
                                     }
-                                    const y = this.actionHandler[x.action];
-                                    if (!y)
-                                        throw new Error(`Unknown action from worker: ${x.action}`);
-                                    if (x.callbackId) {
-                                        const p = this.sourceName,
-                                            E = x.sourceName;
+                                    const S = this.actionHandler[E.action];
+                                    if (!S)
+                                        throw new Error(`Unknown action from worker: ${E.action}`);
+                                    if (E.callbackId) {
+                                        const g = this.sourceName,
+                                            v = E.sourceName;
                                         new Promise(function($) {
-                                            $(y(x.data));
+                                            $(S(E.data));
                                         }).then(function($) {
-                                            k.postMessage({
-                                                sourceName: p,
-                                                targetName: E,
+                                            C.postMessage({
+                                                sourceName: g,
+                                                targetName: v,
                                                 callback: s.DATA,
-                                                callbackId: x.callbackId,
+                                                callbackId: E.callbackId,
                                                 data: $
                                             });
                                         }, function($) {
-                                            k.postMessage({
-                                                sourceName: p,
-                                                targetName: E,
+                                            C.postMessage({
+                                                sourceName: g,
+                                                targetName: v,
                                                 callback: s.ERROR,
-                                                callbackId: x.callbackId,
-                                                reason: h($)
+                                                callbackId: E.callbackId,
+                                                reason: f($)
                                             });
                                         });
                                         return;
                                     }
-                                    if (x.streamId) {
-                                        K(this, c, Mn).call(this, x);
+                                    if (E.streamId) {
+                                        J(this, a, Mn).call(this, E);
                                         return;
                                     }
-                                    y(x.data);
-                                }, k.addEventListener("message", this._onComObjOnMessage);
+                                    S(E.data);
+                                }, C.addEventListener("message", this._onComObjOnMessage);
                             }
-                            on(P, b) {
-                                const k = this.actionHandler;
-                                if (k[P])
+                            on(P, m) {
+                                const C = this.actionHandler;
+                                if (C[P])
                                     throw new Error(`There is already an actionName called "${P}"`);
-                                k[P] = b;
+                                C[P] = m;
                             }
-                            send(P, b, k) {
+                            send(P, m, C) {
                                 this.comObj.postMessage({
                                     sourceName: this.sourceName,
                                     targetName: this.targetName,
                                     action: P,
-                                    data: b
-                                }, k);
+                                    data: m
+                                }, C);
                             }
-                            sendWithPromise(P, b, k) {
-                                const F = this.callbackId++,
-                                    x = new n.PromiseCapability();
-                                this.callbackCapabilities[F] = x;
+                            sendWithPromise(P, m, C) {
+                                const x = this.callbackId++,
+                                    E = new e.PromiseCapability();
+                                this.callbackCapabilities[x] = E;
                                 try {
                                     this.comObj.postMessage({
                                         sourceName: this.sourceName,
                                         targetName: this.targetName,
                                         action: P,
-                                        callbackId: F,
-                                        data: b
-                                    }, k);
-                                } catch (y) {
-                                    x.reject(y);
-                                }
-                                return x.promise;
-                            }
-                            sendWithStream(P, b, k, F) {
-                                const x = this.streamId++,
-                                    y = this.sourceName,
-                                    p = this.targetName,
-                                    E = this.comObj;
+                                        callbackId: x,
+                                        data: m
+                                    }, C);
+                                } catch (S) {
+                                    E.reject(S);
+                                }
+                                return E.promise;
+                            }
+                            sendWithStream(P, m, C, x) {
+                                const E = this.streamId++,
+                                    S = this.sourceName,
+                                    g = this.targetName,
+                                    v = this.comObj;
                                 return new ReadableStream({
                                     start: ($) => {
-                                        const M = new n.PromiseCapability();
-                                        return this.streamControllers[x] = {
+                                        const M = new e.PromiseCapability();
+                                        return this.streamControllers[E] = {
                                             controller: $,
                                             startCall: M,
                                             pullCall: null,
                                             cancelCall: null,
                                             isClosed: !1
-                                        }, E.postMessage({
-                                            sourceName: y,
-                                            targetName: p,
+                                        }, v.postMessage({
+                                            sourceName: S,
+                                            targetName: g,
                                             action: P,
-                                            streamId: x,
-                                            data: b,
+                                            streamId: E,
+                                            data: m,
                                             desiredSize: $.desiredSize
-                                        }, F), M.promise;
+                                        }, x), M.promise;
                                     },
                                     pull: ($) => {
-                                        const M = new n.PromiseCapability();
-                                        return this.streamControllers[x].pullCall = M, E.postMessage({
-                                            sourceName: y,
-                                            targetName: p,
-                                            stream: l.PULL,
-                                            streamId: x,
+                                        const M = new e.PromiseCapability();
+                                        return this.streamControllers[E].pullCall = M, v.postMessage({
+                                            sourceName: S,
+                                            targetName: g,
+                                            stream: p.PULL,
+                                            streamId: E,
                                             desiredSize: $.desiredSize
                                         }), M.promise;
                                     },
                                     cancel: ($) => {
-                                        (0, n.assert)($ instanceof Error, "cancel must have a valid reason");
-                                        const M = new n.PromiseCapability();
-                                        return this.streamControllers[x].cancelCall = M, this.streamControllers[x].isClosed = !0, E.postMessage({
-                                            sourceName: y,
-                                            targetName: p,
-                                            stream: l.CANCEL,
-                                            streamId: x,
-                                            reason: h($)
+                                        (0, e.assert)($ instanceof Error, "cancel must have a valid reason");
+                                        const M = new e.PromiseCapability();
+                                        return this.streamControllers[E].cancelCall = M, this.streamControllers[E].isClosed = !0, v.postMessage({
+                                            sourceName: S,
+                                            targetName: g,
+                                            stream: p.CANCEL,
+                                            streamId: E,
+                                            reason: f($)
                                         }), M.promise;
                                     }
-                                }, k);
+                                }, C);
                             }
                             destroy() {
                                 this.comObj.removeEventListener("message", this._onComObjOnMessage);
                             }
                         }
-                        c = new WeakSet(), Mn = function(P) {
-                            const b = P.streamId,
-                                k = this.sourceName,
-                                F = P.sourceName,
-                                x = this.comObj,
-                                y = this,
-                                p = this.actionHandler[P.action],
-                                E = {
-                                    enqueue($, M = 1, m) {
+                        a = new WeakSet(), Mn = function(P) {
+                            const m = P.streamId,
+                                C = this.sourceName,
+                                x = P.sourceName,
+                                E = this.comObj,
+                                S = this,
+                                g = this.actionHandler[P.action],
+                                v = {
+                                    enqueue($, M = 1, _) {
                                         if (this.isCancelled)
                                             return;
                                         const N = this.desiredSize;
-                                        this.desiredSize -= M, N > 0 && this.desiredSize <= 0 && (this.sinkCapability = new n.PromiseCapability(), this.ready = this.sinkCapability.promise), x.postMessage({
-                                            sourceName: k,
-                                            targetName: F,
-                                            stream: l.ENQUEUE,
-                                            streamId: b,
+                                        this.desiredSize -= M, N > 0 && this.desiredSize <= 0 && (this.sinkCapability = new e.PromiseCapability(), this.ready = this.sinkCapability.promise), E.postMessage({
+                                            sourceName: C,
+                                            targetName: x,
+                                            stream: p.ENQUEUE,
+                                            streamId: m,
                                             chunk: $
-                                        }, m);
+                                        }, _);
                                     },
                                     close() {
-                                        this.isCancelled || (this.isCancelled = !0, x.postMessage({
-                                            sourceName: k,
-                                            targetName: F,
-                                            stream: l.CLOSE,
-                                            streamId: b
-                                        }), delete y.streamSinks[b]);
+                                        this.isCancelled || (this.isCancelled = !0, E.postMessage({
+                                            sourceName: C,
+                                            targetName: x,
+                                            stream: p.CLOSE,
+                                            streamId: m
+                                        }), delete S.streamSinks[m]);
                                     },
                                     error($) {
-                                        (0, n.assert)($ instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, x.postMessage({
-                                            sourceName: k,
-                                            targetName: F,
-                                            stream: l.ERROR,
-                                            streamId: b,
-                                            reason: h($)
+                                        (0, e.assert)($ instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, E.postMessage({
+                                            sourceName: C,
+                                            targetName: x,
+                                            stream: p.ERROR,
+                                            streamId: m,
+                                            reason: f($)
                                         }));
                                     },
-                                    sinkCapability: new n.PromiseCapability(),
+                                    sinkCapability: new e.PromiseCapability(),
                                     onPull: null,
                                     onCancel: null,
                                     isCancelled: !1,
                                     desiredSize: P.desiredSize,
                                     ready: null
                                 };
-                            E.sinkCapability.resolve(), E.ready = E.sinkCapability.promise, this.streamSinks[b] = E, new Promise(function($) {
-                                $(p(P.data, E));
+                            v.sinkCapability.resolve(), v.ready = v.sinkCapability.promise, this.streamSinks[m] = v, new Promise(function($) {
+                                $(g(P.data, v));
                             }).then(function() {
-                                x.postMessage({
-                                    sourceName: k,
-                                    targetName: F,
-                                    stream: l.START_COMPLETE,
-                                    streamId: b,
+                                E.postMessage({
+                                    sourceName: C,
+                                    targetName: x,
+                                    stream: p.START_COMPLETE,
+                                    streamId: m,
                                     success: !0
                                 });
                             }, function($) {
-                                x.postMessage({
-                                    sourceName: k,
-                                    targetName: F,
-                                    stream: l.START_COMPLETE,
-                                    streamId: b,
-                                    reason: h($)
+                                E.postMessage({
+                                    sourceName: C,
+                                    targetName: x,
+                                    stream: p.START_COMPLETE,
+                                    streamId: m,
+                                    reason: f($)
                                 });
                             });
-                        }, r = new WeakSet(), Fn = function(P) {
-                            const b = P.streamId,
-                                k = this.sourceName,
-                                F = P.sourceName,
-                                x = this.comObj,
-                                y = this.streamControllers[b],
-                                p = this.streamSinks[b];
+                        }, o = new WeakSet(), Rn = function(P) {
+                            const m = P.streamId,
+                                C = this.sourceName,
+                                x = P.sourceName,
+                                E = this.comObj,
+                                S = this.streamControllers[m],
+                                g = this.streamSinks[m];
                             switch (P.stream) {
-                                case l.START_COMPLETE:
-                                    P.success ? y.startCall.resolve() : y.startCall.reject(h(P.reason));
+                                case p.START_COMPLETE:
+                                    P.success ? S.startCall.resolve() : S.startCall.reject(f(P.reason));
                                     break;
-                                case l.PULL_COMPLETE:
-                                    P.success ? y.pullCall.resolve() : y.pullCall.reject(h(P.reason));
+                                case p.PULL_COMPLETE:
+                                    P.success ? S.pullCall.resolve() : S.pullCall.reject(f(P.reason));
                                     break;
-                                case l.PULL:
-                                    if (!p) {
-                                        x.postMessage({
-                                            sourceName: k,
-                                            targetName: F,
-                                            stream: l.PULL_COMPLETE,
-                                            streamId: b,
+                                case p.PULL:
+                                    if (!g) {
+                                        E.postMessage({
+                                            sourceName: C,
+                                            targetName: x,
+                                            stream: p.PULL_COMPLETE,
+                                            streamId: m,
                                             success: !0
                                         });
                                         break;
                                     }
-                                    p.desiredSize <= 0 && P.desiredSize > 0 && p.sinkCapability.resolve(), p.desiredSize = P.desiredSize, new Promise(function(E) {
+                                    g.desiredSize <= 0 && P.desiredSize > 0 && g.sinkCapability.resolve(), g.desiredSize = P.desiredSize, new Promise(function(v) {
                                         var $;
-                                        E(($ = p.onPull) == null ? void 0 : $.call(p));
+                                        v(($ = g.onPull) == null ? void 0 : $.call(g));
                                     }).then(function() {
-                                        x.postMessage({
-                                            sourceName: k,
-                                            targetName: F,
-                                            stream: l.PULL_COMPLETE,
-                                            streamId: b,
+                                        E.postMessage({
+                                            sourceName: C,
+                                            targetName: x,
+                                            stream: p.PULL_COMPLETE,
+                                            streamId: m,
                                             success: !0
                                         });
-                                    }, function(E) {
-                                        x.postMessage({
-                                            sourceName: k,
-                                            targetName: F,
-                                            stream: l.PULL_COMPLETE,
-                                            streamId: b,
-                                            reason: h(E)
+                                    }, function(v) {
+                                        E.postMessage({
+                                            sourceName: C,
+                                            targetName: x,
+                                            stream: p.PULL_COMPLETE,
+                                            streamId: m,
+                                            reason: f(v)
                                         });
                                     });
                                     break;
-                                case l.ENQUEUE:
-                                    if ((0, n.assert)(y, "enqueue should have stream controller"), y.isClosed)
+                                case p.ENQUEUE:
+                                    if ((0, e.assert)(S, "enqueue should have stream controller"), S.isClosed)
                                         break;
-                                    y.controller.enqueue(P.chunk);
+                                    S.controller.enqueue(P.chunk);
                                     break;
-                                case l.CLOSE:
-                                    if ((0, n.assert)(y, "close should have stream controller"), y.isClosed)
+                                case p.CLOSE:
+                                    if ((0, e.assert)(S, "close should have stream controller"), S.isClosed)
                                         break;
-                                    y.isClosed = !0, y.controller.close(), K(this, S, kt).call(this, y, b);
+                                    S.isClosed = !0, S.controller.close(), J(this, R, Pe).call(this, S, m);
                                     break;
-                                case l.ERROR:
-                                    (0, n.assert)(y, "error should have stream controller"), y.controller.error(h(P.reason)), K(this, S, kt).call(this, y, b);
+                                case p.ERROR:
+                                    (0, e.assert)(S, "error should have stream controller"), S.controller.error(f(P.reason)), J(this, R, Pe).call(this, S, m);
                                     break;
-                                case l.CANCEL_COMPLETE:
-                                    P.success ? y.cancelCall.resolve() : y.cancelCall.reject(h(P.reason)), K(this, S, kt).call(this, y, b);
+                                case p.CANCEL_COMPLETE:
+                                    P.success ? S.cancelCall.resolve() : S.cancelCall.reject(f(P.reason)), J(this, R, Pe).call(this, S, m);
                                     break;
-                                case l.CANCEL:
-                                    if (!p)
+                                case p.CANCEL:
+                                    if (!g)
                                         break;
-                                    new Promise(function(E) {
+                                    new Promise(function(v) {
                                         var $;
-                                        E(($ = p.onCancel) == null ? void 0 : $.call(p, h(P.reason)));
+                                        v(($ = g.onCancel) == null ? void 0 : $.call(g, f(P.reason)));
                                     }).then(function() {
-                                        x.postMessage({
-                                            sourceName: k,
-                                            targetName: F,
-                                            stream: l.CANCEL_COMPLETE,
-                                            streamId: b,
+                                        E.postMessage({
+                                            sourceName: C,
+                                            targetName: x,
+                                            stream: p.CANCEL_COMPLETE,
+                                            streamId: m,
                                             success: !0
                                         });
-                                    }, function(E) {
-                                        x.postMessage({
-                                            sourceName: k,
-                                            targetName: F,
-                                            stream: l.CANCEL_COMPLETE,
-                                            streamId: b,
-                                            reason: h(E)
+                                    }, function(v) {
+                                        E.postMessage({
+                                            sourceName: C,
+                                            targetName: x,
+                                            stream: p.CANCEL_COMPLETE,
+                                            streamId: m,
+                                            reason: f(v)
                                         });
-                                    }), p.sinkCapability.reject(h(P.reason)), p.isCancelled = !0, delete this.streamSinks[b];
+                                    }), g.sinkCapability.reject(f(P.reason)), g.isCancelled = !0, delete this.streamSinks[m];
                                     break;
                                 default:
                                     throw new Error("Unexpected stream case");
                             }
-                        }, S = new WeakSet(), kt = async function(P, b) {
-                            var k, F, x;
-                            await Promise.allSettled([(k = P.startCall) == null ? void 0 : k.promise, (F = P.pullCall) == null ? void 0 : F.promise, (x = P.cancelCall) == null ? void 0 : x.promise]), delete this.streamControllers[b];
-                        }, e.MessageHandler = _;
+                        }, R = new WeakSet(), Pe = async function(P, m) {
+                            var C, x, E;
+                            await Promise.allSettled([(C = P.startCall) == null ? void 0 : C.promise, (x = P.pullCall) == null ? void 0 : x.promise, (E = P.cancelCall) == null ? void 0 : E.promise]), delete this.streamControllers[m];
+                        }, t.MessageHandler = A;
                     },
                     /* 16 */
                     /***/
-                    (t, e, i) => {
-                        var l, h;
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        var p, f;
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.Metadata = void 0;
-                        var n = i(1);
+                        }), t.Metadata = void 0;
+                        var e = n(1);
                         class s {
                             constructor({
-                                parsedData: c,
-                                rawData: o
+                                parsedData: a,
+                                rawData: h
                             }) {
-                                W(this, l, void 0);
-                                W(this, h, void 0);
-                                oe(this, l, c), oe(this, h, o);
+                                W(this, p, void 0);
+                                W(this, f, void 0);
+                                ot(this, p, a), ot(this, f, h);
                             }
                             getRaw() {
-                                return a(this, h);
+                                return r(this, f);
                             }
-                            get(c) {
-                                return a(this, l).get(c) ?? null;
+                            get(a) {
+                                return r(this, p).get(a) ?? null;
                             }
                             getAll() {
-                                return (0, n.objectFromMap)(a(this, l));
+                                return (0, e.objectFromMap)(r(this, p));
                             }
-                            has(c) {
-                                return a(this, l).has(c);
+                            has(a) {
+                                return r(this, p).has(a);
                             }
                         }
-                        l = new WeakMap(), h = new WeakMap(), e.Metadata = s;
+                        p = new WeakMap(), f = new WeakMap(), t.Metadata = s;
                     },
                     /* 17 */
                     /***/
-                    (t, e, i) => {
-                        var c, o, r, T, S, w, tn;
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        var a, h, o, F, R, w, tn;
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.OptionalContentConfig = void 0;
-                        var n = i(1),
-                            s = i(8);
-                        const l = Symbol("INTERNAL");
-                        class h {
-                            constructor(b, k) {
-                                W(this, c, !0);
-                                this.name = b, this.intent = k;
+                        }), t.OptionalContentConfig = void 0;
+                        var e = n(1),
+                            s = n(8);
+                        const p = Symbol("INTERNAL");
+                        class f {
+                            constructor(m, C) {
+                                W(this, a, !0);
+                                this.name = m, this.intent = C;
                             }
                             get visible() {
-                                return a(this, c);
+                                return r(this, a);
                             }
-                            _setVisible(b, k) {
-                                b !== l && (0, n.unreachable)("Internal method `_setVisible` called."), oe(this, c, k);
+                            _setVisible(m, C) {
+                                m !== p && (0, e.unreachable)("Internal method `_setVisible` called."), ot(this, a, C);
                             }
                         }
-                        c = new WeakMap();
-                        class _ {
-                            constructor(b) {
+                        a = new WeakMap();
+                        class A {
+                            constructor(m) {
                                 W(this, w);
-                                W(this, o, null);
-                                W(this, r, /* @__PURE__ */ new Map());
-                                W(this, T, null);
-                                W(this, S, null);
-                                if (this.name = null, this.creator = null, b !== null) {
-                                    this.name = b.name, this.creator = b.creator, oe(this, S, b.order);
-                                    for (const k of b.groups)
-                                        a(this, r).set(k.id, new h(k.name, k.intent));
-                                    if (b.baseState === "OFF")
-                                        for (const k of a(this, r).values())
-                                            k._setVisible(l, !1);
-                                    for (const k of b.on)
-                                        a(this, r).get(k)._setVisible(l, !0);
-                                    for (const k of b.off)
-                                        a(this, r).get(k)._setVisible(l, !1);
-                                    oe(this, T, this.getHash());
+                                W(this, h, null);
+                                W(this, o, /* @__PURE__ */ new Map());
+                                W(this, F, null);
+                                W(this, R, null);
+                                if (this.name = null, this.creator = null, m !== null) {
+                                    this.name = m.name, this.creator = m.creator, ot(this, R, m.order);
+                                    for (const C of m.groups)
+                                        r(this, o).set(C.id, new f(C.name, C.intent));
+                                    if (m.baseState === "OFF")
+                                        for (const C of r(this, o).values())
+                                            C._setVisible(p, !1);
+                                    for (const C of m.on)
+                                        r(this, o).get(C)._setVisible(p, !0);
+                                    for (const C of m.off)
+                                        r(this, o).get(C)._setVisible(p, !1);
+                                    ot(this, F, this.getHash());
                                 }
                             }
-                            isVisible(b) {
-                                if (a(this, r).size === 0)
+                            isVisible(m) {
+                                if (r(this, o).size === 0)
                                     return !0;
-                                if (!b)
-                                    return (0, n.warn)("Optional content group not defined."), !0;
-                                if (b.type === "OCG")
-                                    return a(this, r).has(b.id) ? a(this, r).get(b.id).visible : ((0, n.warn)(`Optional content group not found: ${b.id}`), !0);
-                                if (b.type === "OCMD") {
-                                    if (b.expression)
-                                        return K(this, w, tn).call(this, b.expression);
-                                    if (!b.policy || b.policy === "AnyOn") {
-                                        for (const k of b.ids) {
-                                            if (!a(this, r).has(k))
-                                                return (0, n.warn)(`Optional content group not found: ${k}`), !0;
-                                            if (a(this, r).get(k).visible)
+                                if (!m)
+                                    return (0, e.warn)("Optional content group not defined."), !0;
+                                if (m.type === "OCG")
+                                    return r(this, o).has(m.id) ? r(this, o).get(m.id).visible : ((0, e.warn)(`Optional content group not found: ${m.id}`), !0);
+                                if (m.type === "OCMD") {
+                                    if (m.expression)
+                                        return J(this, w, tn).call(this, m.expression);
+                                    if (!m.policy || m.policy === "AnyOn") {
+                                        for (const C of m.ids) {
+                                            if (!r(this, o).has(C))
+                                                return (0, e.warn)(`Optional content group not found: ${C}`), !0;
+                                            if (r(this, o).get(C).visible)
                                                 return !0;
                                         }
                                         return !1;
-                                    } else if (b.policy === "AllOn") {
-                                        for (const k of b.ids) {
-                                            if (!a(this, r).has(k))
-                                                return (0, n.warn)(`Optional content group not found: ${k}`), !0;
-                                            if (!a(this, r).get(k).visible)
+                                    } else if (m.policy === "AllOn") {
+                                        for (const C of m.ids) {
+                                            if (!r(this, o).has(C))
+                                                return (0, e.warn)(`Optional content group not found: ${C}`), !0;
+                                            if (!r(this, o).get(C).visible)
                                                 return !1;
                                         }
                                         return !0;
-                                    } else if (b.policy === "AnyOff") {
-                                        for (const k of b.ids) {
-                                            if (!a(this, r).has(k))
-                                                return (0, n.warn)(`Optional content group not found: ${k}`), !0;
-                                            if (!a(this, r).get(k).visible)
+                                    } else if (m.policy === "AnyOff") {
+                                        for (const C of m.ids) {
+                                            if (!r(this, o).has(C))
+                                                return (0, e.warn)(`Optional content group not found: ${C}`), !0;
+                                            if (!r(this, o).get(C).visible)
                                                 return !0;
                                         }
                                         return !1;
-                                    } else if (b.policy === "AllOff") {
-                                        for (const k of b.ids) {
-                                            if (!a(this, r).has(k))
-                                                return (0, n.warn)(`Optional content group not found: ${k}`), !0;
-                                            if (a(this, r).get(k).visible)
+                                    } else if (m.policy === "AllOff") {
+                                        for (const C of m.ids) {
+                                            if (!r(this, o).has(C))
+                                                return (0, e.warn)(`Optional content group not found: ${C}`), !0;
+                                            if (r(this, o).get(C).visible)
                                                 return !1;
                                         }
                                         return !0;
                                     }
-                                    return (0, n.warn)(`Unknown optional content policy ${b.policy}.`), !0;
+                                    return (0, e.warn)(`Unknown optional content policy ${m.policy}.`), !0;
                                 }
-                                return (0, n.warn)(`Unknown group type ${b.type}.`), !0;
+                                return (0, e.warn)(`Unknown group type ${m.type}.`), !0;
                             }
-                            setVisibility(b, k = !0) {
-                                if (!a(this, r).has(b)) {
-                                    (0, n.warn)(`Optional content group not found: ${b}`);
+                            setVisibility(m, C = !0) {
+                                if (!r(this, o).has(m)) {
+                                    (0, e.warn)(`Optional content group not found: ${m}`);
                                     return;
                                 }
-                                a(this, r).get(b)._setVisible(l, !!k), oe(this, o, null);
+                                r(this, o).get(m)._setVisible(p, !!C), ot(this, h, null);
                             }
                             get hasInitialVisibility() {
-                                return a(this, T) === null || this.getHash() === a(this, T);
+                                return r(this, F) === null || this.getHash() === r(this, F);
                             }
                             getOrder() {
-                                return a(this, r).size ? a(this, S) ? a(this, S).slice() : [...a(this, r).keys()] : null;
+                                return r(this, o).size ? r(this, R) ? r(this, R).slice() : [...r(this, o).keys()] : null;
                             }
                             getGroups() {
-                                return a(this, r).size > 0 ? (0, n.objectFromMap)(a(this, r)) : null;
+                                return r(this, o).size > 0 ? (0, e.objectFromMap)(r(this, o)) : null;
                             }
-                            getGroup(b) {
-                                return a(this, r).get(b) || null;
+                            getGroup(m) {
+                                return r(this, o).get(m) || null;
                             }
                             getHash() {
-                                if (a(this, o) !== null)
-                                    return a(this, o);
-                                const b = new s.MurmurHash3_64();
-                                for (const [k, F] of a(this, r))
-                                    b.update(`${k}:${F.visible}`);
-                                return oe(this, o, b.hexdigest());
+                                if (r(this, h) !== null)
+                                    return r(this, h);
+                                const m = new s.MurmurHash3_64();
+                                for (const [C, x] of r(this, o))
+                                    m.update(`${C}:${x.visible}`);
+                                return ot(this, h, m.hexdigest());
                             }
                         }
-                        o = new WeakMap(), r = new WeakMap(), T = new WeakMap(), S = new WeakMap(), w = new WeakSet(), tn = function(b) {
-                            const k = b.length;
-                            if (k < 2)
+                        h = new WeakMap(), o = new WeakMap(), F = new WeakMap(), R = new WeakMap(), w = new WeakSet(), tn = function(m) {
+                            const C = m.length;
+                            if (C < 2)
                                 return !0;
-                            const F = b[0];
-                            for (let x = 1; x < k; x++) {
-                                const y = b[x];
-                                let p;
-                                if (Array.isArray(y))
-                                    p = K(this, w, tn).call(this, y);
-                                else if (a(this, r).has(y))
-                                    p = a(this, r).get(y).visible;
+                            const x = m[0];
+                            for (let E = 1; E < C; E++) {
+                                const S = m[E];
+                                let g;
+                                if (Array.isArray(S))
+                                    g = J(this, w, tn).call(this, S);
+                                else if (r(this, o).has(S))
+                                    g = r(this, o).get(S).visible;
                                 else
-                                    return (0, n.warn)(`Optional content group not found: ${y}`), !0;
-                                switch (F) {
+                                    return (0, e.warn)(`Optional content group not found: ${S}`), !0;
+                                switch (x) {
                                     case "And":
-                                        if (!p)
+                                        if (!g)
                                             return !1;
                                         break;
                                     case "Or":
-                                        if (p)
+                                        if (g)
                                             return !0;
                                         break;
                                     case "Not":
-                                        return !p;
+                                        return !g;
                                     default:
                                         return !0;
                                 }
                             }
-                            return F === "And";
-                        }, e.OptionalContentConfig = _;
+                            return x === "And";
+                        }, t.OptionalContentConfig = A;
                     },
                     /* 18 */
                     /***/
-                    (t, e, i) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.PDFDataTransportStream = void 0;
-                        var n = i(1),
-                            s = i(6);
-                        class l {
+                        }), t.PDFDataTransportStream = void 0;
+                        var e = n(1),
+                            s = n(6);
+                        class p {
                             constructor({
-                                length: o,
-                                initialData: r,
-                                progressiveDone: T = !1,
-                                contentDispositionFilename: S = null,
+                                length: h,
+                                initialData: o,
+                                progressiveDone: F = !1,
+                                contentDispositionFilename: R = null,
                                 disableRange: w = !1,
-                                disableStream: C = !1
+                                disableStream: T = !1
                             }, P) {
-                                if ((0, n.assert)(P, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = T, this._contentDispositionFilename = S, (r == null ? void 0 : r.length) > 0) {
-                                    const b = r instanceof Uint8Array && r.byteLength === r.buffer.byteLength ? r.buffer : new Uint8Array(r).buffer;
-                                    this._queuedChunks.push(b);
+                                if ((0, e.assert)(P, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = F, this._contentDispositionFilename = R, (o == null ? void 0 : o.length) > 0) {
+                                    const m = o instanceof Uint8Array && o.byteLength === o.buffer.byteLength ? o.buffer : new Uint8Array(o).buffer;
+                                    this._queuedChunks.push(m);
                                 }
-                                this._pdfDataRangeTransport = P, this._isStreamingSupported = !C, this._isRangeSupported = !w, this._contentLength = o, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((b, k) => {
+                                this._pdfDataRangeTransport = P, this._isStreamingSupported = !T, this._isRangeSupported = !w, this._contentLength = h, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((m, C) => {
                                     this._onReceiveData({
-                                        begin: b,
-                                        chunk: k
+                                        begin: m,
+                                        chunk: C
                                     });
-                                }), this._pdfDataRangeTransport.addProgressListener((b, k) => {
+                                }), this._pdfDataRangeTransport.addProgressListener((m, C) => {
                                     this._onProgress({
-                                        loaded: b,
-                                        total: k
+                                        loaded: m,
+                                        total: C
                                     });
-                                }), this._pdfDataRangeTransport.addProgressiveReadListener((b) => {
+                                }), this._pdfDataRangeTransport.addProgressiveReadListener((m) => {
                                     this._onReceiveData({
-                                        chunk: b
+                                        chunk: m
                                     });
                                 }), this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                                     this._onProgressiveDone();
                                 }), this._pdfDataRangeTransport.transportReady();
                             }
                             _onReceiveData({
-                                begin: o,
-                                chunk: r
+                                begin: h,
+                                chunk: o
                             }) {
-                                const T = r instanceof Uint8Array && r.byteLength === r.buffer.byteLength ? r.buffer : new Uint8Array(r).buffer;
-                                if (o === void 0)
-                                    this._fullRequestReader ? this._fullRequestReader._enqueue(T) : this._queuedChunks.push(T);
+                                const F = o instanceof Uint8Array && o.byteLength === o.buffer.byteLength ? o.buffer : new Uint8Array(o).buffer;
+                                if (h === void 0)
+                                    this._fullRequestReader ? this._fullRequestReader._enqueue(F) : this._queuedChunks.push(F);
                                 else {
-                                    const S = this._rangeReaders.some(function(w) {
-                                        return w._begin !== o ? !1 : (w._enqueue(T), !0);
+                                    const R = this._rangeReaders.some(function(w) {
+                                        return w._begin !== h ? !1 : (w._enqueue(F), !0);
                                     });
-                                    (0, n.assert)(S, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
+                                    (0, e.assert)(R, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
                                 }
                             }
                             get _progressiveDataLength() {
-                                var o;
-                                return ((o = this._fullRequestReader) == null ? void 0 : o._loaded) ?? 0;
+                                var h;
+                                return ((h = this._fullRequestReader) == null ? void 0 : h._loaded) ?? 0;
                             }
-                            _onProgress(o) {
-                                var r, T, S, w;
-                                o.total === void 0 ? (T = (r = this._rangeReaders[0]) == null ? void 0 : r.onProgress) == null || T.call(r, {
-                                    loaded: o.loaded
-                                }) : (w = (S = this._fullRequestReader) == null ? void 0 : S.onProgress) == null || w.call(S, {
-                                    loaded: o.loaded,
-                                    total: o.total
+                            _onProgress(h) {
+                                var o, F, R, w;
+                                h.total === void 0 ? (F = (o = this._rangeReaders[0]) == null ? void 0 : o.onProgress) == null || F.call(o, {
+                                    loaded: h.loaded
+                                }) : (w = (R = this._fullRequestReader) == null ? void 0 : R.onProgress) == null || w.call(R, {
+                                    loaded: h.loaded,
+                                    total: h.total
                                 });
                             }
                             _onProgressiveDone() {
-                                var o;
-                                (o = this._fullRequestReader) == null || o.progressiveDone(), this._progressiveDone = !0;
+                                var h;
+                                (h = this._fullRequestReader) == null || h.progressiveDone(), this._progressiveDone = !0;
                             }
-                            _removeRangeReader(o) {
-                                const r = this._rangeReaders.indexOf(o);
-                                r >= 0 && this._rangeReaders.splice(r, 1);
+                            _removeRangeReader(h) {
+                                const o = this._rangeReaders.indexOf(h);
+                                o >= 0 && this._rangeReaders.splice(o, 1);
                             }
                             getFullReader() {
-                                (0, n.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
-                                const o = this._queuedChunks;
-                                return this._queuedChunks = null, new h(this, o, this._progressiveDone, this._contentDispositionFilename);
+                                (0, e.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
+                                const h = this._queuedChunks;
+                                return this._queuedChunks = null, new f(this, h, this._progressiveDone, this._contentDispositionFilename);
                             }
-                            getRangeReader(o, r) {
-                                if (r <= this._progressiveDataLength)
+                            getRangeReader(h, o) {
+                                if (o <= this._progressiveDataLength)
                                     return null;
-                                const T = new _(this, o, r);
-                                return this._pdfDataRangeTransport.requestDataRange(o, r), this._rangeReaders.push(T), T;
+                                const F = new A(this, h, o);
+                                return this._pdfDataRangeTransport.requestDataRange(h, o), this._rangeReaders.push(F), F;
                             }
-                            cancelAllRequests(o) {
-                                var r;
-                                (r = this._fullRequestReader) == null || r.cancel(o);
-                                for (const T of this._rangeReaders.slice(0))
-                                    T.cancel(o);
+                            cancelAllRequests(h) {
+                                var o;
+                                (o = this._fullRequestReader) == null || o.cancel(h);
+                                for (const F of this._rangeReaders.slice(0))
+                                    F.cancel(h);
                                 this._pdfDataRangeTransport.abort();
                             }
                         }
-                        e.PDFDataTransportStream = l;
-                        class h {
-                            constructor(o, r, T = !1, S = null) {
-                                this._stream = o, this._done = T || !1, this._filename = (0, s.isPdfFile)(S) ? S : null, this._queuedChunks = r || [], this._loaded = 0;
+                        t.PDFDataTransportStream = p;
+                        class f {
+                            constructor(h, o, F = !1, R = null) {
+                                this._stream = h, this._done = F || !1, this._filename = (0, s.isPdfFile)(R) ? R : null, this._queuedChunks = o || [], this._loaded = 0;
                                 for (const w of this._queuedChunks)
                                     this._loaded += w.byteLength;
-                                this._requests = [], this._headersReady = Promise.resolve(), o._fullRequestReader = this, this.onProgress = null;
+                                this._requests = [], this._headersReady = Promise.resolve(), h._fullRequestReader = this, this.onProgress = null;
                             }
-                            _enqueue(o) {
+                            _enqueue(h) {
                                 this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
-                                    value: o,
+                                    value: h,
                                     done: !1
-                                }) : this._queuedChunks.push(o), this._loaded += o.byteLength);
+                                }) : this._queuedChunks.push(h), this._loaded += h.byteLength);
                             }
                             get headersReady() {
                                 return this._headersReady;
                             }
                             get filename() {
                                 return this._filename;
                             }
@@ -15351,161 +11948,161 @@
                                         done: !1
                                     };
                                 if (this._done)
                                     return {
                                         value: void 0,
                                         done: !0
                                     };
-                                const o = new n.PromiseCapability();
-                                return this._requests.push(o), o.promise;
+                                const h = new e.PromiseCapability();
+                                return this._requests.push(h), h.promise;
                             }
-                            cancel(o) {
+                            cancel(h) {
                                 this._done = !0;
-                                for (const r of this._requests)
-                                    r.resolve({
+                                for (const o of this._requests)
+                                    o.resolve({
                                         value: void 0,
                                         done: !0
                                     });
                                 this._requests.length = 0;
                             }
                             progressiveDone() {
                                 this._done || (this._done = !0);
                             }
                         }
-                        class _ {
-                            constructor(o, r, T) {
-                                this._stream = o, this._begin = r, this._end = T, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
+                        class A {
+                            constructor(h, o, F) {
+                                this._stream = h, this._begin = o, this._end = F, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
                             }
-                            _enqueue(o) {
+                            _enqueue(h) {
                                 if (!this._done) {
                                     if (this._requests.length === 0)
-                                        this._queuedChunk = o;
+                                        this._queuedChunk = h;
                                     else {
                                         this._requests.shift().resolve({
-                                            value: o,
+                                            value: h,
                                             done: !1
                                         });
-                                        for (const T of this._requests)
-                                            T.resolve({
+                                        for (const F of this._requests)
+                                            F.resolve({
                                                 value: void 0,
                                                 done: !0
                                             });
                                         this._requests.length = 0;
                                     }
                                     this._done = !0, this._stream._removeRangeReader(this);
                                 }
                             }
                             get isStreamingSupported() {
                                 return !1;
                             }
                             async read() {
                                 if (this._queuedChunk) {
-                                    const r = this._queuedChunk;
+                                    const o = this._queuedChunk;
                                     return this._queuedChunk = null, {
-                                        value: r,
+                                        value: o,
                                         done: !1
                                     };
                                 }
                                 if (this._done)
                                     return {
                                         value: void 0,
                                         done: !0
                                     };
-                                const o = new n.PromiseCapability();
-                                return this._requests.push(o), o.promise;
+                                const h = new e.PromiseCapability();
+                                return this._requests.push(h), h.promise;
                             }
-                            cancel(o) {
+                            cancel(h) {
                                 this._done = !0;
-                                for (const r of this._requests)
-                                    r.resolve({
+                                for (const o of this._requests)
+                                    o.resolve({
                                         value: void 0,
                                         done: !0
                                     });
                                 this._requests.length = 0, this._stream._removeRangeReader(this);
                             }
                         }
                     },
                     /* 19 */
                     /***/
-                    (t, e, i) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.PDFFetchStream = void 0;
-                        var n = i(1),
-                            s = i(20);
+                        }), t.PDFFetchStream = void 0;
+                        var e = n(1),
+                            s = n(20);
 
-                        function l(T, S, w) {
+                        function p(F, R, w) {
                             return {
                                 method: "GET",
-                                headers: T,
+                                headers: F,
                                 signal: w.signal,
                                 mode: "cors",
-                                credentials: S ? "include" : "same-origin",
+                                credentials: R ? "include" : "same-origin",
                                 redirect: "follow"
                             };
                         }
 
-                        function h(T) {
-                            const S = new Headers();
-                            for (const w in T) {
-                                const C = T[w];
-                                C !== void 0 && S.append(w, C);
+                        function f(F) {
+                            const R = new Headers();
+                            for (const w in F) {
+                                const T = F[w];
+                                T !== void 0 && R.append(w, T);
                             }
-                            return S;
+                            return R;
                         }
 
-                        function _(T) {
-                            return T instanceof Uint8Array ? T.buffer : T instanceof ArrayBuffer ? T : ((0, n.warn)(`getArrayBuffer - unexpected data format: ${T}`), new Uint8Array(T).buffer);
+                        function A(F) {
+                            return F instanceof Uint8Array ? F.buffer : F instanceof ArrayBuffer ? F : ((0, e.warn)(`getArrayBuffer - unexpected data format: ${F}`), new Uint8Array(F).buffer);
                         }
-                        class c {
-                            constructor(S) {
-                                this.source = S, this.isHttp = /^https?:/i.test(S.url), this.httpHeaders = this.isHttp && S.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
+                        class a {
+                            constructor(R) {
+                                this.source = R, this.isHttp = /^https?:/i.test(R.url), this.httpHeaders = this.isHttp && R.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
                             }
                             get _progressiveDataLength() {
-                                var S;
-                                return ((S = this._fullRequestReader) == null ? void 0 : S._loaded) ?? 0;
+                                var R;
+                                return ((R = this._fullRequestReader) == null ? void 0 : R._loaded) ?? 0;
                             }
                             getFullReader() {
-                                return (0, n.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new o(this), this._fullRequestReader;
+                                return (0, e.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new h(this), this._fullRequestReader;
                             }
-                            getRangeReader(S, w) {
+                            getRangeReader(R, w) {
                                 if (w <= this._progressiveDataLength)
                                     return null;
-                                const C = new r(this, S, w);
-                                return this._rangeRequestReaders.push(C), C;
+                                const T = new o(this, R, w);
+                                return this._rangeRequestReaders.push(T), T;
                             }
-                            cancelAllRequests(S) {
+                            cancelAllRequests(R) {
                                 var w;
-                                (w = this._fullRequestReader) == null || w.cancel(S);
-                                for (const C of this._rangeRequestReaders.slice(0))
-                                    C.cancel(S);
+                                (w = this._fullRequestReader) == null || w.cancel(R);
+                                for (const T of this._rangeRequestReaders.slice(0))
+                                    T.cancel(R);
                             }
                         }
-                        e.PDFFetchStream = c;
-                        class o {
-                            constructor(S) {
-                                this._stream = S, this._reader = null, this._loaded = 0, this._filename = null;
-                                const w = S.source;
-                                this._withCredentials = w.withCredentials || !1, this._contentLength = w.length, this._headersCapability = new n.PromiseCapability(), this._disableRange = w.disableRange || !1, this._rangeChunkSize = w.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !w.disableStream, this._isRangeSupported = !w.disableRange, this._headers = h(this._stream.httpHeaders);
-                                const C = w.url;
-                                fetch(C, l(this._headers, this._withCredentials, this._abortController)).then((P) => {
+                        t.PDFFetchStream = a;
+                        class h {
+                            constructor(R) {
+                                this._stream = R, this._reader = null, this._loaded = 0, this._filename = null;
+                                const w = R.source;
+                                this._withCredentials = w.withCredentials || !1, this._contentLength = w.length, this._headersCapability = new e.PromiseCapability(), this._disableRange = w.disableRange || !1, this._rangeChunkSize = w.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !w.disableStream, this._isRangeSupported = !w.disableRange, this._headers = f(this._stream.httpHeaders);
+                                const T = w.url;
+                                fetch(T, p(this._headers, this._withCredentials, this._abortController)).then((P) => {
                                     if (!(0, s.validateResponseStatus)(P.status))
-                                        throw (0, s.createResponseStatusError)(P.status, C);
+                                        throw (0, s.createResponseStatusError)(P.status, T);
                                     this._reader = P.body.getReader(), this._headersCapability.resolve();
-                                    const b = (x) => P.headers.get(x),
+                                    const m = (E) => P.headers.get(E),
                                         {
-                                            allowRangeRequests: k,
-                                            suggestedLength: F
+                                            allowRangeRequests: C,
+                                            suggestedLength: x
                                         } = (0, s.validateRangeRequestCapabilities)({
-                                            getResponseHeader: b,
+                                            getResponseHeader: m,
                                             isHttp: this._stream.isHttp,
                                             rangeChunkSize: this._rangeChunkSize,
                                             disableRange: this._disableRange
                                         });
-                                    this._isRangeSupported = k, this._contentLength = F || this._contentLength, this._filename = (0, s.extractFilenameFromHeader)(b), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new n.AbortException("Streaming is disabled."));
+                                    this._isRangeSupported = C, this._contentLength = x || this._contentLength, this._filename = (0, s.extractFilenameFromHeader)(m), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new e.AbortException("Streaming is disabled."));
                                 }).catch(this._headersCapability.reject), this.onProgress = null;
                             }
                             get headersReady() {
                                 return this._headersCapability.promise;
                             }
                             get filename() {
                                 return this._filename;
@@ -15516,394 +12113,394 @@
                             get isRangeSupported() {
                                 return this._isRangeSupported;
                             }
                             get isStreamingSupported() {
                                 return this._isStreamingSupported;
                             }
                             async read() {
-                                var C;
+                                var T;
                                 await this._headersCapability.promise;
                                 const {
-                                    value: S,
+                                    value: R,
                                     done: w
                                 } = await this._reader.read();
                                 return w ? {
-                                    value: S,
+                                    value: R,
                                     done: w
-                                } : (this._loaded += S.byteLength, (C = this.onProgress) == null || C.call(this, {
+                                } : (this._loaded += R.byteLength, (T = this.onProgress) == null || T.call(this, {
                                     loaded: this._loaded,
                                     total: this._contentLength
                                 }), {
-                                    value: _(S),
+                                    value: A(R),
                                     done: !1
                                 });
                             }
-                            cancel(S) {
+                            cancel(R) {
                                 var w;
-                                (w = this._reader) == null || w.cancel(S), this._abortController.abort();
+                                (w = this._reader) == null || w.cancel(R), this._abortController.abort();
                             }
                         }
-                        class r {
-                            constructor(S, w, C) {
-                                this._stream = S, this._reader = null, this._loaded = 0;
-                                const P = S.source;
-                                this._withCredentials = P.withCredentials || !1, this._readCapability = new n.PromiseCapability(), this._isStreamingSupported = !P.disableStream, this._abortController = new AbortController(), this._headers = h(this._stream.httpHeaders), this._headers.append("Range", `bytes=${w}-${C - 1}`);
-                                const b = P.url;
-                                fetch(b, l(this._headers, this._withCredentials, this._abortController)).then((k) => {
-                                    if (!(0, s.validateResponseStatus)(k.status))
-                                        throw (0, s.createResponseStatusError)(k.status, b);
-                                    this._readCapability.resolve(), this._reader = k.body.getReader();
+                        class o {
+                            constructor(R, w, T) {
+                                this._stream = R, this._reader = null, this._loaded = 0;
+                                const P = R.source;
+                                this._withCredentials = P.withCredentials || !1, this._readCapability = new e.PromiseCapability(), this._isStreamingSupported = !P.disableStream, this._abortController = new AbortController(), this._headers = f(this._stream.httpHeaders), this._headers.append("Range", `bytes=${w}-${T - 1}`);
+                                const m = P.url;
+                                fetch(m, p(this._headers, this._withCredentials, this._abortController)).then((C) => {
+                                    if (!(0, s.validateResponseStatus)(C.status))
+                                        throw (0, s.createResponseStatusError)(C.status, m);
+                                    this._readCapability.resolve(), this._reader = C.body.getReader();
                                 }).catch(this._readCapability.reject), this.onProgress = null;
                             }
                             get isStreamingSupported() {
                                 return this._isStreamingSupported;
                             }
                             async read() {
-                                var C;
+                                var T;
                                 await this._readCapability.promise;
                                 const {
-                                    value: S,
+                                    value: R,
                                     done: w
                                 } = await this._reader.read();
                                 return w ? {
-                                    value: S,
+                                    value: R,
                                     done: w
-                                } : (this._loaded += S.byteLength, (C = this.onProgress) == null || C.call(this, {
+                                } : (this._loaded += R.byteLength, (T = this.onProgress) == null || T.call(this, {
                                     loaded: this._loaded
                                 }), {
-                                    value: _(S),
+                                    value: A(R),
                                     done: !1
                                 });
                             }
-                            cancel(S) {
+                            cancel(R) {
                                 var w;
-                                (w = this._reader) == null || w.cancel(S), this._abortController.abort();
+                                (w = this._reader) == null || w.cancel(R), this._abortController.abort();
                             }
                         }
                     },
                     /* 20 */
                     /***/
-                    (t, e, i) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.createResponseStatusError = c, e.extractFilenameFromHeader = _, e.validateRangeRequestCapabilities = h, e.validateResponseStatus = o;
-                        var n = i(1),
-                            s = i(21),
-                            l = i(6);
-
-                        function h({
-                            getResponseHeader: r,
-                            isHttp: T,
-                            rangeChunkSize: S,
+                        }), t.createResponseStatusError = a, t.extractFilenameFromHeader = A, t.validateRangeRequestCapabilities = f, t.validateResponseStatus = h;
+                        var e = n(1),
+                            s = n(21),
+                            p = n(6);
+
+                        function f({
+                            getResponseHeader: o,
+                            isHttp: F,
+                            rangeChunkSize: R,
                             disableRange: w
                         }) {
-                            const C = {
+                            const T = {
                                     allowRangeRequests: !1,
                                     suggestedLength: void 0
                                 },
-                                P = parseInt(r("Content-Length"), 10);
-                            return !Number.isInteger(P) || (C.suggestedLength = P, P <= 2 * S) || w || !T || r("Accept-Ranges") !== "bytes" || (r("Content-Encoding") || "identity") !== "identity" || (C.allowRangeRequests = !0), C;
+                                P = parseInt(o("Content-Length"), 10);
+                            return !Number.isInteger(P) || (T.suggestedLength = P, P <= 2 * R) || w || !F || o("Accept-Ranges") !== "bytes" || (o("Content-Encoding") || "identity") !== "identity" || (T.allowRangeRequests = !0), T;
                         }
 
-                        function _(r) {
-                            const T = r("Content-Disposition");
-                            if (T) {
-                                let S = (0, s.getFilenameFromContentDispositionHeader)(T);
-                                if (S.includes("%"))
+                        function A(o) {
+                            const F = o("Content-Disposition");
+                            if (F) {
+                                let R = (0, s.getFilenameFromContentDispositionHeader)(F);
+                                if (R.includes("%"))
                                     try {
-                                        S = decodeURIComponent(S);
+                                        R = decodeURIComponent(R);
                                     } catch {}
-                                if ((0, l.isPdfFile)(S))
-                                    return S;
+                                if ((0, p.isPdfFile)(R))
+                                    return R;
                             }
                             return null;
                         }
 
-                        function c(r, T) {
-                            return r === 404 || r === 0 && T.startsWith("file:") ? new n.MissingPDFException('Missing PDF "' + T + '".') : new n.UnexpectedResponseException(`Unexpected server response (${r}) while retrieving PDF "${T}".`, r);
+                        function a(o, F) {
+                            return o === 404 || o === 0 && F.startsWith("file:") ? new e.MissingPDFException('Missing PDF "' + F + '".') : new e.UnexpectedResponseException(`Unexpected server response (${o}) while retrieving PDF "${F}".`, o);
                         }
 
-                        function o(r) {
-                            return r === 200 || r === 206;
+                        function h(o) {
+                            return o === 200 || o === 206;
                         }
                     },
                     /* 21 */
                     /***/
-                    (t, e, i) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.getFilenameFromContentDispositionHeader = s;
-                        var n = i(1);
+                        }), t.getFilenameFromContentDispositionHeader = s;
+                        var e = n(1);
 
-                        function s(l) {
-                            let h = !0,
-                                _ = c("filename\\*", "i").exec(l);
-                            if (_) {
-                                _ = _[1];
-                                let P = S(_);
-                                return P = unescape(P), P = w(P), P = C(P), r(P);
+                        function s(p) {
+                            let f = !0,
+                                A = a("filename\\*", "i").exec(p);
+                            if (A) {
+                                A = A[1];
+                                let P = R(A);
+                                return P = unescape(P), P = w(P), P = T(P), o(P);
                             }
-                            if (_ = T(l), _) {
-                                const P = C(_);
-                                return r(P);
+                            if (A = F(p), A) {
+                                const P = T(A);
+                                return o(P);
                             }
-                            if (_ = c("filename", "i").exec(l), _) {
-                                _ = _[1];
-                                let P = S(_);
-                                return P = C(P), r(P);
+                            if (A = a("filename", "i").exec(p), A) {
+                                A = A[1];
+                                let P = R(A);
+                                return P = T(P), o(P);
                             }
 
-                            function c(P, b) {
-                                return new RegExp("(?:^|;)\\s*" + P + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', b);
+                            function a(P, m) {
+                                return new RegExp("(?:^|;)\\s*" + P + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', m);
                             }
 
-                            function o(P, b) {
+                            function h(P, m) {
                                 if (P) {
-                                    if (!/^[\x00-\xFF]+$/.test(b))
-                                        return b;
+                                    if (!/^[\x00-\xFF]+$/.test(m))
+                                        return m;
                                     try {
-                                        const k = new TextDecoder(P, {
+                                        const C = new TextDecoder(P, {
                                                 fatal: !0
                                             }),
-                                            F = (0, n.stringToBytes)(b);
-                                        b = k.decode(F), h = !1;
+                                            x = (0, e.stringToBytes)(m);
+                                        m = C.decode(x), f = !1;
                                     } catch {}
                                 }
-                                return b;
+                                return m;
                             }
 
-                            function r(P) {
-                                return h && /[\x80-\xff]/.test(P) && (P = o("utf-8", P), h && (P = o("iso-8859-1", P))), P;
+                            function o(P) {
+                                return f && /[\x80-\xff]/.test(P) && (P = h("utf-8", P), f && (P = h("iso-8859-1", P))), P;
                             }
 
-                            function T(P) {
-                                const b = [];
-                                let k;
-                                const F = c("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
+                            function F(P) {
+                                const m = [];
+                                let C;
+                                const x = a("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                                 for (;
-                                    (k = F.exec(P)) !== null;) {
-                                    let [, y, p, E] = k;
-                                    if (y = parseInt(y, 10), y in b) {
-                                        if (y === 0)
+                                    (C = x.exec(P)) !== null;) {
+                                    let [, S, g, v] = C;
+                                    if (S = parseInt(S, 10), S in m) {
+                                        if (S === 0)
                                             break;
                                         continue;
                                     }
-                                    b[y] = [p, E];
+                                    m[S] = [g, v];
                                 }
-                                const x = [];
-                                for (let y = 0; y < b.length && y in b; ++y) {
-                                    let [p, E] = b[y];
-                                    E = S(E), p && (E = unescape(E), y === 0 && (E = w(E))), x.push(E);
+                                const E = [];
+                                for (let S = 0; S < m.length && S in m; ++S) {
+                                    let [g, v] = m[S];
+                                    v = R(v), g && (v = unescape(v), S === 0 && (v = w(v))), E.push(v);
                                 }
-                                return x.join("");
+                                return E.join("");
                             }
 
-                            function S(P) {
+                            function R(P) {
                                 if (P.startsWith('"')) {
-                                    const b = P.slice(1).split('\\"');
-                                    for (let k = 0; k < b.length; ++k) {
-                                        const F = b[k].indexOf('"');
-                                        F !== -1 && (b[k] = b[k].slice(0, F), b.length = k + 1), b[k] = b[k].replaceAll(/\\(.)/g, "$1");
+                                    const m = P.slice(1).split('\\"');
+                                    for (let C = 0; C < m.length; ++C) {
+                                        const x = m[C].indexOf('"');
+                                        x !== -1 && (m[C] = m[C].slice(0, x), m.length = C + 1), m[C] = m[C].replaceAll(/\\(.)/g, "$1");
                                     }
-                                    P = b.join('"');
+                                    P = m.join('"');
                                 }
                                 return P;
                             }
 
                             function w(P) {
-                                const b = P.indexOf("'");
-                                if (b === -1)
+                                const m = P.indexOf("'");
+                                if (m === -1)
                                     return P;
-                                const k = P.slice(0, b),
-                                    x = P.slice(b + 1).replace(/^[^']*'/, "");
-                                return o(k, x);
+                                const C = P.slice(0, m),
+                                    E = P.slice(m + 1).replace(/^[^']*'/, "");
+                                return h(C, E);
                             }
 
-                            function C(P) {
-                                return !P.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(P) ? P : P.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(b, k, F, x) {
-                                    if (F === "q" || F === "Q")
-                                        return x = x.replaceAll("_", " "), x = x.replaceAll(/=([0-9a-fA-F]{2})/g, function(y, p) {
-                                            return String.fromCharCode(parseInt(p, 16));
-                                        }), o(k, x);
+                            function T(P) {
+                                return !P.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(P) ? P : P.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(m, C, x, E) {
+                                    if (x === "q" || x === "Q")
+                                        return E = E.replaceAll("_", " "), E = E.replaceAll(/=([0-9a-fA-F]{2})/g, function(S, g) {
+                                            return String.fromCharCode(parseInt(g, 16));
+                                        }), h(C, E);
                                     try {
-                                        x = atob(x);
+                                        E = atob(E);
                                     } catch {}
-                                    return o(k, x);
+                                    return h(C, E);
                                 });
                             }
                             return "";
                         }
                     },
                     /* 22 */
                     /***/
-                    (t, e, i) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.PDFNetworkStream = void 0;
-                        var n = i(1),
-                            s = i(20);
-                        const l = 200,
-                            h = 206;
-
-                        function _(S) {
-                            const w = S.response;
-                            return typeof w != "string" ? w : (0, n.stringToBytes)(w).buffer;
-                        }
-                        class c {
-                            constructor(w, C = {}) {
-                                this.url = w, this.isHttp = /^https?:/i.test(w), this.httpHeaders = this.isHttp && C.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = C.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
+                        }), t.PDFNetworkStream = void 0;
+                        var e = n(1),
+                            s = n(20);
+                        const p = 200,
+                            f = 206;
+
+                        function A(R) {
+                            const w = R.response;
+                            return typeof w != "string" ? w : (0, e.stringToBytes)(w).buffer;
+                        }
+                        class a {
+                            constructor(w, T = {}) {
+                                this.url = w, this.isHttp = /^https?:/i.test(w), this.httpHeaders = this.isHttp && T.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = T.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
                             }
-                            requestRange(w, C, P) {
-                                const b = {
+                            requestRange(w, T, P) {
+                                const m = {
                                     begin: w,
-                                    end: C
+                                    end: T
                                 };
-                                for (const k in P)
-                                    b[k] = P[k];
-                                return this.request(b);
+                                for (const C in P)
+                                    m[C] = P[C];
+                                return this.request(m);
                             }
                             requestFull(w) {
                                 return this.request(w);
                             }
                             request(w) {
-                                const C = new XMLHttpRequest(),
+                                const T = new XMLHttpRequest(),
                                     P = this.currXhrId++,
-                                    b = this.pendingRequests[P] = {
-                                        xhr: C
+                                    m = this.pendingRequests[P] = {
+                                        xhr: T
                                     };
-                                C.open("GET", this.url), C.withCredentials = this.withCredentials;
-                                for (const k in this.httpHeaders) {
-                                    const F = this.httpHeaders[k];
-                                    F !== void 0 && C.setRequestHeader(k, F);
-                                }
-                                return this.isHttp && "begin" in w && "end" in w ? (C.setRequestHeader("Range", `bytes=${w.begin}-${w.end - 1}`), b.expectedStatus = h) : b.expectedStatus = l, C.responseType = "arraybuffer", w.onError && (C.onerror = function(k) {
-                                    w.onError(C.status);
-                                }), C.onreadystatechange = this.onStateChange.bind(this, P), C.onprogress = this.onProgress.bind(this, P), b.onHeadersReceived = w.onHeadersReceived, b.onDone = w.onDone, b.onError = w.onError, b.onProgress = w.onProgress, C.send(null), P;
+                                T.open("GET", this.url), T.withCredentials = this.withCredentials;
+                                for (const C in this.httpHeaders) {
+                                    const x = this.httpHeaders[C];
+                                    x !== void 0 && T.setRequestHeader(C, x);
+                                }
+                                return this.isHttp && "begin" in w && "end" in w ? (T.setRequestHeader("Range", `bytes=${w.begin}-${w.end - 1}`), m.expectedStatus = f) : m.expectedStatus = p, T.responseType = "arraybuffer", w.onError && (T.onerror = function(C) {
+                                    w.onError(T.status);
+                                }), T.onreadystatechange = this.onStateChange.bind(this, P), T.onprogress = this.onProgress.bind(this, P), m.onHeadersReceived = w.onHeadersReceived, m.onDone = w.onDone, m.onError = w.onError, m.onProgress = w.onProgress, T.send(null), P;
                             }
-                            onProgress(w, C) {
-                                var b;
+                            onProgress(w, T) {
+                                var m;
                                 const P = this.pendingRequests[w];
-                                P && ((b = P.onProgress) == null || b.call(P, C));
+                                P && ((m = P.onProgress) == null || m.call(P, T));
                             }
-                            onStateChange(w, C) {
-                                var y, p, E;
+                            onStateChange(w, T) {
+                                var S, g, v;
                                 const P = this.pendingRequests[w];
                                 if (!P)
                                     return;
-                                const b = P.xhr;
-                                if (b.readyState >= 2 && P.onHeadersReceived && (P.onHeadersReceived(), delete P.onHeadersReceived), b.readyState !== 4 || !(w in this.pendingRequests))
+                                const m = P.xhr;
+                                if (m.readyState >= 2 && P.onHeadersReceived && (P.onHeadersReceived(), delete P.onHeadersReceived), m.readyState !== 4 || !(w in this.pendingRequests))
                                     return;
-                                if (delete this.pendingRequests[w], b.status === 0 && this.isHttp) {
-                                    (y = P.onError) == null || y.call(P, b.status);
+                                if (delete this.pendingRequests[w], m.status === 0 && this.isHttp) {
+                                    (S = P.onError) == null || S.call(P, m.status);
                                     return;
                                 }
-                                const k = b.status || l;
-                                if (!(k === l && P.expectedStatus === h) && k !== P.expectedStatus) {
-                                    (p = P.onError) == null || p.call(P, b.status);
+                                const C = m.status || p;
+                                if (!(C === p && P.expectedStatus === f) && C !== P.expectedStatus) {
+                                    (g = P.onError) == null || g.call(P, m.status);
                                     return;
                                 }
-                                const x = _(b);
-                                if (k === h) {
-                                    const $ = b.getResponseHeader("Content-Range"),
+                                const E = A(m);
+                                if (C === f) {
+                                    const $ = m.getResponseHeader("Content-Range"),
                                         M = /bytes (\d+)-(\d+)\/(\d+)/.exec($);
                                     P.onDone({
                                         begin: parseInt(M[1], 10),
-                                        chunk: x
+                                        chunk: E
                                     });
                                 } else
-                                    x ? P.onDone({
+                                    E ? P.onDone({
                                         begin: 0,
-                                        chunk: x
-                                    }) : (E = P.onError) == null || E.call(P, b.status);
+                                        chunk: E
+                                    }) : (v = P.onError) == null || v.call(P, m.status);
                             }
                             getRequestXhr(w) {
                                 return this.pendingRequests[w].xhr;
                             }
                             isPendingRequest(w) {
                                 return w in this.pendingRequests;
                             }
                             abortRequest(w) {
-                                const C = this.pendingRequests[w].xhr;
-                                delete this.pendingRequests[w], C.abort();
+                                const T = this.pendingRequests[w].xhr;
+                                delete this.pendingRequests[w], T.abort();
                             }
                         }
-                        class o {
+                        class h {
                             constructor(w) {
-                                this._source = w, this._manager = new c(w.url, {
+                                this._source = w, this._manager = new a(w.url, {
                                     httpHeaders: w.httpHeaders,
                                     withCredentials: w.withCredentials
                                 }), this._rangeChunkSize = w.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
                             }
                             _onRangeRequestReaderClosed(w) {
-                                const C = this._rangeRequestReaders.indexOf(w);
-                                C >= 0 && this._rangeRequestReaders.splice(C, 1);
+                                const T = this._rangeRequestReaders.indexOf(w);
+                                T >= 0 && this._rangeRequestReaders.splice(T, 1);
                             }
                             getFullReader() {
-                                return (0, n.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new r(this._manager, this._source), this._fullRequestReader;
+                                return (0, e.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new o(this._manager, this._source), this._fullRequestReader;
                             }
-                            getRangeReader(w, C) {
-                                const P = new T(this._manager, w, C);
+                            getRangeReader(w, T) {
+                                const P = new F(this._manager, w, T);
                                 return P.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(P), P;
                             }
                             cancelAllRequests(w) {
-                                var C;
-                                (C = this._fullRequestReader) == null || C.cancel(w);
+                                var T;
+                                (T = this._fullRequestReader) == null || T.cancel(w);
                                 for (const P of this._rangeRequestReaders.slice(0))
                                     P.cancel(w);
                             }
                         }
-                        e.PDFNetworkStream = o;
-                        class r {
-                            constructor(w, C) {
+                        t.PDFNetworkStream = h;
+                        class o {
+                            constructor(w, T) {
                                 this._manager = w;
                                 const P = {
                                     onHeadersReceived: this._onHeadersReceived.bind(this),
                                     onDone: this._onDone.bind(this),
                                     onError: this._onError.bind(this),
                                     onProgress: this._onProgress.bind(this)
                                 };
-                                this._url = C.url, this._fullRequestId = w.requestFull(P), this._headersReceivedCapability = new n.PromiseCapability(), this._disableRange = C.disableRange || !1, this._contentLength = C.length, this._rangeChunkSize = C.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
+                                this._url = T.url, this._fullRequestId = w.requestFull(P), this._headersReceivedCapability = new e.PromiseCapability(), this._disableRange = T.disableRange || !1, this._contentLength = T.length, this._rangeChunkSize = T.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
                             }
                             _onHeadersReceived() {
                                 const w = this._fullRequestId,
-                                    C = this._manager.getRequestXhr(w),
-                                    P = (F) => C.getResponseHeader(F),
+                                    T = this._manager.getRequestXhr(w),
+                                    P = (x) => T.getResponseHeader(x),
                                     {
-                                        allowRangeRequests: b,
-                                        suggestedLength: k
+                                        allowRangeRequests: m,
+                                        suggestedLength: C
                                     } = (0, s.validateRangeRequestCapabilities)({
                                         getResponseHeader: P,
                                         isHttp: this._manager.isHttp,
                                         rangeChunkSize: this._rangeChunkSize,
                                         disableRange: this._disableRange
                                     });
-                                b && (this._isRangeSupported = !0), this._contentLength = k || this._contentLength, this._filename = (0, s.extractFilenameFromHeader)(P), this._isRangeSupported && this._manager.abortRequest(w), this._headersReceivedCapability.resolve();
+                                m && (this._isRangeSupported = !0), this._contentLength = C || this._contentLength, this._filename = (0, s.extractFilenameFromHeader)(P), this._isRangeSupported && this._manager.abortRequest(w), this._headersReceivedCapability.resolve();
                             }
                             _onDone(w) {
                                 if (w && (this._requests.length > 0 ? this._requests.shift().resolve({
                                         value: w.chunk,
                                         done: !1
                                     }) : this._cachedChunks.push(w.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
-                                    for (const C of this._requests)
-                                        C.resolve({
+                                    for (const T of this._requests)
+                                        T.resolve({
                                             value: void 0,
                                             done: !0
                                         });
                                     this._requests.length = 0;
                                 }
                             }
                             _onError(w) {
                                 this._storedError = (0, s.createResponseStatusError)(w, this._url), this._headersReceivedCapability.reject(this._storedError);
-                                for (const C of this._requests)
-                                    C.reject(this._storedError);
+                                for (const T of this._requests)
+                                    T.reject(this._storedError);
                                 this._requests.length = 0, this._cachedChunks.length = 0;
                             }
                             _onProgress(w) {
-                                var C;
-                                (C = this.onProgress) == null || C.call(this, {
+                                var T;
+                                (T = this.onProgress) == null || T.call(this, {
                                     loaded: w.loaded,
                                     total: w.lengthComputable ? w.total : this._contentLength
                                 });
                             }
                             get filename() {
                                 return this._filename;
                             }
@@ -15928,143 +12525,143 @@
                                         done: !1
                                     };
                                 if (this._done)
                                     return {
                                         value: void 0,
                                         done: !0
                                     };
-                                const w = new n.PromiseCapability();
+                                const w = new e.PromiseCapability();
                                 return this._requests.push(w), w.promise;
                             }
                             cancel(w) {
                                 this._done = !0, this._headersReceivedCapability.reject(w);
-                                for (const C of this._requests)
-                                    C.resolve({
+                                for (const T of this._requests)
+                                    T.resolve({
                                         value: void 0,
                                         done: !0
                                     });
                                 this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
                             }
                         }
-                        class T {
-                            constructor(w, C, P) {
+                        class F {
+                            constructor(w, T, P) {
                                 this._manager = w;
-                                const b = {
+                                const m = {
                                     onDone: this._onDone.bind(this),
                                     onError: this._onError.bind(this),
                                     onProgress: this._onProgress.bind(this)
                                 };
-                                this._url = w.url, this._requestId = w.requestRange(C, P, b), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
+                                this._url = w.url, this._requestId = w.requestRange(T, P, m), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
                             }
                             _close() {
                                 var w;
                                 (w = this.onClosed) == null || w.call(this, this);
                             }
                             _onDone(w) {
-                                const C = w.chunk;
+                                const T = w.chunk;
                                 this._requests.length > 0 ? this._requests.shift().resolve({
-                                    value: C,
+                                    value: T,
                                     done: !1
-                                }) : this._queuedChunk = C, this._done = !0;
+                                }) : this._queuedChunk = T, this._done = !0;
                                 for (const P of this._requests)
                                     P.resolve({
                                         value: void 0,
                                         done: !0
                                     });
                                 this._requests.length = 0, this._close();
                             }
                             _onError(w) {
                                 this._storedError = (0, s.createResponseStatusError)(w, this._url);
-                                for (const C of this._requests)
-                                    C.reject(this._storedError);
+                                for (const T of this._requests)
+                                    T.reject(this._storedError);
                                 this._requests.length = 0, this._queuedChunk = null;
                             }
                             _onProgress(w) {
-                                var C;
-                                this.isStreamingSupported || (C = this.onProgress) == null || C.call(this, {
+                                var T;
+                                this.isStreamingSupported || (T = this.onProgress) == null || T.call(this, {
                                     loaded: w.loaded
                                 });
                             }
                             get isStreamingSupported() {
                                 return !1;
                             }
                             async read() {
                                 if (this._storedError)
                                     throw this._storedError;
                                 if (this._queuedChunk !== null) {
-                                    const C = this._queuedChunk;
+                                    const T = this._queuedChunk;
                                     return this._queuedChunk = null, {
-                                        value: C,
+                                        value: T,
                                         done: !1
                                     };
                                 }
                                 if (this._done)
                                     return {
                                         value: void 0,
                                         done: !0
                                     };
-                                const w = new n.PromiseCapability();
+                                const w = new e.PromiseCapability();
                                 return this._requests.push(w), w.promise;
                             }
                             cancel(w) {
                                 this._done = !0;
-                                for (const C of this._requests)
-                                    C.resolve({
+                                for (const T of this._requests)
+                                    T.resolve({
                                         value: void 0,
                                         done: !0
                                     });
                                 this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
                             }
                         }
                     },
                     /* 23 */
                     /***/
-                    (t, e, i) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.PDFNodeStream = void 0;
-                        var n = i(1),
-                            s = i(20);
-                        const l = /^file:\/\/\/[a-zA-Z]:\//;
-
-                        function h(P) {
-                            const b = require$$5,
-                                k = b.parse(P);
-                            return k.protocol === "file:" || k.host ? k : /^[a-z]:[/\\]/i.test(P) ? b.parse(`file:///${P}`) : (k.host || (k.protocol = "file:"), k);
+                        }), t.PDFNodeStream = void 0;
+                        var e = n(1),
+                            s = n(20);
+                        const p = /^file:\/\/\/[a-zA-Z]:\//;
+
+                        function f(P) {
+                            const m = require$$5,
+                                C = m.parse(P);
+                            return C.protocol === "file:" || C.host ? C : /^[a-z]:[/\\]/i.test(P) ? m.parse(`file:///${P}`) : (C.host || (C.protocol = "file:"), C);
                         }
-                        class _ {
-                            constructor(b) {
-                                this.source = b, this.url = h(b.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && b.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
+                        class A {
+                            constructor(m) {
+                                this.source = m, this.url = f(m.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && m.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
                             }
                             get _progressiveDataLength() {
-                                var b;
-                                return ((b = this._fullRequestReader) == null ? void 0 : b._loaded) ?? 0;
+                                var m;
+                                return ((m = this._fullRequestReader) == null ? void 0 : m._loaded) ?? 0;
                             }
                             getFullReader() {
-                                return (0, n.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new w(this) : new T(this), this._fullRequestReader;
+                                return (0, e.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new w(this) : new F(this), this._fullRequestReader;
                             }
-                            getRangeReader(b, k) {
-                                if (k <= this._progressiveDataLength)
+                            getRangeReader(m, C) {
+                                if (C <= this._progressiveDataLength)
                                     return null;
-                                const F = this.isFsUrl ? new C(this, b, k) : new S(this, b, k);
-                                return this._rangeRequestReaders.push(F), F;
+                                const x = this.isFsUrl ? new T(this, m, C) : new R(this, m, C);
+                                return this._rangeRequestReaders.push(x), x;
                             }
-                            cancelAllRequests(b) {
-                                var k;
-                                (k = this._fullRequestReader) == null || k.cancel(b);
-                                for (const F of this._rangeRequestReaders.slice(0))
-                                    F.cancel(b);
-                            }
-                        }
-                        e.PDFNodeStream = _;
-                        class c {
-                            constructor(b) {
-                                this._url = b.url, this._done = !1, this._storedError = null, this.onProgress = null;
-                                const k = b.source;
-                                this._contentLength = k.length, this._loaded = 0, this._filename = null, this._disableRange = k.disableRange || !1, this._rangeChunkSize = k.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !k.disableStream, this._isRangeSupported = !k.disableRange, this._readableStream = null, this._readCapability = new n.PromiseCapability(), this._headersCapability = new n.PromiseCapability();
+                            cancelAllRequests(m) {
+                                var C;
+                                (C = this._fullRequestReader) == null || C.cancel(m);
+                                for (const x of this._rangeRequestReaders.slice(0))
+                                    x.cancel(m);
+                            }
+                        }
+                        t.PDFNodeStream = A;
+                        class a {
+                            constructor(m) {
+                                this._url = m.url, this._done = !1, this._storedError = null, this.onProgress = null;
+                                const C = m.source;
+                                this._contentLength = C.length, this._loaded = 0, this._filename = null, this._disableRange = C.disableRange || !1, this._rangeChunkSize = C.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !C.disableStream, this._isRangeSupported = !C.disableRange, this._readableStream = null, this._readCapability = new e.PromiseCapability(), this._headersCapability = new e.PromiseCapability();
                             }
                             get headersReady() {
                                 return this._headersCapability.promise;
                             }
                             get filename() {
                                 return this._filename;
                             }
@@ -16074,548 +12671,548 @@
                             get isRangeSupported() {
                                 return this._isRangeSupported;
                             }
                             get isStreamingSupported() {
                                 return this._isStreamingSupported;
                             }
                             async read() {
-                                var F;
+                                var x;
                                 if (await this._readCapability.promise, this._done)
                                     return {
                                         value: void 0,
                                         done: !0
                                     };
                                 if (this._storedError)
                                     throw this._storedError;
-                                const b = this._readableStream.read();
-                                return b === null ? (this._readCapability = new n.PromiseCapability(), this.read()) : (this._loaded += b.length, (F = this.onProgress) == null || F.call(this, {
+                                const m = this._readableStream.read();
+                                return m === null ? (this._readCapability = new e.PromiseCapability(), this.read()) : (this._loaded += m.length, (x = this.onProgress) == null || x.call(this, {
                                     loaded: this._loaded,
                                     total: this._contentLength
                                 }), {
-                                    value: new Uint8Array(b).buffer,
+                                    value: new Uint8Array(m).buffer,
                                     done: !1
                                 });
                             }
-                            cancel(b) {
+                            cancel(m) {
                                 if (!this._readableStream) {
-                                    this._error(b);
+                                    this._error(m);
                                     return;
                                 }
-                                this._readableStream.destroy(b);
+                                this._readableStream.destroy(m);
                             }
-                            _error(b) {
-                                this._storedError = b, this._readCapability.resolve();
+                            _error(m) {
+                                this._storedError = m, this._readCapability.resolve();
                             }
-                            _setReadableStream(b) {
-                                this._readableStream = b, b.on("readable", () => {
+                            _setReadableStream(m) {
+                                this._readableStream = m, m.on("readable", () => {
                                     this._readCapability.resolve();
-                                }), b.on("end", () => {
-                                    b.destroy(), this._done = !0, this._readCapability.resolve();
-                                }), b.on("error", (k) => {
-                                    this._error(k);
-                                }), !this._isStreamingSupported && this._isRangeSupported && this._error(new n.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
+                                }), m.on("end", () => {
+                                    m.destroy(), this._done = !0, this._readCapability.resolve();
+                                }), m.on("error", (C) => {
+                                    this._error(C);
+                                }), !this._isStreamingSupported && this._isRangeSupported && this._error(new e.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
                             }
                         }
-                        class o {
-                            constructor(b) {
-                                this._url = b.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = new n.PromiseCapability();
-                                const k = b.source;
-                                this._isStreamingSupported = !k.disableStream;
+                        class h {
+                            constructor(m) {
+                                this._url = m.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = new e.PromiseCapability();
+                                const C = m.source;
+                                this._isStreamingSupported = !C.disableStream;
                             }
                             get isStreamingSupported() {
                                 return this._isStreamingSupported;
                             }
                             async read() {
-                                var F;
+                                var x;
                                 if (await this._readCapability.promise, this._done)
                                     return {
                                         value: void 0,
                                         done: !0
                                     };
                                 if (this._storedError)
                                     throw this._storedError;
-                                const b = this._readableStream.read();
-                                return b === null ? (this._readCapability = new n.PromiseCapability(), this.read()) : (this._loaded += b.length, (F = this.onProgress) == null || F.call(this, {
+                                const m = this._readableStream.read();
+                                return m === null ? (this._readCapability = new e.PromiseCapability(), this.read()) : (this._loaded += m.length, (x = this.onProgress) == null || x.call(this, {
                                     loaded: this._loaded
                                 }), {
-                                    value: new Uint8Array(b).buffer,
+                                    value: new Uint8Array(m).buffer,
                                     done: !1
                                 });
                             }
-                            cancel(b) {
+                            cancel(m) {
                                 if (!this._readableStream) {
-                                    this._error(b);
+                                    this._error(m);
                                     return;
                                 }
-                                this._readableStream.destroy(b);
+                                this._readableStream.destroy(m);
                             }
-                            _error(b) {
-                                this._storedError = b, this._readCapability.resolve();
+                            _error(m) {
+                                this._storedError = m, this._readCapability.resolve();
                             }
-                            _setReadableStream(b) {
-                                this._readableStream = b, b.on("readable", () => {
+                            _setReadableStream(m) {
+                                this._readableStream = m, m.on("readable", () => {
                                     this._readCapability.resolve();
-                                }), b.on("end", () => {
-                                    b.destroy(), this._done = !0, this._readCapability.resolve();
-                                }), b.on("error", (k) => {
-                                    this._error(k);
+                                }), m.on("end", () => {
+                                    m.destroy(), this._done = !0, this._readCapability.resolve();
+                                }), m.on("error", (C) => {
+                                    this._error(C);
                                 }), this._storedError && this._readableStream.destroy(this._storedError);
                             }
                         }
 
-                        function r(P, b) {
+                        function o(P, m) {
                             return {
                                 protocol: P.protocol,
                                 auth: P.auth,
                                 host: P.hostname,
                                 port: P.port,
                                 path: P.path,
                                 method: "GET",
-                                headers: b
+                                headers: m
                             };
                         }
-                        class T extends c {
-                            constructor(b) {
-                                super(b);
-                                const k = (F) => {
-                                    if (F.statusCode === 404) {
-                                        const E = new n.MissingPDFException(`Missing PDF "${this._url}".`);
-                                        this._storedError = E, this._headersCapability.reject(E);
+                        class F extends a {
+                            constructor(m) {
+                                super(m);
+                                const C = (x) => {
+                                    if (x.statusCode === 404) {
+                                        const v = new e.MissingPDFException(`Missing PDF "${this._url}".`);
+                                        this._storedError = v, this._headersCapability.reject(v);
                                         return;
                                     }
-                                    this._headersCapability.resolve(), this._setReadableStream(F);
-                                    const x = (E) => this._readableStream.headers[E.toLowerCase()],
+                                    this._headersCapability.resolve(), this._setReadableStream(x);
+                                    const E = (v) => this._readableStream.headers[v.toLowerCase()],
                                         {
-                                            allowRangeRequests: y,
-                                            suggestedLength: p
+                                            allowRangeRequests: S,
+                                            suggestedLength: g
                                         } = (0, s.validateRangeRequestCapabilities)({
-                                            getResponseHeader: x,
-                                            isHttp: b.isHttp,
+                                            getResponseHeader: E,
+                                            isHttp: m.isHttp,
                                             rangeChunkSize: this._rangeChunkSize,
                                             disableRange: this._disableRange
                                         });
-                                    this._isRangeSupported = y, this._contentLength = p || this._contentLength, this._filename = (0, s.extractFilenameFromHeader)(x);
+                                    this._isRangeSupported = S, this._contentLength = g || this._contentLength, this._filename = (0, s.extractFilenameFromHeader)(E);
                                 };
                                 if (this._request = null, this._url.protocol === "http:") {
-                                    const F = require$$5;
-                                    this._request = F.request(r(this._url, b.httpHeaders), k);
+                                    const x = require$$5;
+                                    this._request = x.request(o(this._url, m.httpHeaders), C);
                                 } else {
-                                    const F = require$$5;
-                                    this._request = F.request(r(this._url, b.httpHeaders), k);
+                                    const x = require$$5;
+                                    this._request = x.request(o(this._url, m.httpHeaders), C);
                                 }
-                                this._request.on("error", (F) => {
-                                    this._storedError = F, this._headersCapability.reject(F);
+                                this._request.on("error", (x) => {
+                                    this._storedError = x, this._headersCapability.reject(x);
                                 }), this._request.end();
                             }
                         }
-                        class S extends o {
-                            constructor(b, k, F) {
-                                super(b), this._httpHeaders = {};
-                                for (const y in b.httpHeaders) {
-                                    const p = b.httpHeaders[y];
-                                    p !== void 0 && (this._httpHeaders[y] = p);
-                                }
-                                this._httpHeaders.Range = `bytes=${k}-${F - 1}`;
-                                const x = (y) => {
-                                    if (y.statusCode === 404) {
-                                        const p = new n.MissingPDFException(`Missing PDF "${this._url}".`);
-                                        this._storedError = p;
+                        class R extends h {
+                            constructor(m, C, x) {
+                                super(m), this._httpHeaders = {};
+                                for (const S in m.httpHeaders) {
+                                    const g = m.httpHeaders[S];
+                                    g !== void 0 && (this._httpHeaders[S] = g);
+                                }
+                                this._httpHeaders.Range = `bytes=${C}-${x - 1}`;
+                                const E = (S) => {
+                                    if (S.statusCode === 404) {
+                                        const g = new e.MissingPDFException(`Missing PDF "${this._url}".`);
+                                        this._storedError = g;
                                         return;
                                     }
-                                    this._setReadableStream(y);
+                                    this._setReadableStream(S);
                                 };
                                 if (this._request = null, this._url.protocol === "http:") {
-                                    const y = require$$5;
-                                    this._request = y.request(r(this._url, this._httpHeaders), x);
+                                    const S = require$$5;
+                                    this._request = S.request(o(this._url, this._httpHeaders), E);
                                 } else {
-                                    const y = require$$5;
-                                    this._request = y.request(r(this._url, this._httpHeaders), x);
+                                    const S = require$$5;
+                                    this._request = S.request(o(this._url, this._httpHeaders), E);
                                 }
-                                this._request.on("error", (y) => {
-                                    this._storedError = y;
+                                this._request.on("error", (S) => {
+                                    this._storedError = S;
                                 }), this._request.end();
                             }
                         }
-                        class w extends c {
-                            constructor(b) {
-                                super(b);
-                                let k = decodeURIComponent(this._url.path);
-                                l.test(this._url.href) && (k = k.replace(/^\//, ""));
-                                const F = require$$5;
-                                F.lstat(k, (x, y) => {
-                                    if (x) {
-                                        x.code === "ENOENT" && (x = new n.MissingPDFException(`Missing PDF "${k}".`)), this._storedError = x, this._headersCapability.reject(x);
+                        class w extends a {
+                            constructor(m) {
+                                super(m);
+                                let C = decodeURIComponent(this._url.path);
+                                p.test(this._url.href) && (C = C.replace(/^\//, ""));
+                                const x = require$$5;
+                                x.lstat(C, (E, S) => {
+                                    if (E) {
+                                        E.code === "ENOENT" && (E = new e.MissingPDFException(`Missing PDF "${C}".`)), this._storedError = E, this._headersCapability.reject(E);
                                         return;
                                     }
-                                    this._contentLength = y.size, this._setReadableStream(F.createReadStream(k)), this._headersCapability.resolve();
+                                    this._contentLength = S.size, this._setReadableStream(x.createReadStream(C)), this._headersCapability.resolve();
                                 });
                             }
                         }
-                        class C extends o {
-                            constructor(b, k, F) {
-                                super(b);
-                                let x = decodeURIComponent(this._url.path);
-                                l.test(this._url.href) && (x = x.replace(/^\//, ""));
-                                const y = require$$5;
-                                this._setReadableStream(y.createReadStream(x, {
-                                    start: k,
-                                    end: F - 1
+                        class T extends h {
+                            constructor(m, C, x) {
+                                super(m);
+                                let E = decodeURIComponent(this._url.path);
+                                p.test(this._url.href) && (E = E.replace(/^\//, ""));
+                                const S = require$$5;
+                                this._setReadableStream(S.createReadStream(E, {
+                                    start: C,
+                                    end: x - 1
                                 }));
                             }
                         }
                     },
                     /* 24 */
                     /***/
-                    (t, e, i) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.SVGGraphics = void 0;
-                        var n = i(6),
-                            s = i(1);
-                        const l = {
+                        }), t.SVGGraphics = void 0;
+                        var e = n(6),
+                            s = n(1);
+                        const p = {
                                 fontStyle: "normal",
                                 fontWeight: "normal",
                                 fillColor: "#000000"
                             },
-                            h = "http://www.w3.org/XML/1998/namespace",
-                            _ = "http://www.w3.org/1999/xlink",
-                            c = ["butt", "round", "square"],
-                            o = ["miter", "round", "bevel"],
-                            r = function(y, p = "", E = !1) {
-                                if (URL.createObjectURL && typeof Blob < "u" && !E)
-                                    return URL.createObjectURL(new Blob([y], {
-                                        type: p
+                            f = "http://www.w3.org/XML/1998/namespace",
+                            A = "http://www.w3.org/1999/xlink",
+                            a = ["butt", "round", "square"],
+                            h = ["miter", "round", "bevel"],
+                            o = function(S, g = "", v = !1) {
+                                if (URL.createObjectURL && typeof Blob < "u" && !v)
+                                    return URL.createObjectURL(new Blob([S], {
+                                        type: g
                                     }));
                                 const $ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
-                                let M = `data:${p};base64,`;
-                                for (let m = 0, N = y.length; m < N; m += 3) {
-                                    const D = y[m] & 255,
-                                        X = y[m + 1] & 255,
-                                        G = y[m + 2] & 255,
+                                let M = `data:${g};base64,`;
+                                for (let _ = 0, N = S.length; _ < N; _ += 3) {
+                                    const D = S[_] & 255,
+                                        X = S[_ + 1] & 255,
+                                        Y = S[_ + 2] & 255,
                                         I = D >> 2,
-                                        B = (D & 3) << 4 | X >> 4,
-                                        ee = m + 1 < N ? (X & 15) << 2 | G >> 6 : 64,
-                                        Y = m + 2 < N ? G & 63 : 64;
-                                    M += $[I] + $[B] + $[ee] + $[Y];
+                                        U = (D & 3) << 4 | X >> 4,
+                                        G = _ + 1 < N ? (X & 15) << 2 | Y >> 6 : 64,
+                                        V = _ + 2 < N ? Y & 63 : 64;
+                                    M += $[I] + $[U] + $[G] + $[V];
                                 }
                                 return M;
                             },
-                            T = function() {
-                                const y = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]),
-                                    p = 12,
-                                    E = new Int32Array(256);
-                                for (let G = 0; G < 256; G++) {
-                                    let I = G;
-                                    for (let B = 0; B < 8; B++)
+                            F = function() {
+                                const S = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]),
+                                    g = 12,
+                                    v = new Int32Array(256);
+                                for (let Y = 0; Y < 256; Y++) {
+                                    let I = Y;
+                                    for (let U = 0; U < 8; U++)
                                         I = I & 1 ? 3988292384 ^ I >> 1 & 2147483647 : I >> 1 & 2147483647;
-                                    E[G] = I;
+                                    v[Y] = I;
                                 }
 
-                                function $(G, I, B) {
-                                    let ee = -1;
-                                    for (let Y = I; Y < B; Y++) {
-                                        const q = (ee ^ G[Y]) & 255,
-                                            le = E[q];
-                                        ee = ee >>> 8 ^ le;
+                                function $(Y, I, U) {
+                                    let G = -1;
+                                    for (let V = I; V < U; V++) {
+                                        const H = (G ^ Y[V]) & 255,
+                                            st = v[H];
+                                        G = G >>> 8 ^ st;
                                     }
-                                    return ee ^ -1;
+                                    return G ^ -1;
                                 }
 
-                                function M(G, I, B, ee) {
-                                    let Y = ee;
-                                    const q = I.length;
-                                    B[Y] = q >> 24 & 255, B[Y + 1] = q >> 16 & 255, B[Y + 2] = q >> 8 & 255, B[Y + 3] = q & 255, Y += 4, B[Y] = G.charCodeAt(0) & 255, B[Y + 1] = G.charCodeAt(1) & 255, B[Y + 2] = G.charCodeAt(2) & 255, B[Y + 3] = G.charCodeAt(3) & 255, Y += 4, B.set(I, Y), Y += I.length;
-                                    const le = $(B, ee + 4, Y);
-                                    B[Y] = le >> 24 & 255, B[Y + 1] = le >> 16 & 255, B[Y + 2] = le >> 8 & 255, B[Y + 3] = le & 255;
+                                function M(Y, I, U, G) {
+                                    let V = G;
+                                    const H = I.length;
+                                    U[V] = H >> 24 & 255, U[V + 1] = H >> 16 & 255, U[V + 2] = H >> 8 & 255, U[V + 3] = H & 255, V += 4, U[V] = Y.charCodeAt(0) & 255, U[V + 1] = Y.charCodeAt(1) & 255, U[V + 2] = Y.charCodeAt(2) & 255, U[V + 3] = Y.charCodeAt(3) & 255, V += 4, U.set(I, V), V += I.length;
+                                    const st = $(U, G + 4, V);
+                                    U[V] = st >> 24 & 255, U[V + 1] = st >> 16 & 255, U[V + 2] = st >> 8 & 255, U[V + 3] = st & 255;
                                 }
 
-                                function m(G, I, B) {
-                                    let ee = 1,
-                                        Y = 0;
-                                    for (let q = I; q < B; ++q)
-                                        ee = (ee + (G[q] & 255)) % 65521, Y = (Y + ee) % 65521;
-                                    return Y << 16 | ee;
+                                function _(Y, I, U) {
+                                    let G = 1,
+                                        V = 0;
+                                    for (let H = I; H < U; ++H)
+                                        G = (G + (Y[H] & 255)) % 65521, V = (V + G) % 65521;
+                                    return V << 16 | G;
                                 }
 
-                                function N(G) {
+                                function N(Y) {
                                     if (!s.isNodeJS)
-                                        return D(G);
+                                        return D(Y);
                                     try {
-                                        const I = parseInt(process.versions.node) >= 8 ? G : Buffer.from(G),
-                                            B = require$$5.deflateSync(I, {
+                                        const I = parseInt(process.versions.node) >= 8 ? Y : Buffer.from(Y),
+                                            U = require$$5.deflateSync(I, {
                                                 level: 9
                                             });
-                                        return B instanceof Uint8Array ? B : new Uint8Array(B);
+                                        return U instanceof Uint8Array ? U : new Uint8Array(U);
                                     } catch (I) {
                                         (0, s.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + I);
                                     }
-                                    return D(G);
+                                    return D(Y);
+                                }
+
+                                function D(Y) {
+                                    let I = Y.length;
+                                    const U = 65535,
+                                        G = Math.ceil(I / U),
+                                        V = new Uint8Array(2 + I + G * 5 + 4);
+                                    let H = 0;
+                                    V[H++] = 120, V[H++] = 156;
+                                    let st = 0;
+                                    for (; I > U;)
+                                        V[H++] = 0, V[H++] = 255, V[H++] = 255, V[H++] = 0, V[H++] = 0, V.set(Y.subarray(st, st + U), H), H += U, st += U, I -= U;
+                                    V[H++] = 1, V[H++] = I & 255, V[H++] = I >> 8 & 255, V[H++] = ~I & 65535 & 255, V[H++] = (~I & 65535) >> 8 & 255, V.set(Y.subarray(st), H), H += Y.length - st;
+                                    const dt = _(Y, 0, Y.length);
+                                    return V[H++] = dt >> 24 & 255, V[H++] = dt >> 16 & 255, V[H++] = dt >> 8 & 255, V[H++] = dt & 255, V;
                                 }
 
-                                function D(G) {
-                                    let I = G.length;
-                                    const B = 65535,
-                                        ee = Math.ceil(I / B),
-                                        Y = new Uint8Array(2 + I + ee * 5 + 4);
-                                    let q = 0;
-                                    Y[q++] = 120, Y[q++] = 156;
-                                    let le = 0;
-                                    for (; I > B;)
-                                        Y[q++] = 0, Y[q++] = 255, Y[q++] = 255, Y[q++] = 0, Y[q++] = 0, Y.set(G.subarray(le, le + B), q), q += B, le += B, I -= B;
-                                    Y[q++] = 1, Y[q++] = I & 255, Y[q++] = I >> 8 & 255, Y[q++] = ~I & 65535 & 255, Y[q++] = (~I & 65535) >> 8 & 255, Y.set(G.subarray(le), q), q += G.length - le;
-                                    const pe = m(G, 0, G.length);
-                                    return Y[q++] = pe >> 24 & 255, Y[q++] = pe >> 16 & 255, Y[q++] = pe >> 8 & 255, Y[q++] = pe & 255, Y;
-                                }
-
-                                function X(G, I, B, ee) {
-                                    const Y = G.width,
-                                        q = G.height;
-                                    let le, pe, we;
-                                    const be = G.data;
+                                function X(Y, I, U, G) {
+                                    const V = Y.width,
+                                        H = Y.height;
+                                    let st, dt, yt;
+                                    const gt = Y.data;
                                     switch (I) {
                                         case s.ImageKind.GRAYSCALE_1BPP:
-                                            pe = 0, le = 1, we = Y + 7 >> 3;
+                                            dt = 0, st = 1, yt = V + 7 >> 3;
                                             break;
                                         case s.ImageKind.RGB_24BPP:
-                                            pe = 2, le = 8, we = Y * 3;
+                                            dt = 2, st = 8, yt = V * 3;
                                             break;
                                         case s.ImageKind.RGBA_32BPP:
-                                            pe = 6, le = 8, we = Y * 4;
+                                            dt = 6, st = 8, yt = V * 4;
                                             break;
                                         default:
                                             throw new Error("invalid format");
                                     }
-                                    const R = new Uint8Array((1 + we) * q);
-                                    let d = 0,
-                                        g = 0;
-                                    for (let z = 0; z < q; ++z)
-                                        R[d++] = 0, R.set(be.subarray(g, g + we), d), g += we, d += we;
-                                    if (I === s.ImageKind.GRAYSCALE_1BPP && ee) {
-                                        d = 0;
-                                        for (let z = 0; z < q; z++) {
-                                            d++;
-                                            for (let ae = 0; ae < we; ae++)
-                                                R[d++] ^= 255;
+                                    const k = new Uint8Array((1 + yt) * H);
+                                    let l = 0,
+                                        u = 0;
+                                    for (let z = 0; z < H; ++z)
+                                        k[l++] = 0, k.set(gt.subarray(u, u + yt), l), u += yt, l += yt;
+                                    if (I === s.ImageKind.GRAYSCALE_1BPP && G) {
+                                        l = 0;
+                                        for (let z = 0; z < H; z++) {
+                                            l++;
+                                            for (let it = 0; it < yt; it++)
+                                                k[l++] ^= 255;
                                         }
                                     }
-                                    const f = new Uint8Array([Y >> 24 & 255, Y >> 16 & 255, Y >> 8 & 255, Y & 255, q >> 24 & 255, q >> 16 & 255, q >> 8 & 255, q & 255, le, pe, 0, 0, 0]),
-                                        v = N(R),
-                                        A = y.length + p * 3 + f.length + v.length,
-                                        O = new Uint8Array(A);
-                                    let H = 0;
-                                    return O.set(y, H), H += y.length, M("IHDR", f, O, H), H += p + f.length, M("IDATA", v, O, H), H += p + v.length, M("IEND", new Uint8Array(0), O, H), r(O, "image/png", B);
-                                }
-                                return function(I, B, ee) {
-                                    const Y = I.kind === void 0 ? s.ImageKind.GRAYSCALE_1BPP : I.kind;
-                                    return X(I, Y, B, ee);
+                                    const d = new Uint8Array([V >> 24 & 255, V >> 16 & 255, V >> 8 & 255, V & 255, H >> 24 & 255, H >> 16 & 255, H >> 8 & 255, H & 255, st, dt, 0, 0, 0]),
+                                        b = N(k),
+                                        y = S.length + g * 3 + d.length + b.length,
+                                        O = new Uint8Array(y);
+                                    let B = 0;
+                                    return O.set(S, B), B += S.length, M("IHDR", d, O, B), B += g + d.length, M("IDATA", b, O, B), B += g + b.length, M("IEND", new Uint8Array(0), O, B), o(O, "image/png", U);
+                                }
+                                return function(I, U, G) {
+                                    const V = I.kind === void 0 ? s.ImageKind.GRAYSCALE_1BPP : I.kind;
+                                    return X(I, V, U, G);
                                 };
                             }();
-                        class S {
+                        class R {
                             constructor() {
-                                this.fontSizeScale = 1, this.fontWeight = l.fontWeight, this.fontSize = 0, this.textMatrix = s.IDENTITY_MATRIX, this.fontMatrix = s.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = s.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = l.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = "";
+                                this.fontSizeScale = 1, this.fontWeight = p.fontWeight, this.fontSize = 0, this.textMatrix = s.IDENTITY_MATRIX, this.fontMatrix = s.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = s.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = p.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = "";
                             }
                             clone() {
                                 return Object.create(this);
                             }
-                            setCurrentPoint(p, E) {
-                                this.x = p, this.y = E;
+                            setCurrentPoint(g, v) {
+                                this.x = g, this.y = v;
                             }
                         }
 
-                        function w(y) {
-                            let p = [];
-                            const E = [];
-                            for (const $ of y) {
+                        function w(S) {
+                            let g = [];
+                            const v = [];
+                            for (const $ of S) {
                                 if ($.fn === "save") {
-                                    p.push({
+                                    g.push({
                                         fnId: 92,
                                         fn: "group",
                                         items: []
-                                    }), E.push(p), p = p.at(-1).items;
+                                    }), v.push(g), g = g.at(-1).items;
                                     continue;
                                 }
-                                $.fn === "restore" ? p = E.pop() : p.push($);
+                                $.fn === "restore" ? g = v.pop() : g.push($);
                             }
-                            return p;
+                            return g;
                         }
 
-                        function C(y) {
-                            if (Number.isInteger(y))
-                                return y.toString();
-                            const p = y.toFixed(10);
-                            let E = p.length - 1;
-                            if (p[E] !== "0")
-                                return p;
+                        function T(S) {
+                            if (Number.isInteger(S))
+                                return S.toString();
+                            const g = S.toFixed(10);
+                            let v = g.length - 1;
+                            if (g[v] !== "0")
+                                return g;
                             do
-                                E--;
-                            while (p[E] === "0");
-                            return p.substring(0, p[E] === "." ? E : E + 1);
-                        }
-
-                        function P(y) {
-                            if (y[4] === 0 && y[5] === 0) {
-                                if (y[1] === 0 && y[2] === 0)
-                                    return y[0] === 1 && y[3] === 1 ? "" : `scale(${C(y[0])} ${C(y[3])})`;
-                                if (y[0] === y[3] && y[1] === -y[2]) {
-                                    const p = Math.acos(y[0]) * 180 / Math.PI;
-                                    return `rotate(${C(p)})`;
-                                }
-                            } else if (y[0] === 1 && y[1] === 0 && y[2] === 0 && y[3] === 1)
-                                return `translate(${C(y[4])} ${C(y[5])})`;
-                            return `matrix(${C(y[0])} ${C(y[1])} ${C(y[2])} ${C(y[3])} ${C(y[4])} ${C(y[5])})`;
-                        }
-                        let b = 0,
-                            k = 0,
-                            F = 0;
-                        class x {
-                            constructor(p, E, $ = !1) {
-                                (0, n.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future."), this.svgFactory = new n.DOMSVGFactory(), this.current = new S(), this.transformMatrix = s.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = p, this.objs = E, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = /* @__PURE__ */ Object.create(null), this.cssStyle = null, this.forceDataSchema = !!$, this._operatorIdMapping = [];
+                                v--;
+                            while (g[v] === "0");
+                            return g.substring(0, g[v] === "." ? v : v + 1);
+                        }
+
+                        function P(S) {
+                            if (S[4] === 0 && S[5] === 0) {
+                                if (S[1] === 0 && S[2] === 0)
+                                    return S[0] === 1 && S[3] === 1 ? "" : `scale(${T(S[0])} ${T(S[3])})`;
+                                if (S[0] === S[3] && S[1] === -S[2]) {
+                                    const g = Math.acos(S[0]) * 180 / Math.PI;
+                                    return `rotate(${T(g)})`;
+                                }
+                            } else if (S[0] === 1 && S[1] === 0 && S[2] === 0 && S[3] === 1)
+                                return `translate(${T(S[4])} ${T(S[5])})`;
+                            return `matrix(${T(S[0])} ${T(S[1])} ${T(S[2])} ${T(S[3])} ${T(S[4])} ${T(S[5])})`;
+                        }
+                        let m = 0,
+                            C = 0,
+                            x = 0;
+                        class E {
+                            constructor(g, v, $ = !1) {
+                                (0, e.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future."), this.svgFactory = new e.DOMSVGFactory(), this.current = new R(), this.transformMatrix = s.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = g, this.objs = v, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = /* @__PURE__ */ Object.create(null), this.cssStyle = null, this.forceDataSchema = !!$, this._operatorIdMapping = [];
                                 for (const M in s.OPS)
                                     this._operatorIdMapping[s.OPS[M]] = M;
                             }
-                            getObject(p, E = null) {
-                                return typeof p == "string" ? p.startsWith("g_") ? this.commonObjs.get(p) : this.objs.get(p) : E;
+                            getObject(g, v = null) {
+                                return typeof g == "string" ? g.startsWith("g_") ? this.commonObjs.get(g) : this.objs.get(g) : v;
                             }
                             save() {
                                 this.transformStack.push(this.transformMatrix);
-                                const p = this.current;
-                                this.extraStack.push(p), this.current = p.clone();
+                                const g = this.current;
+                                this.extraStack.push(g), this.current = g.clone();
                             }
                             restore() {
                                 this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.pendingClip = null, this.tgrp = null;
                             }
-                            group(p) {
-                                this.save(), this.executeOpTree(p), this.restore();
+                            group(g) {
+                                this.save(), this.executeOpTree(g), this.restore();
                             }
-                            loadDependencies(p) {
-                                const E = p.fnArray,
-                                    $ = p.argsArray;
-                                for (let M = 0, m = E.length; M < m; M++)
-                                    if (E[M] === s.OPS.dependency)
+                            loadDependencies(g) {
+                                const v = g.fnArray,
+                                    $ = g.argsArray;
+                                for (let M = 0, _ = v.length; M < _; M++)
+                                    if (v[M] === s.OPS.dependency)
                                         for (const N of $[M]) {
                                             const D = N.startsWith("g_") ? this.commonObjs : this.objs,
-                                                X = new Promise((G) => {
-                                                    D.get(N, G);
+                                                X = new Promise((Y) => {
+                                                    D.get(N, Y);
                                                 });
                                             this.current.dependencies.push(X);
                                         }
                                 return Promise.all(this.current.dependencies);
                             }
-                            transform(p, E, $, M, m, N) {
-                                const D = [p, E, $, M, m, N];
+                            transform(g, v, $, M, _, N) {
+                                const D = [g, v, $, M, _, N];
                                 this.transformMatrix = s.Util.transform(this.transformMatrix, D), this.tgrp = null;
                             }
-                            getSVG(p, E) {
-                                this.viewport = E;
-                                const $ = this._initialize(E);
-                                return this.loadDependencies(p).then(() => (this.transformMatrix = s.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(p)), $));
-                            }
-                            convertOpList(p) {
-                                const E = this._operatorIdMapping,
-                                    $ = p.argsArray,
-                                    M = p.fnArray,
-                                    m = [];
+                            getSVG(g, v) {
+                                this.viewport = v;
+                                const $ = this._initialize(v);
+                                return this.loadDependencies(g).then(() => (this.transformMatrix = s.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(g)), $));
+                            }
+                            convertOpList(g) {
+                                const v = this._operatorIdMapping,
+                                    $ = g.argsArray,
+                                    M = g.fnArray,
+                                    _ = [];
                                 for (let N = 0, D = M.length; N < D; N++) {
                                     const X = M[N];
-                                    m.push({
+                                    _.push({
                                         fnId: X,
-                                        fn: E[X],
+                                        fn: v[X],
                                         args: $[N]
                                     });
                                 }
-                                return w(m);
+                                return w(_);
                             }
-                            executeOpTree(p) {
-                                for (const E of p) {
-                                    const $ = E.fn,
-                                        M = E.fnId,
-                                        m = E.args;
+                            executeOpTree(g) {
+                                for (const v of g) {
+                                    const $ = v.fn,
+                                        M = v.fnId,
+                                        _ = v.args;
                                     switch (M | 0) {
                                         case s.OPS.beginText:
                                             this.beginText();
                                             break;
                                         case s.OPS.dependency:
                                             break;
                                         case s.OPS.setLeading:
-                                            this.setLeading(m);
+                                            this.setLeading(_);
                                             break;
                                         case s.OPS.setLeadingMoveText:
-                                            this.setLeadingMoveText(m[0], m[1]);
+                                            this.setLeadingMoveText(_[0], _[1]);
                                             break;
                                         case s.OPS.setFont:
-                                            this.setFont(m);
+                                            this.setFont(_);
                                             break;
                                         case s.OPS.showText:
-                                            this.showText(m[0]);
+                                            this.showText(_[0]);
                                             break;
                                         case s.OPS.showSpacedText:
-                                            this.showText(m[0]);
+                                            this.showText(_[0]);
                                             break;
                                         case s.OPS.endText:
                                             this.endText();
                                             break;
                                         case s.OPS.moveText:
-                                            this.moveText(m[0], m[1]);
+                                            this.moveText(_[0], _[1]);
                                             break;
                                         case s.OPS.setCharSpacing:
-                                            this.setCharSpacing(m[0]);
+                                            this.setCharSpacing(_[0]);
                                             break;
                                         case s.OPS.setWordSpacing:
-                                            this.setWordSpacing(m[0]);
+                                            this.setWordSpacing(_[0]);
                                             break;
                                         case s.OPS.setHScale:
-                                            this.setHScale(m[0]);
+                                            this.setHScale(_[0]);
                                             break;
                                         case s.OPS.setTextMatrix:
-                                            this.setTextMatrix(m[0], m[1], m[2], m[3], m[4], m[5]);
+                                            this.setTextMatrix(_[0], _[1], _[2], _[3], _[4], _[5]);
                                             break;
                                         case s.OPS.setTextRise:
-                                            this.setTextRise(m[0]);
+                                            this.setTextRise(_[0]);
                                             break;
                                         case s.OPS.setTextRenderingMode:
-                                            this.setTextRenderingMode(m[0]);
+                                            this.setTextRenderingMode(_[0]);
                                             break;
                                         case s.OPS.setLineWidth:
-                                            this.setLineWidth(m[0]);
+                                            this.setLineWidth(_[0]);
                                             break;
                                         case s.OPS.setLineJoin:
-                                            this.setLineJoin(m[0]);
+                                            this.setLineJoin(_[0]);
                                             break;
                                         case s.OPS.setLineCap:
-                                            this.setLineCap(m[0]);
+                                            this.setLineCap(_[0]);
                                             break;
                                         case s.OPS.setMiterLimit:
-                                            this.setMiterLimit(m[0]);
+                                            this.setMiterLimit(_[0]);
                                             break;
                                         case s.OPS.setFillRGBColor:
-                                            this.setFillRGBColor(m[0], m[1], m[2]);
+                                            this.setFillRGBColor(_[0], _[1], _[2]);
                                             break;
                                         case s.OPS.setStrokeRGBColor:
-                                            this.setStrokeRGBColor(m[0], m[1], m[2]);
+                                            this.setStrokeRGBColor(_[0], _[1], _[2]);
                                             break;
                                         case s.OPS.setStrokeColorN:
-                                            this.setStrokeColorN(m);
+                                            this.setStrokeColorN(_);
                                             break;
                                         case s.OPS.setFillColorN:
-                                            this.setFillColorN(m);
+                                            this.setFillColorN(_);
                                             break;
                                         case s.OPS.shadingFill:
-                                            this.shadingFill(m[0]);
+                                            this.shadingFill(_[0]);
                                             break;
                                         case s.OPS.setDash:
-                                            this.setDash(m[0], m[1]);
+                                            this.setDash(_[0], _[1]);
                                             break;
                                         case s.OPS.setRenderingIntent:
-                                            this.setRenderingIntent(m[0]);
+                                            this.setRenderingIntent(_[0]);
                                             break;
                                         case s.OPS.setFlatness:
-                                            this.setFlatness(m[0]);
+                                            this.setFlatness(_[0]);
                                             break;
                                         case s.OPS.setGState:
-                                            this.setGState(m[0]);
+                                            this.setGState(_[0]);
                                             break;
                                         case s.OPS.fill:
                                             this.fill();
                                             break;
                                         case s.OPS.eoFill:
                                             this.eoFill();
                                             break;
@@ -16634,24 +13231,24 @@
                                         case s.OPS.eoClip:
                                             this.clip("evenodd");
                                             break;
                                         case s.OPS.paintSolidColorImageMask:
                                             this.paintSolidColorImageMask();
                                             break;
                                         case s.OPS.paintImageXObject:
-                                            this.paintImageXObject(m[0]);
+                                            this.paintImageXObject(_[0]);
                                             break;
                                         case s.OPS.paintInlineImageXObject:
-                                            this.paintInlineImageXObject(m[0]);
+                                            this.paintInlineImageXObject(_[0]);
                                             break;
                                         case s.OPS.paintImageMaskXObject:
-                                            this.paintImageMaskXObject(m[0]);
+                                            this.paintImageMaskXObject(_[0]);
                                             break;
                                         case s.OPS.paintFormXObjectBegin:
-                                            this.paintFormXObjectBegin(m[0], m[1]);
+                                            this.paintFormXObjectBegin(_[0], _[1]);
                                             break;
                                         case s.OPS.paintFormXObjectEnd:
                                             this.paintFormXObjectEnd();
                                             break;
                                         case s.OPS.closePath:
                                             this.closePath();
                                             break;
@@ -16664,314 +13261,314 @@
                                         case s.OPS.closeEOFillStroke:
                                             this.closeEOFillStroke();
                                             break;
                                         case s.OPS.nextLine:
                                             this.nextLine();
                                             break;
                                         case s.OPS.transform:
-                                            this.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
+                                            this.transform(_[0], _[1], _[2], _[3], _[4], _[5]);
                                             break;
                                         case s.OPS.constructPath:
-                                            this.constructPath(m[0], m[1]);
+                                            this.constructPath(_[0], _[1]);
                                             break;
                                         case s.OPS.endPath:
                                             this.endPath();
                                             break;
                                         case 92:
-                                            this.group(E.items);
+                                            this.group(v.items);
                                             break;
                                         default:
                                             (0, s.warn)(`Unimplemented operator ${$}`);
                                             break;
                                     }
                                 }
                             }
-                            setWordSpacing(p) {
-                                this.current.wordSpacing = p;
+                            setWordSpacing(g) {
+                                this.current.wordSpacing = g;
                             }
-                            setCharSpacing(p) {
-                                this.current.charSpacing = p;
+                            setCharSpacing(g) {
+                                this.current.charSpacing = g;
                             }
                             nextLine() {
                                 this.moveText(0, this.current.leading);
                             }
-                            setTextMatrix(p, E, $, M, m, N) {
+                            setTextMatrix(g, v, $, M, _, N) {
                                 const D = this.current;
-                                D.textMatrix = D.lineMatrix = [p, E, $, M, m, N], D.textMatrixScale = Math.hypot(p, E), D.x = D.lineX = 0, D.y = D.lineY = 0, D.xcoords = [], D.ycoords = [], D.tspan = this.svgFactory.createElement("svg:tspan"), D.tspan.setAttributeNS(null, "font-family", D.fontFamily), D.tspan.setAttributeNS(null, "font-size", `${C(D.fontSize)}px`), D.tspan.setAttributeNS(null, "y", C(-D.y)), D.txtElement = this.svgFactory.createElement("svg:text"), D.txtElement.append(D.tspan);
+                                D.textMatrix = D.lineMatrix = [g, v, $, M, _, N], D.textMatrixScale = Math.hypot(g, v), D.x = D.lineX = 0, D.y = D.lineY = 0, D.xcoords = [], D.ycoords = [], D.tspan = this.svgFactory.createElement("svg:tspan"), D.tspan.setAttributeNS(null, "font-family", D.fontFamily), D.tspan.setAttributeNS(null, "font-size", `${T(D.fontSize)}px`), D.tspan.setAttributeNS(null, "y", T(-D.y)), D.txtElement = this.svgFactory.createElement("svg:text"), D.txtElement.append(D.tspan);
                             }
                             beginText() {
-                                const p = this.current;
-                                p.x = p.lineX = 0, p.y = p.lineY = 0, p.textMatrix = s.IDENTITY_MATRIX, p.lineMatrix = s.IDENTITY_MATRIX, p.textMatrixScale = 1, p.tspan = this.svgFactory.createElement("svg:tspan"), p.txtElement = this.svgFactory.createElement("svg:text"), p.txtgrp = this.svgFactory.createElement("svg:g"), p.xcoords = [], p.ycoords = [];
+                                const g = this.current;
+                                g.x = g.lineX = 0, g.y = g.lineY = 0, g.textMatrix = s.IDENTITY_MATRIX, g.lineMatrix = s.IDENTITY_MATRIX, g.textMatrixScale = 1, g.tspan = this.svgFactory.createElement("svg:tspan"), g.txtElement = this.svgFactory.createElement("svg:text"), g.txtgrp = this.svgFactory.createElement("svg:g"), g.xcoords = [], g.ycoords = [];
                             }
-                            moveText(p, E) {
+                            moveText(g, v) {
                                 const $ = this.current;
-                                $.x = $.lineX += p, $.y = $.lineY += E, $.xcoords = [], $.ycoords = [], $.tspan = this.svgFactory.createElement("svg:tspan"), $.tspan.setAttributeNS(null, "font-family", $.fontFamily), $.tspan.setAttributeNS(null, "font-size", `${C($.fontSize)}px`), $.tspan.setAttributeNS(null, "y", C(-$.y));
+                                $.x = $.lineX += g, $.y = $.lineY += v, $.xcoords = [], $.ycoords = [], $.tspan = this.svgFactory.createElement("svg:tspan"), $.tspan.setAttributeNS(null, "font-family", $.fontFamily), $.tspan.setAttributeNS(null, "font-size", `${T($.fontSize)}px`), $.tspan.setAttributeNS(null, "y", T(-$.y));
                             }
-                            showText(p) {
-                                const E = this.current,
-                                    $ = E.font,
-                                    M = E.fontSize;
+                            showText(g) {
+                                const v = this.current,
+                                    $ = v.font,
+                                    M = v.fontSize;
                                 if (M === 0)
                                     return;
-                                const m = E.fontSizeScale,
-                                    N = E.charSpacing,
-                                    D = E.wordSpacing,
-                                    X = E.fontDirection,
-                                    G = E.textHScale * X,
+                                const _ = v.fontSizeScale,
+                                    N = v.charSpacing,
+                                    D = v.wordSpacing,
+                                    X = v.fontDirection,
+                                    Y = v.textHScale * X,
                                     I = $.vertical,
-                                    B = I ? 1 : -1,
-                                    ee = $.defaultVMetrics,
-                                    Y = M * E.fontMatrix[0];
-                                let q = 0;
-                                for (const we of p) {
-                                    if (we === null) {
-                                        q += X * D;
+                                    U = I ? 1 : -1,
+                                    G = $.defaultVMetrics,
+                                    V = M * v.fontMatrix[0];
+                                let H = 0;
+                                for (const yt of g) {
+                                    if (yt === null) {
+                                        H += X * D;
                                         continue;
-                                    } else if (typeof we == "number") {
-                                        q += B * we * M / 1e3;
+                                    } else if (typeof yt == "number") {
+                                        H += U * yt * M / 1e3;
                                         continue;
                                     }
-                                    const be = (we.isSpace ? D : 0) + N,
-                                        R = we.fontChar;
-                                    let d, g, f = we.width;
+                                    const gt = (yt.isSpace ? D : 0) + N,
+                                        k = yt.fontChar;
+                                    let l, u, d = yt.width;
                                     if (I) {
-                                        let A;
-                                        const O = we.vmetric || ee;
-                                        A = we.vmetric ? O[1] : f * 0.5, A = -A * Y;
-                                        const H = O[2] * Y;
-                                        f = O ? -O[0] : f, d = A / m, g = (q + H) / m;
+                                        let y;
+                                        const O = yt.vmetric || G;
+                                        y = yt.vmetric ? O[1] : d * 0.5, y = -y * V;
+                                        const B = O[2] * V;
+                                        d = O ? -O[0] : d, l = y / _, u = (H + B) / _;
                                     } else
-                                        d = q / m, g = 0;
-                                    (we.isInFont || $.missingFile) && (E.xcoords.push(E.x + d), I && E.ycoords.push(-E.y + g), E.tspan.textContent += R);
-                                    const v = I ? f * Y - be * X : f * Y + be * X;
-                                    q += v;
-                                }
-                                E.tspan.setAttributeNS(null, "x", E.xcoords.map(C).join(" ")), I ? E.tspan.setAttributeNS(null, "y", E.ycoords.map(C).join(" ")) : E.tspan.setAttributeNS(null, "y", C(-E.y)), I ? E.y -= q : E.x += q * G, E.tspan.setAttributeNS(null, "font-family", E.fontFamily), E.tspan.setAttributeNS(null, "font-size", `${C(E.fontSize)}px`), E.fontStyle !== l.fontStyle && E.tspan.setAttributeNS(null, "font-style", E.fontStyle), E.fontWeight !== l.fontWeight && E.tspan.setAttributeNS(null, "font-weight", E.fontWeight);
-                                const le = E.textRenderingMode & s.TextRenderingMode.FILL_STROKE_MASK;
-                                if (le === s.TextRenderingMode.FILL || le === s.TextRenderingMode.FILL_STROKE ? (E.fillColor !== l.fillColor && E.tspan.setAttributeNS(null, "fill", E.fillColor), E.fillAlpha < 1 && E.tspan.setAttributeNS(null, "fill-opacity", E.fillAlpha)) : E.textRenderingMode === s.TextRenderingMode.ADD_TO_PATH ? E.tspan.setAttributeNS(null, "fill", "transparent") : E.tspan.setAttributeNS(null, "fill", "none"), le === s.TextRenderingMode.STROKE || le === s.TextRenderingMode.FILL_STROKE) {
-                                    const we = 1 / (E.textMatrixScale || 1);
-                                    this._setStrokeAttributes(E.tspan, we);
+                                        l = H / _, u = 0;
+                                    (yt.isInFont || $.missingFile) && (v.xcoords.push(v.x + l), I && v.ycoords.push(-v.y + u), v.tspan.textContent += k);
+                                    const b = I ? d * V - gt * X : d * V + gt * X;
+                                    H += b;
+                                }
+                                v.tspan.setAttributeNS(null, "x", v.xcoords.map(T).join(" ")), I ? v.tspan.setAttributeNS(null, "y", v.ycoords.map(T).join(" ")) : v.tspan.setAttributeNS(null, "y", T(-v.y)), I ? v.y -= H : v.x += H * Y, v.tspan.setAttributeNS(null, "font-family", v.fontFamily), v.tspan.setAttributeNS(null, "font-size", `${T(v.fontSize)}px`), v.fontStyle !== p.fontStyle && v.tspan.setAttributeNS(null, "font-style", v.fontStyle), v.fontWeight !== p.fontWeight && v.tspan.setAttributeNS(null, "font-weight", v.fontWeight);
+                                const st = v.textRenderingMode & s.TextRenderingMode.FILL_STROKE_MASK;
+                                if (st === s.TextRenderingMode.FILL || st === s.TextRenderingMode.FILL_STROKE ? (v.fillColor !== p.fillColor && v.tspan.setAttributeNS(null, "fill", v.fillColor), v.fillAlpha < 1 && v.tspan.setAttributeNS(null, "fill-opacity", v.fillAlpha)) : v.textRenderingMode === s.TextRenderingMode.ADD_TO_PATH ? v.tspan.setAttributeNS(null, "fill", "transparent") : v.tspan.setAttributeNS(null, "fill", "none"), st === s.TextRenderingMode.STROKE || st === s.TextRenderingMode.FILL_STROKE) {
+                                    const yt = 1 / (v.textMatrixScale || 1);
+                                    this._setStrokeAttributes(v.tspan, yt);
                                 }
-                                let pe = E.textMatrix;
-                                E.textRise !== 0 && (pe = pe.slice(), pe[5] += E.textRise), E.txtElement.setAttributeNS(null, "transform", `${P(pe)} scale(${C(G)}, -1)`), E.txtElement.setAttributeNS(h, "xml:space", "preserve"), E.txtElement.append(E.tspan), E.txtgrp.append(E.txtElement), this._ensureTransformGroup().append(E.txtElement);
+                                let dt = v.textMatrix;
+                                v.textRise !== 0 && (dt = dt.slice(), dt[5] += v.textRise), v.txtElement.setAttributeNS(null, "transform", `${P(dt)} scale(${T(Y)}, -1)`), v.txtElement.setAttributeNS(f, "xml:space", "preserve"), v.txtElement.append(v.tspan), v.txtgrp.append(v.txtElement), this._ensureTransformGroup().append(v.txtElement);
                             }
-                            setLeadingMoveText(p, E) {
-                                this.setLeading(-E), this.moveText(p, E);
+                            setLeadingMoveText(g, v) {
+                                this.setLeading(-v), this.moveText(g, v);
                             }
-                            addFontStyle(p) {
-                                if (!p.data)
+                            addFontStyle(g) {
+                                if (!g.data)
                                     throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                                 this.cssStyle || (this.cssStyle = this.svgFactory.createElement("svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.append(this.cssStyle));
-                                const E = r(p.data, p.mimetype, this.forceDataSchema);
-                                this.cssStyle.textContent += `@font-face { font-family: "${p.loadedName}"; src: url(${E}); }
+                                const v = o(g.data, g.mimetype, this.forceDataSchema);
+                                this.cssStyle.textContent += `@font-face { font-family: "${g.loadedName}"; src: url(${v}); }
 `;
                             }
-                            setFont(p) {
-                                const E = this.current,
-                                    $ = this.commonObjs.get(p[0]);
-                                let M = p[1];
-                                E.font = $, this.embedFonts && !$.missingFile && !this.embeddedFonts[$.loadedName] && (this.addFontStyle($), this.embeddedFonts[$.loadedName] = $), E.fontMatrix = $.fontMatrix || s.FONT_IDENTITY_MATRIX;
-                                let m = "normal";
-                                $.black ? m = "900" : $.bold && (m = "bold");
+                            setFont(g) {
+                                const v = this.current,
+                                    $ = this.commonObjs.get(g[0]);
+                                let M = g[1];
+                                v.font = $, this.embedFonts && !$.missingFile && !this.embeddedFonts[$.loadedName] && (this.addFontStyle($), this.embeddedFonts[$.loadedName] = $), v.fontMatrix = $.fontMatrix || s.FONT_IDENTITY_MATRIX;
+                                let _ = "normal";
+                                $.black ? _ = "900" : $.bold && (_ = "bold");
                                 const N = $.italic ? "italic" : "normal";
-                                M < 0 ? (M = -M, E.fontDirection = -1) : E.fontDirection = 1, E.fontSize = M, E.fontFamily = $.loadedName, E.fontWeight = m, E.fontStyle = N, E.tspan = this.svgFactory.createElement("svg:tspan"), E.tspan.setAttributeNS(null, "y", C(-E.y)), E.xcoords = [], E.ycoords = [];
+                                M < 0 ? (M = -M, v.fontDirection = -1) : v.fontDirection = 1, v.fontSize = M, v.fontFamily = $.loadedName, v.fontWeight = _, v.fontStyle = N, v.tspan = this.svgFactory.createElement("svg:tspan"), v.tspan.setAttributeNS(null, "y", T(-v.y)), v.xcoords = [], v.ycoords = [];
                             }
                             endText() {
-                                var E;
-                                const p = this.current;
-                                p.textRenderingMode & s.TextRenderingMode.ADD_TO_PATH_FLAG && ((E = p.txtElement) != null && E.hasChildNodes()) && (p.element = p.txtElement, this.clip("nonzero"), this.endPath());
+                                var v;
+                                const g = this.current;
+                                g.textRenderingMode & s.TextRenderingMode.ADD_TO_PATH_FLAG && ((v = g.txtElement) != null && v.hasChildNodes()) && (g.element = g.txtElement, this.clip("nonzero"), this.endPath());
                             }
-                            setLineWidth(p) {
-                                p > 0 && (this.current.lineWidth = p);
+                            setLineWidth(g) {
+                                g > 0 && (this.current.lineWidth = g);
                             }
-                            setLineCap(p) {
-                                this.current.lineCap = c[p];
+                            setLineCap(g) {
+                                this.current.lineCap = a[g];
                             }
-                            setLineJoin(p) {
-                                this.current.lineJoin = o[p];
+                            setLineJoin(g) {
+                                this.current.lineJoin = h[g];
                             }
-                            setMiterLimit(p) {
-                                this.current.miterLimit = p;
+                            setMiterLimit(g) {
+                                this.current.miterLimit = g;
                             }
-                            setStrokeAlpha(p) {
-                                this.current.strokeAlpha = p;
+                            setStrokeAlpha(g) {
+                                this.current.strokeAlpha = g;
                             }
-                            setStrokeRGBColor(p, E, $) {
-                                this.current.strokeColor = s.Util.makeHexColor(p, E, $);
+                            setStrokeRGBColor(g, v, $) {
+                                this.current.strokeColor = s.Util.makeHexColor(g, v, $);
                             }
-                            setFillAlpha(p) {
-                                this.current.fillAlpha = p;
+                            setFillAlpha(g) {
+                                this.current.fillAlpha = g;
                             }
-                            setFillRGBColor(p, E, $) {
-                                this.current.fillColor = s.Util.makeHexColor(p, E, $), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = [];
+                            setFillRGBColor(g, v, $) {
+                                this.current.fillColor = s.Util.makeHexColor(g, v, $), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = [];
                             }
-                            setStrokeColorN(p) {
-                                this.current.strokeColor = this._makeColorN_Pattern(p);
+                            setStrokeColorN(g) {
+                                this.current.strokeColor = this._makeColorN_Pattern(g);
                             }
-                            setFillColorN(p) {
-                                this.current.fillColor = this._makeColorN_Pattern(p);
+                            setFillColorN(g) {
+                                this.current.fillColor = this._makeColorN_Pattern(g);
                             }
-                            shadingFill(p) {
+                            shadingFill(g) {
                                 const {
-                                    width: E,
+                                    width: v,
                                     height: $
-                                } = this.viewport, M = s.Util.inverseTransform(this.transformMatrix), [m, N, D, X] = s.Util.getAxialAlignedBoundingBox([0, 0, E, $], M), G = this.svgFactory.createElement("svg:rect");
-                                G.setAttributeNS(null, "x", m), G.setAttributeNS(null, "y", N), G.setAttributeNS(null, "width", D - m), G.setAttributeNS(null, "height", X - N), G.setAttributeNS(null, "fill", this._makeShadingPattern(p)), this.current.fillAlpha < 1 && G.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().append(G);
+                                } = this.viewport, M = s.Util.inverseTransform(this.transformMatrix), [_, N, D, X] = s.Util.getAxialAlignedBoundingBox([0, 0, v, $], M), Y = this.svgFactory.createElement("svg:rect");
+                                Y.setAttributeNS(null, "x", _), Y.setAttributeNS(null, "y", N), Y.setAttributeNS(null, "width", D - _), Y.setAttributeNS(null, "height", X - N), Y.setAttributeNS(null, "fill", this._makeShadingPattern(g)), this.current.fillAlpha < 1 && Y.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().append(Y);
                             }
-                            _makeColorN_Pattern(p) {
-                                return p[0] === "TilingPattern" ? this._makeTilingPattern(p) : this._makeShadingPattern(p);
+                            _makeColorN_Pattern(g) {
+                                return g[0] === "TilingPattern" ? this._makeTilingPattern(g) : this._makeShadingPattern(g);
                             }
-                            _makeTilingPattern(p) {
-                                const E = p[1],
-                                    $ = p[2],
-                                    M = p[3] || s.IDENTITY_MATRIX,
-                                    [m, N, D, X] = p[4],
-                                    G = p[5],
-                                    I = p[6],
-                                    B = p[7],
-                                    ee = `shading${F++}`,
-                                    [Y, q, le, pe] = s.Util.normalizeRect([...s.Util.applyTransform([m, N], M), ...s.Util.applyTransform([D, X], M)]),
-                                    [we, be] = s.Util.singularValueDecompose2dScale(M),
-                                    R = G * we,
-                                    d = I * be,
-                                    g = this.svgFactory.createElement("svg:pattern");
-                                g.setAttributeNS(null, "id", ee), g.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), g.setAttributeNS(null, "width", R), g.setAttributeNS(null, "height", d), g.setAttributeNS(null, "x", `${Y}`), g.setAttributeNS(null, "y", `${q}`);
-                                const f = this.svg,
-                                    v = this.transformMatrix,
-                                    A = this.current.fillColor,
+                            _makeTilingPattern(g) {
+                                const v = g[1],
+                                    $ = g[2],
+                                    M = g[3] || s.IDENTITY_MATRIX,
+                                    [_, N, D, X] = g[4],
+                                    Y = g[5],
+                                    I = g[6],
+                                    U = g[7],
+                                    G = `shading${x++}`,
+                                    [V, H, st, dt] = s.Util.normalizeRect([...s.Util.applyTransform([_, N], M), ...s.Util.applyTransform([D, X], M)]),
+                                    [yt, gt] = s.Util.singularValueDecompose2dScale(M),
+                                    k = Y * yt,
+                                    l = I * gt,
+                                    u = this.svgFactory.createElement("svg:pattern");
+                                u.setAttributeNS(null, "id", G), u.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), u.setAttributeNS(null, "width", k), u.setAttributeNS(null, "height", l), u.setAttributeNS(null, "x", `${V}`), u.setAttributeNS(null, "y", `${H}`);
+                                const d = this.svg,
+                                    b = this.transformMatrix,
+                                    y = this.current.fillColor,
                                     O = this.current.strokeColor,
-                                    H = this.svgFactory.create(le - Y, pe - q);
-                                if (this.svg = H, this.transformMatrix = M, B === 2) {
-                                    const z = s.Util.makeHexColor(...E);
+                                    B = this.svgFactory.create(st - V, dt - H);
+                                if (this.svg = B, this.transformMatrix = M, U === 2) {
+                                    const z = s.Util.makeHexColor(...v);
                                     this.current.fillColor = z, this.current.strokeColor = z;
                                 }
-                                return this.executeOpTree(this.convertOpList($)), this.svg = f, this.transformMatrix = v, this.current.fillColor = A, this.current.strokeColor = O, g.append(H.childNodes[0]), this.defs.append(g), `url(#${ee})`;
+                                return this.executeOpTree(this.convertOpList($)), this.svg = d, this.transformMatrix = b, this.current.fillColor = y, this.current.strokeColor = O, u.append(B.childNodes[0]), this.defs.append(u), `url(#${G})`;
                             }
-                            _makeShadingPattern(p) {
-                                switch (typeof p == "string" && (p = this.objs.get(p)), p[0]) {
+                            _makeShadingPattern(g) {
+                                switch (typeof g == "string" && (g = this.objs.get(g)), g[0]) {
                                     case "RadialAxial":
-                                        const E = `shading${F++}`,
-                                            $ = p[3];
+                                        const v = `shading${x++}`,
+                                            $ = g[3];
                                         let M;
-                                        switch (p[1]) {
+                                        switch (g[1]) {
                                             case "axial":
-                                                const m = p[4],
-                                                    N = p[5];
-                                                M = this.svgFactory.createElement("svg:linearGradient"), M.setAttributeNS(null, "id", E), M.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), M.setAttributeNS(null, "x1", m[0]), M.setAttributeNS(null, "y1", m[1]), M.setAttributeNS(null, "x2", N[0]), M.setAttributeNS(null, "y2", N[1]);
+                                                const _ = g[4],
+                                                    N = g[5];
+                                                M = this.svgFactory.createElement("svg:linearGradient"), M.setAttributeNS(null, "id", v), M.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), M.setAttributeNS(null, "x1", _[0]), M.setAttributeNS(null, "y1", _[1]), M.setAttributeNS(null, "x2", N[0]), M.setAttributeNS(null, "y2", N[1]);
                                                 break;
                                             case "radial":
-                                                const D = p[4],
-                                                    X = p[5],
-                                                    G = p[6],
-                                                    I = p[7];
-                                                M = this.svgFactory.createElement("svg:radialGradient"), M.setAttributeNS(null, "id", E), M.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), M.setAttributeNS(null, "cx", X[0]), M.setAttributeNS(null, "cy", X[1]), M.setAttributeNS(null, "r", I), M.setAttributeNS(null, "fx", D[0]), M.setAttributeNS(null, "fy", D[1]), M.setAttributeNS(null, "fr", G);
+                                                const D = g[4],
+                                                    X = g[5],
+                                                    Y = g[6],
+                                                    I = g[7];
+                                                M = this.svgFactory.createElement("svg:radialGradient"), M.setAttributeNS(null, "id", v), M.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), M.setAttributeNS(null, "cx", X[0]), M.setAttributeNS(null, "cy", X[1]), M.setAttributeNS(null, "r", I), M.setAttributeNS(null, "fx", D[0]), M.setAttributeNS(null, "fy", D[1]), M.setAttributeNS(null, "fr", Y);
                                                 break;
                                             default:
-                                                throw new Error(`Unknown RadialAxial type: ${p[1]}`);
+                                                throw new Error(`Unknown RadialAxial type: ${g[1]}`);
                                         }
-                                        for (const m of $) {
+                                        for (const _ of $) {
                                             const N = this.svgFactory.createElement("svg:stop");
-                                            N.setAttributeNS(null, "offset", m[0]), N.setAttributeNS(null, "stop-color", m[1]), M.append(N);
+                                            N.setAttributeNS(null, "offset", _[0]), N.setAttributeNS(null, "stop-color", _[1]), M.append(N);
                                         }
-                                        return this.defs.append(M), `url(#${E})`;
+                                        return this.defs.append(M), `url(#${v})`;
                                     case "Mesh":
                                         return (0, s.warn)("Unimplemented pattern Mesh"), null;
                                     case "Dummy":
                                         return "hotpink";
                                     default:
-                                        throw new Error(`Unknown IR type: ${p[0]}`);
+                                        throw new Error(`Unknown IR type: ${g[0]}`);
                                 }
                             }
-                            setDash(p, E) {
-                                this.current.dashArray = p, this.current.dashPhase = E;
+                            setDash(g, v) {
+                                this.current.dashArray = g, this.current.dashPhase = v;
                             }
-                            constructPath(p, E) {
+                            constructPath(g, v) {
                                 const $ = this.current;
                                 let M = $.x,
-                                    m = $.y,
+                                    _ = $.y,
                                     N = [],
                                     D = 0;
-                                for (const X of p)
+                                for (const X of g)
                                     switch (X | 0) {
                                         case s.OPS.rectangle:
-                                            M = E[D++], m = E[D++];
-                                            const G = E[D++],
-                                                I = E[D++],
-                                                B = M + G,
-                                                ee = m + I;
-                                            N.push("M", C(M), C(m), "L", C(B), C(m), "L", C(B), C(ee), "L", C(M), C(ee), "Z");
+                                            M = v[D++], _ = v[D++];
+                                            const Y = v[D++],
+                                                I = v[D++],
+                                                U = M + Y,
+                                                G = _ + I;
+                                            N.push("M", T(M), T(_), "L", T(U), T(_), "L", T(U), T(G), "L", T(M), T(G), "Z");
                                             break;
                                         case s.OPS.moveTo:
-                                            M = E[D++], m = E[D++], N.push("M", C(M), C(m));
+                                            M = v[D++], _ = v[D++], N.push("M", T(M), T(_));
                                             break;
                                         case s.OPS.lineTo:
-                                            M = E[D++], m = E[D++], N.push("L", C(M), C(m));
+                                            M = v[D++], _ = v[D++], N.push("L", T(M), T(_));
                                             break;
                                         case s.OPS.curveTo:
-                                            M = E[D + 4], m = E[D + 5], N.push("C", C(E[D]), C(E[D + 1]), C(E[D + 2]), C(E[D + 3]), C(M), C(m)), D += 6;
+                                            M = v[D + 4], _ = v[D + 5], N.push("C", T(v[D]), T(v[D + 1]), T(v[D + 2]), T(v[D + 3]), T(M), T(_)), D += 6;
                                             break;
                                         case s.OPS.curveTo2:
-                                            N.push("C", C(M), C(m), C(E[D]), C(E[D + 1]), C(E[D + 2]), C(E[D + 3])), M = E[D + 2], m = E[D + 3], D += 4;
+                                            N.push("C", T(M), T(_), T(v[D]), T(v[D + 1]), T(v[D + 2]), T(v[D + 3])), M = v[D + 2], _ = v[D + 3], D += 4;
                                             break;
                                         case s.OPS.curveTo3:
-                                            M = E[D + 2], m = E[D + 3], N.push("C", C(E[D]), C(E[D + 1]), C(M), C(m), C(M), C(m)), D += 4;
+                                            M = v[D + 2], _ = v[D + 3], N.push("C", T(v[D]), T(v[D + 1]), T(M), T(_), T(M), T(_)), D += 4;
                                             break;
                                         case s.OPS.closePath:
                                             N.push("Z");
                                             break;
                                     }
-                                N = N.join(" "), $.path && p.length > 0 && p[0] !== s.OPS.rectangle && p[0] !== s.OPS.moveTo ? N = $.path.getAttributeNS(null, "d") + N : ($.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().append($.path)), $.path.setAttributeNS(null, "d", N), $.path.setAttributeNS(null, "fill", "none"), $.element = $.path, $.setCurrentPoint(M, m);
+                                N = N.join(" "), $.path && g.length > 0 && g[0] !== s.OPS.rectangle && g[0] !== s.OPS.moveTo ? N = $.path.getAttributeNS(null, "d") + N : ($.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().append($.path)), $.path.setAttributeNS(null, "d", N), $.path.setAttributeNS(null, "fill", "none"), $.element = $.path, $.setCurrentPoint(M, _);
                             }
                             endPath() {
-                                const p = this.current;
-                                if (p.path = null, !this.pendingClip)
+                                const g = this.current;
+                                if (g.path = null, !this.pendingClip)
                                     return;
-                                if (!p.element) {
+                                if (!g.element) {
                                     this.pendingClip = null;
                                     return;
                                 }
-                                const E = `clippath${b++}`,
+                                const v = `clippath${m++}`,
                                     $ = this.svgFactory.createElement("svg:clipPath");
-                                $.setAttributeNS(null, "id", E), $.setAttributeNS(null, "transform", P(this.transformMatrix));
-                                const M = p.element.cloneNode(!0);
-                                if (this.pendingClip === "evenodd" ? M.setAttributeNS(null, "clip-rule", "evenodd") : M.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, $.append(M), this.defs.append($), p.activeClipUrl) {
-                                    p.clipGroup = null;
-                                    for (const m of this.extraStack)
-                                        m.clipGroup = null;
-                                    $.setAttributeNS(null, "clip-path", p.activeClipUrl);
+                                $.setAttributeNS(null, "id", v), $.setAttributeNS(null, "transform", P(this.transformMatrix));
+                                const M = g.element.cloneNode(!0);
+                                if (this.pendingClip === "evenodd" ? M.setAttributeNS(null, "clip-rule", "evenodd") : M.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, $.append(M), this.defs.append($), g.activeClipUrl) {
+                                    g.clipGroup = null;
+                                    for (const _ of this.extraStack)
+                                        _.clipGroup = null;
+                                    $.setAttributeNS(null, "clip-path", g.activeClipUrl);
                                 }
-                                p.activeClipUrl = `url(#${E})`, this.tgrp = null;
+                                g.activeClipUrl = `url(#${v})`, this.tgrp = null;
                             }
-                            clip(p) {
-                                this.pendingClip = p;
+                            clip(g) {
+                                this.pendingClip = g;
                             }
                             closePath() {
-                                const p = this.current;
-                                if (p.path) {
-                                    const E = `${p.path.getAttributeNS(null, "d")}Z`;
-                                    p.path.setAttributeNS(null, "d", E);
+                                const g = this.current;
+                                if (g.path) {
+                                    const v = `${g.path.getAttributeNS(null, "d")}Z`;
+                                    g.path.setAttributeNS(null, "d", v);
                                 }
                             }
-                            setLeading(p) {
-                                this.current.leading = -p;
+                            setLeading(g) {
+                                this.current.leading = -g;
                             }
-                            setTextRise(p) {
-                                this.current.textRise = p;
+                            setTextRise(g) {
+                                this.current.textRise = g;
                             }
-                            setTextRenderingMode(p) {
-                                this.current.textRenderingMode = p;
+                            setTextRenderingMode(g) {
+                                this.current.textRenderingMode = g;
                             }
-                            setHScale(p) {
-                                this.current.textHScale = p / 100;
+                            setHScale(g) {
+                                this.current.textHScale = g / 100;
                             }
-                            setRenderingIntent(p) {}
-                            setFlatness(p) {}
-                            setGState(p) {
-                                for (const [E, $] of p)
-                                    switch (E) {
+                            setRenderingIntent(g) {}
+                            setFlatness(g) {}
+                            setGState(g) {
+                                for (const [v, $] of g)
+                                    switch (v) {
                                         case "LW":
                                             this.setLineWidth($);
                                             break;
                                         case "LC":
                                             this.setLineCap($);
                                             break;
                                         case "LJ":
@@ -16995,3000 +13592,3000 @@
                                         case "CA":
                                             this.setStrokeAlpha($);
                                             break;
                                         case "ca":
                                             this.setFillAlpha($);
                                             break;
                                         default:
-                                            (0, s.warn)(`Unimplemented graphic state operator ${E}`);
+                                            (0, s.warn)(`Unimplemented graphic state operator ${v}`);
                                             break;
                                     }
                             }
                             fill() {
-                                const p = this.current;
-                                p.element && (p.element.setAttributeNS(null, "fill", p.fillColor), p.element.setAttributeNS(null, "fill-opacity", p.fillAlpha), this.endPath());
+                                const g = this.current;
+                                g.element && (g.element.setAttributeNS(null, "fill", g.fillColor), g.element.setAttributeNS(null, "fill-opacity", g.fillAlpha), this.endPath());
                             }
                             stroke() {
-                                const p = this.current;
-                                p.element && (this._setStrokeAttributes(p.element), p.element.setAttributeNS(null, "fill", "none"), this.endPath());
+                                const g = this.current;
+                                g.element && (this._setStrokeAttributes(g.element), g.element.setAttributeNS(null, "fill", "none"), this.endPath());
                             }
-                            _setStrokeAttributes(p, E = 1) {
+                            _setStrokeAttributes(g, v = 1) {
                                 const $ = this.current;
                                 let M = $.dashArray;
-                                E !== 1 && M.length > 0 && (M = M.map(function(m) {
-                                    return E * m;
-                                })), p.setAttributeNS(null, "stroke", $.strokeColor), p.setAttributeNS(null, "stroke-opacity", $.strokeAlpha), p.setAttributeNS(null, "stroke-miterlimit", C($.miterLimit)), p.setAttributeNS(null, "stroke-linecap", $.lineCap), p.setAttributeNS(null, "stroke-linejoin", $.lineJoin), p.setAttributeNS(null, "stroke-width", C(E * $.lineWidth) + "px"), p.setAttributeNS(null, "stroke-dasharray", M.map(C).join(" ")), p.setAttributeNS(null, "stroke-dashoffset", C(E * $.dashPhase) + "px");
+                                v !== 1 && M.length > 0 && (M = M.map(function(_) {
+                                    return v * _;
+                                })), g.setAttributeNS(null, "stroke", $.strokeColor), g.setAttributeNS(null, "stroke-opacity", $.strokeAlpha), g.setAttributeNS(null, "stroke-miterlimit", T($.miterLimit)), g.setAttributeNS(null, "stroke-linecap", $.lineCap), g.setAttributeNS(null, "stroke-linejoin", $.lineJoin), g.setAttributeNS(null, "stroke-width", T(v * $.lineWidth) + "px"), g.setAttributeNS(null, "stroke-dasharray", M.map(T).join(" ")), g.setAttributeNS(null, "stroke-dashoffset", T(v * $.dashPhase) + "px");
                             }
                             eoFill() {
-                                var p;
-                                (p = this.current.element) == null || p.setAttributeNS(null, "fill-rule", "evenodd"), this.fill();
+                                var g;
+                                (g = this.current.element) == null || g.setAttributeNS(null, "fill-rule", "evenodd"), this.fill();
                             }
                             fillStroke() {
                                 this.stroke(), this.fill();
                             }
                             eoFillStroke() {
-                                var p;
-                                (p = this.current.element) == null || p.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke();
+                                var g;
+                                (g = this.current.element) == null || g.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke();
                             }
                             closeStroke() {
                                 this.closePath(), this.stroke();
                             }
                             closeFillStroke() {
                                 this.closePath(), this.fillStroke();
                             }
                             closeEOFillStroke() {
                                 this.closePath(), this.eoFillStroke();
                             }
                             paintSolidColorImageMask() {
-                                const p = this.svgFactory.createElement("svg:rect");
-                                p.setAttributeNS(null, "x", "0"), p.setAttributeNS(null, "y", "0"), p.setAttributeNS(null, "width", "1px"), p.setAttributeNS(null, "height", "1px"), p.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().append(p);
+                                const g = this.svgFactory.createElement("svg:rect");
+                                g.setAttributeNS(null, "x", "0"), g.setAttributeNS(null, "y", "0"), g.setAttributeNS(null, "width", "1px"), g.setAttributeNS(null, "height", "1px"), g.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().append(g);
                             }
-                            paintImageXObject(p) {
-                                const E = this.getObject(p);
-                                if (!E) {
-                                    (0, s.warn)(`Dependent image with object ID ${p} is not ready yet`);
+                            paintImageXObject(g) {
+                                const v = this.getObject(g);
+                                if (!v) {
+                                    (0, s.warn)(`Dependent image with object ID ${g} is not ready yet`);
                                     return;
                                 }
-                                this.paintInlineImageXObject(E);
+                                this.paintInlineImageXObject(v);
                             }
-                            paintInlineImageXObject(p, E) {
-                                const $ = p.width,
-                                    M = p.height,
-                                    m = T(p, this.forceDataSchema, !!E),
+                            paintInlineImageXObject(g, v) {
+                                const $ = g.width,
+                                    M = g.height,
+                                    _ = F(g, this.forceDataSchema, !!v),
                                     N = this.svgFactory.createElement("svg:rect");
-                                N.setAttributeNS(null, "x", "0"), N.setAttributeNS(null, "y", "0"), N.setAttributeNS(null, "width", C($)), N.setAttributeNS(null, "height", C(M)), this.current.element = N, this.clip("nonzero");
+                                N.setAttributeNS(null, "x", "0"), N.setAttributeNS(null, "y", "0"), N.setAttributeNS(null, "width", T($)), N.setAttributeNS(null, "height", T(M)), this.current.element = N, this.clip("nonzero");
                                 const D = this.svgFactory.createElement("svg:image");
-                                D.setAttributeNS(_, "xlink:href", m), D.setAttributeNS(null, "x", "0"), D.setAttributeNS(null, "y", C(-M)), D.setAttributeNS(null, "width", C($) + "px"), D.setAttributeNS(null, "height", C(M) + "px"), D.setAttributeNS(null, "transform", `scale(${C(1 / $)} ${C(-1 / M)})`), E ? E.append(D) : this._ensureTransformGroup().append(D);
+                                D.setAttributeNS(A, "xlink:href", _), D.setAttributeNS(null, "x", "0"), D.setAttributeNS(null, "y", T(-M)), D.setAttributeNS(null, "width", T($) + "px"), D.setAttributeNS(null, "height", T(M) + "px"), D.setAttributeNS(null, "transform", `scale(${T(1 / $)} ${T(-1 / M)})`), v ? v.append(D) : this._ensureTransformGroup().append(D);
                             }
-                            paintImageMaskXObject(p) {
-                                const E = this.getObject(p.data, p);
-                                if (E.bitmap) {
+                            paintImageMaskXObject(g) {
+                                const v = this.getObject(g.data, g);
+                                if (v.bitmap) {
                                     (0, s.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled.");
                                     return;
                                 }
                                 const $ = this.current,
-                                    M = E.width,
-                                    m = E.height,
+                                    M = v.width,
+                                    _ = v.height,
                                     N = $.fillColor;
-                                $.maskId = `mask${k++}`;
+                                $.maskId = `mask${C++}`;
                                 const D = this.svgFactory.createElement("svg:mask");
                                 D.setAttributeNS(null, "id", $.maskId);
                                 const X = this.svgFactory.createElement("svg:rect");
-                                X.setAttributeNS(null, "x", "0"), X.setAttributeNS(null, "y", "0"), X.setAttributeNS(null, "width", C(M)), X.setAttributeNS(null, "height", C(m)), X.setAttributeNS(null, "fill", N), X.setAttributeNS(null, "mask", `url(#${$.maskId})`), this.defs.append(D), this._ensureTransformGroup().append(X), this.paintInlineImageXObject(E, D);
+                                X.setAttributeNS(null, "x", "0"), X.setAttributeNS(null, "y", "0"), X.setAttributeNS(null, "width", T(M)), X.setAttributeNS(null, "height", T(_)), X.setAttributeNS(null, "fill", N), X.setAttributeNS(null, "mask", `url(#${$.maskId})`), this.defs.append(D), this._ensureTransformGroup().append(X), this.paintInlineImageXObject(v, D);
                             }
-                            paintFormXObjectBegin(p, E) {
-                                if (Array.isArray(p) && p.length === 6 && this.transform(p[0], p[1], p[2], p[3], p[4], p[5]), E) {
-                                    const $ = E[2] - E[0],
-                                        M = E[3] - E[1],
-                                        m = this.svgFactory.createElement("svg:rect");
-                                    m.setAttributeNS(null, "x", E[0]), m.setAttributeNS(null, "y", E[1]), m.setAttributeNS(null, "width", C($)), m.setAttributeNS(null, "height", C(M)), this.current.element = m, this.clip("nonzero"), this.endPath();
+                            paintFormXObjectBegin(g, v) {
+                                if (Array.isArray(g) && g.length === 6 && this.transform(g[0], g[1], g[2], g[3], g[4], g[5]), v) {
+                                    const $ = v[2] - v[0],
+                                        M = v[3] - v[1],
+                                        _ = this.svgFactory.createElement("svg:rect");
+                                    _.setAttributeNS(null, "x", v[0]), _.setAttributeNS(null, "y", v[1]), _.setAttributeNS(null, "width", T($)), _.setAttributeNS(null, "height", T(M)), this.current.element = _, this.clip("nonzero"), this.endPath();
                                 }
                             }
                             paintFormXObjectEnd() {}
-                            _initialize(p) {
-                                const E = this.svgFactory.create(p.width, p.height),
+                            _initialize(g) {
+                                const v = this.svgFactory.create(g.width, g.height),
                                     $ = this.svgFactory.createElement("svg:defs");
-                                E.append($), this.defs = $;
+                                v.append($), this.defs = $;
                                 const M = this.svgFactory.createElement("svg:g");
-                                return M.setAttributeNS(null, "transform", P(p.transform)), E.append(M), this.svg = M, E;
+                                return M.setAttributeNS(null, "transform", P(g.transform)), v.append(M), this.svg = M, v;
                             }
                             _ensureClipGroup() {
                                 if (!this.current.clipGroup) {
-                                    const p = this.svgFactory.createElement("svg:g");
-                                    p.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.append(p), this.current.clipGroup = p;
+                                    const g = this.svgFactory.createElement("svg:g");
+                                    g.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.append(g), this.current.clipGroup = g;
                                 }
                                 return this.current.clipGroup;
                             }
                             _ensureTransformGroup() {
                                 return this.tgrp || (this.tgrp = this.svgFactory.createElement("svg:g"), this.tgrp.setAttributeNS(null, "transform", P(this.transformMatrix)), this.current.activeClipUrl ? this._ensureClipGroup().append(this.tgrp) : this.svg.append(this.tgrp)), this.tgrp;
                             }
                         }
-                        e.SVGGraphics = x;
+                        t.SVGGraphics = E;
                     },
                     /* 25 */
                     /***/
-                    (t, e) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.XfaText = void 0;
-                        class i {
+                        }), t.XfaText = void 0;
+                        class n {
                             static textContent(s) {
-                                const l = [],
-                                    h = {
-                                        items: l,
+                                const p = [],
+                                    f = {
+                                        items: p,
                                         styles: /* @__PURE__ */ Object.create(null)
                                     };
 
-                                function _(c) {
-                                    var T;
-                                    if (!c)
+                                function A(a) {
+                                    var F;
+                                    if (!a)
                                         return;
-                                    let o = null;
-                                    const r = c.name;
-                                    if (r === "#text")
-                                        o = c.value;
-                                    else if (i.shouldBuildText(r))
-                                        (T = c == null ? void 0 : c.attributes) != null && T.textContent ? o = c.attributes.textContent : c.value && (o = c.value);
+                                    let h = null;
+                                    const o = a.name;
+                                    if (o === "#text")
+                                        h = a.value;
+                                    else if (n.shouldBuildText(o))
+                                        (F = a == null ? void 0 : a.attributes) != null && F.textContent ? h = a.attributes.textContent : a.value && (h = a.value);
                                     else
                                         return;
-                                    if (o !== null && l.push({
-                                            str: o
-                                        }), !!c.children)
-                                        for (const S of c.children)
-                                            _(S);
+                                    if (h !== null && p.push({
+                                            str: h
+                                        }), !!a.children)
+                                        for (const R of a.children)
+                                            A(R);
                                 }
-                                return _(s), h;
+                                return A(s), f;
                             }
                             static shouldBuildText(s) {
                                 return !(s === "textarea" || s === "input" || s === "option" || s === "select");
                             }
                         }
-                        e.XfaText = i;
+                        t.XfaText = n;
                     },
                     /* 26 */
                     /***/
-                    (t, e, i) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.TextLayerRenderTask = void 0, e.renderTextLayer = P, e.updateTextLayer = b;
-                        var n = i(1),
-                            s = i(6);
-                        const l = 1e5,
-                            h = 30,
-                            _ = 0.8,
-                            c = /* @__PURE__ */ new Map();
-
-                        function o(k, F) {
-                            let x;
-                            if (F && n.FeatureTest.isOffscreenCanvasSupported)
-                                x = new OffscreenCanvas(k, k).getContext("2d", {
+                        }), t.TextLayerRenderTask = void 0, t.renderTextLayer = P, t.updateTextLayer = m;
+                        var e = n(1),
+                            s = n(6);
+                        const p = 1e5,
+                            f = 30,
+                            A = 0.8,
+                            a = /* @__PURE__ */ new Map();
+
+                        function h(C, x) {
+                            let E;
+                            if (x && e.FeatureTest.isOffscreenCanvasSupported)
+                                E = new OffscreenCanvas(C, C).getContext("2d", {
                                     alpha: !1
                                 });
                             else {
-                                const y = document.createElement("canvas");
-                                y.width = y.height = k, x = y.getContext("2d", {
+                                const S = document.createElement("canvas");
+                                S.width = S.height = C, E = S.getContext("2d", {
                                     alpha: !1
                                 });
                             }
-                            return x;
+                            return E;
                         }
 
-                        function r(k, F) {
-                            const x = c.get(k);
-                            if (x)
-                                return x;
-                            const y = o(h, F);
-                            y.font = `${h}px ${k}`;
-                            const p = y.measureText("");
-                            let E = p.fontBoundingBoxAscent,
-                                $ = Math.abs(p.fontBoundingBoxDescent);
-                            if (E) {
-                                const m = E / (E + $);
-                                return c.set(k, m), y.canvas.width = y.canvas.height = 0, m;
+                        function o(C, x) {
+                            const E = a.get(C);
+                            if (E)
+                                return E;
+                            const S = h(f, x);
+                            S.font = `${f}px ${C}`;
+                            const g = S.measureText("");
+                            let v = g.fontBoundingBoxAscent,
+                                $ = Math.abs(g.fontBoundingBoxDescent);
+                            if (v) {
+                                const _ = v / (v + $);
+                                return a.set(C, _), S.canvas.width = S.canvas.height = 0, _;
                             }
-                            y.strokeStyle = "red", y.clearRect(0, 0, h, h), y.strokeText("g", 0, 0);
-                            let M = y.getImageData(0, 0, h, h).data;
+                            S.strokeStyle = "red", S.clearRect(0, 0, f, f), S.strokeText("g", 0, 0);
+                            let M = S.getImageData(0, 0, f, f).data;
                             $ = 0;
-                            for (let m = M.length - 1 - 3; m >= 0; m -= 4)
-                                if (M[m] > 0) {
-                                    $ = Math.ceil(m / 4 / h);
+                            for (let _ = M.length - 1 - 3; _ >= 0; _ -= 4)
+                                if (M[_] > 0) {
+                                    $ = Math.ceil(_ / 4 / f);
                                     break;
                                 }
-                            y.clearRect(0, 0, h, h), y.strokeText("A", 0, h), M = y.getImageData(0, 0, h, h).data, E = 0;
-                            for (let m = 0, N = M.length; m < N; m += 4)
-                                if (M[m] > 0) {
-                                    E = h - Math.floor(m / 4 / h);
+                            S.clearRect(0, 0, f, f), S.strokeText("A", 0, f), M = S.getImageData(0, 0, f, f).data, v = 0;
+                            for (let _ = 0, N = M.length; _ < N; _ += 4)
+                                if (M[_] > 0) {
+                                    v = f - Math.floor(_ / 4 / f);
                                     break;
                                 }
-                            if (y.canvas.width = y.canvas.height = 0, E) {
-                                const m = E / (E + $);
-                                return c.set(k, m), m;
+                            if (S.canvas.width = S.canvas.height = 0, v) {
+                                const _ = v / (v + $);
+                                return a.set(C, _), _;
                             }
-                            return c.set(k, _), _;
+                            return a.set(C, A), A;
                         }
 
-                        function T(k, F, x) {
-                            const y = document.createElement("span"),
-                                p = {
+                        function F(C, x, E) {
+                            const S = document.createElement("span"),
+                                g = {
                                     angle: 0,
                                     canvasWidth: 0,
-                                    hasText: F.str !== "",
-                                    hasEOL: F.hasEOL,
+                                    hasText: x.str !== "",
+                                    hasEOL: x.hasEOL,
                                     fontSize: 0
                                 };
-                            k._textDivs.push(y);
-                            const E = n.Util.transform(k._transform, F.transform);
-                            let $ = Math.atan2(E[1], E[0]);
-                            const M = x[F.fontName];
+                            C._textDivs.push(S);
+                            const v = e.Util.transform(C._transform, x.transform);
+                            let $ = Math.atan2(v[1], v[0]);
+                            const M = E[x.fontName];
                             M.vertical && ($ += Math.PI / 2);
-                            const m = Math.hypot(E[2], E[3]),
-                                N = m * r(M.fontFamily, k._isOffscreenCanvasSupported);
+                            const _ = Math.hypot(v[2], v[3]),
+                                N = _ * o(M.fontFamily, C._isOffscreenCanvasSupported);
                             let D, X;
-                            $ === 0 ? (D = E[4], X = E[5] - N) : (D = E[4] + N * Math.sin($), X = E[5] - N * Math.cos($));
-                            const G = "calc(var(--scale-factor)*",
-                                I = y.style;
-                            k._container === k._rootContainer ? (I.left = `${(100 * D / k._pageWidth).toFixed(2)}%`, I.top = `${(100 * X / k._pageHeight).toFixed(2)}%`) : (I.left = `${G}${D.toFixed(2)}px)`, I.top = `${G}${X.toFixed(2)}px)`), I.fontSize = `${G}${m.toFixed(2)}px)`, I.fontFamily = M.fontFamily, p.fontSize = m, y.setAttribute("role", "presentation"), y.textContent = F.str, y.dir = F.dir, k._fontInspectorEnabled && (y.dataset.fontName = F.fontName), $ !== 0 && (p.angle = $ * (180 / Math.PI));
-                            let B = !1;
-                            if (F.str.length > 1)
-                                B = !0;
-                            else if (F.str !== " " && F.transform[0] !== F.transform[3]) {
-                                const ee = Math.abs(F.transform[0]),
-                                    Y = Math.abs(F.transform[3]);
-                                ee !== Y && Math.max(ee, Y) / Math.min(ee, Y) > 1.5 && (B = !0);
+                            $ === 0 ? (D = v[4], X = v[5] - N) : (D = v[4] + N * Math.sin($), X = v[5] - N * Math.cos($));
+                            const Y = "calc(var(--scale-factor)*",
+                                I = S.style;
+                            C._container === C._rootContainer ? (I.left = `${(100 * D / C._pageWidth).toFixed(2)}%`, I.top = `${(100 * X / C._pageHeight).toFixed(2)}%`) : (I.left = `${Y}${D.toFixed(2)}px)`, I.top = `${Y}${X.toFixed(2)}px)`), I.fontSize = `${Y}${_.toFixed(2)}px)`, I.fontFamily = M.fontFamily, g.fontSize = _, S.setAttribute("role", "presentation"), S.textContent = x.str, S.dir = x.dir, C._fontInspectorEnabled && (S.dataset.fontName = x.fontName), $ !== 0 && (g.angle = $ * (180 / Math.PI));
+                            let U = !1;
+                            if (x.str.length > 1)
+                                U = !0;
+                            else if (x.str !== " " && x.transform[0] !== x.transform[3]) {
+                                const G = Math.abs(x.transform[0]),
+                                    V = Math.abs(x.transform[3]);
+                                G !== V && Math.max(G, V) / Math.min(G, V) > 1.5 && (U = !0);
                             }
-                            B && (p.canvasWidth = M.vertical ? F.height : F.width), k._textDivProperties.set(y, p), k._isReadableStream && k._layoutText(y);
+                            U && (g.canvasWidth = M.vertical ? x.height : x.width), C._textDivProperties.set(S, g), C._isReadableStream && C._layoutText(S);
                         }
 
-                        function S(k) {
+                        function R(C) {
                             const {
-                                div: F,
-                                scale: x,
-                                properties: y,
-                                ctx: p,
-                                prevFontSize: E,
+                                div: x,
+                                scale: E,
+                                properties: S,
+                                ctx: g,
+                                prevFontSize: v,
                                 prevFontFamily: $
-                            } = k, {
+                            } = C, {
                                 style: M
-                            } = F;
-                            let m = "";
-                            if (y.canvasWidth !== 0 && y.hasText) {
+                            } = x;
+                            let _ = "";
+                            if (S.canvasWidth !== 0 && S.hasText) {
                                 const {
                                     fontFamily: N
                                 } = M, {
                                     canvasWidth: D,
                                     fontSize: X
-                                } = y;
-                                (E !== X || $ !== N) && (p.font = `${X * x}px ${N}`, k.prevFontSize = X, k.prevFontFamily = N);
+                                } = S;
+                                (v !== X || $ !== N) && (g.font = `${X * E}px ${N}`, C.prevFontSize = X, C.prevFontFamily = N);
                                 const {
-                                    width: G
-                                } = p.measureText(F.textContent);
-                                G > 0 && (m = `scaleX(${D * x / G})`);
+                                    width: Y
+                                } = g.measureText(x.textContent);
+                                Y > 0 && (_ = `scaleX(${D * E / Y})`);
                             }
-                            y.angle !== 0 && (m = `rotate(${y.angle}deg) ${m}`), m.length > 0 && (M.transform = m);
+                            S.angle !== 0 && (_ = `rotate(${S.angle}deg) ${_}`), _.length > 0 && (M.transform = _);
                         }
 
-                        function w(k) {
-                            if (k._canceled)
+                        function w(C) {
+                            if (C._canceled)
                                 return;
-                            const F = k._textDivs,
-                                x = k._capability;
-                            if (F.length > l) {
-                                x.resolve();
+                            const x = C._textDivs,
+                                E = C._capability;
+                            if (x.length > p) {
+                                E.resolve();
                                 return;
                             }
-                            if (!k._isReadableStream)
-                                for (const p of F)
-                                    k._layoutText(p);
-                            x.resolve();
+                            if (!C._isReadableStream)
+                                for (const g of x)
+                                    C._layoutText(g);
+                            E.resolve();
                         }
-                        class C {
+                        class T {
                             constructor({
-                                textContentSource: F,
-                                container: x,
-                                viewport: y,
-                                textDivs: p,
-                                textDivProperties: E,
+                                textContentSource: x,
+                                container: E,
+                                viewport: S,
+                                textDivs: g,
+                                textDivProperties: v,
                                 textContentItemsStr: $,
                                 isOffscreenCanvasSupported: M
                             }) {
-                                var G;
-                                this._textContentSource = F, this._isReadableStream = F instanceof ReadableStream, this._container = this._rootContainer = x, this._textDivs = p || [], this._textContentItemsStr = $ || [], this._isOffscreenCanvasSupported = M, this._fontInspectorEnabled = !!((G = globalThis.FontInspector) != null && G.enabled), this._reader = null, this._textDivProperties = E || /* @__PURE__ */ new WeakMap(), this._canceled = !1, this._capability = new n.PromiseCapability(), this._layoutTextParams = {
+                                var Y;
+                                this._textContentSource = x, this._isReadableStream = x instanceof ReadableStream, this._container = this._rootContainer = E, this._textDivs = g || [], this._textContentItemsStr = $ || [], this._isOffscreenCanvasSupported = M, this._fontInspectorEnabled = !!((Y = globalThis.FontInspector) != null && Y.enabled), this._reader = null, this._textDivProperties = v || /* @__PURE__ */ new WeakMap(), this._canceled = !1, this._capability = new e.PromiseCapability(), this._layoutTextParams = {
                                     prevFontSize: null,
                                     prevFontFamily: null,
                                     div: null,
-                                    scale: y.scale * (globalThis.devicePixelRatio || 1),
+                                    scale: S.scale * (globalThis.devicePixelRatio || 1),
                                     properties: null,
-                                    ctx: o(0, M)
+                                    ctx: h(0, M)
                                 };
                                 const {
-                                    pageWidth: m,
+                                    pageWidth: _,
                                     pageHeight: N,
                                     pageX: D,
                                     pageY: X
-                                } = y.rawDims;
-                                this._transform = [1, 0, 0, -1, -D, X + N], this._pageWidth = m, this._pageHeight = N, (0, s.setLayerDimensions)(x, y), this._capability.promise.finally(() => {
+                                } = S.rawDims;
+                                this._transform = [1, 0, 0, -1, -D, X + N], this._pageWidth = _, this._pageHeight = N, (0, s.setLayerDimensions)(E, S), this._capability.promise.finally(() => {
                                     this._layoutTextParams = null;
                                 }).catch(() => {});
                             }
                             get promise() {
                                 return this._capability.promise;
                             }
                             cancel() {
-                                this._canceled = !0, this._reader && (this._reader.cancel(new n.AbortException("TextLayer task cancelled.")).catch(() => {}), this._reader = null), this._capability.reject(new n.AbortException("TextLayer task cancelled."));
+                                this._canceled = !0, this._reader && (this._reader.cancel(new e.AbortException("TextLayer task cancelled.")).catch(() => {}), this._reader = null), this._capability.reject(new e.AbortException("TextLayer task cancelled."));
                             }
-                            _processItems(F, x) {
-                                for (const y of F) {
-                                    if (y.str === void 0) {
-                                        if (y.type === "beginMarkedContentProps" || y.type === "beginMarkedContent") {
-                                            const p = this._container;
-                                            this._container = document.createElement("span"), this._container.classList.add("markedContent"), y.id !== null && this._container.setAttribute("id", `${y.id}`), p.append(this._container);
+                            _processItems(x, E) {
+                                for (const S of x) {
+                                    if (S.str === void 0) {
+                                        if (S.type === "beginMarkedContentProps" || S.type === "beginMarkedContent") {
+                                            const g = this._container;
+                                            this._container = document.createElement("span"), this._container.classList.add("markedContent"), S.id !== null && this._container.setAttribute("id", `${S.id}`), g.append(this._container);
                                         } else
-                                            y.type === "endMarkedContent" && (this._container = this._container.parentNode);
+                                            S.type === "endMarkedContent" && (this._container = this._container.parentNode);
                                         continue;
                                     }
-                                    this._textContentItemsStr.push(y.str), T(this, y, x);
+                                    this._textContentItemsStr.push(S.str), F(this, S, E);
                                 }
                             }
-                            _layoutText(F) {
-                                const x = this._layoutTextParams.properties = this._textDivProperties.get(F);
-                                if (this._layoutTextParams.div = F, S(this._layoutTextParams), x.hasText && this._container.append(F), x.hasEOL) {
-                                    const y = document.createElement("br");
-                                    y.setAttribute("role", "presentation"), this._container.append(y);
+                            _layoutText(x) {
+                                const E = this._layoutTextParams.properties = this._textDivProperties.get(x);
+                                if (this._layoutTextParams.div = x, R(this._layoutTextParams), E.hasText && this._container.append(x), E.hasEOL) {
+                                    const S = document.createElement("br");
+                                    S.setAttribute("role", "presentation"), this._container.append(S);
                                 }
                             }
                             _render() {
-                                const F = new n.PromiseCapability();
-                                let x = /* @__PURE__ */ Object.create(null);
+                                const x = new e.PromiseCapability();
+                                let E = /* @__PURE__ */ Object.create(null);
                                 if (this._isReadableStream) {
-                                    const y = () => {
+                                    const S = () => {
                                         this._reader.read().then(({
-                                            value: p,
-                                            done: E
+                                            value: g,
+                                            done: v
                                         }) => {
-                                            if (E) {
-                                                F.resolve();
+                                            if (v) {
+                                                x.resolve();
                                                 return;
                                             }
-                                            Object.assign(x, p.styles), this._processItems(p.items, x), y();
-                                        }, F.reject);
+                                            Object.assign(E, g.styles), this._processItems(g.items, E), S();
+                                        }, x.reject);
                                     };
-                                    this._reader = this._textContentSource.getReader(), y();
+                                    this._reader = this._textContentSource.getReader(), S();
                                 } else if (this._textContentSource) {
                                     const {
-                                        items: y,
-                                        styles: p
+                                        items: S,
+                                        styles: g
                                     } = this._textContentSource;
-                                    this._processItems(y, p), F.resolve();
+                                    this._processItems(S, g), x.resolve();
                                 } else
                                     throw new Error('No "textContentSource" parameter specified.');
-                                F.promise.then(() => {
-                                    x = null, w(this);
+                                x.promise.then(() => {
+                                    E = null, w(this);
                                 }, this._capability.reject);
                             }
                         }
-                        e.TextLayerRenderTask = C;
+                        t.TextLayerRenderTask = T;
 
-                        function P(k) {
-                            !k.textContentSource && (k.textContent || k.textContentStream) && ((0, s.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead."), k.textContentSource = k.textContent || k.textContentStream);
+                        function P(C) {
+                            !C.textContentSource && (C.textContent || C.textContentStream) && ((0, s.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead."), C.textContentSource = C.textContent || C.textContentStream);
                             const {
-                                container: F,
-                                viewport: x
-                            } = k, y = getComputedStyle(F), p = y.getPropertyValue("visibility"), E = parseFloat(y.getPropertyValue("--scale-factor"));
-                            p === "visible" && (!E || Math.abs(E - x.scale) > 1e-5) && console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.");
-                            const $ = new C(k);
+                                container: x,
+                                viewport: E
+                            } = C, S = getComputedStyle(x), g = S.getPropertyValue("visibility"), v = parseFloat(S.getPropertyValue("--scale-factor"));
+                            g === "visible" && (!v || Math.abs(v - E.scale) > 1e-5) && console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.");
+                            const $ = new T(C);
                             return $._render(), $;
                         }
 
-                        function b({
-                            container: k,
-                            viewport: F,
-                            textDivs: x,
-                            textDivProperties: y,
-                            isOffscreenCanvasSupported: p,
-                            mustRotate: E = !0,
+                        function m({
+                            container: C,
+                            viewport: x,
+                            textDivs: E,
+                            textDivProperties: S,
+                            isOffscreenCanvasSupported: g,
+                            mustRotate: v = !0,
                             mustRescale: $ = !0
                         }) {
-                            if (E && (0, s.setLayerDimensions)(k, {
-                                    rotation: F.rotation
+                            if (v && (0, s.setLayerDimensions)(C, {
+                                    rotation: x.rotation
                                 }), $) {
-                                const M = o(0, p),
+                                const M = h(0, g),
                                     N = {
                                         prevFontSize: null,
                                         prevFontFamily: null,
                                         div: null,
-                                        scale: F.scale * (globalThis.devicePixelRatio || 1),
+                                        scale: x.scale * (globalThis.devicePixelRatio || 1),
                                         properties: null,
                                         ctx: M
                                     };
-                                for (const D of x)
-                                    N.properties = y.get(D), N.div = D, S(N);
+                                for (const D of E)
+                                    N.properties = S.get(D), N.div = D, R(N);
                             }
                         }
                     },
                     /* 27 */
                     /***/
-                    (t, e, i) => {
-                        var r, T, S, w, C, P, b, k, F, x, y, nn, E, Rt, M, sn, N, rn;
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        var o, F, R, w, T, P, m, C, x, E, S, en, v, Fe, M, nn, N, sn;
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.AnnotationEditorLayer = void 0;
-                        var n = i(1),
-                            s = i(4),
-                            l = i(28),
-                            h = i(33),
-                            _ = i(6),
-                            c = i(34);
+                        }), t.AnnotationEditorLayer = void 0;
+                        var e = n(1),
+                            s = n(4),
+                            p = n(28),
+                            f = n(33),
+                            A = n(6),
+                            a = n(34);
                         const X = class X {
                             constructor({
                                 uiManager: I,
-                                pageIndex: B,
-                                div: ee,
-                                accessibilityManager: Y,
-                                annotationLayer: q,
-                                viewport: le,
-                                l10n: pe
+                                pageIndex: U,
+                                div: G,
+                                accessibilityManager: V,
+                                annotationLayer: H,
+                                viewport: st,
+                                l10n: dt
                             }) {
-                                W(this, y);
-                                W(this, E);
+                                W(this, S);
+                                W(this, v);
                                 W(this, M);
                                 W(this, N);
-                                W(this, r, void 0);
-                                W(this, T, !1);
-                                W(this, S, null);
+                                W(this, o, void 0);
+                                W(this, F, !1);
+                                W(this, R, null);
                                 W(this, w, this.pointerup.bind(this));
-                                W(this, C, this.pointerdown.bind(this));
+                                W(this, T, this.pointerdown.bind(this));
                                 W(this, P, /* @__PURE__ */ new Map());
-                                W(this, b, !1);
-                                W(this, k, !1);
-                                W(this, F, !1);
-                                W(this, x, void 0);
-                                const we = [l.FreeTextEditor, h.InkEditor, c.StampEditor];
+                                W(this, m, !1);
+                                W(this, C, !1);
+                                W(this, x, !1);
+                                W(this, E, void 0);
+                                const yt = [p.FreeTextEditor, f.InkEditor, a.StampEditor];
                                 if (!X._initialized) {
                                     X._initialized = !0;
-                                    for (const be of we)
-                                        be.initialize(pe);
+                                    for (const gt of yt)
+                                        gt.initialize(dt);
                                 }
-                                I.registerEditorTypes(we), oe(this, x, I), this.pageIndex = B, this.div = ee, oe(this, r, Y), oe(this, S, q), this.viewport = le, a(this, x).addLayer(this);
+                                I.registerEditorTypes(yt), ot(this, E, I), this.pageIndex = U, this.div = G, ot(this, o, V), ot(this, R, H), this.viewport = st, r(this, E).addLayer(this);
                             }
                             get isEmpty() {
-                                return a(this, P).size === 0;
+                                return r(this, P).size === 0;
                             }
                             updateToolbar(I) {
-                                a(this, x).updateToolbar(I);
+                                r(this, E).updateToolbar(I);
                             }
-                            updateMode(I = a(this, x).getMode()) {
-                                K(this, N, rn).call(this), I === n.AnnotationEditorType.INK ? (this.addInkEditorIfNeeded(!1), this.disableClick()) : this.enableClick(), I !== n.AnnotationEditorType.NONE && (this.div.classList.toggle("freeTextEditing", I === n.AnnotationEditorType.FREETEXT), this.div.classList.toggle("inkEditing", I === n.AnnotationEditorType.INK), this.div.classList.toggle("stampEditing", I === n.AnnotationEditorType.STAMP), this.div.hidden = !1);
+                            updateMode(I = r(this, E).getMode()) {
+                                J(this, N, sn).call(this), I === e.AnnotationEditorType.INK ? (this.addInkEditorIfNeeded(!1), this.disableClick()) : this.enableClick(), I !== e.AnnotationEditorType.NONE && (this.div.classList.toggle("freeTextEditing", I === e.AnnotationEditorType.FREETEXT), this.div.classList.toggle("inkEditing", I === e.AnnotationEditorType.INK), this.div.classList.toggle("stampEditing", I === e.AnnotationEditorType.STAMP), this.div.hidden = !1);
                             }
                             addInkEditorIfNeeded(I) {
-                                if (!I && a(this, x).getMode() !== n.AnnotationEditorType.INK)
+                                if (!I && r(this, E).getMode() !== e.AnnotationEditorType.INK)
                                     return;
                                 if (!I) {
-                                    for (const ee of a(this, P).values())
-                                        if (ee.isEmpty()) {
-                                            ee.setInBackground();
+                                    for (const G of r(this, P).values())
+                                        if (G.isEmpty()) {
+                                            G.setInBackground();
                                             return;
                                         }
                                 }
-                                K(this, E, Rt).call(this, {
+                                J(this, v, Fe).call(this, {
                                     offsetX: 0,
                                     offsetY: 0
                                 }, !1).setInBackground();
                             }
                             setEditingState(I) {
-                                a(this, x).setEditingState(I);
+                                r(this, E).setEditingState(I);
                             }
                             addCommands(I) {
-                                a(this, x).addCommands(I);
+                                r(this, E).addCommands(I);
                             }
                             enable() {
                                 this.div.style.pointerEvents = "auto";
                                 const I = /* @__PURE__ */ new Set();
-                                for (const ee of a(this, P).values())
-                                    ee.enableEditing(), ee.annotationElementId && I.add(ee.annotationElementId);
-                                if (!a(this, S))
+                                for (const G of r(this, P).values())
+                                    G.enableEditing(), G.annotationElementId && I.add(G.annotationElementId);
+                                if (!r(this, R))
                                     return;
-                                const B = a(this, S).getEditableAnnotations();
-                                for (const ee of B) {
-                                    if (ee.hide(), a(this, x).isDeletedAnnotationElement(ee.data.id) || I.has(ee.data.id))
+                                const U = r(this, R).getEditableAnnotations();
+                                for (const G of U) {
+                                    if (G.hide(), r(this, E).isDeletedAnnotationElement(G.data.id) || I.has(G.data.id))
                                         continue;
-                                    const Y = this.deserialize(ee);
-                                    Y && (this.addOrRebuild(Y), Y.enableEditing());
+                                    const V = this.deserialize(G);
+                                    V && (this.addOrRebuild(V), V.enableEditing());
                                 }
                             }
                             disable() {
-                                var B;
-                                oe(this, F, !0), this.div.style.pointerEvents = "none";
+                                var U;
+                                ot(this, x, !0), this.div.style.pointerEvents = "none";
                                 const I = /* @__PURE__ */ new Set();
-                                for (const ee of a(this, P).values()) {
-                                    if (ee.disableEditing(), !ee.annotationElementId || ee.serialize() !== null) {
-                                        I.add(ee.annotationElementId);
+                                for (const G of r(this, P).values()) {
+                                    if (G.disableEditing(), !G.annotationElementId || G.serialize() !== null) {
+                                        I.add(G.annotationElementId);
                                         continue;
                                     }
-                                    (B = this.getEditableAnnotation(ee.annotationElementId)) == null || B.show(), ee.remove();
+                                    (U = this.getEditableAnnotation(G.annotationElementId)) == null || U.show(), G.remove();
                                 }
-                                if (a(this, S)) {
-                                    const ee = a(this, S).getEditableAnnotations();
-                                    for (const Y of ee) {
+                                if (r(this, R)) {
+                                    const G = r(this, R).getEditableAnnotations();
+                                    for (const V of G) {
                                         const {
-                                            id: q
-                                        } = Y.data;
-                                        I.has(q) || a(this, x).isDeletedAnnotationElement(q) || Y.show();
+                                            id: H
+                                        } = V.data;
+                                        I.has(H) || r(this, E).isDeletedAnnotationElement(H) || V.show();
                                     }
                                 }
-                                K(this, N, rn).call(this), this.isEmpty && (this.div.hidden = !0), oe(this, F, !1);
+                                J(this, N, sn).call(this), this.isEmpty && (this.div.hidden = !0), ot(this, x, !1);
                             }
                             getEditableAnnotation(I) {
-                                var B;
-                                return ((B = a(this, S)) == null ? void 0 : B.getEditableAnnotation(I)) || null;
+                                var U;
+                                return ((U = r(this, R)) == null ? void 0 : U.getEditableAnnotation(I)) || null;
                             }
                             setActiveEditor(I) {
-                                a(this, x).getActive() !== I && a(this, x).setActiveEditor(I);
+                                r(this, E).getActive() !== I && r(this, E).setActiveEditor(I);
                             }
                             enableClick() {
-                                this.div.addEventListener("pointerdown", a(this, C)), this.div.addEventListener("pointerup", a(this, w));
+                                this.div.addEventListener("pointerdown", r(this, T)), this.div.addEventListener("pointerup", r(this, w));
                             }
                             disableClick() {
-                                this.div.removeEventListener("pointerdown", a(this, C)), this.div.removeEventListener("pointerup", a(this, w));
+                                this.div.removeEventListener("pointerdown", r(this, T)), this.div.removeEventListener("pointerup", r(this, w));
                             }
                             attach(I) {
-                                a(this, P).set(I.id, I);
+                                r(this, P).set(I.id, I);
                                 const {
-                                    annotationElementId: B
+                                    annotationElementId: U
                                 } = I;
-                                B && a(this, x).isDeletedAnnotationElement(B) && a(this, x).removeDeletedAnnotationElement(I);
+                                U && r(this, E).isDeletedAnnotationElement(U) && r(this, E).removeDeletedAnnotationElement(I);
                             }
                             detach(I) {
-                                var B;
-                                a(this, P).delete(I.id), (B = a(this, r)) == null || B.removePointerInTextLayer(I.contentDiv), !a(this, F) && I.annotationElementId && a(this, x).addDeletedAnnotationElement(I);
+                                var U;
+                                r(this, P).delete(I.id), (U = r(this, o)) == null || U.removePointerInTextLayer(I.contentDiv), !r(this, x) && I.annotationElementId && r(this, E).addDeletedAnnotationElement(I);
                             }
                             remove(I) {
-                                this.detach(I), a(this, x).removeEditor(I), I.div.contains(document.activeElement) && setTimeout(() => {
-                                    a(this, x).focusMainContainer();
-                                }, 0), I.div.remove(), I.isAttachedToDOM = !1, a(this, k) || this.addInkEditorIfNeeded(!1);
+                                this.detach(I), r(this, E).removeEditor(I), I.div.contains(document.activeElement) && setTimeout(() => {
+                                    r(this, E).focusMainContainer();
+                                }, 0), I.div.remove(), I.isAttachedToDOM = !1, r(this, C) || this.addInkEditorIfNeeded(!1);
                             }
                             changeParent(I) {
-                                var B;
-                                I.parent !== this && (I.annotationElementId && (a(this, x).addDeletedAnnotationElement(I.annotationElementId), s.AnnotationEditor.deleteAnnotationElement(I), I.annotationElementId = null), this.attach(I), (B = I.parent) == null || B.detach(I), I.setParent(this), I.div && I.isAttachedToDOM && (I.div.remove(), this.div.append(I.div)));
+                                var U;
+                                I.parent !== this && (I.annotationElementId && (r(this, E).addDeletedAnnotationElement(I.annotationElementId), s.AnnotationEditor.deleteAnnotationElement(I), I.annotationElementId = null), this.attach(I), (U = I.parent) == null || U.detach(I), I.setParent(this), I.div && I.isAttachedToDOM && (I.div.remove(), this.div.append(I.div)));
                             }
                             add(I) {
-                                if (this.changeParent(I), a(this, x).addEditor(I), this.attach(I), !I.isAttachedToDOM) {
-                                    const B = I.render();
-                                    this.div.append(B), I.isAttachedToDOM = !0;
+                                if (this.changeParent(I), r(this, E).addEditor(I), this.attach(I), !I.isAttachedToDOM) {
+                                    const U = I.render();
+                                    this.div.append(U), I.isAttachedToDOM = !0;
                                 }
-                                I.fixAndSetPosition(), I.onceAdded(), a(this, x).addToAnnotationStorage(I);
+                                I.fixAndSetPosition(), I.onceAdded(), r(this, E).addToAnnotationStorage(I);
                             }
                             moveEditorInDOM(I) {
-                                var ee;
+                                var G;
                                 if (!I.isAttachedToDOM)
                                     return;
                                 const {
-                                    activeElement: B
+                                    activeElement: U
                                 } = document;
-                                I.div.contains(B) && (I._focusEventsAllowed = !1, setTimeout(() => {
+                                I.div.contains(U) && (I._focusEventsAllowed = !1, setTimeout(() => {
                                     I.div.contains(document.activeElement) ? I._focusEventsAllowed = !0 : (I.div.addEventListener("focusin", () => {
                                         I._focusEventsAllowed = !0;
                                     }, {
                                         once: !0
-                                    }), B.focus());
-                                }, 0)), I._structTreeParentId = (ee = a(this, r)) == null ? void 0 : ee.moveElementInDOM(this.div, I.div, I.contentDiv, !0);
+                                    }), U.focus());
+                                }, 0)), I._structTreeParentId = (G = r(this, o)) == null ? void 0 : G.moveElementInDOM(this.div, I.div, I.contentDiv, !0);
                             }
                             addOrRebuild(I) {
                                 I.needsToBeRebuilt() ? I.rebuild() : this.add(I);
                             }
                             addUndoableEditor(I) {
-                                const B = () => I._uiManager.rebuild(I),
-                                    ee = () => {
+                                const U = () => I._uiManager.rebuild(I),
+                                    G = () => {
                                         I.remove();
                                     };
                                 this.addCommands({
-                                    cmd: B,
-                                    undo: ee,
+                                    cmd: U,
+                                    undo: G,
                                     mustExec: !1
                                 });
                             }
                             getNextId() {
-                                return a(this, x).getId();
+                                return r(this, E).getId();
                             }
-                            pasteEditor(I, B) {
-                                a(this, x).updateToolbar(I), a(this, x).updateMode(I);
+                            pasteEditor(I, U) {
+                                r(this, E).updateToolbar(I), r(this, E).updateMode(I);
                                 const {
-                                    offsetX: ee,
-                                    offsetY: Y
-                                } = K(this, M, sn).call(this), q = this.getNextId(), le = K(this, y, nn).call(this, {
+                                    offsetX: G,
+                                    offsetY: V
+                                } = J(this, M, nn).call(this), H = this.getNextId(), st = J(this, S, en).call(this, {
                                     parent: this,
-                                    id: q,
-                                    x: ee,
-                                    y: Y,
-                                    uiManager: a(this, x),
+                                    id: H,
+                                    x: G,
+                                    y: V,
+                                    uiManager: r(this, E),
                                     isCentered: !0,
-                                    ...B
+                                    ...U
                                 });
-                                le && this.add(le);
+                                st && this.add(st);
                             }
                             deserialize(I) {
                                 switch (I.annotationType ?? I.annotationEditorType) {
-                                    case n.AnnotationEditorType.FREETEXT:
-                                        return l.FreeTextEditor.deserialize(I, this, a(this, x));
-                                    case n.AnnotationEditorType.INK:
-                                        return h.InkEditor.deserialize(I, this, a(this, x));
-                                    case n.AnnotationEditorType.STAMP:
-                                        return c.StampEditor.deserialize(I, this, a(this, x));
+                                    case e.AnnotationEditorType.FREETEXT:
+                                        return p.FreeTextEditor.deserialize(I, this, r(this, E));
+                                    case e.AnnotationEditorType.INK:
+                                        return f.InkEditor.deserialize(I, this, r(this, E));
+                                    case e.AnnotationEditorType.STAMP:
+                                        return a.StampEditor.deserialize(I, this, r(this, E));
                                 }
                                 return null;
                             }
                             addNewEditor() {
-                                K(this, E, Rt).call(this, K(this, M, sn).call(this), !0);
+                                J(this, v, Fe).call(this, J(this, M, nn).call(this), !0);
                             }
                             setSelected(I) {
-                                a(this, x).setSelected(I);
+                                r(this, E).setSelected(I);
                             }
                             toggleSelected(I) {
-                                a(this, x).toggleSelected(I);
+                                r(this, E).toggleSelected(I);
                             }
                             isSelected(I) {
-                                return a(this, x).isSelected(I);
+                                return r(this, E).isSelected(I);
                             }
                             unselect(I) {
-                                a(this, x).unselect(I);
+                                r(this, E).unselect(I);
                             }
                             pointerup(I) {
                                 const {
-                                    isMac: B
-                                } = n.FeatureTest.platform;
-                                if (!(I.button !== 0 || I.ctrlKey && B) && I.target === this.div && a(this, b)) {
-                                    if (oe(this, b, !1), !a(this, T)) {
-                                        oe(this, T, !0);
+                                    isMac: U
+                                } = e.FeatureTest.platform;
+                                if (!(I.button !== 0 || I.ctrlKey && U) && I.target === this.div && r(this, m)) {
+                                    if (ot(this, m, !1), !r(this, F)) {
+                                        ot(this, F, !0);
                                         return;
                                     }
-                                    if (a(this, x).getMode() === n.AnnotationEditorType.STAMP) {
-                                        a(this, x).unselectAll();
+                                    if (r(this, E).getMode() === e.AnnotationEditorType.STAMP) {
+                                        r(this, E).unselectAll();
                                         return;
                                     }
-                                    K(this, E, Rt).call(this, I, !1);
+                                    J(this, v, Fe).call(this, I, !1);
                                 }
                             }
                             pointerdown(I) {
-                                if (a(this, b)) {
-                                    oe(this, b, !1);
+                                if (r(this, m)) {
+                                    ot(this, m, !1);
                                     return;
                                 }
                                 const {
-                                    isMac: B
-                                } = n.FeatureTest.platform;
-                                if (I.button !== 0 || I.ctrlKey && B || I.target !== this.div)
+                                    isMac: U
+                                } = e.FeatureTest.platform;
+                                if (I.button !== 0 || I.ctrlKey && U || I.target !== this.div)
                                     return;
-                                oe(this, b, !0);
-                                const ee = a(this, x).getActive();
-                                oe(this, T, !ee || ee.isEmpty());
-                            }
-                            findNewParent(I, B, ee) {
-                                const Y = a(this, x).findParent(B, ee);
-                                return Y === null || Y === this ? !1 : (Y.changeParent(I), !0);
+                                ot(this, m, !0);
+                                const G = r(this, E).getActive();
+                                ot(this, F, !G || G.isEmpty());
+                            }
+                            findNewParent(I, U, G) {
+                                const V = r(this, E).findParent(U, G);
+                                return V === null || V === this ? !1 : (V.changeParent(I), !0);
                             }
                             destroy() {
-                                var I, B;
-                                ((I = a(this, x).getActive()) == null ? void 0 : I.parent) === this && (a(this, x).commitOrRemove(), a(this, x).setActiveEditor(null));
-                                for (const ee of a(this, P).values())
-                                    (B = a(this, r)) == null || B.removePointerInTextLayer(ee.contentDiv), ee.setParent(null), ee.isAttachedToDOM = !1, ee.div.remove();
-                                this.div = null, a(this, P).clear(), a(this, x).removeLayer(this);
+                                var I, U;
+                                ((I = r(this, E).getActive()) == null ? void 0 : I.parent) === this && (r(this, E).commitOrRemove(), r(this, E).setActiveEditor(null));
+                                for (const G of r(this, P).values())
+                                    (U = r(this, o)) == null || U.removePointerInTextLayer(G.contentDiv), G.setParent(null), G.isAttachedToDOM = !1, G.div.remove();
+                                this.div = null, r(this, P).clear(), r(this, E).removeLayer(this);
                             }
                             render({
                                 viewport: I
                             }) {
-                                this.viewport = I, (0, _.setLayerDimensions)(this.div, I);
-                                for (const B of a(this, x).getEditors(this.pageIndex))
-                                    this.add(B);
+                                this.viewport = I, (0, A.setLayerDimensions)(this.div, I);
+                                for (const U of r(this, E).getEditors(this.pageIndex))
+                                    this.add(U);
                                 this.updateMode();
                             }
                             update({
                                 viewport: I
                             }) {
-                                a(this, x).commitOrRemove(), this.viewport = I, (0, _.setLayerDimensions)(this.div, {
+                                r(this, E).commitOrRemove(), this.viewport = I, (0, A.setLayerDimensions)(this.div, {
                                     rotation: I.rotation
                                 }), this.updateMode();
                             }
                             get pageDimensions() {
                                 const {
                                     pageWidth: I,
-                                    pageHeight: B
+                                    pageHeight: U
                                 } = this.viewport.rawDims;
-                                return [I, B];
+                                return [I, U];
                             }
                         };
-                        r = new WeakMap(), T = new WeakMap(), S = new WeakMap(), w = new WeakMap(), C = new WeakMap(), P = new WeakMap(), b = new WeakMap(), k = new WeakMap(), F = new WeakMap(), x = new WeakMap(), y = new WeakSet(), nn = function(I) {
-                            switch (a(this, x).getMode()) {
-                                case n.AnnotationEditorType.FREETEXT:
-                                    return new l.FreeTextEditor(I);
-                                case n.AnnotationEditorType.INK:
-                                    return new h.InkEditor(I);
-                                case n.AnnotationEditorType.STAMP:
-                                    return new c.StampEditor(I);
+                        o = new WeakMap(), F = new WeakMap(), R = new WeakMap(), w = new WeakMap(), T = new WeakMap(), P = new WeakMap(), m = new WeakMap(), C = new WeakMap(), x = new WeakMap(), E = new WeakMap(), S = new WeakSet(), en = function(I) {
+                            switch (r(this, E).getMode()) {
+                                case e.AnnotationEditorType.FREETEXT:
+                                    return new p.FreeTextEditor(I);
+                                case e.AnnotationEditorType.INK:
+                                    return new f.InkEditor(I);
+                                case e.AnnotationEditorType.STAMP:
+                                    return new a.StampEditor(I);
                             }
                             return null;
-                        }, E = new WeakSet(), Rt = function(I, B) {
-                            const ee = this.getNextId(),
-                                Y = K(this, y, nn).call(this, {
+                        }, v = new WeakSet(), Fe = function(I, U) {
+                            const G = this.getNextId(),
+                                V = J(this, S, en).call(this, {
                                     parent: this,
-                                    id: ee,
+                                    id: G,
                                     x: I.offsetX,
                                     y: I.offsetY,
-                                    uiManager: a(this, x),
-                                    isCentered: B
+                                    uiManager: r(this, E),
+                                    isCentered: U
                                 });
-                            return Y && this.add(Y), Y;
-                        }, M = new WeakSet(), sn = function() {
+                            return V && this.add(V), V;
+                        }, M = new WeakSet(), nn = function() {
                             const {
                                 x: I,
-                                y: B,
-                                width: ee,
-                                height: Y
-                            } = this.div.getBoundingClientRect(), q = Math.max(0, I), le = Math.max(0, B), pe = Math.min(window.innerWidth, I + ee), we = Math.min(window.innerHeight, B + Y), be = (q + pe) / 2 - I, R = (le + we) / 2 - B, [d, g] = this.viewport.rotation % 180 === 0 ? [be, R] : [R, be];
+                                y: U,
+                                width: G,
+                                height: V
+                            } = this.div.getBoundingClientRect(), H = Math.max(0, I), st = Math.max(0, U), dt = Math.min(window.innerWidth, I + G), yt = Math.min(window.innerHeight, U + V), gt = (H + dt) / 2 - I, k = (st + yt) / 2 - U, [l, u] = this.viewport.rotation % 180 === 0 ? [gt, k] : [k, gt];
                             return {
-                                offsetX: d,
-                                offsetY: g
+                                offsetX: l,
+                                offsetY: u
                             };
-                        }, N = new WeakSet(), rn = function() {
-                            oe(this, k, !0);
-                            for (const I of a(this, P).values())
+                        }, N = new WeakSet(), sn = function() {
+                            ot(this, C, !0);
+                            for (const I of r(this, P).values())
                                 I.isEmpty() && I.remove();
-                            oe(this, k, !1);
-                        }, nt(X, "_initialized", !1);
-                        let o = X;
-                        e.AnnotationEditorLayer = o;
+                            ot(this, C, !1);
+                        }, ee(X, "_initialized", !1);
+                        let h = X;
+                        t.AnnotationEditorLayer = h;
                     },
                     /* 28 */
                     /***/
-                    (t, e, i) => {
-                        var c, o, r, T, S, w, C, P, b, k, In, x, Ln, p, Dn, $, At, m, an, D, On, G, on;
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        var a, h, o, F, R, w, T, P, m, C, xn, E, Dn, g, In, $, Ae, _, rn, D, Ln, Y, an;
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.FreeTextEditor = void 0;
-                        var n = i(1),
-                            s = i(5),
-                            l = i(4),
-                            h = i(29);
-                        const B = class B extends l.AnnotationEditor {
-                            constructor(q) {
+                        }), t.FreeTextEditor = void 0;
+                        var e = n(1),
+                            s = n(5),
+                            p = n(4),
+                            f = n(29);
+                        const U = class U extends p.AnnotationEditor {
+                            constructor(H) {
                                 super({
-                                    ...q,
+                                    ...H,
                                     name: "freeTextEditor"
                                 });
-                                W(this, k);
-                                W(this, x);
-                                W(this, p);
+                                W(this, C);
+                                W(this, E);
+                                W(this, g);
                                 W(this, $);
-                                W(this, m);
+                                W(this, _);
                                 W(this, D);
-                                W(this, G);
-                                W(this, c, this.editorDivBlur.bind(this));
-                                W(this, o, this.editorDivFocus.bind(this));
-                                W(this, r, this.editorDivInput.bind(this));
-                                W(this, T, this.editorDivKeydown.bind(this));
-                                W(this, S, void 0);
+                                W(this, Y);
+                                W(this, a, this.editorDivBlur.bind(this));
+                                W(this, h, this.editorDivFocus.bind(this));
+                                W(this, o, this.editorDivInput.bind(this));
+                                W(this, F, this.editorDivKeydown.bind(this));
+                                W(this, R, void 0);
                                 W(this, w, "");
-                                W(this, C, `${this.id}-editor`);
+                                W(this, T, `${this.id}-editor`);
                                 W(this, P, void 0);
-                                W(this, b, null);
-                                oe(this, S, q.color || B._defaultColor || l.AnnotationEditor._defaultLineColor), oe(this, P, q.fontSize || B._defaultFontSize);
+                                W(this, m, null);
+                                ot(this, R, H.color || U._defaultColor || p.AnnotationEditor._defaultLineColor), ot(this, P, H.fontSize || U._defaultFontSize);
                             }
                             static get _keyboardManager() {
-                                const q = B.prototype,
-                                    le = (be) => be.isEmpty(),
-                                    pe = s.AnnotationEditorUIManager.TRANSLATE_SMALL,
-                                    we = s.AnnotationEditorUIManager.TRANSLATE_BIG;
-                                return (0, n.shadow)(this, "_keyboardManager", new s.KeyboardManager([
+                                const H = U.prototype,
+                                    st = (gt) => gt.isEmpty(),
+                                    dt = s.AnnotationEditorUIManager.TRANSLATE_SMALL,
+                                    yt = s.AnnotationEditorUIManager.TRANSLATE_BIG;
+                                return (0, e.shadow)(this, "_keyboardManager", new s.KeyboardManager([
                                     [
-                                        ["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], q.commitOrRemove, {
+                                        ["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], H.commitOrRemove, {
                                             bubbles: !0
                                         }
                                     ],
                                     [
-                                        ["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], q.commitOrRemove
+                                        ["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], H.commitOrRemove
                                     ],
                                     [
-                                        ["ArrowLeft", "mac+ArrowLeft"], q._translateEmpty, {
-                                            args: [-pe, 0],
-                                            checker: le
+                                        ["ArrowLeft", "mac+ArrowLeft"], H._translateEmpty, {
+                                            args: [-dt, 0],
+                                            checker: st
                                         }
                                     ],
                                     [
-                                        ["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], q._translateEmpty, {
-                                            args: [-we, 0],
-                                            checker: le
+                                        ["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], H._translateEmpty, {
+                                            args: [-yt, 0],
+                                            checker: st
                                         }
                                     ],
                                     [
-                                        ["ArrowRight", "mac+ArrowRight"], q._translateEmpty, {
-                                            args: [pe, 0],
-                                            checker: le
+                                        ["ArrowRight", "mac+ArrowRight"], H._translateEmpty, {
+                                            args: [dt, 0],
+                                            checker: st
                                         }
                                     ],
                                     [
-                                        ["ctrl+ArrowRight", "mac+shift+ArrowRight"], q._translateEmpty, {
-                                            args: [we, 0],
-                                            checker: le
+                                        ["ctrl+ArrowRight", "mac+shift+ArrowRight"], H._translateEmpty, {
+                                            args: [yt, 0],
+                                            checker: st
                                         }
                                     ],
                                     [
-                                        ["ArrowUp", "mac+ArrowUp"], q._translateEmpty, {
-                                            args: [0, -pe],
-                                            checker: le
+                                        ["ArrowUp", "mac+ArrowUp"], H._translateEmpty, {
+                                            args: [0, -dt],
+                                            checker: st
                                         }
                                     ],
                                     [
-                                        ["ctrl+ArrowUp", "mac+shift+ArrowUp"], q._translateEmpty, {
-                                            args: [0, -we],
-                                            checker: le
+                                        ["ctrl+ArrowUp", "mac+shift+ArrowUp"], H._translateEmpty, {
+                                            args: [0, -yt],
+                                            checker: st
                                         }
                                     ],
                                     [
-                                        ["ArrowDown", "mac+ArrowDown"], q._translateEmpty, {
-                                            args: [0, pe],
-                                            checker: le
+                                        ["ArrowDown", "mac+ArrowDown"], H._translateEmpty, {
+                                            args: [0, dt],
+                                            checker: st
                                         }
                                     ],
                                     [
-                                        ["ctrl+ArrowDown", "mac+shift+ArrowDown"], q._translateEmpty, {
-                                            args: [0, we],
-                                            checker: le
+                                        ["ctrl+ArrowDown", "mac+shift+ArrowDown"], H._translateEmpty, {
+                                            args: [0, yt],
+                                            checker: st
                                         }
                                     ]
                                 ]));
                             }
-                            static initialize(q) {
-                                l.AnnotationEditor.initialize(q, {
+                            static initialize(H) {
+                                p.AnnotationEditor.initialize(H, {
                                     strings: ["free_text2_default_content", "editor_free_text2_aria_label"]
                                 });
-                                const le = getComputedStyle(document.documentElement);
-                                this._internalPadding = parseFloat(le.getPropertyValue("--freetext-padding"));
+                                const st = getComputedStyle(document.documentElement);
+                                this._internalPadding = parseFloat(st.getPropertyValue("--freetext-padding"));
                             }
-                            static updateDefaultParams(q, le) {
-                                switch (q) {
-                                    case n.AnnotationEditorParamsType.FREETEXT_SIZE:
-                                        B._defaultFontSize = le;
+                            static updateDefaultParams(H, st) {
+                                switch (H) {
+                                    case e.AnnotationEditorParamsType.FREETEXT_SIZE:
+                                        U._defaultFontSize = st;
                                         break;
-                                    case n.AnnotationEditorParamsType.FREETEXT_COLOR:
-                                        B._defaultColor = le;
+                                    case e.AnnotationEditorParamsType.FREETEXT_COLOR:
+                                        U._defaultColor = st;
                                         break;
                                 }
                             }
-                            updateParams(q, le) {
-                                switch (q) {
-                                    case n.AnnotationEditorParamsType.FREETEXT_SIZE:
-                                        K(this, k, In).call(this, le);
+                            updateParams(H, st) {
+                                switch (H) {
+                                    case e.AnnotationEditorParamsType.FREETEXT_SIZE:
+                                        J(this, C, xn).call(this, st);
                                         break;
-                                    case n.AnnotationEditorParamsType.FREETEXT_COLOR:
-                                        K(this, x, Ln).call(this, le);
+                                    case e.AnnotationEditorParamsType.FREETEXT_COLOR:
+                                        J(this, E, Dn).call(this, st);
                                         break;
                                 }
                             }
                             static get defaultPropertiesToUpdate() {
                                 return [
-                                    [n.AnnotationEditorParamsType.FREETEXT_SIZE, B._defaultFontSize],
-                                    [n.AnnotationEditorParamsType.FREETEXT_COLOR, B._defaultColor || l.AnnotationEditor._defaultLineColor]
+                                    [e.AnnotationEditorParamsType.FREETEXT_SIZE, U._defaultFontSize],
+                                    [e.AnnotationEditorParamsType.FREETEXT_COLOR, U._defaultColor || p.AnnotationEditor._defaultLineColor]
                                 ];
                             }
                             get propertiesToUpdate() {
                                 return [
-                                    [n.AnnotationEditorParamsType.FREETEXT_SIZE, a(this, P)],
-                                    [n.AnnotationEditorParamsType.FREETEXT_COLOR, a(this, S)]
+                                    [e.AnnotationEditorParamsType.FREETEXT_SIZE, r(this, P)],
+                                    [e.AnnotationEditorParamsType.FREETEXT_COLOR, r(this, R)]
                                 ];
                             }
-                            _translateEmpty(q, le) {
-                                this._uiManager.translateSelectedEditors(q, le, !0);
+                            _translateEmpty(H, st) {
+                                this._uiManager.translateSelectedEditors(H, st, !0);
                             }
                             getInitialTranslation() {
-                                const q = this.parentScale;
-                                return [-B._internalPadding * q, -(B._internalPadding + a(this, P)) * q];
+                                const H = this.parentScale;
+                                return [-U._internalPadding * H, -(U._internalPadding + r(this, P)) * H];
                             }
                             rebuild() {
                                 this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
                             }
                             enableEditMode() {
-                                this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(n.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), this.editorDiv.addEventListener("keydown", a(this, T)), this.editorDiv.addEventListener("focus", a(this, o)), this.editorDiv.addEventListener("blur", a(this, c)), this.editorDiv.addEventListener("input", a(this, r)));
+                                this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(e.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), this.editorDiv.addEventListener("keydown", r(this, F)), this.editorDiv.addEventListener("focus", r(this, h)), this.editorDiv.addEventListener("blur", r(this, a)), this.editorDiv.addEventListener("input", r(this, o)));
                             }
                             disableEditMode() {
-                                this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", a(this, C)), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", a(this, T)), this.editorDiv.removeEventListener("focus", a(this, o)), this.editorDiv.removeEventListener("blur", a(this, c)), this.editorDiv.removeEventListener("input", a(this, r)), this.div.focus({
+                                this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", r(this, T)), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", r(this, F)), this.editorDiv.removeEventListener("focus", r(this, h)), this.editorDiv.removeEventListener("blur", r(this, a)), this.editorDiv.removeEventListener("input", r(this, o)), this.div.focus({
                                     preventScroll: !0
                                 }), this.isEditing = !1, this.parent.div.classList.add("freeTextEditing"));
                             }
-                            focusin(q) {
-                                this._focusEventsAllowed && (super.focusin(q), q.target !== this.editorDiv && this.editorDiv.focus());
+                            focusin(H) {
+                                this._focusEventsAllowed && (super.focusin(H), H.target !== this.editorDiv && this.editorDiv.focus());
                             }
                             onceAdded() {
-                                var q;
+                                var H;
                                 if (this.width) {
-                                    K(this, G, on).call(this);
+                                    J(this, Y, an).call(this);
                                     return;
                                 }
-                                this.enableEditMode(), this.editorDiv.focus(), (q = this._initialOptions) != null && q.isCentered && this.center(), this._initialOptions = null;
+                                this.enableEditMode(), this.editorDiv.focus(), (H = this._initialOptions) != null && H.isCentered && this.center(), this._initialOptions = null;
                             }
                             isEmpty() {
                                 return !this.editorDiv || this.editorDiv.innerText.trim() === "";
                             }
                             remove() {
                                 this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freeTextEditing")), super.remove();
                             }
                             commit() {
                                 if (!this.isInEditMode())
                                     return;
                                 super.commit(), this.disableEditMode();
-                                const q = a(this, w),
-                                    le = oe(this, w, K(this, p, Dn).call(this).trimEnd());
-                                if (q === le)
+                                const H = r(this, w),
+                                    st = ot(this, w, J(this, g, In).call(this).trimEnd());
+                                if (H === st)
                                     return;
-                                const pe = (we) => {
-                                    if (oe(this, w, we), !we) {
+                                const dt = (yt) => {
+                                    if (ot(this, w, yt), !yt) {
                                         this.remove();
                                         return;
                                     }
-                                    K(this, m, an).call(this), this._uiManager.rebuild(this), K(this, $, At).call(this);
+                                    J(this, _, rn).call(this), this._uiManager.rebuild(this), J(this, $, Ae).call(this);
                                 };
                                 this.addCommands({
                                     cmd: () => {
-                                        pe(le);
+                                        dt(st);
                                     },
                                     undo: () => {
-                                        pe(q);
+                                        dt(H);
                                     },
                                     mustExec: !1
-                                }), K(this, $, At).call(this);
+                                }), J(this, $, Ae).call(this);
                             }
                             shouldGetKeyboardEvents() {
                                 return this.isInEditMode();
                             }
                             enterInEditMode() {
                                 this.enableEditMode(), this.editorDiv.focus();
                             }
-                            dblclick(q) {
+                            dblclick(H) {
                                 this.enterInEditMode();
                             }
-                            keydown(q) {
-                                q.target === this.div && q.key === "Enter" && (this.enterInEditMode(), q.preventDefault());
+                            keydown(H) {
+                                H.target === this.div && H.key === "Enter" && (this.enterInEditMode(), H.preventDefault());
                             }
-                            editorDivKeydown(q) {
-                                B._keyboardManager.exec(this, q);
+                            editorDivKeydown(H) {
+                                U._keyboardManager.exec(this, H);
                             }
-                            editorDivFocus(q) {
+                            editorDivFocus(H) {
                                 this.isEditing = !0;
                             }
-                            editorDivBlur(q) {
+                            editorDivBlur(H) {
                                 this.isEditing = !1;
                             }
-                            editorDivInput(q) {
+                            editorDivInput(H) {
                                 this.parent.div.classList.toggle("freeTextEditing", this.isEmpty());
                             }
                             disableEditing() {
                                 this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
                             }
                             enableEditing() {
                                 this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
                             }
                             render() {
                                 if (this.div)
                                     return this.div;
-                                let q, le;
-                                this.width && (q = this.x, le = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", a(this, C)), this.enableEditing(), l.AnnotationEditor._l10nPromise.get("editor_free_text2_aria_label").then((we) => {
-                                    var be;
-                                    return (be = this.editorDiv) == null ? void 0 : be.setAttribute("aria-label", we);
-                                }), l.AnnotationEditor._l10nPromise.get("free_text2_default_content").then((we) => {
-                                    var be;
-                                    return (be = this.editorDiv) == null ? void 0 : be.setAttribute("default-content", we);
+                                let H, st;
+                                this.width && (H = this.x, st = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", r(this, T)), this.enableEditing(), p.AnnotationEditor._l10nPromise.get("editor_free_text2_aria_label").then((yt) => {
+                                    var gt;
+                                    return (gt = this.editorDiv) == null ? void 0 : gt.setAttribute("aria-label", yt);
+                                }), p.AnnotationEditor._l10nPromise.get("free_text2_default_content").then((yt) => {
+                                    var gt;
+                                    return (gt = this.editorDiv) == null ? void 0 : gt.setAttribute("default-content", yt);
                                 }), this.editorDiv.contentEditable = !0;
                                 const {
-                                    style: pe
+                                    style: dt
                                 } = this.editorDiv;
-                                if (pe.fontSize = `calc(${a(this, P)}px * var(--scale-factor))`, pe.color = a(this, S), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, s.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) {
-                                    const [we, be] = this.parentDimensions;
+                                if (dt.fontSize = `calc(${r(this, P)}px * var(--scale-factor))`, dt.color = r(this, R), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, s.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) {
+                                    const [yt, gt] = this.parentDimensions;
                                     if (this.annotationElementId) {
                                         const {
-                                            position: R
-                                        } = a(this, b);
-                                        let [d, g] = this.getInitialTranslation();
-                                        [d, g] = this.pageTranslationToScreen(d, g);
-                                        const [f, v] = this.pageDimensions, [A, O] = this.pageTranslation;
-                                        let H, z;
+                                            position: k
+                                        } = r(this, m);
+                                        let [l, u] = this.getInitialTranslation();
+                                        [l, u] = this.pageTranslationToScreen(l, u);
+                                        const [d, b] = this.pageDimensions, [y, O] = this.pageTranslation;
+                                        let B, z;
                                         switch (this.rotation) {
                                             case 0:
-                                                H = q + (R[0] - A) / f, z = le + this.height - (R[1] - O) / v;
+                                                B = H + (k[0] - y) / d, z = st + this.height - (k[1] - O) / b;
                                                 break;
                                             case 90:
-                                                H = q + (R[0] - A) / f, z = le - (R[1] - O) / v, [d, g] = [g, -d];
+                                                B = H + (k[0] - y) / d, z = st - (k[1] - O) / b, [l, u] = [u, -l];
                                                 break;
                                             case 180:
-                                                H = q - this.width + (R[0] - A) / f, z = le - (R[1] - O) / v, [d, g] = [-d, -g];
+                                                B = H - this.width + (k[0] - y) / d, z = st - (k[1] - O) / b, [l, u] = [-l, -u];
                                                 break;
                                             case 270:
-                                                H = q + (R[0] - A - this.height * v) / f, z = le + (R[1] - O - this.width * f) / v, [d, g] = [-g, d];
+                                                B = H + (k[0] - y - this.height * b) / d, z = st + (k[1] - O - this.width * d) / b, [l, u] = [-u, l];
                                                 break;
                                         }
-                                        this.setAt(H * we, z * be, d, g);
+                                        this.setAt(B * yt, z * gt, l, u);
                                     } else
-                                        this.setAt(q * we, le * be, this.width * we, this.height * be);
-                                    K(this, m, an).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
+                                        this.setAt(H * yt, st * gt, this.width * yt, this.height * gt);
+                                    J(this, _, rn).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
                                 } else
                                     this._isDraggable = !1, this.editorDiv.contentEditable = !0;
                                 return this.div;
                             }
                             get contentDiv() {
                                 return this.editorDiv;
                             }
-                            static deserialize(q, le, pe) {
-                                let we = null;
-                                if (q instanceof h.FreeTextAnnotationElement) {
+                            static deserialize(H, st, dt) {
+                                let yt = null;
+                                if (H instanceof f.FreeTextAnnotationElement) {
                                     const {
                                         data: {
                                             defaultAppearanceData: {
-                                                fontSize: R,
-                                                fontColor: d
+                                                fontSize: k,
+                                                fontColor: l
                                             },
-                                            rect: g,
-                                            rotation: f,
-                                            id: v
+                                            rect: u,
+                                            rotation: d,
+                                            id: b
                                         },
-                                        textContent: A,
+                                        textContent: y,
                                         textPosition: O,
                                         parent: {
                                             page: {
-                                                pageNumber: H
+                                                pageNumber: B
                                             }
                                         }
-                                    } = q;
-                                    if (!A || A.length === 0)
+                                    } = H;
+                                    if (!y || y.length === 0)
                                         return null;
-                                    we = q = {
-                                        annotationType: n.AnnotationEditorType.FREETEXT,
-                                        color: Array.from(d),
-                                        fontSize: R,
-                                        value: A.join(`
+                                    yt = H = {
+                                        annotationType: e.AnnotationEditorType.FREETEXT,
+                                        color: Array.from(l),
+                                        fontSize: k,
+                                        value: y.join(`
 `),
                                         position: O,
-                                        pageIndex: H - 1,
-                                        rect: g,
-                                        rotation: f,
-                                        id: v,
+                                        pageIndex: B - 1,
+                                        rect: u,
+                                        rotation: d,
+                                        id: b,
                                         deleted: !1
                                     };
                                 }
-                                const be = super.deserialize(q, le, pe);
-                                return oe(be, P, q.fontSize), oe(be, S, n.Util.makeHexColor(...q.color)), oe(be, w, q.value), be.annotationElementId = q.id || null, oe(be, b, we), be;
+                                const gt = super.deserialize(H, st, dt);
+                                return ot(gt, P, H.fontSize), ot(gt, R, e.Util.makeHexColor(...H.color)), ot(gt, w, H.value), gt.annotationElementId = H.id || null, ot(gt, m, yt), gt;
                             }
-                            serialize(q = !1) {
+                            serialize(H = !1) {
                                 if (this.isEmpty())
                                     return null;
                                 if (this.deleted)
                                     return {
                                         pageIndex: this.pageIndex,
                                         id: this.annotationElementId,
                                         deleted: !0
                                     };
-                                const le = B._internalPadding * this.parentScale,
-                                    pe = this.getRect(le, le),
-                                    we = l.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : a(this, S)),
-                                    be = {
-                                        annotationType: n.AnnotationEditorType.FREETEXT,
-                                        color: we,
-                                        fontSize: a(this, P),
-                                        value: a(this, w),
+                                const st = U._internalPadding * this.parentScale,
+                                    dt = this.getRect(st, st),
+                                    yt = p.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : r(this, R)),
+                                    gt = {
+                                        annotationType: e.AnnotationEditorType.FREETEXT,
+                                        color: yt,
+                                        fontSize: r(this, P),
+                                        value: r(this, w),
                                         pageIndex: this.pageIndex,
-                                        rect: pe,
+                                        rect: dt,
                                         rotation: this.rotation,
                                         structTreeParentId: this._structTreeParentId
                                     };
-                                return q ? be : this.annotationElementId && !K(this, D, On).call(this, be) ? null : (be.id = this.annotationElementId, be);
+                                return H ? gt : this.annotationElementId && !J(this, D, Ln).call(this, gt) ? null : (gt.id = this.annotationElementId, gt);
                             }
                         };
-                        c = new WeakMap(), o = new WeakMap(), r = new WeakMap(), T = new WeakMap(), S = new WeakMap(), w = new WeakMap(), C = new WeakMap(), P = new WeakMap(), b = new WeakMap(), k = new WeakSet(), In = function(q) {
-                            const le = (we) => {
-                                    this.editorDiv.style.fontSize = `calc(${we}px * var(--scale-factor))`, this.translate(0, -(we - a(this, P)) * this.parentScale), oe(this, P, we), K(this, $, At).call(this);
+                        a = new WeakMap(), h = new WeakMap(), o = new WeakMap(), F = new WeakMap(), R = new WeakMap(), w = new WeakMap(), T = new WeakMap(), P = new WeakMap(), m = new WeakMap(), C = new WeakSet(), xn = function(H) {
+                            const st = (yt) => {
+                                    this.editorDiv.style.fontSize = `calc(${yt}px * var(--scale-factor))`, this.translate(0, -(yt - r(this, P)) * this.parentScale), ot(this, P, yt), J(this, $, Ae).call(this);
                                 },
-                                pe = a(this, P);
+                                dt = r(this, P);
                             this.addCommands({
                                 cmd: () => {
-                                    le(q);
+                                    st(H);
                                 },
                                 undo: () => {
-                                    le(pe);
+                                    st(dt);
                                 },
                                 mustExec: !0,
-                                type: n.AnnotationEditorParamsType.FREETEXT_SIZE,
+                                type: e.AnnotationEditorParamsType.FREETEXT_SIZE,
                                 overwriteIfSameType: !0,
                                 keepUndo: !0
                             });
-                        }, x = new WeakSet(), Ln = function(q) {
-                            const le = a(this, S);
+                        }, E = new WeakSet(), Dn = function(H) {
+                            const st = r(this, R);
                             this.addCommands({
                                 cmd: () => {
-                                    oe(this, S, this.editorDiv.style.color = q);
+                                    ot(this, R, this.editorDiv.style.color = H);
                                 },
                                 undo: () => {
-                                    oe(this, S, this.editorDiv.style.color = le);
+                                    ot(this, R, this.editorDiv.style.color = st);
                                 },
                                 mustExec: !0,
-                                type: n.AnnotationEditorParamsType.FREETEXT_COLOR,
+                                type: e.AnnotationEditorParamsType.FREETEXT_COLOR,
                                 overwriteIfSameType: !0,
                                 keepUndo: !0
                             });
-                        }, p = new WeakSet(), Dn = function() {
-                            const q = this.editorDiv.getElementsByTagName("div");
-                            if (q.length === 0)
+                        }, g = new WeakSet(), In = function() {
+                            const H = this.editorDiv.getElementsByTagName("div");
+                            if (H.length === 0)
                                 return this.editorDiv.innerText;
-                            const le = [];
-                            for (const pe of q)
-                                le.push(pe.innerText.replace(/\r\n?|\n/, ""));
-                            return le.join(`
+                            const st = [];
+                            for (const dt of H)
+                                st.push(dt.innerText.replace(/\r\n?|\n/, ""));
+                            return st.join(`
 `);
-                        }, $ = new WeakSet(), At = function() {
-                            const [q, le] = this.parentDimensions;
-                            let pe;
+                        }, $ = new WeakSet(), Ae = function() {
+                            const [H, st] = this.parentDimensions;
+                            let dt;
                             if (this.isAttachedToDOM)
-                                pe = this.div.getBoundingClientRect();
+                                dt = this.div.getBoundingClientRect();
                             else {
                                 const {
-                                    currentLayer: we,
-                                    div: be
-                                } = this, R = be.style.display;
-                                be.style.display = "hidden", we.div.append(this.div), pe = be.getBoundingClientRect(), be.remove(), be.style.display = R;
-                            }
-                            this.rotation % 180 === this.parentRotation % 180 ? (this.width = pe.width / q, this.height = pe.height / le) : (this.width = pe.height / q, this.height = pe.width / le), this.fixAndSetPosition();
-                        }, m = new WeakSet(), an = function() {
-                            if (this.editorDiv.replaceChildren(), !!a(this, w))
-                                for (const q of a(this, w).split(`
+                                    currentLayer: yt,
+                                    div: gt
+                                } = this, k = gt.style.display;
+                                gt.style.display = "hidden", yt.div.append(this.div), dt = gt.getBoundingClientRect(), gt.remove(), gt.style.display = k;
+                            }
+                            this.rotation % 180 === this.parentRotation % 180 ? (this.width = dt.width / H, this.height = dt.height / st) : (this.width = dt.height / H, this.height = dt.width / st), this.fixAndSetPosition();
+                        }, _ = new WeakSet(), rn = function() {
+                            if (this.editorDiv.replaceChildren(), !!r(this, w))
+                                for (const H of r(this, w).split(`
 `)) {
-                                    const le = document.createElement("div");
-                                    le.append(q ? document.createTextNode(q) : document.createElement("br")), this.editorDiv.append(le);
+                                    const st = document.createElement("div");
+                                    st.append(H ? document.createTextNode(H) : document.createElement("br")), this.editorDiv.append(st);
                                 }
-                        }, D = new WeakSet(), On = function(q) {
+                        }, D = new WeakSet(), Ln = function(H) {
                             const {
-                                value: le,
-                                fontSize: pe,
-                                color: we,
-                                rect: be,
-                                pageIndex: R
-                            } = a(this, b);
-                            return q.value !== le || q.fontSize !== pe || q.rect.some((d, g) => Math.abs(d - be[g]) >= 1) || q.color.some((d, g) => d !== we[g]) || q.pageIndex !== R;
-                        }, G = new WeakSet(), on = function(q = !1) {
+                                value: st,
+                                fontSize: dt,
+                                color: yt,
+                                rect: gt,
+                                pageIndex: k
+                            } = r(this, m);
+                            return H.value !== st || H.fontSize !== dt || H.rect.some((l, u) => Math.abs(l - gt[u]) >= 1) || H.color.some((l, u) => l !== yt[u]) || H.pageIndex !== k;
+                        }, Y = new WeakSet(), an = function(H = !1) {
                             if (!this.annotationElementId)
                                 return;
-                            if (K(this, $, At).call(this), !q && (this.width === 0 || this.height === 0)) {
-                                setTimeout(() => K(this, G, on).call(this, !0), 0);
+                            if (J(this, $, Ae).call(this), !H && (this.width === 0 || this.height === 0)) {
+                                setTimeout(() => J(this, Y, an).call(this, !0), 0);
                                 return;
                             }
-                            const le = B._internalPadding * this.parentScale;
-                            a(this, b).rect = this.getRect(le, le);
-                        }, nt(B, "_freeTextDefaultContent", ""), nt(B, "_internalPadding", 0), nt(B, "_defaultColor", null), nt(B, "_defaultFontSize", 10), nt(B, "_type", "freetext");
-                        let _ = B;
-                        e.FreeTextEditor = _;
+                            const st = U._internalPadding * this.parentScale;
+                            r(this, m).rect = this.getRect(st, st);
+                        }, ee(U, "_freeTextDefaultContent", ""), ee(U, "_internalPadding", 0), ee(U, "_defaultColor", null), ee(U, "_defaultFontSize", 10), ee(U, "_type", "freetext");
+                        let A = U;
+                        t.FreeTextEditor = A;
                     },
                     /* 29 */
                     /***/
-                    (t, e, i) => {
-                        var g, v, ht, O, Nn, z, ae, Z, ce, ue, me, fe, Pe, Fe, Ee, De, _e, ie, se, ge, Ce, xe, He, $n, je, Mt, Xe, ln, Ye, cn, ne, J, ve, Se, tt, et, te, hn, Ne, ke, $e, Be, Bn, Ae, un;
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        var u, b, ce, O, On, z, it, Z, lt, ht, mt, ft, kt, Rt, St, It, _t, rt, at, pt, Ct, Tt, Bt, $n, jt, Me, Gt, on, Vt, ln, nt, Q, At, wt, te, Qt, et, cn, Ot, Pt, $t, Nt, Nn, vt, hn;
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.StampAnnotationElement = e.InkAnnotationElement = e.FreeTextAnnotationElement = e.AnnotationLayer = void 0;
-                        var n = i(1),
-                            s = i(6),
-                            l = i(3),
-                            h = i(30),
-                            _ = i(31),
-                            c = i(32);
-                        const o = 1e3,
-                            r = 9,
-                            T = /* @__PURE__ */ new WeakSet();
+                        }), t.StampAnnotationElement = t.InkAnnotationElement = t.FreeTextAnnotationElement = t.AnnotationLayer = void 0;
+                        var e = n(1),
+                            s = n(6),
+                            p = n(3),
+                            f = n(30),
+                            A = n(31),
+                            a = n(32);
+                        const h = 1e3,
+                            o = 9,
+                            F = /* @__PURE__ */ new WeakSet();
 
-                        function S(Oe) {
+                        function R(Lt) {
                             return {
-                                width: Oe[2] - Oe[0],
-                                height: Oe[3] - Oe[1]
+                                width: Lt[2] - Lt[0],
+                                height: Lt[3] - Lt[1]
                             };
                         }
                         class w {
-                            static create(U) {
-                                switch (U.data.annotationType) {
-                                    case n.AnnotationType.LINK:
-                                        return new P(U);
-                                    case n.AnnotationType.TEXT:
-                                        return new b(U);
-                                    case n.AnnotationType.WIDGET:
-                                        switch (U.data.fieldType) {
+                            static create(j) {
+                                switch (j.data.annotationType) {
+                                    case e.AnnotationType.LINK:
+                                        return new P(j);
+                                    case e.AnnotationType.TEXT:
+                                        return new m(j);
+                                    case e.AnnotationType.WIDGET:
+                                        switch (j.data.fieldType) {
                                             case "Tx":
-                                                return new F(U);
+                                                return new x(j);
                                             case "Btn":
-                                                return U.data.radioButton ? new p(U) : U.data.checkBox ? new y(U) : new E(U);
+                                                return j.data.radioButton ? new g(j) : j.data.checkBox ? new S(j) : new v(j);
                                             case "Ch":
-                                                return new $(U);
+                                                return new $(j);
                                             case "Sig":
-                                                return new x(U);
+                                                return new E(j);
                                         }
-                                        return new k(U);
-                                    case n.AnnotationType.POPUP:
-                                        return new M(U);
-                                    case n.AnnotationType.FREETEXT:
-                                        return new N(U);
-                                    case n.AnnotationType.LINE:
-                                        return new D(U);
-                                    case n.AnnotationType.SQUARE:
-                                        return new X(U);
-                                    case n.AnnotationType.CIRCLE:
-                                        return new G(U);
-                                    case n.AnnotationType.POLYLINE:
-                                        return new I(U);
-                                    case n.AnnotationType.CARET:
-                                        return new ee(U);
-                                    case n.AnnotationType.INK:
-                                        return new Y(U);
-                                    case n.AnnotationType.POLYGON:
-                                        return new B(U);
-                                    case n.AnnotationType.HIGHLIGHT:
-                                        return new q(U);
-                                    case n.AnnotationType.UNDERLINE:
-                                        return new le(U);
-                                    case n.AnnotationType.SQUIGGLY:
-                                        return new pe(U);
-                                    case n.AnnotationType.STRIKEOUT:
-                                        return new we(U);
-                                    case n.AnnotationType.STAMP:
-                                        return new be(U);
-                                    case n.AnnotationType.FILEATTACHMENT:
-                                        return new R(U);
+                                        return new C(j);
+                                    case e.AnnotationType.POPUP:
+                                        return new M(j);
+                                    case e.AnnotationType.FREETEXT:
+                                        return new N(j);
+                                    case e.AnnotationType.LINE:
+                                        return new D(j);
+                                    case e.AnnotationType.SQUARE:
+                                        return new X(j);
+                                    case e.AnnotationType.CIRCLE:
+                                        return new Y(j);
+                                    case e.AnnotationType.POLYLINE:
+                                        return new I(j);
+                                    case e.AnnotationType.CARET:
+                                        return new G(j);
+                                    case e.AnnotationType.INK:
+                                        return new V(j);
+                                    case e.AnnotationType.POLYGON:
+                                        return new U(j);
+                                    case e.AnnotationType.HIGHLIGHT:
+                                        return new H(j);
+                                    case e.AnnotationType.UNDERLINE:
+                                        return new st(j);
+                                    case e.AnnotationType.SQUIGGLY:
+                                        return new dt(j);
+                                    case e.AnnotationType.STRIKEOUT:
+                                        return new yt(j);
+                                    case e.AnnotationType.STAMP:
+                                        return new gt(j);
+                                    case e.AnnotationType.FILEATTACHMENT:
+                                        return new k(j);
                                     default:
-                                        return new C(U);
+                                        return new T(j);
                                 }
                             }
                         }
-                        const f = class f {
-                            constructor(U, {
-                                isRenderable: u = !1,
+                        const d = class d {
+                            constructor(j, {
+                                isRenderable: c = !1,
                                 ignoreBorder: L = !1,
-                                createQuadrilaterals: j = !1
+                                createQuadrilaterals: q = !1
                             } = {}) {
-                                W(this, g, !1);
-                                this.isRenderable = u, this.data = U.data, this.layer = U.layer, this.linkService = U.linkService, this.downloadManager = U.downloadManager, this.imageResourcesPath = U.imageResourcesPath, this.renderForms = U.renderForms, this.svgFactory = U.svgFactory, this.annotationStorage = U.annotationStorage, this.enableScripting = U.enableScripting, this.hasJSActions = U.hasJSActions, this._fieldObjects = U.fieldObjects, this.parent = U.parent, u && (this.container = this._createContainer(L)), j && this._createQuadrilaterals();
+                                W(this, u, !1);
+                                this.isRenderable = c, this.data = j.data, this.layer = j.layer, this.linkService = j.linkService, this.downloadManager = j.downloadManager, this.imageResourcesPath = j.imageResourcesPath, this.renderForms = j.renderForms, this.svgFactory = j.svgFactory, this.annotationStorage = j.annotationStorage, this.enableScripting = j.enableScripting, this.hasJSActions = j.hasJSActions, this._fieldObjects = j.fieldObjects, this.parent = j.parent, c && (this.container = this._createContainer(L)), q && this._createQuadrilaterals();
                             }
                             static _hasPopupData({
-                                titleObj: U,
-                                contentsObj: u,
+                                titleObj: j,
+                                contentsObj: c,
                                 richText: L
                             }) {
-                                return !!(U != null && U.str || u != null && u.str || L != null && L.str);
+                                return !!(j != null && j.str || c != null && c.str || L != null && L.str);
                             }
                             get hasPopupData() {
-                                return f._hasPopupData(this.data);
+                                return d._hasPopupData(this.data);
                             }
-                            _createContainer(U) {
+                            _createContainer(j) {
                                 const {
-                                    data: u,
+                                    data: c,
                                     parent: {
                                         page: L,
-                                        viewport: j
+                                        viewport: q
                                     }
-                                } = this, V = document.createElement("section");
-                                V.setAttribute("data-annotation-id", u.id), this instanceof k || (V.tabIndex = o), V.style.zIndex = this.parent.zIndex++, this.data.popupRef && V.setAttribute("aria-haspopup", "dialog"), u.noRotate && V.classList.add("norotate");
+                                } = this, K = document.createElement("section");
+                                K.setAttribute("data-annotation-id", c.id), this instanceof C || (K.tabIndex = h), K.style.zIndex = this.parent.zIndex++, this.data.popupRef && K.setAttribute("aria-haspopup", "dialog"), c.noRotate && K.classList.add("norotate");
                                 const {
-                                    pageWidth: Q,
-                                    pageHeight: he,
-                                    pageX: ye,
-                                    pageY: Me
-                                } = j.rawDims;
-                                if (!u.rect || this instanceof M) {
+                                    pageWidth: tt,
+                                    pageHeight: ct,
+                                    pageX: bt,
+                                    pageY: Mt
+                                } = q.rawDims;
+                                if (!c.rect || this instanceof M) {
                                     const {
-                                        rotation: Ue
-                                    } = u;
-                                    return !u.hasOwnCanvas && Ue !== 0 && this.setRotation(Ue, V), V;
+                                        rotation: Ut
+                                    } = c;
+                                    return !c.hasOwnCanvas && Ut !== 0 && this.setRotation(Ut, K), K;
                                 }
                                 const {
-                                    width: Re,
-                                    height: qe
-                                } = S(u.rect), Ie = n.Util.normalizeRect([u.rect[0], L.view[3] - u.rect[1] + L.view[1], u.rect[2], L.view[3] - u.rect[3] + L.view[1]]);
-                                if (!U && u.borderStyle.width > 0) {
-                                    V.style.borderWidth = `${u.borderStyle.width}px`;
-                                    const Ue = u.borderStyle.horizontalCornerRadius,
-                                        Ve = u.borderStyle.verticalCornerRadius;
-                                    if (Ue > 0 || Ve > 0) {
-                                        const Qe = `calc(${Ue}px * var(--scale-factor)) / calc(${Ve}px * var(--scale-factor))`;
-                                        V.style.borderRadius = Qe;
-                                    } else if (this instanceof p) {
-                                        const Qe = `calc(${Re}px * var(--scale-factor)) / calc(${qe}px * var(--scale-factor))`;
-                                        V.style.borderRadius = Qe;
-                                    }
-                                    switch (u.borderStyle.style) {
-                                        case n.AnnotationBorderStyleType.SOLID:
-                                            V.style.borderStyle = "solid";
-                                            break;
-                                        case n.AnnotationBorderStyleType.DASHED:
-                                            V.style.borderStyle = "dashed";
-                                            break;
-                                        case n.AnnotationBorderStyleType.BEVELED:
-                                            (0, n.warn)("Unimplemented border style: beveled");
-                                            break;
-                                        case n.AnnotationBorderStyleType.INSET:
-                                            (0, n.warn)("Unimplemented border style: inset");
+                                    width: Ft,
+                                    height: Ht
+                                } = R(c.rect), xt = e.Util.normalizeRect([c.rect[0], L.view[3] - c.rect[1] + L.view[1], c.rect[2], L.view[3] - c.rect[3] + L.view[1]]);
+                                if (!j && c.borderStyle.width > 0) {
+                                    K.style.borderWidth = `${c.borderStyle.width}px`;
+                                    const Ut = c.borderStyle.horizontalCornerRadius,
+                                        Xt = c.borderStyle.verticalCornerRadius;
+                                    if (Ut > 0 || Xt > 0) {
+                                        const Zt = `calc(${Ut}px * var(--scale-factor)) / calc(${Xt}px * var(--scale-factor))`;
+                                        K.style.borderRadius = Zt;
+                                    } else if (this instanceof g) {
+                                        const Zt = `calc(${Ft}px * var(--scale-factor)) / calc(${Ht}px * var(--scale-factor))`;
+                                        K.style.borderRadius = Zt;
+                                    }
+                                    switch (c.borderStyle.style) {
+                                        case e.AnnotationBorderStyleType.SOLID:
+                                            K.style.borderStyle = "solid";
+                                            break;
+                                        case e.AnnotationBorderStyleType.DASHED:
+                                            K.style.borderStyle = "dashed";
+                                            break;
+                                        case e.AnnotationBorderStyleType.BEVELED:
+                                            (0, e.warn)("Unimplemented border style: beveled");
+                                            break;
+                                        case e.AnnotationBorderStyleType.INSET:
+                                            (0, e.warn)("Unimplemented border style: inset");
                                             break;
-                                        case n.AnnotationBorderStyleType.UNDERLINE:
-                                            V.style.borderBottomStyle = "solid";
+                                        case e.AnnotationBorderStyleType.UNDERLINE:
+                                            K.style.borderBottomStyle = "solid";
                                             break;
                                     }
-                                    const Je = u.borderColor || null;
-                                    Je ? (oe(this, g, !0), V.style.borderColor = n.Util.makeHexColor(Je[0] | 0, Je[1] | 0, Je[2] | 0)) : V.style.borderWidth = 0;
+                                    const Kt = c.borderColor || null;
+                                    Kt ? (ot(this, u, !0), K.style.borderColor = e.Util.makeHexColor(Kt[0] | 0, Kt[1] | 0, Kt[2] | 0)) : K.style.borderWidth = 0;
                                 }
-                                V.style.left = `${100 * (Ie[0] - ye) / Q}%`, V.style.top = `${100 * (Ie[1] - Me) / he}%`;
+                                K.style.left = `${100 * (xt[0] - bt) / tt}%`, K.style.top = `${100 * (xt[1] - Mt) / ct}%`;
                                 const {
-                                    rotation: Le
-                                } = u;
-                                return u.hasOwnCanvas || Le === 0 ? (V.style.width = `${100 * Re / Q}%`, V.style.height = `${100 * qe / he}%`) : this.setRotation(Le, V), V;
+                                    rotation: Dt
+                                } = c;
+                                return c.hasOwnCanvas || Dt === 0 ? (K.style.width = `${100 * Ft / tt}%`, K.style.height = `${100 * Ht / ct}%`) : this.setRotation(Dt, K), K;
                             }
-                            setRotation(U, u = this.container) {
+                            setRotation(j, c = this.container) {
                                 if (!this.data.rect)
                                     return;
                                 const {
                                     pageWidth: L,
-                                    pageHeight: j
+                                    pageHeight: q
                                 } = this.parent.viewport.rawDims, {
-                                    width: V,
-                                    height: Q
-                                } = S(this.data.rect);
-                                let he, ye;
-                                U % 180 === 0 ? (he = 100 * V / L, ye = 100 * Q / j) : (he = 100 * Q / L, ye = 100 * V / j), u.style.width = `${he}%`, u.style.height = `${ye}%`, u.setAttribute("data-main-rotation", (360 - U) % 360);
+                                    width: K,
+                                    height: tt
+                                } = R(this.data.rect);
+                                let ct, bt;
+                                j % 180 === 0 ? (ct = 100 * K / L, bt = 100 * tt / q) : (ct = 100 * tt / L, bt = 100 * K / q), c.style.width = `${ct}%`, c.style.height = `${bt}%`, c.setAttribute("data-main-rotation", (360 - j) % 360);
                             }
                             get _commonActions() {
-                                const U = (u, L, j) => {
-                                    const V = j.detail[u],
-                                        Q = V[0],
-                                        he = V.slice(1);
-                                    j.target.style[L] = h.ColorConverters[`${Q}_HTML`](he), this.annotationStorage.setValue(this.data.id, {
-                                        [L]: h.ColorConverters[`${Q}_rgb`](he)
+                                const j = (c, L, q) => {
+                                    const K = q.detail[c],
+                                        tt = K[0],
+                                        ct = K.slice(1);
+                                    q.target.style[L] = f.ColorConverters[`${tt}_HTML`](ct), this.annotationStorage.setValue(this.data.id, {
+                                        [L]: f.ColorConverters[`${tt}_rgb`](ct)
                                     });
                                 };
-                                return (0, n.shadow)(this, "_commonActions", {
-                                    display: (u) => {
+                                return (0, e.shadow)(this, "_commonActions", {
+                                    display: (c) => {
                                         const {
                                             display: L
-                                        } = u.detail, j = L % 2 === 1;
-                                        this.container.style.visibility = j ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
-                                            noView: j,
+                                        } = c.detail, q = L % 2 === 1;
+                                        this.container.style.visibility = q ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
+                                            noView: q,
                                             noPrint: L === 1 || L === 2
                                         });
                                     },
-                                    print: (u) => {
+                                    print: (c) => {
                                         this.annotationStorage.setValue(this.data.id, {
-                                            noPrint: !u.detail.print
+                                            noPrint: !c.detail.print
                                         });
                                     },
-                                    hidden: (u) => {
+                                    hidden: (c) => {
                                         const {
                                             hidden: L
-                                        } = u.detail;
+                                        } = c.detail;
                                         this.container.style.visibility = L ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                                             noPrint: L,
                                             noView: L
                                         });
                                     },
-                                    focus: (u) => {
-                                        setTimeout(() => u.target.focus({
+                                    focus: (c) => {
+                                        setTimeout(() => c.target.focus({
                                             preventScroll: !1
                                         }), 0);
                                     },
-                                    userName: (u) => {
-                                        u.target.title = u.detail.userName;
+                                    userName: (c) => {
+                                        c.target.title = c.detail.userName;
                                     },
-                                    readonly: (u) => {
-                                        u.target.disabled = u.detail.readonly;
+                                    readonly: (c) => {
+                                        c.target.disabled = c.detail.readonly;
                                     },
-                                    required: (u) => {
-                                        this._setRequired(u.target, u.detail.required);
+                                    required: (c) => {
+                                        this._setRequired(c.target, c.detail.required);
                                     },
-                                    bgColor: (u) => {
-                                        U("bgColor", "backgroundColor", u);
+                                    bgColor: (c) => {
+                                        j("bgColor", "backgroundColor", c);
                                     },
-                                    fillColor: (u) => {
-                                        U("fillColor", "backgroundColor", u);
+                                    fillColor: (c) => {
+                                        j("fillColor", "backgroundColor", c);
                                     },
-                                    fgColor: (u) => {
-                                        U("fgColor", "color", u);
+                                    fgColor: (c) => {
+                                        j("fgColor", "color", c);
                                     },
-                                    textColor: (u) => {
-                                        U("textColor", "color", u);
+                                    textColor: (c) => {
+                                        j("textColor", "color", c);
                                     },
-                                    borderColor: (u) => {
-                                        U("borderColor", "borderColor", u);
+                                    borderColor: (c) => {
+                                        j("borderColor", "borderColor", c);
                                     },
-                                    strokeColor: (u) => {
-                                        U("strokeColor", "borderColor", u);
+                                    strokeColor: (c) => {
+                                        j("strokeColor", "borderColor", c);
                                     },
-                                    rotation: (u) => {
-                                        const L = u.detail.rotation;
+                                    rotation: (c) => {
+                                        const L = c.detail.rotation;
                                         this.setRotation(L), this.annotationStorage.setValue(this.data.id, {
                                             rotation: L
                                         });
                                     }
                                 });
                             }
-                            _dispatchEventFromSandbox(U, u) {
+                            _dispatchEventFromSandbox(j, c) {
                                 const L = this._commonActions;
-                                for (const j of Object.keys(u.detail)) {
-                                    const V = U[j] || L[j];
-                                    V == null || V(u);
+                                for (const q of Object.keys(c.detail)) {
+                                    const K = j[q] || L[q];
+                                    K == null || K(c);
                                 }
                             }
-                            _setDefaultPropertiesFromJS(U) {
+                            _setDefaultPropertiesFromJS(j) {
                                 if (!this.enableScripting)
                                     return;
-                                const u = this.annotationStorage.getRawValue(this.data.id);
-                                if (!u)
+                                const c = this.annotationStorage.getRawValue(this.data.id);
+                                if (!c)
                                     return;
                                 const L = this._commonActions;
-                                for (const [j, V] of Object.entries(u)) {
-                                    const Q = L[j];
-                                    if (Q) {
-                                        const he = {
+                                for (const [q, K] of Object.entries(c)) {
+                                    const tt = L[q];
+                                    if (tt) {
+                                        const ct = {
                                             detail: {
-                                                [j]: V
+                                                [q]: K
                                             },
-                                            target: U
+                                            target: j
                                         };
-                                        Q(he), delete u[j];
+                                        tt(ct), delete c[q];
                                     }
                                 }
                             }
                             _createQuadrilaterals() {
                                 if (!this.container)
                                     return;
                                 const {
-                                    quadPoints: U
+                                    quadPoints: j
                                 } = this.data;
-                                if (!U)
+                                if (!j)
                                     return;
-                                const [u, L, j, V] = this.data.rect;
-                                if (U.length === 1) {
+                                const [c, L, q, K] = this.data.rect;
+                                if (j.length === 1) {
                                     const [, {
-                                        x: Ve,
-                                        y: Je
+                                        x: Xt,
+                                        y: Kt
                                     }, {
-                                        x: Qe,
-                                        y: st
-                                    }] = U[0];
-                                    if (j === Ve && V === Je && u === Qe && L === st)
+                                        x: Zt,
+                                        y: ie
+                                    }] = j[0];
+                                    if (q === Xt && K === Kt && c === Zt && L === ie)
                                         return;
                                 }
                                 const {
-                                    style: Q
+                                    style: tt
                                 } = this.container;
-                                let he;
-                                if (a(this, g)) {
+                                let ct;
+                                if (r(this, u)) {
                                     const {
-                                        borderColor: Ve,
-                                        borderWidth: Je
-                                    } = Q;
-                                    Q.borderWidth = 0, he = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${Ve}" stroke-width="${Je}">`], this.container.classList.add("hasBorder");
+                                        borderColor: Xt,
+                                        borderWidth: Kt
+                                    } = tt;
+                                    tt.borderWidth = 0, ct = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${Xt}" stroke-width="${Kt}">`], this.container.classList.add("hasBorder");
                                 }
-                                const ye = j - u,
-                                    Me = V - L,
+                                const bt = q - c,
+                                    Mt = K - L,
                                     {
-                                        svgFactory: Re
+                                        svgFactory: Ft
                                     } = this,
-                                    qe = Re.createElement("svg");
-                                qe.classList.add("quadrilateralsContainer"), qe.setAttribute("width", 0), qe.setAttribute("height", 0);
-                                const Ie = Re.createElement("defs");
-                                qe.append(Ie);
-                                const Le = Re.createElement("clipPath"),
-                                    Ue = `clippath_${this.data.id}`;
-                                Le.setAttribute("id", Ue), Le.setAttribute("clipPathUnits", "objectBoundingBox"), Ie.append(Le);
+                                    Ht = Ft.createElement("svg");
+                                Ht.classList.add("quadrilateralsContainer"), Ht.setAttribute("width", 0), Ht.setAttribute("height", 0);
+                                const xt = Ft.createElement("defs");
+                                Ht.append(xt);
+                                const Dt = Ft.createElement("clipPath"),
+                                    Ut = `clippath_${this.data.id}`;
+                                Dt.setAttribute("id", Ut), Dt.setAttribute("clipPathUnits", "objectBoundingBox"), xt.append(Dt);
                                 for (const [, {
-                                        x: Ve,
-                                        y: Je
+                                        x: Xt,
+                                        y: Kt
                                     }, {
-                                        x: Qe,
-                                        y: st
-                                    }] of U) {
-                                    const it = Re.createElement("rect"),
-                                        rt = (Qe - u) / ye,
-                                        lt = (V - Je) / Me,
-                                        ct = (Ve - Qe) / ye,
-                                        An = (Je - st) / Me;
-                                    it.setAttribute("x", rt), it.setAttribute("y", lt), it.setAttribute("width", ct), it.setAttribute("height", An), Le.append(it), he == null || he.push(`<rect vector-effect="non-scaling-stroke" x="${rt}" y="${lt}" width="${ct}" height="${An}"/>`);
+                                        x: Zt,
+                                        y: ie
+                                    }] of j) {
+                                    const ne = Ft.createElement("rect"),
+                                        se = (Zt - c) / bt,
+                                        oe = (K - Kt) / Mt,
+                                        le = (Xt - Zt) / bt,
+                                        An = (Kt - ie) / Mt;
+                                    ne.setAttribute("x", se), ne.setAttribute("y", oe), ne.setAttribute("width", le), ne.setAttribute("height", An), Dt.append(ne), ct == null || ct.push(`<rect vector-effect="non-scaling-stroke" x="${se}" y="${oe}" width="${le}" height="${An}"/>`);
                                 }
-                                a(this, g) && (he.push("</g></svg>')"), Q.backgroundImage = he.join("")), this.container.append(qe), this.container.style.clipPath = `url(#${Ue})`;
+                                r(this, u) && (ct.push("</g></svg>')"), tt.backgroundImage = ct.join("")), this.container.append(Ht), this.container.style.clipPath = `url(#${Ut})`;
                             }
                             _createPopup() {
                                 const {
-                                    container: U,
-                                    data: u
+                                    container: j,
+                                    data: c
                                 } = this;
-                                U.setAttribute("aria-haspopup", "dialog");
+                                j.setAttribute("aria-haspopup", "dialog");
                                 const L = new M({
                                     data: {
-                                        color: u.color,
-                                        titleObj: u.titleObj,
-                                        modificationDate: u.modificationDate,
-                                        contentsObj: u.contentsObj,
-                                        richText: u.richText,
-                                        parentRect: u.rect,
+                                        color: c.color,
+                                        titleObj: c.titleObj,
+                                        modificationDate: c.modificationDate,
+                                        contentsObj: c.contentsObj,
+                                        richText: c.richText,
+                                        parentRect: c.rect,
                                         borderStyle: 0,
-                                        id: `popup_${u.id}`,
-                                        rotation: u.rotation
+                                        id: `popup_${c.id}`,
+                                        rotation: c.rotation
                                     },
                                     parent: this.parent,
                                     elements: [this]
                                 });
                                 this.parent.div.append(L.render());
                             }
                             render() {
-                                (0, n.unreachable)("Abstract method `AnnotationElement.render` called");
+                                (0, e.unreachable)("Abstract method `AnnotationElement.render` called");
                             }
-                            _getElementsByName(U, u = null) {
+                            _getElementsByName(j, c = null) {
                                 const L = [];
                                 if (this._fieldObjects) {
-                                    const j = this._fieldObjects[U];
-                                    if (j)
+                                    const q = this._fieldObjects[j];
+                                    if (q)
                                         for (const {
-                                                page: V,
-                                                id: Q,
-                                                exportValues: he
+                                                page: K,
+                                                id: tt,
+                                                exportValues: ct
                                             }
-                                            of j) {
-                                            if (V === -1 || Q === u)
+                                            of q) {
+                                            if (K === -1 || tt === c)
                                                 continue;
-                                            const ye = typeof he == "string" ? he : null,
-                                                Me = document.querySelector(`[data-element-id="${Q}"]`);
-                                            if (Me && !T.has(Me)) {
-                                                (0, n.warn)(`_getElementsByName - element not allowed: ${Q}`);
+                                            const bt = typeof ct == "string" ? ct : null,
+                                                Mt = document.querySelector(`[data-element-id="${tt}"]`);
+                                            if (Mt && !F.has(Mt)) {
+                                                (0, e.warn)(`_getElementsByName - element not allowed: ${tt}`);
                                                 continue;
                                             }
                                             L.push({
-                                                id: Q,
-                                                exportValue: ye,
-                                                domElement: Me
+                                                id: tt,
+                                                exportValue: bt,
+                                                domElement: Mt
                                             });
                                         }
                                     return L;
                                 }
-                                for (const j of document.getElementsByName(U)) {
+                                for (const q of document.getElementsByName(j)) {
                                     const {
-                                        exportValue: V
-                                    } = j, Q = j.getAttribute("data-element-id");
-                                    Q !== u && T.has(j) && L.push({
-                                        id: Q,
-                                        exportValue: V,
-                                        domElement: j
+                                        exportValue: K
+                                    } = q, tt = q.getAttribute("data-element-id");
+                                    tt !== c && F.has(q) && L.push({
+                                        id: tt,
+                                        exportValue: K,
+                                        domElement: q
                                     });
                                 }
                                 return L;
                             }
                             show() {
-                                var U;
-                                this.container && (this.container.hidden = !1), (U = this.popup) == null || U.maybeShow();
+                                var j;
+                                this.container && (this.container.hidden = !1), (j = this.popup) == null || j.maybeShow();
                             }
                             hide() {
-                                var U;
-                                this.container && (this.container.hidden = !0), (U = this.popup) == null || U.forceHide();
+                                var j;
+                                this.container && (this.container.hidden = !0), (j = this.popup) == null || j.forceHide();
                             }
                             getElementsToTriggerPopup() {
                                 return this.container;
                             }
                             addHighlightArea() {
-                                const U = this.getElementsToTriggerPopup();
-                                if (Array.isArray(U))
-                                    for (const u of U)
-                                        u.classList.add("highlightArea");
+                                const j = this.getElementsToTriggerPopup();
+                                if (Array.isArray(j))
+                                    for (const c of j)
+                                        c.classList.add("highlightArea");
                                 else
-                                    U.classList.add("highlightArea");
+                                    j.classList.add("highlightArea");
                             }
                             _editOnDoubleClick() {
                                 const {
-                                    annotationEditorType: U,
+                                    annotationEditorType: j,
                                     data: {
-                                        id: u
+                                        id: c
                                     }
                                 } = this;
                                 this.container.addEventListener("dblclick", () => {
                                     var L;
                                     (L = this.linkService.eventBus) == null || L.dispatch("switchannotationeditormode", {
                                         source: this,
-                                        mode: U,
-                                        editId: u
+                                        mode: j,
+                                        editId: c
                                     });
                                 });
                             }
                         };
-                        g = new WeakMap();
-                        let C = f;
-                        class P extends C {
-                            constructor(u, L = null) {
-                                super(u, {
+                        u = new WeakMap();
+                        let T = d;
+                        class P extends T {
+                            constructor(c, L = null) {
+                                super(c, {
                                     isRenderable: !0,
                                     ignoreBorder: !!(L != null && L.ignoreBorder),
                                     createQuadrilaterals: !0
                                 });
-                                W(this, v);
+                                W(this, b);
                                 W(this, O);
-                                this.isTooltipOnly = u.data.isTooltipOnly;
+                                this.isTooltipOnly = c.data.isTooltipOnly;
                             }
                             render() {
                                 const {
-                                    data: u,
+                                    data: c,
                                     linkService: L
-                                } = this, j = document.createElement("a");
-                                j.setAttribute("data-element-id", u.id);
-                                let V = !1;
-                                return u.url ? (L.addLinkAttributes(j, u.url, u.newWindow), V = !0) : u.action ? (this._bindNamedAction(j, u.action), V = !0) : u.attachment ? (this._bindAttachment(j, u.attachment), V = !0) : u.setOCGState ? (K(this, O, Nn).call(this, j, u.setOCGState), V = !0) : u.dest ? (this._bindLink(j, u.dest), V = !0) : (u.actions && (u.actions.Action || u.actions["Mouse Up"] || u.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(j, u), V = !0), u.resetForm ? (this._bindResetFormAction(j, u.resetForm), V = !0) : this.isTooltipOnly && !V && (this._bindLink(j, ""), V = !0)), this.container.classList.add("linkAnnotation"), V && this.container.append(j), this.container;
-                            }
-                            _bindLink(u, L) {
-                                u.href = this.linkService.getDestinationHash(L), u.onclick = () => (L && this.linkService.goToDestination(L), !1), (L || L === "") && K(this, v, ht).call(this);
-                            }
-                            _bindNamedAction(u, L) {
-                                u.href = this.linkService.getAnchorUrl(""), u.onclick = () => (this.linkService.executeNamedAction(L), !1), K(this, v, ht).call(this);
-                            }
-                            _bindAttachment(u, L) {
-                                u.href = this.linkService.getAnchorUrl(""), u.onclick = () => {
-                                    var j;
-                                    return (j = this.downloadManager) == null || j.openOrDownloadData(this.container, L.content, L.filename), !1;
-                                }, K(this, v, ht).call(this);
-                            }
-                            _bindJSAction(u, L) {
-                                u.href = this.linkService.getAnchorUrl("");
-                                const j = /* @__PURE__ */ new Map([
+                                } = this, q = document.createElement("a");
+                                q.setAttribute("data-element-id", c.id);
+                                let K = !1;
+                                return c.url ? (L.addLinkAttributes(q, c.url, c.newWindow), K = !0) : c.action ? (this._bindNamedAction(q, c.action), K = !0) : c.attachment ? (this._bindAttachment(q, c.attachment), K = !0) : c.setOCGState ? (J(this, O, On).call(this, q, c.setOCGState), K = !0) : c.dest ? (this._bindLink(q, c.dest), K = !0) : (c.actions && (c.actions.Action || c.actions["Mouse Up"] || c.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(q, c), K = !0), c.resetForm ? (this._bindResetFormAction(q, c.resetForm), K = !0) : this.isTooltipOnly && !K && (this._bindLink(q, ""), K = !0)), this.container.classList.add("linkAnnotation"), K && this.container.append(q), this.container;
+                            }
+                            _bindLink(c, L) {
+                                c.href = this.linkService.getDestinationHash(L), c.onclick = () => (L && this.linkService.goToDestination(L), !1), (L || L === "") && J(this, b, ce).call(this);
+                            }
+                            _bindNamedAction(c, L) {
+                                c.href = this.linkService.getAnchorUrl(""), c.onclick = () => (this.linkService.executeNamedAction(L), !1), J(this, b, ce).call(this);
+                            }
+                            _bindAttachment(c, L) {
+                                c.href = this.linkService.getAnchorUrl(""), c.onclick = () => {
+                                    var q;
+                                    return (q = this.downloadManager) == null || q.openOrDownloadData(this.container, L.content, L.filename), !1;
+                                }, J(this, b, ce).call(this);
+                            }
+                            _bindJSAction(c, L) {
+                                c.href = this.linkService.getAnchorUrl("");
+                                const q = /* @__PURE__ */ new Map([
                                     ["Action", "onclick"],
                                     ["Mouse Up", "onmouseup"],
                                     ["Mouse Down", "onmousedown"]
                                 ]);
-                                for (const V of Object.keys(L.actions)) {
-                                    const Q = j.get(V);
-                                    Q && (u[Q] = () => {
-                                        var he;
-                                        return (he = this.linkService.eventBus) == null || he.dispatch("dispatcheventinsandbox", {
+                                for (const K of Object.keys(L.actions)) {
+                                    const tt = q.get(K);
+                                    tt && (c[tt] = () => {
+                                        var ct;
+                                        return (ct = this.linkService.eventBus) == null || ct.dispatch("dispatcheventinsandbox", {
                                             source: this,
                                             detail: {
                                                 id: L.id,
-                                                name: V
+                                                name: K
                                             }
                                         }), !1;
                                     });
                                 }
-                                u.onclick || (u.onclick = () => !1), K(this, v, ht).call(this);
+                                c.onclick || (c.onclick = () => !1), J(this, b, ce).call(this);
                             }
-                            _bindResetFormAction(u, L) {
-                                const j = u.onclick;
-                                if (j || (u.href = this.linkService.getAnchorUrl("")), K(this, v, ht).call(this), !this._fieldObjects) {
-                                    (0, n.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), j || (u.onclick = () => !1);
+                            _bindResetFormAction(c, L) {
+                                const q = c.onclick;
+                                if (q || (c.href = this.linkService.getAnchorUrl("")), J(this, b, ce).call(this), !this._fieldObjects) {
+                                    (0, e.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), q || (c.onclick = () => !1);
                                     return;
                                 }
-                                u.onclick = () => {
-                                    var qe;
-                                    j == null || j();
+                                c.onclick = () => {
+                                    var Ht;
+                                    q == null || q();
                                     const {
-                                        fields: V,
-                                        refs: Q,
-                                        include: he
-                                    } = L, ye = [];
-                                    if (V.length !== 0 || Q.length !== 0) {
-                                        const Ie = new Set(Q);
-                                        for (const Le of V) {
-                                            const Ue = this._fieldObjects[Le] || [];
+                                        fields: K,
+                                        refs: tt,
+                                        include: ct
+                                    } = L, bt = [];
+                                    if (K.length !== 0 || tt.length !== 0) {
+                                        const xt = new Set(tt);
+                                        for (const Dt of K) {
+                                            const Ut = this._fieldObjects[Dt] || [];
                                             for (const {
-                                                    id: Ve
+                                                    id: Xt
                                                 }
-                                                of Ue)
-                                                Ie.add(Ve);
+                                                of Ut)
+                                                xt.add(Xt);
                                         }
-                                        for (const Le of Object.values(this._fieldObjects))
-                                            for (const Ue of Le)
-                                                Ie.has(Ue.id) === he && ye.push(Ue);
+                                        for (const Dt of Object.values(this._fieldObjects))
+                                            for (const Ut of Dt)
+                                                xt.has(Ut.id) === ct && bt.push(Ut);
                                     } else
-                                        for (const Ie of Object.values(this._fieldObjects))
-                                            ye.push(...Ie);
-                                    const Me = this.annotationStorage,
-                                        Re = [];
-                                    for (const Ie of ye) {
+                                        for (const xt of Object.values(this._fieldObjects))
+                                            bt.push(...xt);
+                                    const Mt = this.annotationStorage,
+                                        Ft = [];
+                                    for (const xt of bt) {
                                         const {
-                                            id: Le
-                                        } = Ie;
-                                        switch (Re.push(Le), Ie.type) {
+                                            id: Dt
+                                        } = xt;
+                                        switch (Ft.push(Dt), xt.type) {
                                             case "text": {
-                                                const Ve = Ie.defaultValue || "";
-                                                Me.setValue(Le, {
-                                                    value: Ve
+                                                const Xt = xt.defaultValue || "";
+                                                Mt.setValue(Dt, {
+                                                    value: Xt
                                                 });
                                                 break;
                                             }
                                             case "checkbox":
                                             case "radiobutton": {
-                                                const Ve = Ie.defaultValue === Ie.exportValues;
-                                                Me.setValue(Le, {
-                                                    value: Ve
+                                                const Xt = xt.defaultValue === xt.exportValues;
+                                                Mt.setValue(Dt, {
+                                                    value: Xt
                                                 });
                                                 break;
                                             }
                                             case "combobox":
                                             case "listbox": {
-                                                const Ve = Ie.defaultValue || "";
-                                                Me.setValue(Le, {
-                                                    value: Ve
+                                                const Xt = xt.defaultValue || "";
+                                                Mt.setValue(Dt, {
+                                                    value: Xt
                                                 });
                                                 break;
                                             }
                                             default:
                                                 continue;
                                         }
-                                        const Ue = document.querySelector(`[data-element-id="${Le}"]`);
-                                        if (Ue) {
-                                            if (!T.has(Ue)) {
-                                                (0, n.warn)(`_bindResetFormAction - element not allowed: ${Le}`);
+                                        const Ut = document.querySelector(`[data-element-id="${Dt}"]`);
+                                        if (Ut) {
+                                            if (!F.has(Ut)) {
+                                                (0, e.warn)(`_bindResetFormAction - element not allowed: ${Dt}`);
                                                 continue;
                                             }
                                         } else
                                             continue;
-                                        Ue.dispatchEvent(new Event("resetform"));
+                                        Ut.dispatchEvent(new Event("resetform"));
                                     }
-                                    return this.enableScripting && ((qe = this.linkService.eventBus) == null || qe.dispatch("dispatcheventinsandbox", {
+                                    return this.enableScripting && ((Ht = this.linkService.eventBus) == null || Ht.dispatch("dispatcheventinsandbox", {
                                         source: this,
                                         detail: {
                                             id: "app",
-                                            ids: Re,
+                                            ids: Ft,
                                             name: "ResetForm"
                                         }
                                     })), !1;
                                 };
                             }
                         }
-                        v = new WeakSet(), ht = function() {
+                        b = new WeakSet(), ce = function() {
                             this.container.setAttribute("data-internal-link", "");
-                        }, O = new WeakSet(), Nn = function(u, L) {
-                            u.href = this.linkService.getAnchorUrl(""), u.onclick = () => (this.linkService.executeSetOCGState(L), !1), K(this, v, ht).call(this);
+                        }, O = new WeakSet(), On = function(c, L) {
+                            c.href = this.linkService.getAnchorUrl(""), c.onclick = () => (this.linkService.executeSetOCGState(L), !1), J(this, b, ce).call(this);
                         };
-                        class b extends C {
-                            constructor(U) {
-                                super(U, {
+                        class m extends T {
+                            constructor(j) {
+                                super(j, {
                                     isRenderable: !0
                                 });
                             }
                             render() {
                                 this.container.classList.add("textAnnotation");
-                                const U = document.createElement("img");
-                                return U.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", U.alt = "[{{type}} Annotation]", U.dataset.l10nId = "text_annotation_type", U.dataset.l10nArgs = JSON.stringify({
+                                const j = document.createElement("img");
+                                return j.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", j.alt = "[{{type}} Annotation]", j.dataset.l10nId = "text_annotation_type", j.dataset.l10nArgs = JSON.stringify({
                                     type: this.data.name
-                                }), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(U), this.container;
+                                }), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(j), this.container;
                             }
                         }
-                        class k extends C {
+                        class C extends T {
                             render() {
                                 return this.data.alternativeText && (this.container.title = this.data.alternativeText), this.container;
                             }
-                            showElementAndHideCanvas(U) {
-                                var u;
-                                this.data.hasOwnCanvas && (((u = U.previousSibling) == null ? void 0 : u.nodeName) === "CANVAS" && (U.previousSibling.hidden = !0), U.hidden = !1);
+                            showElementAndHideCanvas(j) {
+                                var c;
+                                this.data.hasOwnCanvas && (((c = j.previousSibling) == null ? void 0 : c.nodeName) === "CANVAS" && (j.previousSibling.hidden = !0), j.hidden = !1);
                             }
-                            _getKeyModifier(U) {
+                            _getKeyModifier(j) {
                                 const {
-                                    isWin: u,
+                                    isWin: c,
                                     isMac: L
-                                } = n.FeatureTest.platform;
-                                return u && U.ctrlKey || L && U.metaKey;
+                                } = e.FeatureTest.platform;
+                                return c && j.ctrlKey || L && j.metaKey;
                             }
-                            _setEventListener(U, u, L, j, V) {
-                                L.includes("mouse") ? U.addEventListener(L, (Q) => {
-                                    var he;
-                                    (he = this.linkService.eventBus) == null || he.dispatch("dispatcheventinsandbox", {
+                            _setEventListener(j, c, L, q, K) {
+                                L.includes("mouse") ? j.addEventListener(L, (tt) => {
+                                    var ct;
+                                    (ct = this.linkService.eventBus) == null || ct.dispatch("dispatcheventinsandbox", {
                                         source: this,
                                         detail: {
                                             id: this.data.id,
-                                            name: j,
-                                            value: V(Q),
-                                            shift: Q.shiftKey,
-                                            modifier: this._getKeyModifier(Q)
+                                            name: q,
+                                            value: K(tt),
+                                            shift: tt.shiftKey,
+                                            modifier: this._getKeyModifier(tt)
                                         }
                                     });
-                                }) : U.addEventListener(L, (Q) => {
-                                    var he;
+                                }) : j.addEventListener(L, (tt) => {
+                                    var ct;
                                     if (L === "blur") {
-                                        if (!u.focused || !Q.relatedTarget)
+                                        if (!c.focused || !tt.relatedTarget)
                                             return;
-                                        u.focused = !1;
+                                        c.focused = !1;
                                     } else if (L === "focus") {
-                                        if (u.focused)
+                                        if (c.focused)
                                             return;
-                                        u.focused = !0;
+                                        c.focused = !0;
                                     }
-                                    V && ((he = this.linkService.eventBus) == null || he.dispatch("dispatcheventinsandbox", {
+                                    K && ((ct = this.linkService.eventBus) == null || ct.dispatch("dispatcheventinsandbox", {
                                         source: this,
                                         detail: {
                                             id: this.data.id,
-                                            name: j,
-                                            value: V(Q)
+                                            name: q,
+                                            value: K(tt)
                                         }
                                     }));
                                 });
                             }
-                            _setEventListeners(U, u, L, j) {
-                                var V, Q, he;
-                                for (const [ye, Me] of L)
-                                    (Me === "Action" || (V = this.data.actions) != null && V[Me]) && ((Me === "Focus" || Me === "Blur") && (u || (u = {
+                            _setEventListeners(j, c, L, q) {
+                                var K, tt, ct;
+                                for (const [bt, Mt] of L)
+                                    (Mt === "Action" || (K = this.data.actions) != null && K[Mt]) && ((Mt === "Focus" || Mt === "Blur") && (c || (c = {
                                         focused: !1
-                                    })), this._setEventListener(U, u, ye, Me, j), Me === "Focus" && !((Q = this.data.actions) != null && Q.Blur) ? this._setEventListener(U, u, "blur", "Blur", null) : Me === "Blur" && !((he = this.data.actions) != null && he.Focus) && this._setEventListener(U, u, "focus", "Focus", null));
+                                    })), this._setEventListener(j, c, bt, Mt, q), Mt === "Focus" && !((tt = this.data.actions) != null && tt.Blur) ? this._setEventListener(j, c, "blur", "Blur", null) : Mt === "Blur" && !((ct = this.data.actions) != null && ct.Focus) && this._setEventListener(j, c, "focus", "Focus", null));
                             }
-                            _setBackgroundColor(U) {
-                                const u = this.data.backgroundColor || null;
-                                U.style.backgroundColor = u === null ? "transparent" : n.Util.makeHexColor(u[0], u[1], u[2]);
+                            _setBackgroundColor(j) {
+                                const c = this.data.backgroundColor || null;
+                                j.style.backgroundColor = c === null ? "transparent" : e.Util.makeHexColor(c[0], c[1], c[2]);
                             }
-                            _setTextStyle(U) {
-                                const u = ["left", "center", "right"],
+                            _setTextStyle(j) {
+                                const c = ["left", "center", "right"],
                                     {
                                         fontColor: L
                                     } = this.data.defaultAppearanceData,
-                                    j = this.data.defaultAppearanceData.fontSize || r,
-                                    V = U.style;
-                                let Q;
-                                const he = 2,
-                                    ye = (Me) => Math.round(10 * Me) / 10;
+                                    q = this.data.defaultAppearanceData.fontSize || o,
+                                    K = j.style;
+                                let tt;
+                                const ct = 2,
+                                    bt = (Mt) => Math.round(10 * Mt) / 10;
                                 if (this.data.multiLine) {
-                                    const Me = Math.abs(this.data.rect[3] - this.data.rect[1] - he),
-                                        Re = Math.round(Me / (n.LINE_FACTOR * j)) || 1,
-                                        qe = Me / Re;
-                                    Q = Math.min(j, ye(qe / n.LINE_FACTOR));
+                                    const Mt = Math.abs(this.data.rect[3] - this.data.rect[1] - ct),
+                                        Ft = Math.round(Mt / (e.LINE_FACTOR * q)) || 1,
+                                        Ht = Mt / Ft;
+                                    tt = Math.min(q, bt(Ht / e.LINE_FACTOR));
                                 } else {
-                                    const Me = Math.abs(this.data.rect[3] - this.data.rect[1] - he);
-                                    Q = Math.min(j, ye(Me / n.LINE_FACTOR));
+                                    const Mt = Math.abs(this.data.rect[3] - this.data.rect[1] - ct);
+                                    tt = Math.min(q, bt(Mt / e.LINE_FACTOR));
                                 }
-                                V.fontSize = `calc(${Q}px * var(--scale-factor))`, V.color = n.Util.makeHexColor(L[0], L[1], L[2]), this.data.textAlignment !== null && (V.textAlign = u[this.data.textAlignment]);
+                                K.fontSize = `calc(${tt}px * var(--scale-factor))`, K.color = e.Util.makeHexColor(L[0], L[1], L[2]), this.data.textAlignment !== null && (K.textAlign = c[this.data.textAlignment]);
                             }
-                            _setRequired(U, u) {
-                                u ? U.setAttribute("required", !0) : U.removeAttribute("required"), U.setAttribute("aria-required", u);
+                            _setRequired(j, c) {
+                                c ? j.setAttribute("required", !0) : j.removeAttribute("required"), j.setAttribute("aria-required", c);
                             }
                         }
-                        class F extends k {
-                            constructor(U) {
-                                const u = U.renderForms || !U.data.hasAppearance && !!U.data.fieldValue;
-                                super(U, {
-                                    isRenderable: u
+                        class x extends C {
+                            constructor(j) {
+                                const c = j.renderForms || !j.data.hasAppearance && !!j.data.fieldValue;
+                                super(j, {
+                                    isRenderable: c
                                 });
                             }
-                            setPropertyOnSiblings(U, u, L, j) {
-                                const V = this.annotationStorage;
-                                for (const Q of this._getElementsByName(U.name, U.id))
-                                    Q.domElement && (Q.domElement[u] = L), V.setValue(Q.id, {
-                                        [j]: L
+                            setPropertyOnSiblings(j, c, L, q) {
+                                const K = this.annotationStorage;
+                                for (const tt of this._getElementsByName(j.name, j.id))
+                                    tt.domElement && (tt.domElement[c] = L), K.setValue(tt.id, {
+                                        [q]: L
                                     });
                             }
                             render() {
-                                var j, V;
-                                const U = this.annotationStorage,
-                                    u = this.data.id;
+                                var q, K;
+                                const j = this.annotationStorage,
+                                    c = this.data.id;
                                 this.container.classList.add("textWidgetAnnotation");
                                 let L = null;
                                 if (this.renderForms) {
-                                    const Q = U.getValue(u, {
+                                    const tt = j.getValue(c, {
                                         value: this.data.fieldValue
                                     });
-                                    let he = Q.value || "";
-                                    const ye = U.getValue(u, {
+                                    let ct = tt.value || "";
+                                    const bt = j.getValue(c, {
                                         charLimit: this.data.maxLen
                                     }).charLimit;
-                                    ye && he.length > ye && (he = he.slice(0, ye));
-                                    let Me = Q.formattedValue || ((j = this.data.textContent) == null ? void 0 : j.join(`
+                                    bt && ct.length > bt && (ct = ct.slice(0, bt));
+                                    let Mt = tt.formattedValue || ((q = this.data.textContent) == null ? void 0 : q.join(`
 `)) || null;
-                                    Me && this.data.comb && (Me = Me.replaceAll(/\s+/g, ""));
-                                    const Re = {
-                                        userValue: he,
-                                        formattedValue: Me,
+                                    Mt && this.data.comb && (Mt = Mt.replaceAll(/\s+/g, ""));
+                                    const Ft = {
+                                        userValue: ct,
+                                        formattedValue: Mt,
                                         lastCommittedValue: null,
                                         commitKey: 1,
                                         focused: !1
                                     };
-                                    this.data.multiLine ? (L = document.createElement("textarea"), L.textContent = Me ?? he, this.data.doNotScroll && (L.style.overflowY = "hidden")) : (L = document.createElement("input"), L.type = "text", L.setAttribute("value", Me ?? he), this.data.doNotScroll && (L.style.overflowX = "hidden")), this.data.hasOwnCanvas && (L.hidden = !0), T.add(L), L.setAttribute("data-element-id", u), L.disabled = this.data.readOnly, L.name = this.data.fieldName, L.tabIndex = o, this._setRequired(L, this.data.required), ye && (L.maxLength = ye), L.addEventListener("input", (Ie) => {
-                                        U.setValue(u, {
-                                            value: Ie.target.value
-                                        }), this.setPropertyOnSiblings(L, "value", Ie.target.value, "value"), Re.formattedValue = null;
-                                    }), L.addEventListener("resetform", (Ie) => {
-                                        const Le = this.data.defaultFieldValue ?? "";
-                                        L.value = Re.userValue = Le, Re.formattedValue = null;
+                                    this.data.multiLine ? (L = document.createElement("textarea"), L.textContent = Mt ?? ct, this.data.doNotScroll && (L.style.overflowY = "hidden")) : (L = document.createElement("input"), L.type = "text", L.setAttribute("value", Mt ?? ct), this.data.doNotScroll && (L.style.overflowX = "hidden")), this.data.hasOwnCanvas && (L.hidden = !0), F.add(L), L.setAttribute("data-element-id", c), L.disabled = this.data.readOnly, L.name = this.data.fieldName, L.tabIndex = h, this._setRequired(L, this.data.required), bt && (L.maxLength = bt), L.addEventListener("input", (xt) => {
+                                        j.setValue(c, {
+                                            value: xt.target.value
+                                        }), this.setPropertyOnSiblings(L, "value", xt.target.value, "value"), Ft.formattedValue = null;
+                                    }), L.addEventListener("resetform", (xt) => {
+                                        const Dt = this.data.defaultFieldValue ?? "";
+                                        L.value = Ft.userValue = Dt, Ft.formattedValue = null;
                                     });
-                                    let qe = (Ie) => {
+                                    let Ht = (xt) => {
                                         const {
-                                            formattedValue: Le
-                                        } = Re;
-                                        Le != null && (Ie.target.value = Le), Ie.target.scrollLeft = 0;
+                                            formattedValue: Dt
+                                        } = Ft;
+                                        Dt != null && (xt.target.value = Dt), xt.target.scrollLeft = 0;
                                     };
                                     if (this.enableScripting && this.hasJSActions) {
-                                        L.addEventListener("focus", (Le) => {
-                                            if (Re.focused)
+                                        L.addEventListener("focus", (Dt) => {
+                                            if (Ft.focused)
                                                 return;
                                             const {
-                                                target: Ue
-                                            } = Le;
-                                            Re.userValue && (Ue.value = Re.userValue), Re.lastCommittedValue = Ue.value, Re.commitKey = 1, Re.focused = !0;
-                                        }), L.addEventListener("updatefromsandbox", (Le) => {
-                                            this.showElementAndHideCanvas(Le.target);
-                                            const Ue = {
-                                                value(Ve) {
-                                                    Re.userValue = Ve.detail.value ?? "", U.setValue(u, {
-                                                        value: Re.userValue.toString()
-                                                    }), Ve.target.value = Re.userValue;
+                                                target: Ut
+                                            } = Dt;
+                                            Ft.userValue && (Ut.value = Ft.userValue), Ft.lastCommittedValue = Ut.value, Ft.commitKey = 1, Ft.focused = !0;
+                                        }), L.addEventListener("updatefromsandbox", (Dt) => {
+                                            this.showElementAndHideCanvas(Dt.target);
+                                            const Ut = {
+                                                value(Xt) {
+                                                    Ft.userValue = Xt.detail.value ?? "", j.setValue(c, {
+                                                        value: Ft.userValue.toString()
+                                                    }), Xt.target.value = Ft.userValue;
                                                 },
-                                                formattedValue(Ve) {
+                                                formattedValue(Xt) {
                                                     const {
-                                                        formattedValue: Je
-                                                    } = Ve.detail;
-                                                    Re.formattedValue = Je, Je != null && Ve.target !== document.activeElement && (Ve.target.value = Je), U.setValue(u, {
-                                                        formattedValue: Je
+                                                        formattedValue: Kt
+                                                    } = Xt.detail;
+                                                    Ft.formattedValue = Kt, Kt != null && Xt.target !== document.activeElement && (Xt.target.value = Kt), j.setValue(c, {
+                                                        formattedValue: Kt
                                                     });
                                                 },
-                                                selRange(Ve) {
-                                                    Ve.target.setSelectionRange(...Ve.detail.selRange);
+                                                selRange(Xt) {
+                                                    Xt.target.setSelectionRange(...Xt.detail.selRange);
                                                 },
-                                                charLimit: (Ve) => {
-                                                    var it;
+                                                charLimit: (Xt) => {
+                                                    var ne;
                                                     const {
-                                                        charLimit: Je
-                                                    } = Ve.detail, {
-                                                        target: Qe
-                                                    } = Ve;
-                                                    if (Je === 0) {
-                                                        Qe.removeAttribute("maxLength");
+                                                        charLimit: Kt
+                                                    } = Xt.detail, {
+                                                        target: Zt
+                                                    } = Xt;
+                                                    if (Kt === 0) {
+                                                        Zt.removeAttribute("maxLength");
                                                         return;
                                                     }
-                                                    Qe.setAttribute("maxLength", Je);
-                                                    let st = Re.userValue;
-                                                    !st || st.length <= Je || (st = st.slice(0, Je), Qe.value = Re.userValue = st, U.setValue(u, {
-                                                        value: st
-                                                    }), (it = this.linkService.eventBus) == null || it.dispatch("dispatcheventinsandbox", {
+                                                    Zt.setAttribute("maxLength", Kt);
+                                                    let ie = Ft.userValue;
+                                                    !ie || ie.length <= Kt || (ie = ie.slice(0, Kt), Zt.value = Ft.userValue = ie, j.setValue(c, {
+                                                        value: ie
+                                                    }), (ne = this.linkService.eventBus) == null || ne.dispatch("dispatcheventinsandbox", {
                                                         source: this,
                                                         detail: {
-                                                            id: u,
+                                                            id: c,
                                                             name: "Keystroke",
-                                                            value: st,
+                                                            value: ie,
                                                             willCommit: !0,
                                                             commitKey: 1,
-                                                            selStart: Qe.selectionStart,
-                                                            selEnd: Qe.selectionEnd
+                                                            selStart: Zt.selectionStart,
+                                                            selEnd: Zt.selectionEnd
                                                         }
                                                     }));
                                                 }
                                             };
-                                            this._dispatchEventFromSandbox(Ue, Le);
-                                        }), L.addEventListener("keydown", (Le) => {
-                                            var Je;
-                                            Re.commitKey = 1;
-                                            let Ue = -1;
-                                            if (Le.key === "Escape" ? Ue = 0 : Le.key === "Enter" && !this.data.multiLine ? Ue = 2 : Le.key === "Tab" && (Re.commitKey = 3), Ue === -1)
+                                            this._dispatchEventFromSandbox(Ut, Dt);
+                                        }), L.addEventListener("keydown", (Dt) => {
+                                            var Kt;
+                                            Ft.commitKey = 1;
+                                            let Ut = -1;
+                                            if (Dt.key === "Escape" ? Ut = 0 : Dt.key === "Enter" && !this.data.multiLine ? Ut = 2 : Dt.key === "Tab" && (Ft.commitKey = 3), Ut === -1)
                                                 return;
                                             const {
-                                                value: Ve
-                                            } = Le.target;
-                                            Re.lastCommittedValue !== Ve && (Re.lastCommittedValue = Ve, Re.userValue = Ve, (Je = this.linkService.eventBus) == null || Je.dispatch("dispatcheventinsandbox", {
+                                                value: Xt
+                                            } = Dt.target;
+                                            Ft.lastCommittedValue !== Xt && (Ft.lastCommittedValue = Xt, Ft.userValue = Xt, (Kt = this.linkService.eventBus) == null || Kt.dispatch("dispatcheventinsandbox", {
                                                 source: this,
                                                 detail: {
-                                                    id: u,
+                                                    id: c,
                                                     name: "Keystroke",
-                                                    value: Ve,
+                                                    value: Xt,
                                                     willCommit: !0,
-                                                    commitKey: Ue,
-                                                    selStart: Le.target.selectionStart,
-                                                    selEnd: Le.target.selectionEnd
+                                                    commitKey: Ut,
+                                                    selStart: Dt.target.selectionStart,
+                                                    selEnd: Dt.target.selectionEnd
                                                 }
                                             }));
                                         });
-                                        const Ie = qe;
-                                        qe = null, L.addEventListener("blur", (Le) => {
-                                            var Ve;
-                                            if (!Re.focused || !Le.relatedTarget)
+                                        const xt = Ht;
+                                        Ht = null, L.addEventListener("blur", (Dt) => {
+                                            var Xt;
+                                            if (!Ft.focused || !Dt.relatedTarget)
                                                 return;
-                                            Re.focused = !1;
+                                            Ft.focused = !1;
                                             const {
-                                                value: Ue
-                                            } = Le.target;
-                                            Re.userValue = Ue, Re.lastCommittedValue !== Ue && ((Ve = this.linkService.eventBus) == null || Ve.dispatch("dispatcheventinsandbox", {
+                                                value: Ut
+                                            } = Dt.target;
+                                            Ft.userValue = Ut, Ft.lastCommittedValue !== Ut && ((Xt = this.linkService.eventBus) == null || Xt.dispatch("dispatcheventinsandbox", {
                                                 source: this,
                                                 detail: {
-                                                    id: u,
+                                                    id: c,
                                                     name: "Keystroke",
-                                                    value: Ue,
+                                                    value: Ut,
                                                     willCommit: !0,
-                                                    commitKey: Re.commitKey,
-                                                    selStart: Le.target.selectionStart,
-                                                    selEnd: Le.target.selectionEnd
+                                                    commitKey: Ft.commitKey,
+                                                    selStart: Dt.target.selectionStart,
+                                                    selEnd: Dt.target.selectionEnd
                                                 }
-                                            })), Ie(Le);
-                                        }), (V = this.data.actions) != null && V.Keystroke && L.addEventListener("beforeinput", (Le) => {
-                                            var lt;
-                                            Re.lastCommittedValue = null;
+                                            })), xt(Dt);
+                                        }), (K = this.data.actions) != null && K.Keystroke && L.addEventListener("beforeinput", (Dt) => {
+                                            var oe;
+                                            Ft.lastCommittedValue = null;
                                             const {
-                                                data: Ue,
-                                                target: Ve
-                                            } = Le, {
-                                                value: Je,
-                                                selectionStart: Qe,
-                                                selectionEnd: st
-                                            } = Ve;
-                                            let it = Qe,
-                                                rt = st;
-                                            switch (Le.inputType) {
+                                                data: Ut,
+                                                target: Xt
+                                            } = Dt, {
+                                                value: Kt,
+                                                selectionStart: Zt,
+                                                selectionEnd: ie
+                                            } = Xt;
+                                            let ne = Zt,
+                                                se = ie;
+                                            switch (Dt.inputType) {
                                                 case "deleteWordBackward": {
-                                                    const ct = Je.substring(0, Qe).match(/\w*[^\w]*$/);
-                                                    ct && (it -= ct[0].length);
+                                                    const le = Kt.substring(0, Zt).match(/\w*[^\w]*$/);
+                                                    le && (ne -= le[0].length);
                                                     break;
                                                 }
                                                 case "deleteWordForward": {
-                                                    const ct = Je.substring(Qe).match(/^[^\w]*\w*/);
-                                                    ct && (rt += ct[0].length);
+                                                    const le = Kt.substring(Zt).match(/^[^\w]*\w*/);
+                                                    le && (se += le[0].length);
                                                     break;
                                                 }
                                                 case "deleteContentBackward":
-                                                    Qe === st && (it -= 1);
+                                                    Zt === ie && (ne -= 1);
                                                     break;
                                                 case "deleteContentForward":
-                                                    Qe === st && (rt += 1);
+                                                    Zt === ie && (se += 1);
                                                     break;
                                             }
-                                            Le.preventDefault(), (lt = this.linkService.eventBus) == null || lt.dispatch("dispatcheventinsandbox", {
+                                            Dt.preventDefault(), (oe = this.linkService.eventBus) == null || oe.dispatch("dispatcheventinsandbox", {
                                                 source: this,
                                                 detail: {
-                                                    id: u,
+                                                    id: c,
                                                     name: "Keystroke",
-                                                    value: Je,
-                                                    change: Ue || "",
+                                                    value: Kt,
+                                                    change: Ut || "",
                                                     willCommit: !1,
-                                                    selStart: it,
-                                                    selEnd: rt
+                                                    selStart: ne,
+                                                    selEnd: se
                                                 }
                                             });
-                                        }), this._setEventListeners(L, Re, [
+                                        }), this._setEventListeners(L, Ft, [
                                             ["focus", "Focus"],
                                             ["blur", "Blur"],
                                             ["mousedown", "Mouse Down"],
                                             ["mouseenter", "Mouse Enter"],
                                             ["mouseleave", "Mouse Exit"],
                                             ["mouseup", "Mouse Up"]
-                                        ], (Le) => Le.target.value);
+                                        ], (Dt) => Dt.target.value);
                                     }
-                                    if (qe && L.addEventListener("blur", qe), this.data.comb) {
-                                        const Le = (this.data.rect[2] - this.data.rect[0]) / ye;
-                                        L.classList.add("comb"), L.style.letterSpacing = `calc(${Le}px * var(--scale-factor) - 1ch)`;
+                                    if (Ht && L.addEventListener("blur", Ht), this.data.comb) {
+                                        const Dt = (this.data.rect[2] - this.data.rect[0]) / bt;
+                                        L.classList.add("comb"), L.style.letterSpacing = `calc(${Dt}px * var(--scale-factor) - 1ch)`;
                                     }
                                 } else
                                     L = document.createElement("div"), L.textContent = this.data.fieldValue, L.style.verticalAlign = "middle", L.style.display = "table-cell";
                                 return this._setTextStyle(L), this._setBackgroundColor(L), this._setDefaultPropertiesFromJS(L), this.container.append(L), this.container;
                             }
                         }
-                        class x extends k {
-                            constructor(U) {
-                                super(U, {
-                                    isRenderable: !!U.data.hasOwnCanvas
+                        class E extends C {
+                            constructor(j) {
+                                super(j, {
+                                    isRenderable: !!j.data.hasOwnCanvas
                                 });
                             }
                         }
-                        class y extends k {
-                            constructor(U) {
-                                super(U, {
-                                    isRenderable: U.renderForms
+                        class S extends C {
+                            constructor(j) {
+                                super(j, {
+                                    isRenderable: j.renderForms
                                 });
                             }
                             render() {
-                                const U = this.annotationStorage,
-                                    u = this.data,
-                                    L = u.id;
-                                let j = U.getValue(L, {
-                                    value: u.exportValue === u.fieldValue
+                                const j = this.annotationStorage,
+                                    c = this.data,
+                                    L = c.id;
+                                let q = j.getValue(L, {
+                                    value: c.exportValue === c.fieldValue
                                 }).value;
-                                typeof j == "string" && (j = j !== "Off", U.setValue(L, {
-                                    value: j
+                                typeof q == "string" && (q = q !== "Off", j.setValue(L, {
+                                    value: q
                                 })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
-                                const V = document.createElement("input");
-                                return T.add(V), V.setAttribute("data-element-id", L), V.disabled = u.readOnly, this._setRequired(V, this.data.required), V.type = "checkbox", V.name = u.fieldName, j && V.setAttribute("checked", !0), V.setAttribute("exportValue", u.exportValue), V.tabIndex = o, V.addEventListener("change", (Q) => {
+                                const K = document.createElement("input");
+                                return F.add(K), K.setAttribute("data-element-id", L), K.disabled = c.readOnly, this._setRequired(K, this.data.required), K.type = "checkbox", K.name = c.fieldName, q && K.setAttribute("checked", !0), K.setAttribute("exportValue", c.exportValue), K.tabIndex = h, K.addEventListener("change", (tt) => {
                                     const {
-                                        name: he,
-                                        checked: ye
-                                    } = Q.target;
-                                    for (const Me of this._getElementsByName(he, L)) {
-                                        const Re = ye && Me.exportValue === u.exportValue;
-                                        Me.domElement && (Me.domElement.checked = Re), U.setValue(Me.id, {
-                                            value: Re
+                                        name: ct,
+                                        checked: bt
+                                    } = tt.target;
+                                    for (const Mt of this._getElementsByName(ct, L)) {
+                                        const Ft = bt && Mt.exportValue === c.exportValue;
+                                        Mt.domElement && (Mt.domElement.checked = Ft), j.setValue(Mt.id, {
+                                            value: Ft
                                         });
                                     }
-                                    U.setValue(L, {
-                                        value: ye
+                                    j.setValue(L, {
+                                        value: bt
                                     });
-                                }), V.addEventListener("resetform", (Q) => {
-                                    const he = u.defaultFieldValue || "Off";
-                                    Q.target.checked = he === u.exportValue;
-                                }), this.enableScripting && this.hasJSActions && (V.addEventListener("updatefromsandbox", (Q) => {
-                                    const he = {
-                                        value(ye) {
-                                            ye.target.checked = ye.detail.value !== "Off", U.setValue(L, {
-                                                value: ye.target.checked
+                                }), K.addEventListener("resetform", (tt) => {
+                                    const ct = c.defaultFieldValue || "Off";
+                                    tt.target.checked = ct === c.exportValue;
+                                }), this.enableScripting && this.hasJSActions && (K.addEventListener("updatefromsandbox", (tt) => {
+                                    const ct = {
+                                        value(bt) {
+                                            bt.target.checked = bt.detail.value !== "Off", j.setValue(L, {
+                                                value: bt.target.checked
                                             });
                                         }
                                     };
-                                    this._dispatchEventFromSandbox(he, Q);
-                                }), this._setEventListeners(V, null, [
+                                    this._dispatchEventFromSandbox(ct, tt);
+                                }), this._setEventListeners(K, null, [
                                     ["change", "Validate"],
                                     ["change", "Action"],
                                     ["focus", "Focus"],
                                     ["blur", "Blur"],
                                     ["mousedown", "Mouse Down"],
                                     ["mouseenter", "Mouse Enter"],
                                     ["mouseleave", "Mouse Exit"],
                                     ["mouseup", "Mouse Up"]
-                                ], (Q) => Q.target.checked)), this._setBackgroundColor(V), this._setDefaultPropertiesFromJS(V), this.container.append(V), this.container;
+                                ], (tt) => tt.target.checked)), this._setBackgroundColor(K), this._setDefaultPropertiesFromJS(K), this.container.append(K), this.container;
                             }
                         }
-                        class p extends k {
-                            constructor(U) {
-                                super(U, {
-                                    isRenderable: U.renderForms
+                        class g extends C {
+                            constructor(j) {
+                                super(j, {
+                                    isRenderable: j.renderForms
                                 });
                             }
                             render() {
                                 this.container.classList.add("buttonWidgetAnnotation", "radioButton");
-                                const U = this.annotationStorage,
-                                    u = this.data,
-                                    L = u.id;
-                                let j = U.getValue(L, {
-                                    value: u.fieldValue === u.buttonValue
+                                const j = this.annotationStorage,
+                                    c = this.data,
+                                    L = c.id;
+                                let q = j.getValue(L, {
+                                    value: c.fieldValue === c.buttonValue
                                 }).value;
-                                typeof j == "string" && (j = j !== u.buttonValue, U.setValue(L, {
-                                    value: j
+                                typeof q == "string" && (q = q !== c.buttonValue, j.setValue(L, {
+                                    value: q
                                 }));
-                                const V = document.createElement("input");
-                                if (T.add(V), V.setAttribute("data-element-id", L), V.disabled = u.readOnly, this._setRequired(V, this.data.required), V.type = "radio", V.name = u.fieldName, j && V.setAttribute("checked", !0), V.tabIndex = o, V.addEventListener("change", (Q) => {
+                                const K = document.createElement("input");
+                                if (F.add(K), K.setAttribute("data-element-id", L), K.disabled = c.readOnly, this._setRequired(K, this.data.required), K.type = "radio", K.name = c.fieldName, q && K.setAttribute("checked", !0), K.tabIndex = h, K.addEventListener("change", (tt) => {
                                         const {
-                                            name: he,
-                                            checked: ye
-                                        } = Q.target;
-                                        for (const Me of this._getElementsByName(he, L))
-                                            U.setValue(Me.id, {
+                                            name: ct,
+                                            checked: bt
+                                        } = tt.target;
+                                        for (const Mt of this._getElementsByName(ct, L))
+                                            j.setValue(Mt.id, {
                                                 value: !1
                                             });
-                                        U.setValue(L, {
-                                            value: ye
+                                        j.setValue(L, {
+                                            value: bt
                                         });
-                                    }), V.addEventListener("resetform", (Q) => {
-                                        const he = u.defaultFieldValue;
-                                        Q.target.checked = he != null && he === u.buttonValue;
+                                    }), K.addEventListener("resetform", (tt) => {
+                                        const ct = c.defaultFieldValue;
+                                        tt.target.checked = ct != null && ct === c.buttonValue;
                                     }), this.enableScripting && this.hasJSActions) {
-                                    const Q = u.buttonValue;
-                                    V.addEventListener("updatefromsandbox", (he) => {
-                                        const ye = {
-                                            value: (Me) => {
-                                                const Re = Q === Me.detail.value;
-                                                for (const qe of this._getElementsByName(Me.target.name)) {
-                                                    const Ie = Re && qe.id === L;
-                                                    qe.domElement && (qe.domElement.checked = Ie), U.setValue(qe.id, {
-                                                        value: Ie
+                                    const tt = c.buttonValue;
+                                    K.addEventListener("updatefromsandbox", (ct) => {
+                                        const bt = {
+                                            value: (Mt) => {
+                                                const Ft = tt === Mt.detail.value;
+                                                for (const Ht of this._getElementsByName(Mt.target.name)) {
+                                                    const xt = Ft && Ht.id === L;
+                                                    Ht.domElement && (Ht.domElement.checked = xt), j.setValue(Ht.id, {
+                                                        value: xt
                                                     });
                                                 }
                                             }
                                         };
-                                        this._dispatchEventFromSandbox(ye, he);
-                                    }), this._setEventListeners(V, null, [
+                                        this._dispatchEventFromSandbox(bt, ct);
+                                    }), this._setEventListeners(K, null, [
                                         ["change", "Validate"],
                                         ["change", "Action"],
                                         ["focus", "Focus"],
                                         ["blur", "Blur"],
                                         ["mousedown", "Mouse Down"],
                                         ["mouseenter", "Mouse Enter"],
                                         ["mouseleave", "Mouse Exit"],
                                         ["mouseup", "Mouse Up"]
-                                    ], (he) => he.target.checked);
+                                    ], (ct) => ct.target.checked);
                                 }
-                                return this._setBackgroundColor(V), this._setDefaultPropertiesFromJS(V), this.container.append(V), this.container;
+                                return this._setBackgroundColor(K), this._setDefaultPropertiesFromJS(K), this.container.append(K), this.container;
                             }
                         }
-                        class E extends P {
-                            constructor(U) {
-                                super(U, {
-                                    ignoreBorder: U.data.hasAppearance
+                        class v extends P {
+                            constructor(j) {
+                                super(j, {
+                                    ignoreBorder: j.data.hasAppearance
                                 });
                             }
                             render() {
-                                const U = super.render();
-                                U.classList.add("buttonWidgetAnnotation", "pushButton"), this.data.alternativeText && (U.title = this.data.alternativeText);
-                                const u = U.lastChild;
-                                return this.enableScripting && this.hasJSActions && u && (this._setDefaultPropertiesFromJS(u), u.addEventListener("updatefromsandbox", (L) => {
+                                const j = super.render();
+                                j.classList.add("buttonWidgetAnnotation", "pushButton"), this.data.alternativeText && (j.title = this.data.alternativeText);
+                                const c = j.lastChild;
+                                return this.enableScripting && this.hasJSActions && c && (this._setDefaultPropertiesFromJS(c), c.addEventListener("updatefromsandbox", (L) => {
                                     this._dispatchEventFromSandbox({}, L);
-                                })), U;
+                                })), j;
                             }
                         }
-                        class $ extends k {
-                            constructor(U) {
-                                super(U, {
-                                    isRenderable: U.renderForms
+                        class $ extends C {
+                            constructor(j) {
+                                super(j, {
+                                    isRenderable: j.renderForms
                                 });
                             }
                             render() {
                                 this.container.classList.add("choiceWidgetAnnotation");
-                                const U = this.annotationStorage,
-                                    u = this.data.id,
-                                    L = U.getValue(u, {
+                                const j = this.annotationStorage,
+                                    c = this.data.id,
+                                    L = j.getValue(c, {
                                         value: this.data.fieldValue
                                     }),
-                                    j = document.createElement("select");
-                                T.add(j), j.setAttribute("data-element-id", u), j.disabled = this.data.readOnly, this._setRequired(j, this.data.required), j.name = this.data.fieldName, j.tabIndex = o;
-                                let V = this.data.combo && this.data.options.length > 0;
-                                this.data.combo || (j.size = this.data.options.length, this.data.multiSelect && (j.multiple = !0)), j.addEventListener("resetform", (Re) => {
-                                    const qe = this.data.defaultFieldValue;
-                                    for (const Ie of j.options)
-                                        Ie.selected = Ie.value === qe;
-                                });
-                                for (const Re of this.data.options) {
-                                    const qe = document.createElement("option");
-                                    qe.textContent = Re.displayValue, qe.value = Re.exportValue, L.value.includes(Re.exportValue) && (qe.setAttribute("selected", !0), V = !1), j.append(qe);
-                                }
-                                let Q = null;
-                                if (V) {
-                                    const Re = document.createElement("option");
-                                    Re.value = " ", Re.setAttribute("hidden", !0), Re.setAttribute("selected", !0), j.prepend(Re), Q = () => {
-                                        Re.remove(), j.removeEventListener("input", Q), Q = null;
-                                    }, j.addEventListener("input", Q);
+                                    q = document.createElement("select");
+                                F.add(q), q.setAttribute("data-element-id", c), q.disabled = this.data.readOnly, this._setRequired(q, this.data.required), q.name = this.data.fieldName, q.tabIndex = h;
+                                let K = this.data.combo && this.data.options.length > 0;
+                                this.data.combo || (q.size = this.data.options.length, this.data.multiSelect && (q.multiple = !0)), q.addEventListener("resetform", (Ft) => {
+                                    const Ht = this.data.defaultFieldValue;
+                                    for (const xt of q.options)
+                                        xt.selected = xt.value === Ht;
+                                });
+                                for (const Ft of this.data.options) {
+                                    const Ht = document.createElement("option");
+                                    Ht.textContent = Ft.displayValue, Ht.value = Ft.exportValue, L.value.includes(Ft.exportValue) && (Ht.setAttribute("selected", !0), K = !1), q.append(Ht);
+                                }
+                                let tt = null;
+                                if (K) {
+                                    const Ft = document.createElement("option");
+                                    Ft.value = " ", Ft.setAttribute("hidden", !0), Ft.setAttribute("selected", !0), q.prepend(Ft), tt = () => {
+                                        Ft.remove(), q.removeEventListener("input", tt), tt = null;
+                                    }, q.addEventListener("input", tt);
                                 }
-                                const he = (Re) => {
-                                    const qe = Re ? "value" : "textContent",
+                                const ct = (Ft) => {
+                                    const Ht = Ft ? "value" : "textContent",
                                         {
-                                            options: Ie,
-                                            multiple: Le
-                                        } = j;
-                                    return Le ? Array.prototype.filter.call(Ie, (Ue) => Ue.selected).map((Ue) => Ue[qe]) : Ie.selectedIndex === -1 ? null : Ie[Ie.selectedIndex][qe];
+                                            options: xt,
+                                            multiple: Dt
+                                        } = q;
+                                    return Dt ? Array.prototype.filter.call(xt, (Ut) => Ut.selected).map((Ut) => Ut[Ht]) : xt.selectedIndex === -1 ? null : xt[xt.selectedIndex][Ht];
                                 };
-                                let ye = he(!1);
-                                const Me = (Re) => {
-                                    const qe = Re.target.options;
-                                    return Array.prototype.map.call(qe, (Ie) => ({
-                                        displayValue: Ie.textContent,
-                                        exportValue: Ie.value
+                                let bt = ct(!1);
+                                const Mt = (Ft) => {
+                                    const Ht = Ft.target.options;
+                                    return Array.prototype.map.call(Ht, (xt) => ({
+                                        displayValue: xt.textContent,
+                                        exportValue: xt.value
                                     }));
                                 };
-                                return this.enableScripting && this.hasJSActions ? (j.addEventListener("updatefromsandbox", (Re) => {
-                                    const qe = {
-                                        value(Ie) {
-                                            Q == null || Q();
-                                            const Le = Ie.detail.value,
-                                                Ue = new Set(Array.isArray(Le) ? Le : [Le]);
-                                            for (const Ve of j.options)
-                                                Ve.selected = Ue.has(Ve.value);
-                                            U.setValue(u, {
-                                                value: he(!0)
-                                            }), ye = he(!1);
+                                return this.enableScripting && this.hasJSActions ? (q.addEventListener("updatefromsandbox", (Ft) => {
+                                    const Ht = {
+                                        value(xt) {
+                                            tt == null || tt();
+                                            const Dt = xt.detail.value,
+                                                Ut = new Set(Array.isArray(Dt) ? Dt : [Dt]);
+                                            for (const Xt of q.options)
+                                                Xt.selected = Ut.has(Xt.value);
+                                            j.setValue(c, {
+                                                value: ct(!0)
+                                            }), bt = ct(!1);
                                         },
-                                        multipleSelection(Ie) {
-                                            j.multiple = !0;
+                                        multipleSelection(xt) {
+                                            q.multiple = !0;
                                         },
-                                        remove(Ie) {
-                                            const Le = j.options,
-                                                Ue = Ie.detail.remove;
-                                            Le[Ue].selected = !1, j.remove(Ue), Le.length > 0 && Array.prototype.findIndex.call(Le, (Je) => Je.selected) === -1 && (Le[0].selected = !0), U.setValue(u, {
-                                                value: he(!0),
-                                                items: Me(Ie)
-                                            }), ye = he(!1);
+                                        remove(xt) {
+                                            const Dt = q.options,
+                                                Ut = xt.detail.remove;
+                                            Dt[Ut].selected = !1, q.remove(Ut), Dt.length > 0 && Array.prototype.findIndex.call(Dt, (Kt) => Kt.selected) === -1 && (Dt[0].selected = !0), j.setValue(c, {
+                                                value: ct(!0),
+                                                items: Mt(xt)
+                                            }), bt = ct(!1);
                                         },
-                                        clear(Ie) {
-                                            for (; j.length !== 0;)
-                                                j.remove(0);
-                                            U.setValue(u, {
+                                        clear(xt) {
+                                            for (; q.length !== 0;)
+                                                q.remove(0);
+                                            j.setValue(c, {
                                                 value: null,
                                                 items: []
-                                            }), ye = he(!1);
+                                            }), bt = ct(!1);
                                         },
-                                        insert(Ie) {
+                                        insert(xt) {
                                             const {
-                                                index: Le,
-                                                displayValue: Ue,
-                                                exportValue: Ve
-                                            } = Ie.detail.insert, Je = j.children[Le], Qe = document.createElement("option");
-                                            Qe.textContent = Ue, Qe.value = Ve, Je ? Je.before(Qe) : j.append(Qe), U.setValue(u, {
-                                                value: he(!0),
-                                                items: Me(Ie)
-                                            }), ye = he(!1);
+                                                index: Dt,
+                                                displayValue: Ut,
+                                                exportValue: Xt
+                                            } = xt.detail.insert, Kt = q.children[Dt], Zt = document.createElement("option");
+                                            Zt.textContent = Ut, Zt.value = Xt, Kt ? Kt.before(Zt) : q.append(Zt), j.setValue(c, {
+                                                value: ct(!0),
+                                                items: Mt(xt)
+                                            }), bt = ct(!1);
                                         },
-                                        items(Ie) {
+                                        items(xt) {
                                             const {
-                                                items: Le
-                                            } = Ie.detail;
-                                            for (; j.length !== 0;)
-                                                j.remove(0);
-                                            for (const Ue of Le) {
+                                                items: Dt
+                                            } = xt.detail;
+                                            for (; q.length !== 0;)
+                                                q.remove(0);
+                                            for (const Ut of Dt) {
                                                 const {
-                                                    displayValue: Ve,
-                                                    exportValue: Je
-                                                } = Ue, Qe = document.createElement("option");
-                                                Qe.textContent = Ve, Qe.value = Je, j.append(Qe);
+                                                    displayValue: Xt,
+                                                    exportValue: Kt
+                                                } = Ut, Zt = document.createElement("option");
+                                                Zt.textContent = Xt, Zt.value = Kt, q.append(Zt);
                                             }
-                                            j.options.length > 0 && (j.options[0].selected = !0), U.setValue(u, {
-                                                value: he(!0),
-                                                items: Me(Ie)
-                                            }), ye = he(!1);
+                                            q.options.length > 0 && (q.options[0].selected = !0), j.setValue(c, {
+                                                value: ct(!0),
+                                                items: Mt(xt)
+                                            }), bt = ct(!1);
                                         },
-                                        indices(Ie) {
-                                            const Le = new Set(Ie.detail.indices);
-                                            for (const Ue of Ie.target.options)
-                                                Ue.selected = Le.has(Ue.index);
-                                            U.setValue(u, {
-                                                value: he(!0)
-                                            }), ye = he(!1);
+                                        indices(xt) {
+                                            const Dt = new Set(xt.detail.indices);
+                                            for (const Ut of xt.target.options)
+                                                Ut.selected = Dt.has(Ut.index);
+                                            j.setValue(c, {
+                                                value: ct(!0)
+                                            }), bt = ct(!1);
                                         },
-                                        editable(Ie) {
-                                            Ie.target.disabled = !Ie.detail.editable;
+                                        editable(xt) {
+                                            xt.target.disabled = !xt.detail.editable;
                                         }
                                     };
-                                    this._dispatchEventFromSandbox(qe, Re);
-                                }), j.addEventListener("input", (Re) => {
-                                    var Ie;
-                                    const qe = he(!0);
-                                    U.setValue(u, {
-                                        value: qe
-                                    }), Re.preventDefault(), (Ie = this.linkService.eventBus) == null || Ie.dispatch("dispatcheventinsandbox", {
+                                    this._dispatchEventFromSandbox(Ht, Ft);
+                                }), q.addEventListener("input", (Ft) => {
+                                    var xt;
+                                    const Ht = ct(!0);
+                                    j.setValue(c, {
+                                        value: Ht
+                                    }), Ft.preventDefault(), (xt = this.linkService.eventBus) == null || xt.dispatch("dispatcheventinsandbox", {
                                         source: this,
                                         detail: {
-                                            id: u,
+                                            id: c,
                                             name: "Keystroke",
-                                            value: ye,
-                                            changeEx: qe,
+                                            value: bt,
+                                            changeEx: Ht,
                                             willCommit: !1,
                                             commitKey: 1,
                                             keyDown: !1
                                         }
                                     });
-                                }), this._setEventListeners(j, null, [
+                                }), this._setEventListeners(q, null, [
                                     ["focus", "Focus"],
                                     ["blur", "Blur"],
                                     ["mousedown", "Mouse Down"],
                                     ["mouseenter", "Mouse Enter"],
                                     ["mouseleave", "Mouse Exit"],
                                     ["mouseup", "Mouse Up"],
                                     ["input", "Action"],
                                     ["input", "Validate"]
-                                ], (Re) => Re.target.value)) : j.addEventListener("input", function(Re) {
-                                    U.setValue(u, {
-                                        value: he(!0)
+                                ], (Ft) => Ft.target.value)) : q.addEventListener("input", function(Ft) {
+                                    j.setValue(c, {
+                                        value: ct(!0)
                                     });
-                                }), this.data.combo && this._setTextStyle(j), this._setBackgroundColor(j), this._setDefaultPropertiesFromJS(j), this.container.append(j), this.container;
+                                }), this.data.combo && this._setTextStyle(q), this._setBackgroundColor(q), this._setDefaultPropertiesFromJS(q), this.container.append(q), this.container;
                             }
                         }
-                        class M extends C {
-                            constructor(U) {
+                        class M extends T {
+                            constructor(j) {
                                 const {
-                                    data: u,
+                                    data: c,
                                     elements: L
-                                } = U;
-                                super(U, {
-                                    isRenderable: C._hasPopupData(u)
+                                } = j;
+                                super(j, {
+                                    isRenderable: T._hasPopupData(c)
                                 }), this.elements = L;
                             }
                             render() {
                                 this.container.classList.add("popupAnnotation");
-                                const U = new m({
+                                const j = new _({
                                         container: this.container,
                                         color: this.data.color,
                                         titleObj: this.data.titleObj,
                                         modificationDate: this.data.modificationDate,
                                         contentsObj: this.data.contentsObj,
                                         richText: this.data.richText,
                                         rect: this.data.rect,
                                         parentRect: this.data.parentRect || null,
                                         parent: this.parent,
                                         elements: this.elements,
                                         open: this.data.open
                                     }),
-                                    u = [];
+                                    c = [];
                                 for (const L of this.elements)
-                                    L.popup = U, u.push(L.data.id), L.addHighlightArea();
-                                return this.container.setAttribute("aria-controls", u.map((L) => `${n.AnnotationPrefix}${L}`).join(",")), this.container;
+                                    L.popup = j, c.push(L.data.id), L.addHighlightArea();
+                                return this.container.setAttribute("aria-controls", c.map((L) => `${e.AnnotationPrefix}${L}`).join(",")), this.container;
                             }
                         }
-                        class m {
+                        class _ {
                             constructor({
-                                container: U,
-                                color: u,
+                                container: j,
+                                color: c,
                                 elements: L,
-                                titleObj: j,
-                                modificationDate: V,
-                                contentsObj: Q,
-                                richText: he,
-                                parent: ye,
-                                rect: Me,
-                                parentRect: Re,
-                                open: qe
+                                titleObj: q,
+                                modificationDate: K,
+                                contentsObj: tt,
+                                richText: ct,
+                                parent: bt,
+                                rect: Mt,
+                                parentRect: Ft,
+                                open: Ht
                             }) {
-                                W(this, He);
-                                W(this, je);
-                                W(this, Xe);
-                                W(this, Ye);
+                                W(this, Bt);
+                                W(this, jt);
+                                W(this, Gt);
+                                W(this, Vt);
                                 W(this, z, null);
-                                W(this, ae, K(this, He, $n).bind(this));
-                                W(this, Z, K(this, Ye, cn).bind(this));
-                                W(this, ce, K(this, Xe, ln).bind(this));
-                                W(this, ue, K(this, je, Mt).bind(this));
-                                W(this, me, null);
-                                W(this, fe, null);
-                                W(this, Pe, null);
-                                W(this, Fe, null);
-                                W(this, Ee, null);
-                                W(this, De, null);
-                                W(this, _e, !1);
-                                W(this, ie, null);
-                                W(this, se, null);
-                                W(this, ge, null);
-                                W(this, Ce, null);
-                                W(this, xe, !1);
-                                var Le;
-                                oe(this, fe, U), oe(this, Ce, j), oe(this, Pe, Q), oe(this, ge, he), oe(this, Ee, ye), oe(this, me, u), oe(this, se, Me), oe(this, De, Re), oe(this, Fe, L);
-                                const Ie = s.PDFDateString.toDateObject(V);
-                                Ie && oe(this, z, ye.l10n.get("annotation_date_string", {
-                                    date: Ie.toLocaleDateString(),
-                                    time: Ie.toLocaleTimeString()
-                                })), this.trigger = L.flatMap((Ue) => Ue.getElementsToTriggerPopup());
-                                for (const Ue of this.trigger)
-                                    Ue.addEventListener("click", a(this, ue)), Ue.addEventListener("mouseenter", a(this, ce)), Ue.addEventListener("mouseleave", a(this, Z)), Ue.classList.add("popupTriggerArea");
-                                for (const Ue of L)
-                                    (Le = Ue.container) == null || Le.addEventListener("keydown", a(this, ae));
-                                a(this, fe).hidden = !0, qe && K(this, je, Mt).call(this);
+                                W(this, it, J(this, Bt, $n).bind(this));
+                                W(this, Z, J(this, Vt, ln).bind(this));
+                                W(this, lt, J(this, Gt, on).bind(this));
+                                W(this, ht, J(this, jt, Me).bind(this));
+                                W(this, mt, null);
+                                W(this, ft, null);
+                                W(this, kt, null);
+                                W(this, Rt, null);
+                                W(this, St, null);
+                                W(this, It, null);
+                                W(this, _t, !1);
+                                W(this, rt, null);
+                                W(this, at, null);
+                                W(this, pt, null);
+                                W(this, Ct, null);
+                                W(this, Tt, !1);
+                                var Dt;
+                                ot(this, ft, j), ot(this, Ct, q), ot(this, kt, tt), ot(this, pt, ct), ot(this, St, bt), ot(this, mt, c), ot(this, at, Mt), ot(this, It, Ft), ot(this, Rt, L);
+                                const xt = s.PDFDateString.toDateObject(K);
+                                xt && ot(this, z, bt.l10n.get("annotation_date_string", {
+                                    date: xt.toLocaleDateString(),
+                                    time: xt.toLocaleTimeString()
+                                })), this.trigger = L.flatMap((Ut) => Ut.getElementsToTriggerPopup());
+                                for (const Ut of this.trigger)
+                                    Ut.addEventListener("click", r(this, ht)), Ut.addEventListener("mouseenter", r(this, lt)), Ut.addEventListener("mouseleave", r(this, Z)), Ut.classList.add("popupTriggerArea");
+                                for (const Ut of L)
+                                    (Dt = Ut.container) == null || Dt.addEventListener("keydown", r(this, it));
+                                r(this, ft).hidden = !0, Ht && J(this, jt, Me).call(this);
                             }
                             render() {
-                                if (a(this, ie))
+                                if (r(this, rt))
                                     return;
                                 const {
                                     page: {
-                                        view: U
+                                        view: j
                                     },
                                     viewport: {
                                         rawDims: {
-                                            pageWidth: u,
+                                            pageWidth: c,
                                             pageHeight: L,
-                                            pageX: j,
-                                            pageY: V
+                                            pageX: q,
+                                            pageY: K
                                         }
                                     }
-                                } = a(this, Ee), Q = oe(this, ie, document.createElement("div"));
-                                if (Q.className = "popup", a(this, me)) {
-                                    const it = Q.style.outlineColor = n.Util.makeHexColor(...a(this, me));
-                                    CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? Q.style.backgroundColor = `color-mix(in srgb, ${it} 30%, white)` : Q.style.backgroundColor = n.Util.makeHexColor(...a(this, me).map((lt) => Math.floor(0.7 * (255 - lt) + lt)));
-                                }
-                                const he = document.createElement("span");
-                                he.className = "header";
-                                const ye = document.createElement("h1");
-                                if (he.append(ye), {
-                                        dir: ye.dir,
-                                        str: ye.textContent
-                                    } = a(this, Ce), Q.append(he), a(this, z)) {
-                                    const it = document.createElement("span");
-                                    it.classList.add("popupDate"), a(this, z).then((rt) => {
-                                        it.textContent = rt;
-                                    }), he.append(it);
-                                }
-                                const Me = a(this, Pe),
-                                    Re = a(this, ge);
-                                if (Re != null && Re.str && (!(Me != null && Me.str) || Me.str === Re.str))
-                                    c.XfaLayer.render({
-                                        xfaHtml: Re.html,
+                                } = r(this, St), tt = ot(this, rt, document.createElement("div"));
+                                if (tt.className = "popup", r(this, mt)) {
+                                    const ne = tt.style.outlineColor = e.Util.makeHexColor(...r(this, mt));
+                                    CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? tt.style.backgroundColor = `color-mix(in srgb, ${ne} 30%, white)` : tt.style.backgroundColor = e.Util.makeHexColor(...r(this, mt).map((oe) => Math.floor(0.7 * (255 - oe) + oe)));
+                                }
+                                const ct = document.createElement("span");
+                                ct.className = "header";
+                                const bt = document.createElement("h1");
+                                if (ct.append(bt), {
+                                        dir: bt.dir,
+                                        str: bt.textContent
+                                    } = r(this, Ct), tt.append(ct), r(this, z)) {
+                                    const ne = document.createElement("span");
+                                    ne.classList.add("popupDate"), r(this, z).then((se) => {
+                                        ne.textContent = se;
+                                    }), ct.append(ne);
+                                }
+                                const Mt = r(this, kt),
+                                    Ft = r(this, pt);
+                                if (Ft != null && Ft.str && (!(Mt != null && Mt.str) || Mt.str === Ft.str))
+                                    a.XfaLayer.render({
+                                        xfaHtml: Ft.html,
                                         intent: "richText",
-                                        div: Q
-                                    }), Q.lastChild.classList.add("richText", "popupContent");
+                                        div: tt
+                                    }), tt.lastChild.classList.add("richText", "popupContent");
                                 else {
-                                    const it = this._formatContents(Me);
-                                    Q.append(it);
+                                    const ne = this._formatContents(Mt);
+                                    tt.append(ne);
                                 }
-                                let qe = !!a(this, De),
-                                    Ie = qe ? a(this, De) : a(this, se);
-                                for (const it of a(this, Fe))
-                                    if (!Ie || n.Util.intersect(it.data.rect, Ie) !== null) {
-                                        Ie = it.data.rect, qe = !0;
+                                let Ht = !!r(this, It),
+                                    xt = Ht ? r(this, It) : r(this, at);
+                                for (const ne of r(this, Rt))
+                                    if (!xt || e.Util.intersect(ne.data.rect, xt) !== null) {
+                                        xt = ne.data.rect, Ht = !0;
                                         break;
                                     }
-                                const Le = n.Util.normalizeRect([Ie[0], U[3] - Ie[1] + U[1], Ie[2], U[3] - Ie[3] + U[1]]),
-                                    Ve = qe ? Ie[2] - Ie[0] + 5 : 0,
-                                    Je = Le[0] + Ve,
-                                    Qe = Le[1],
+                                const Dt = e.Util.normalizeRect([xt[0], j[3] - xt[1] + j[1], xt[2], j[3] - xt[3] + j[1]]),
+                                    Xt = Ht ? xt[2] - xt[0] + 5 : 0,
+                                    Kt = Dt[0] + Xt,
+                                    Zt = Dt[1],
                                     {
-                                        style: st
-                                    } = a(this, fe);
-                                st.left = `${100 * (Je - j) / u}%`, st.top = `${100 * (Qe - V) / L}%`, a(this, fe).append(Q);
+                                        style: ie
+                                    } = r(this, ft);
+                                ie.left = `${100 * (Kt - q) / c}%`, ie.top = `${100 * (Zt - K) / L}%`, r(this, ft).append(tt);
                             }
                             _formatContents({
-                                str: U,
-                                dir: u
+                                str: j,
+                                dir: c
                             }) {
                                 const L = document.createElement("p");
-                                L.classList.add("popupContent"), L.dir = u;
-                                const j = U.split(/(?:\r\n?|\n)/);
-                                for (let V = 0, Q = j.length; V < Q; ++V) {
-                                    const he = j[V];
-                                    L.append(document.createTextNode(he)), V < Q - 1 && L.append(document.createElement("br"));
+                                L.classList.add("popupContent"), L.dir = c;
+                                const q = j.split(/(?:\r\n?|\n)/);
+                                for (let K = 0, tt = q.length; K < tt; ++K) {
+                                    const ct = q[K];
+                                    L.append(document.createTextNode(ct)), K < tt - 1 && L.append(document.createElement("br"));
                                 }
                                 return L;
                             }
                             forceHide() {
-                                oe(this, xe, this.isVisible), a(this, xe) && (a(this, fe).hidden = !0);
+                                ot(this, Tt, this.isVisible), r(this, Tt) && (r(this, ft).hidden = !0);
                             }
                             maybeShow() {
-                                a(this, xe) && (oe(this, xe, !1), a(this, fe).hidden = !1);
+                                r(this, Tt) && (ot(this, Tt, !1), r(this, ft).hidden = !1);
                             }
                             get isVisible() {
-                                return a(this, fe).hidden === !1;
+                                return r(this, ft).hidden === !1;
                             }
                         }
-                        z = new WeakMap(), ae = new WeakMap(), Z = new WeakMap(), ce = new WeakMap(), ue = new WeakMap(), me = new WeakMap(), fe = new WeakMap(), Pe = new WeakMap(), Fe = new WeakMap(), Ee = new WeakMap(), De = new WeakMap(), _e = new WeakMap(), ie = new WeakMap(), se = new WeakMap(), ge = new WeakMap(), Ce = new WeakMap(), xe = new WeakMap(), He = new WeakSet(), $n = function(U) {
-                            U.altKey || U.shiftKey || U.ctrlKey || U.metaKey || (U.key === "Enter" || U.key === "Escape" && a(this, _e)) && K(this, je, Mt).call(this);
-                        }, je = new WeakSet(), Mt = function() {
-                            oe(this, _e, !a(this, _e)), a(this, _e) ? (K(this, Xe, ln).call(this), a(this, fe).addEventListener("click", a(this, ue)), a(this, fe).addEventListener("keydown", a(this, ae))) : (K(this, Ye, cn).call(this), a(this, fe).removeEventListener("click", a(this, ue)), a(this, fe).removeEventListener("keydown", a(this, ae)));
-                        }, Xe = new WeakSet(), ln = function() {
-                            a(this, ie) || this.render(), this.isVisible ? a(this, _e) && a(this, fe).classList.add("focused") : (a(this, fe).hidden = !1, a(this, fe).style.zIndex = parseInt(a(this, fe).style.zIndex) + 1e3);
-                        }, Ye = new WeakSet(), cn = function() {
-                            a(this, fe).classList.remove("focused"), !(a(this, _e) || !this.isVisible) && (a(this, fe).hidden = !0, a(this, fe).style.zIndex = parseInt(a(this, fe).style.zIndex) - 1e3);
+                        z = new WeakMap(), it = new WeakMap(), Z = new WeakMap(), lt = new WeakMap(), ht = new WeakMap(), mt = new WeakMap(), ft = new WeakMap(), kt = new WeakMap(), Rt = new WeakMap(), St = new WeakMap(), It = new WeakMap(), _t = new WeakMap(), rt = new WeakMap(), at = new WeakMap(), pt = new WeakMap(), Ct = new WeakMap(), Tt = new WeakMap(), Bt = new WeakSet(), $n = function(j) {
+                            j.altKey || j.shiftKey || j.ctrlKey || j.metaKey || (j.key === "Enter" || j.key === "Escape" && r(this, _t)) && J(this, jt, Me).call(this);
+                        }, jt = new WeakSet(), Me = function() {
+                            ot(this, _t, !r(this, _t)), r(this, _t) ? (J(this, Gt, on).call(this), r(this, ft).addEventListener("click", r(this, ht)), r(this, ft).addEventListener("keydown", r(this, it))) : (J(this, Vt, ln).call(this), r(this, ft).removeEventListener("click", r(this, ht)), r(this, ft).removeEventListener("keydown", r(this, it)));
+                        }, Gt = new WeakSet(), on = function() {
+                            r(this, rt) || this.render(), this.isVisible ? r(this, _t) && r(this, ft).classList.add("focused") : (r(this, ft).hidden = !1, r(this, ft).style.zIndex = parseInt(r(this, ft).style.zIndex) + 1e3);
+                        }, Vt = new WeakSet(), ln = function() {
+                            r(this, ft).classList.remove("focused"), !(r(this, _t) || !this.isVisible) && (r(this, ft).hidden = !0, r(this, ft).style.zIndex = parseInt(r(this, ft).style.zIndex) - 1e3);
                         };
-                        class N extends C {
-                            constructor(U) {
-                                super(U, {
+                        class N extends T {
+                            constructor(j) {
+                                super(j, {
                                     isRenderable: !0,
                                     ignoreBorder: !0
-                                }), this.textContent = U.data.textContent, this.textPosition = U.data.textPosition, this.annotationEditorType = n.AnnotationEditorType.FREETEXT;
+                                }), this.textContent = j.data.textContent, this.textPosition = j.data.textPosition, this.annotationEditorType = e.AnnotationEditorType.FREETEXT;
                             }
                             render() {
                                 if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
-                                    const U = document.createElement("div");
-                                    U.classList.add("annotationTextContent"), U.setAttribute("role", "comment");
-                                    for (const u of this.textContent) {
+                                    const j = document.createElement("div");
+                                    j.classList.add("annotationTextContent"), j.setAttribute("role", "comment");
+                                    for (const c of this.textContent) {
                                         const L = document.createElement("span");
-                                        L.textContent = u, U.append(L);
+                                        L.textContent = c, j.append(L);
                                     }
-                                    this.container.append(U);
+                                    this.container.append(j);
                                 }
                                 return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
                             }
                         }
-                        e.FreeTextAnnotationElement = N;
-                        class D extends C {
-                            constructor(u) {
-                                super(u, {
+                        t.FreeTextAnnotationElement = N;
+                        class D extends T {
+                            constructor(c) {
+                                super(c, {
                                     isRenderable: !0,
                                     ignoreBorder: !0
                                 });
-                                W(this, ne, null);
+                                W(this, nt, null);
                             }
                             render() {
                                 this.container.classList.add("lineAnnotation");
-                                const u = this.data,
+                                const c = this.data,
                                     {
                                         width: L,
-                                        height: j
-                                    } = S(u.rect),
-                                    V = this.svgFactory.create(L, j, !0),
-                                    Q = oe(this, ne, this.svgFactory.createElement("svg:line"));
-                                return Q.setAttribute("x1", u.rect[2] - u.lineCoordinates[0]), Q.setAttribute("y1", u.rect[3] - u.lineCoordinates[1]), Q.setAttribute("x2", u.rect[2] - u.lineCoordinates[2]), Q.setAttribute("y2", u.rect[3] - u.lineCoordinates[3]), Q.setAttribute("stroke-width", u.borderStyle.width || 1), Q.setAttribute("stroke", "transparent"), Q.setAttribute("fill", "transparent"), V.append(Q), this.container.append(V), !u.popupRef && this.hasPopupData && this._createPopup(), this.container;
+                                        height: q
+                                    } = R(c.rect),
+                                    K = this.svgFactory.create(L, q, !0),
+                                    tt = ot(this, nt, this.svgFactory.createElement("svg:line"));
+                                return tt.setAttribute("x1", c.rect[2] - c.lineCoordinates[0]), tt.setAttribute("y1", c.rect[3] - c.lineCoordinates[1]), tt.setAttribute("x2", c.rect[2] - c.lineCoordinates[2]), tt.setAttribute("y2", c.rect[3] - c.lineCoordinates[3]), tt.setAttribute("stroke-width", c.borderStyle.width || 1), tt.setAttribute("stroke", "transparent"), tt.setAttribute("fill", "transparent"), K.append(tt), this.container.append(K), !c.popupRef && this.hasPopupData && this._createPopup(), this.container;
                             }
                             getElementsToTriggerPopup() {
-                                return a(this, ne);
+                                return r(this, nt);
                             }
                             addHighlightArea() {
                                 this.container.classList.add("highlightArea");
                             }
                         }
-                        ne = new WeakMap();
-                        class X extends C {
-                            constructor(u) {
-                                super(u, {
+                        nt = new WeakMap();
+                        class X extends T {
+                            constructor(c) {
+                                super(c, {
                                     isRenderable: !0,
                                     ignoreBorder: !0
                                 });
-                                W(this, J, null);
+                                W(this, Q, null);
                             }
                             render() {
                                 this.container.classList.add("squareAnnotation");
-                                const u = this.data,
+                                const c = this.data,
                                     {
                                         width: L,
-                                        height: j
-                                    } = S(u.rect),
-                                    V = this.svgFactory.create(L, j, !0),
-                                    Q = u.borderStyle.width,
-                                    he = oe(this, J, this.svgFactory.createElement("svg:rect"));
-                                return he.setAttribute("x", Q / 2), he.setAttribute("y", Q / 2), he.setAttribute("width", L - Q), he.setAttribute("height", j - Q), he.setAttribute("stroke-width", Q || 1), he.setAttribute("stroke", "transparent"), he.setAttribute("fill", "transparent"), V.append(he), this.container.append(V), !u.popupRef && this.hasPopupData && this._createPopup(), this.container;
+                                        height: q
+                                    } = R(c.rect),
+                                    K = this.svgFactory.create(L, q, !0),
+                                    tt = c.borderStyle.width,
+                                    ct = ot(this, Q, this.svgFactory.createElement("svg:rect"));
+                                return ct.setAttribute("x", tt / 2), ct.setAttribute("y", tt / 2), ct.setAttribute("width", L - tt), ct.setAttribute("height", q - tt), ct.setAttribute("stroke-width", tt || 1), ct.setAttribute("stroke", "transparent"), ct.setAttribute("fill", "transparent"), K.append(ct), this.container.append(K), !c.popupRef && this.hasPopupData && this._createPopup(), this.container;
                             }
                             getElementsToTriggerPopup() {
-                                return a(this, J);
+                                return r(this, Q);
                             }
                             addHighlightArea() {
                                 this.container.classList.add("highlightArea");
                             }
                         }
-                        J = new WeakMap();
-                        class G extends C {
-                            constructor(u) {
-                                super(u, {
+                        Q = new WeakMap();
+                        class Y extends T {
+                            constructor(c) {
+                                super(c, {
                                     isRenderable: !0,
                                     ignoreBorder: !0
                                 });
-                                W(this, ve, null);
+                                W(this, At, null);
                             }
                             render() {
                                 this.container.classList.add("circleAnnotation");
-                                const u = this.data,
+                                const c = this.data,
                                     {
                                         width: L,
-                                        height: j
-                                    } = S(u.rect),
-                                    V = this.svgFactory.create(L, j, !0),
-                                    Q = u.borderStyle.width,
-                                    he = oe(this, ve, this.svgFactory.createElement("svg:ellipse"));
-                                return he.setAttribute("cx", L / 2), he.setAttribute("cy", j / 2), he.setAttribute("rx", L / 2 - Q / 2), he.setAttribute("ry", j / 2 - Q / 2), he.setAttribute("stroke-width", Q || 1), he.setAttribute("stroke", "transparent"), he.setAttribute("fill", "transparent"), V.append(he), this.container.append(V), !u.popupRef && this.hasPopupData && this._createPopup(), this.container;
+                                        height: q
+                                    } = R(c.rect),
+                                    K = this.svgFactory.create(L, q, !0),
+                                    tt = c.borderStyle.width,
+                                    ct = ot(this, At, this.svgFactory.createElement("svg:ellipse"));
+                                return ct.setAttribute("cx", L / 2), ct.setAttribute("cy", q / 2), ct.setAttribute("rx", L / 2 - tt / 2), ct.setAttribute("ry", q / 2 - tt / 2), ct.setAttribute("stroke-width", tt || 1), ct.setAttribute("stroke", "transparent"), ct.setAttribute("fill", "transparent"), K.append(ct), this.container.append(K), !c.popupRef && this.hasPopupData && this._createPopup(), this.container;
                             }
                             getElementsToTriggerPopup() {
-                                return a(this, ve);
+                                return r(this, At);
                             }
                             addHighlightArea() {
                                 this.container.classList.add("highlightArea");
                             }
                         }
-                        ve = new WeakMap();
-                        class I extends C {
-                            constructor(u) {
-                                super(u, {
+                        At = new WeakMap();
+                        class I extends T {
+                            constructor(c) {
+                                super(c, {
                                     isRenderable: !0,
                                     ignoreBorder: !0
                                 });
-                                W(this, Se, null);
+                                W(this, wt, null);
                                 this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
                             }
                             render() {
                                 this.container.classList.add(this.containerClassName);
-                                const u = this.data,
+                                const c = this.data,
                                     {
                                         width: L,
-                                        height: j
-                                    } = S(u.rect),
-                                    V = this.svgFactory.create(L, j, !0);
-                                let Q = [];
-                                for (const ye of u.vertices) {
-                                    const Me = ye.x - u.rect[0],
-                                        Re = u.rect[3] - ye.y;
-                                    Q.push(Me + "," + Re);
-                                }
-                                Q = Q.join(" ");
-                                const he = oe(this, Se, this.svgFactory.createElement(this.svgElementName));
-                                return he.setAttribute("points", Q), he.setAttribute("stroke-width", u.borderStyle.width || 1), he.setAttribute("stroke", "transparent"), he.setAttribute("fill", "transparent"), V.append(he), this.container.append(V), !u.popupRef && this.hasPopupData && this._createPopup(), this.container;
+                                        height: q
+                                    } = R(c.rect),
+                                    K = this.svgFactory.create(L, q, !0);
+                                let tt = [];
+                                for (const bt of c.vertices) {
+                                    const Mt = bt.x - c.rect[0],
+                                        Ft = c.rect[3] - bt.y;
+                                    tt.push(Mt + "," + Ft);
+                                }
+                                tt = tt.join(" ");
+                                const ct = ot(this, wt, this.svgFactory.createElement(this.svgElementName));
+                                return ct.setAttribute("points", tt), ct.setAttribute("stroke-width", c.borderStyle.width || 1), ct.setAttribute("stroke", "transparent"), ct.setAttribute("fill", "transparent"), K.append(ct), this.container.append(K), !c.popupRef && this.hasPopupData && this._createPopup(), this.container;
                             }
                             getElementsToTriggerPopup() {
-                                return a(this, Se);
+                                return r(this, wt);
                             }
                             addHighlightArea() {
                                 this.container.classList.add("highlightArea");
                             }
                         }
-                        Se = new WeakMap();
-                        class B extends I {
-                            constructor(U) {
-                                super(U), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
+                        wt = new WeakMap();
+                        class U extends I {
+                            constructor(j) {
+                                super(j), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
                             }
                         }
-                        class ee extends C {
-                            constructor(U) {
-                                super(U, {
+                        class G extends T {
+                            constructor(j) {
+                                super(j, {
                                     isRenderable: !0,
                                     ignoreBorder: !0
                                 });
                             }
                             render() {
                                 return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
                             }
                         }
-                        class Y extends C {
-                            constructor(u) {
-                                super(u, {
+                        class V extends T {
+                            constructor(c) {
+                                super(c, {
                                     isRenderable: !0,
                                     ignoreBorder: !0
                                 });
-                                W(this, tt, []);
-                                this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = n.AnnotationEditorType.INK;
+                                W(this, te, []);
+                                this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = e.AnnotationEditorType.INK;
                             }
                             render() {
                                 this.container.classList.add(this.containerClassName);
-                                const u = this.data,
+                                const c = this.data,
                                     {
                                         width: L,
-                                        height: j
-                                    } = S(u.rect),
-                                    V = this.svgFactory.create(L, j, !0);
-                                for (const Q of u.inkLists) {
-                                    let he = [];
-                                    for (const Me of Q) {
-                                        const Re = Me.x - u.rect[0],
-                                            qe = u.rect[3] - Me.y;
-                                        he.push(`${Re},${qe}`);
-                                    }
-                                    he = he.join(" ");
-                                    const ye = this.svgFactory.createElement(this.svgElementName);
-                                    a(this, tt).push(ye), ye.setAttribute("points", he), ye.setAttribute("stroke-width", u.borderStyle.width || 1), ye.setAttribute("stroke", "transparent"), ye.setAttribute("fill", "transparent"), !u.popupRef && this.hasPopupData && this._createPopup(), V.append(ye);
+                                        height: q
+                                    } = R(c.rect),
+                                    K = this.svgFactory.create(L, q, !0);
+                                for (const tt of c.inkLists) {
+                                    let ct = [];
+                                    for (const Mt of tt) {
+                                        const Ft = Mt.x - c.rect[0],
+                                            Ht = c.rect[3] - Mt.y;
+                                        ct.push(`${Ft},${Ht}`);
+                                    }
+                                    ct = ct.join(" ");
+                                    const bt = this.svgFactory.createElement(this.svgElementName);
+                                    r(this, te).push(bt), bt.setAttribute("points", ct), bt.setAttribute("stroke-width", c.borderStyle.width || 1), bt.setAttribute("stroke", "transparent"), bt.setAttribute("fill", "transparent"), !c.popupRef && this.hasPopupData && this._createPopup(), K.append(bt);
                                 }
-                                return this.container.append(V), this.container;
+                                return this.container.append(K), this.container;
                             }
                             getElementsToTriggerPopup() {
-                                return a(this, tt);
+                                return r(this, te);
                             }
                             addHighlightArea() {
                                 this.container.classList.add("highlightArea");
                             }
                         }
-                        tt = new WeakMap(), e.InkAnnotationElement = Y;
-                        class q extends C {
-                            constructor(U) {
-                                super(U, {
+                        te = new WeakMap(), t.InkAnnotationElement = V;
+                        class H extends T {
+                            constructor(j) {
+                                super(j, {
                                     isRenderable: !0,
                                     ignoreBorder: !0,
                                     createQuadrilaterals: !0
                                 });
                             }
                             render() {
                                 return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this.container;
                             }
                         }
-                        class le extends C {
-                            constructor(U) {
-                                super(U, {
+                        class st extends T {
+                            constructor(j) {
+                                super(j, {
                                     isRenderable: !0,
                                     ignoreBorder: !0,
                                     createQuadrilaterals: !0
                                 });
                             }
                             render() {
                                 return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
                             }
                         }
-                        class pe extends C {
-                            constructor(U) {
-                                super(U, {
+                        class dt extends T {
+                            constructor(j) {
+                                super(j, {
                                     isRenderable: !0,
                                     ignoreBorder: !0,
                                     createQuadrilaterals: !0
                                 });
                             }
                             render() {
                                 return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
                             }
                         }
-                        class we extends C {
-                            constructor(U) {
-                                super(U, {
+                        class yt extends T {
+                            constructor(j) {
+                                super(j, {
                                     isRenderable: !0,
                                     ignoreBorder: !0,
                                     createQuadrilaterals: !0
                                 });
                             }
                             render() {
                                 return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
                             }
                         }
-                        class be extends C {
-                            constructor(U) {
-                                super(U, {
+                        class gt extends T {
+                            constructor(j) {
+                                super(j, {
                                     isRenderable: !0,
                                     ignoreBorder: !0
                                 });
                             }
                             render() {
                                 return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
                             }
                         }
-                        e.StampAnnotationElement = be;
-                        class R extends C {
-                            constructor(u) {
-                                var V;
-                                super(u, {
+                        t.StampAnnotationElement = gt;
+                        class k extends T {
+                            constructor(c) {
+                                var K;
+                                super(c, {
                                     isRenderable: !0
                                 });
-                                W(this, te);
-                                W(this, et, null);
+                                W(this, et);
+                                W(this, Qt, null);
                                 const {
                                     filename: L,
-                                    content: j
+                                    content: q
                                 } = this.data.file;
-                                this.filename = (0, s.getFilenameFromUrl)(L, !0), this.content = j, (V = this.linkService.eventBus) == null || V.dispatch("fileattachmentannotation", {
+                                this.filename = (0, s.getFilenameFromUrl)(L, !0), this.content = q, (K = this.linkService.eventBus) == null || K.dispatch("fileattachmentannotation", {
                                     source: this,
                                     filename: L,
-                                    content: j
+                                    content: q
                                 });
                             }
                             render() {
                                 this.container.classList.add("fileAttachmentAnnotation");
                                 const {
-                                    container: u,
+                                    container: c,
                                     data: L
                                 } = this;
-                                let j;
-                                L.hasAppearance || L.fillAlpha === 0 ? j = document.createElement("div") : (j = document.createElement("img"), j.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(L.name) ? "paperclip" : "pushpin"}.svg`, L.fillAlpha && L.fillAlpha < 1 && (j.style = `filter: opacity(${Math.round(L.fillAlpha * 100)}%);`)), j.addEventListener("dblclick", K(this, te, hn).bind(this)), oe(this, et, j);
+                                let q;
+                                L.hasAppearance || L.fillAlpha === 0 ? q = document.createElement("div") : (q = document.createElement("img"), q.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(L.name) ? "paperclip" : "pushpin"}.svg`, L.fillAlpha && L.fillAlpha < 1 && (q.style = `filter: opacity(${Math.round(L.fillAlpha * 100)}%);`)), q.addEventListener("dblclick", J(this, et, cn).bind(this)), ot(this, Qt, q);
                                 const {
-                                    isMac: V
-                                } = n.FeatureTest.platform;
-                                return u.addEventListener("keydown", (Q) => {
-                                    Q.key === "Enter" && (V ? Q.metaKey : Q.ctrlKey) && K(this, te, hn).call(this);
-                                }), !L.popupRef && this.hasPopupData ? this._createPopup() : j.classList.add("popupTriggerArea"), u.append(j), u;
+                                    isMac: K
+                                } = e.FeatureTest.platform;
+                                return c.addEventListener("keydown", (tt) => {
+                                    tt.key === "Enter" && (K ? tt.metaKey : tt.ctrlKey) && J(this, et, cn).call(this);
+                                }), !L.popupRef && this.hasPopupData ? this._createPopup() : q.classList.add("popupTriggerArea"), c.append(q), c;
                             }
                             getElementsToTriggerPopup() {
-                                return a(this, et);
+                                return r(this, Qt);
                             }
                             addHighlightArea() {
                                 this.container.classList.add("highlightArea");
                             }
                         }
-                        et = new WeakMap(), te = new WeakSet(), hn = function() {
-                            var u;
-                            (u = this.downloadManager) == null || u.openOrDownloadData(this.container, this.content, this.filename);
+                        Qt = new WeakMap(), et = new WeakSet(), cn = function() {
+                            var c;
+                            (c = this.downloadManager) == null || c.openOrDownloadData(this.container, this.content, this.filename);
                         };
-                        class d {
+                        class l {
                             constructor({
-                                div: U,
-                                accessibilityManager: u,
+                                div: j,
+                                accessibilityManager: c,
                                 annotationCanvasMap: L,
-                                l10n: j,
-                                page: V,
-                                viewport: Q
+                                l10n: q,
+                                page: K,
+                                viewport: tt
                             }) {
-                                W(this, Be);
-                                W(this, Ae);
-                                W(this, Ne, null);
-                                W(this, ke, null);
-                                W(this, $e, /* @__PURE__ */ new Map());
-                                this.div = U, oe(this, Ne, u), oe(this, ke, L), this.l10n = j, this.page = V, this.viewport = Q, this.zIndex = 0, this.l10n || (this.l10n = _.NullL10n);
+                                W(this, Nt);
+                                W(this, vt);
+                                W(this, Ot, null);
+                                W(this, Pt, null);
+                                W(this, $t, /* @__PURE__ */ new Map());
+                                this.div = j, ot(this, Ot, c), ot(this, Pt, L), this.l10n = q, this.page = K, this.viewport = tt, this.zIndex = 0, this.l10n || (this.l10n = A.NullL10n);
                             }
-                            async render(U) {
+                            async render(j) {
                                 const {
-                                    annotations: u
-                                } = U, L = this.div;
+                                    annotations: c
+                                } = j, L = this.div;
                                 (0, s.setLayerDimensions)(L, this.viewport);
-                                const j = /* @__PURE__ */ new Map(),
-                                    V = {
+                                const q = /* @__PURE__ */ new Map(),
+                                    K = {
                                         data: null,
                                         layer: L,
-                                        linkService: U.linkService,
-                                        downloadManager: U.downloadManager,
-                                        imageResourcesPath: U.imageResourcesPath || "",
-                                        renderForms: U.renderForms !== !1,
+                                        linkService: j.linkService,
+                                        downloadManager: j.downloadManager,
+                                        imageResourcesPath: j.imageResourcesPath || "",
+                                        renderForms: j.renderForms !== !1,
                                         svgFactory: new s.DOMSVGFactory(),
-                                        annotationStorage: U.annotationStorage || new l.AnnotationStorage(),
-                                        enableScripting: U.enableScripting === !0,
-                                        hasJSActions: U.hasJSActions,
-                                        fieldObjects: U.fieldObjects,
+                                        annotationStorage: j.annotationStorage || new p.AnnotationStorage(),
+                                        enableScripting: j.enableScripting === !0,
+                                        hasJSActions: j.hasJSActions,
+                                        fieldObjects: j.fieldObjects,
                                         parent: this,
                                         elements: null
                                     };
-                                for (const Q of u) {
-                                    if (Q.noHTML)
+                                for (const tt of c) {
+                                    if (tt.noHTML)
                                         continue;
-                                    const he = Q.annotationType === n.AnnotationType.POPUP;
-                                    if (he) {
-                                        const Re = j.get(Q.id);
-                                        if (!Re)
+                                    const ct = tt.annotationType === e.AnnotationType.POPUP;
+                                    if (ct) {
+                                        const Ft = q.get(tt.id);
+                                        if (!Ft)
                                             continue;
-                                        V.elements = Re;
+                                        K.elements = Ft;
                                     } else {
                                         const {
-                                            width: Re,
-                                            height: qe
-                                        } = S(Q.rect);
-                                        if (Re <= 0 || qe <= 0)
+                                            width: Ft,
+                                            height: Ht
+                                        } = R(tt.rect);
+                                        if (Ft <= 0 || Ht <= 0)
                                             continue;
                                     }
-                                    V.data = Q;
-                                    const ye = w.create(V);
-                                    if (!ye.isRenderable)
+                                    K.data = tt;
+                                    const bt = w.create(K);
+                                    if (!bt.isRenderable)
                                         continue;
-                                    if (!he && Q.popupRef) {
-                                        const Re = j.get(Q.popupRef);
-                                        Re ? Re.push(ye) : j.set(Q.popupRef, [ye]);
-                                    }
-                                    ye.annotationEditorType > 0 && a(this, $e).set(ye.data.id, ye);
-                                    const Me = ye.render();
-                                    Q.hidden && (Me.style.visibility = "hidden"), K(this, Be, Bn).call(this, Me, Q.id);
+                                    if (!ct && tt.popupRef) {
+                                        const Ft = q.get(tt.popupRef);
+                                        Ft ? Ft.push(bt) : q.set(tt.popupRef, [bt]);
+                                    }
+                                    bt.annotationEditorType > 0 && r(this, $t).set(bt.data.id, bt);
+                                    const Mt = bt.render();
+                                    tt.hidden && (Mt.style.visibility = "hidden"), J(this, Nt, Nn).call(this, Mt, tt.id);
                                 }
-                                K(this, Ae, un).call(this), await this.l10n.translate(L);
+                                J(this, vt, hn).call(this), await this.l10n.translate(L);
                             }
                             update({
-                                viewport: U
+                                viewport: j
                             }) {
-                                const u = this.div;
-                                this.viewport = U, (0, s.setLayerDimensions)(u, {
-                                    rotation: U.rotation
-                                }), K(this, Ae, un).call(this), u.hidden = !1;
+                                const c = this.div;
+                                this.viewport = j, (0, s.setLayerDimensions)(c, {
+                                    rotation: j.rotation
+                                }), J(this, vt, hn).call(this), c.hidden = !1;
                             }
                             getEditableAnnotations() {
-                                return Array.from(a(this, $e).values());
+                                return Array.from(r(this, $t).values());
                             }
-                            getEditableAnnotation(U) {
-                                return a(this, $e).get(U);
+                            getEditableAnnotation(j) {
+                                return r(this, $t).get(j);
                             }
                         }
-                        Ne = new WeakMap(), ke = new WeakMap(), $e = new WeakMap(), Be = new WeakSet(), Bn = function(U, u) {
-                            var j;
-                            const L = U.firstChild || U;
-                            L.id = `${n.AnnotationPrefix}${u}`, this.div.append(U), (j = a(this, Ne)) == null || j.moveElementInDOM(this.div, U, L, !1);
-                        }, Ae = new WeakSet(), un = function() {
-                            if (!a(this, ke))
+                        Ot = new WeakMap(), Pt = new WeakMap(), $t = new WeakMap(), Nt = new WeakSet(), Nn = function(j, c) {
+                            var q;
+                            const L = j.firstChild || j;
+                            L.id = `${e.AnnotationPrefix}${c}`, this.div.append(j), (q = r(this, Ot)) == null || q.moveElementInDOM(this.div, j, L, !1);
+                        }, vt = new WeakSet(), hn = function() {
+                            if (!r(this, Pt))
                                 return;
-                            const U = this.div;
-                            for (const [u, L] of a(this, ke)) {
-                                const j = U.querySelector(`[data-annotation-id="${u}"]`);
-                                if (!j)
+                            const j = this.div;
+                            for (const [c, L] of r(this, Pt)) {
+                                const q = j.querySelector(`[data-annotation-id="${c}"]`);
+                                if (!q)
                                     continue;
                                 const {
-                                    firstChild: V
-                                } = j;
-                                V ? V.nodeName === "CANVAS" ? V.replaceWith(L) : V.before(L) : j.append(L);
+                                    firstChild: K
+                                } = q;
+                                K ? K.nodeName === "CANVAS" ? K.replaceWith(L) : K.before(L) : q.append(L);
                             }
-                            a(this, ke).clear();
-                        }, e.AnnotationLayer = d;
+                            r(this, Pt).clear();
+                        }, t.AnnotationLayer = l;
                     },
                     /* 30 */
                     /***/
-                    (t, e) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.ColorConverters = void 0;
+                        }), t.ColorConverters = void 0;
 
-                        function i(l) {
-                            return Math.floor(Math.max(0, Math.min(1, l)) * 255).toString(16).padStart(2, "0");
+                        function n(p) {
+                            return Math.floor(Math.max(0, Math.min(1, p)) * 255).toString(16).padStart(2, "0");
                         }
 
-                        function n(l) {
-                            return Math.max(0, Math.min(255, 255 * l));
+                        function e(p) {
+                            return Math.max(0, Math.min(255, 255 * p));
                         }
                         class s {
-                            static CMYK_G([h, _, c, o]) {
-                                return ["G", 1 - Math.min(1, 0.3 * h + 0.59 * c + 0.11 * _ + o)];
+                            static CMYK_G([f, A, a, h]) {
+                                return ["G", 1 - Math.min(1, 0.3 * f + 0.59 * a + 0.11 * A + h)];
                             }
-                            static G_CMYK([h]) {
-                                return ["CMYK", 0, 0, 0, 1 - h];
+                            static G_CMYK([f]) {
+                                return ["CMYK", 0, 0, 0, 1 - f];
                             }
-                            static G_RGB([h]) {
-                                return ["RGB", h, h, h];
+                            static G_RGB([f]) {
+                                return ["RGB", f, f, f];
                             }
-                            static G_rgb([h]) {
-                                return h = n(h), [h, h, h];
+                            static G_rgb([f]) {
+                                return f = e(f), [f, f, f];
                             }
-                            static G_HTML([h]) {
-                                const _ = i(h);
-                                return `#${_}${_}${_}`;
+                            static G_HTML([f]) {
+                                const A = n(f);
+                                return `#${A}${A}${A}`;
                             }
-                            static RGB_G([h, _, c]) {
-                                return ["G", 0.3 * h + 0.59 * _ + 0.11 * c];
+                            static RGB_G([f, A, a]) {
+                                return ["G", 0.3 * f + 0.59 * A + 0.11 * a];
                             }
-                            static RGB_rgb(h) {
-                                return h.map(n);
+                            static RGB_rgb(f) {
+                                return f.map(e);
                             }
-                            static RGB_HTML(h) {
-                                return `#${h.map(i).join("")}`;
+                            static RGB_HTML(f) {
+                                return `#${f.map(n).join("")}`;
                             }
                             static T_HTML() {
                                 return "#00000000";
                             }
                             static T_rgb() {
                                 return [null];
                             }
-                            static CMYK_RGB([h, _, c, o]) {
-                                return ["RGB", 1 - Math.min(1, h + o), 1 - Math.min(1, c + o), 1 - Math.min(1, _ + o)];
+                            static CMYK_RGB([f, A, a, h]) {
+                                return ["RGB", 1 - Math.min(1, f + h), 1 - Math.min(1, a + h), 1 - Math.min(1, A + h)];
                             }
-                            static CMYK_rgb([h, _, c, o]) {
-                                return [n(1 - Math.min(1, h + o)), n(1 - Math.min(1, c + o)), n(1 - Math.min(1, _ + o))];
+                            static CMYK_rgb([f, A, a, h]) {
+                                return [e(1 - Math.min(1, f + h)), e(1 - Math.min(1, a + h)), e(1 - Math.min(1, A + h))];
                             }
-                            static CMYK_HTML(h) {
-                                const _ = this.CMYK_RGB(h).slice(1);
-                                return this.RGB_HTML(_);
+                            static CMYK_HTML(f) {
+                                const A = this.CMYK_RGB(f).slice(1);
+                                return this.RGB_HTML(A);
                             }
-                            static RGB_CMYK([h, _, c]) {
-                                const o = 1 - h,
-                                    r = 1 - _,
-                                    T = 1 - c,
-                                    S = Math.min(o, r, T);
-                                return ["CMYK", o, r, T, S];
+                            static RGB_CMYK([f, A, a]) {
+                                const h = 1 - f,
+                                    o = 1 - A,
+                                    F = 1 - a,
+                                    R = Math.min(h, o, F);
+                                return ["CMYK", h, o, F, R];
                             }
                         }
-                        e.ColorConverters = s;
+                        t.ColorConverters = s;
                     },
                     /* 31 */
                     /***/
-                    (t, e) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.NullL10n = void 0, e.getL10nFallback = n;
-                        const i = {
+                        }), t.NullL10n = void 0, t.getL10nFallback = e;
+                        const n = {
                             of_pages: "of {{pagesCount}}",
                             page_of_pages: "({{pageNumber}} of {{pagesCount}})",
                             document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
                             document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
                             document_properties_date_string: "{{date}}, {{time}}",
                             document_properties_page_size_unit_inches: "in",
                             document_properties_page_size_unit_millimeters: "mm",
@@ -20031,1836 +16628,1876 @@
                             editor_free_text2_aria_label: "Text Editor",
                             editor_ink2_aria_label: "Draw Editor",
                             editor_ink_canvas_aria_label: "User-created image",
                             editor_alt_text_button_label: "Alt text",
                             editor_alt_text_edit_button_label: "Edit alt text",
                             editor_alt_text_decorative_tooltip: "Marked as decorative"
                         };
-                        i.print_progress_percent = "{{progress}}%";
+                        n.print_progress_percent = "{{progress}}%";
 
-                        function n(h, _) {
-                            switch (h) {
+                        function e(f, A) {
+                            switch (f) {
                                 case "find_match_count":
-                                    h = `find_match_count[${_.total === 1 ? "one" : "other"}]`;
+                                    f = `find_match_count[${A.total === 1 ? "one" : "other"}]`;
                                     break;
                                 case "find_match_count_limit":
-                                    h = `find_match_count_limit[${_.limit === 1 ? "one" : "other"}]`;
+                                    f = `find_match_count_limit[${A.limit === 1 ? "one" : "other"}]`;
                                     break;
                             }
-                            return i[h] || "";
+                            return n[f] || "";
                         }
 
-                        function s(h, _) {
-                            return _ ? h.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (c, o) => o in _ ? _[o] : "{{" + o + "}}") : h;
+                        function s(f, A) {
+                            return A ? f.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (a, h) => h in A ? A[h] : "{{" + h + "}}") : f;
                         }
-                        const l = {
+                        const p = {
                             async getLanguage() {
                                 return "en-us";
                             },
                             async getDirection() {
                                 return "ltr";
                             },
-                            async get(h, _ = null, c = n(h, _)) {
-                                return s(c, _);
+                            async get(f, A = null, a = e(f, A)) {
+                                return s(a, A);
                             },
-                            async translate(h) {}
+                            async translate(f) {}
                         };
-                        e.NullL10n = l;
+                        t.NullL10n = p;
                     },
                     /* 32 */
                     /***/
-                    (t, e, i) => {
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.XfaLayer = void 0;
-                        var n = i(25);
+                        }), t.XfaLayer = void 0;
+                        var e = n(25);
                         class s {
-                            static setupStorage(h, _, c, o, r) {
-                                const T = o.getValue(_, {
+                            static setupStorage(f, A, a, h, o) {
+                                const F = h.getValue(A, {
                                     value: null
                                 });
-                                switch (c.name) {
+                                switch (a.name) {
                                     case "textarea":
-                                        if (T.value !== null && (h.textContent = T.value), r === "print")
+                                        if (F.value !== null && (f.textContent = F.value), o === "print")
                                             break;
-                                        h.addEventListener("input", (S) => {
-                                            o.setValue(_, {
-                                                value: S.target.value
+                                        f.addEventListener("input", (R) => {
+                                            h.setValue(A, {
+                                                value: R.target.value
                                             });
                                         });
                                         break;
                                     case "input":
-                                        if (c.attributes.type === "radio" || c.attributes.type === "checkbox") {
-                                            if (T.value === c.attributes.xfaOn ? h.setAttribute("checked", !0) : T.value === c.attributes.xfaOff && h.removeAttribute("checked"), r === "print")
+                                        if (a.attributes.type === "radio" || a.attributes.type === "checkbox") {
+                                            if (F.value === a.attributes.xfaOn ? f.setAttribute("checked", !0) : F.value === a.attributes.xfaOff && f.removeAttribute("checked"), o === "print")
                                                 break;
-                                            h.addEventListener("change", (S) => {
-                                                o.setValue(_, {
-                                                    value: S.target.checked ? S.target.getAttribute("xfaOn") : S.target.getAttribute("xfaOff")
+                                            f.addEventListener("change", (R) => {
+                                                h.setValue(A, {
+                                                    value: R.target.checked ? R.target.getAttribute("xfaOn") : R.target.getAttribute("xfaOff")
                                                 });
                                             });
                                         } else {
-                                            if (T.value !== null && h.setAttribute("value", T.value), r === "print")
+                                            if (F.value !== null && f.setAttribute("value", F.value), o === "print")
                                                 break;
-                                            h.addEventListener("input", (S) => {
-                                                o.setValue(_, {
-                                                    value: S.target.value
+                                            f.addEventListener("input", (R) => {
+                                                h.setValue(A, {
+                                                    value: R.target.value
                                                 });
                                             });
                                         }
                                         break;
                                     case "select":
-                                        if (T.value !== null) {
-                                            h.setAttribute("value", T.value);
-                                            for (const S of c.children)
-                                                S.attributes.value === T.value ? S.attributes.selected = !0 : S.attributes.hasOwnProperty("selected") && delete S.attributes.selected;
+                                        if (F.value !== null) {
+                                            f.setAttribute("value", F.value);
+                                            for (const R of a.children)
+                                                R.attributes.value === F.value ? R.attributes.selected = !0 : R.attributes.hasOwnProperty("selected") && delete R.attributes.selected;
                                         }
-                                        h.addEventListener("input", (S) => {
-                                            const w = S.target.options,
-                                                C = w.selectedIndex === -1 ? "" : w[w.selectedIndex].value;
-                                            o.setValue(_, {
-                                                value: C
+                                        f.addEventListener("input", (R) => {
+                                            const w = R.target.options,
+                                                T = w.selectedIndex === -1 ? "" : w[w.selectedIndex].value;
+                                            h.setValue(A, {
+                                                value: T
                                             });
                                         });
                                         break;
                                 }
                             }
                             static setAttributes({
-                                html: h,
-                                element: _,
-                                storage: c = null,
-                                intent: o,
-                                linkService: r
+                                html: f,
+                                element: A,
+                                storage: a = null,
+                                intent: h,
+                                linkService: o
                             }) {
                                 const {
-                                    attributes: T
-                                } = _, S = h instanceof HTMLAnchorElement;
-                                T.type === "radio" && (T.name = `${T.name}-${o}`);
-                                for (const [w, C] of Object.entries(T))
-                                    if (C != null)
+                                    attributes: F
+                                } = A, R = f instanceof HTMLAnchorElement;
+                                F.type === "radio" && (F.name = `${F.name}-${h}`);
+                                for (const [w, T] of Object.entries(F))
+                                    if (T != null)
                                         switch (w) {
                                             case "class":
-                                                C.length && h.setAttribute(w, C.join(" "));
+                                                T.length && f.setAttribute(w, T.join(" "));
                                                 break;
                                             case "dataId":
                                                 break;
                                             case "id":
-                                                h.setAttribute("data-element-id", C);
+                                                f.setAttribute("data-element-id", T);
                                                 break;
                                             case "style":
-                                                Object.assign(h.style, C);
+                                                Object.assign(f.style, T);
                                                 break;
                                             case "textContent":
-                                                h.textContent = C;
+                                                f.textContent = T;
                                                 break;
                                             default:
-                                                (!S || w !== "href" && w !== "newWindow") && h.setAttribute(w, C);
+                                                (!R || w !== "href" && w !== "newWindow") && f.setAttribute(w, T);
                                         }
-                                S && r.addLinkAttributes(h, T.href, T.newWindow), c && T.dataId && this.setupStorage(h, T.dataId, _, c);
+                                R && o.addLinkAttributes(f, F.href, F.newWindow), a && F.dataId && this.setupStorage(f, F.dataId, A, a);
                             }
-                            static render(h) {
+                            static render(f) {
                                 var P;
-                                const _ = h.annotationStorage,
-                                    c = h.linkService,
-                                    o = h.xfaHtml,
-                                    r = h.intent || "display",
-                                    T = document.createElement(o.name);
-                                o.attributes && this.setAttributes({
-                                    html: T,
-                                    element: o,
-                                    intent: r,
-                                    linkService: c
+                                const A = f.annotationStorage,
+                                    a = f.linkService,
+                                    h = f.xfaHtml,
+                                    o = f.intent || "display",
+                                    F = document.createElement(h.name);
+                                h.attributes && this.setAttributes({
+                                    html: F,
+                                    element: h,
+                                    intent: o,
+                                    linkService: a
                                 });
-                                const S = [
-                                        [o, -1, T]
+                                const R = [
+                                        [h, -1, F]
                                     ],
-                                    w = h.div;
-                                if (w.append(T), h.viewport) {
-                                    const b = `matrix(${h.viewport.transform.join(",")})`;
-                                    w.style.transform = b;
-                                }
-                                r !== "richText" && w.setAttribute("class", "xfaLayer xfaFont");
-                                const C = [];
-                                for (; S.length > 0;) {
-                                    const [b, k, F] = S.at(-1);
-                                    if (k + 1 === b.children.length) {
-                                        S.pop();
+                                    w = f.div;
+                                if (w.append(F), f.viewport) {
+                                    const m = `matrix(${f.viewport.transform.join(",")})`;
+                                    w.style.transform = m;
+                                }
+                                o !== "richText" && w.setAttribute("class", "xfaLayer xfaFont");
+                                const T = [];
+                                for (; R.length > 0;) {
+                                    const [m, C, x] = R.at(-1);
+                                    if (C + 1 === m.children.length) {
+                                        R.pop();
                                         continue;
                                     }
-                                    const x = b.children[++S.at(-1)[1]];
-                                    if (x === null)
+                                    const E = m.children[++R.at(-1)[1]];
+                                    if (E === null)
                                         continue;
                                     const {
-                                        name: y
-                                    } = x;
-                                    if (y === "#text") {
-                                        const E = document.createTextNode(x.value);
-                                        C.push(E), F.append(E);
+                                        name: S
+                                    } = E;
+                                    if (S === "#text") {
+                                        const v = document.createTextNode(E.value);
+                                        T.push(v), x.append(v);
                                         continue;
                                     }
-                                    const p = (P = x == null ? void 0 : x.attributes) != null && P.xmlns ? document.createElementNS(x.attributes.xmlns, y) : document.createElement(y);
-                                    if (F.append(p), x.attributes && this.setAttributes({
-                                            html: p,
-                                            element: x,
-                                            storage: _,
-                                            intent: r,
-                                            linkService: c
-                                        }), x.children && x.children.length > 0)
-                                        S.push([x, -1, p]);
-                                    else if (x.value) {
-                                        const E = document.createTextNode(x.value);
-                                        n.XfaText.shouldBuildText(y) && C.push(E), p.append(E);
+                                    const g = (P = E == null ? void 0 : E.attributes) != null && P.xmlns ? document.createElementNS(E.attributes.xmlns, S) : document.createElement(S);
+                                    if (x.append(g), E.attributes && this.setAttributes({
+                                            html: g,
+                                            element: E,
+                                            storage: A,
+                                            intent: o,
+                                            linkService: a
+                                        }), E.children && E.children.length > 0)
+                                        R.push([E, -1, g]);
+                                    else if (E.value) {
+                                        const v = document.createTextNode(E.value);
+                                        e.XfaText.shouldBuildText(S) && T.push(v), g.append(v);
                                     }
                                 }
-                                for (const b of w.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
-                                    b.setAttribute("readOnly", !0);
+                                for (const m of w.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
+                                    m.setAttribute("readOnly", !0);
                                 return {
-                                    textDivs: C
+                                    textDivs: T
                                 };
                             }
-                            static update(h) {
-                                const _ = `matrix(${h.viewport.transform.join(",")})`;
-                                h.div.style.transform = _, h.div.hidden = !1;
+                            static update(f) {
+                                const A = `matrix(${f.viewport.transform.join(",")})`;
+                                f.div.style.transform = A, f.div.hidden = !1;
                             }
                         }
-                        e.XfaLayer = s;
+                        t.XfaLayer = s;
                     },
                     /* 33 */
                     /***/
-                    (t, e, i) => {
-                        var o, r, T, S, w, C, P, b, k, F, x, y, p, E, $, Hn, m, Un, D, jn, G, Gn, B, dn, Y, Wn, le, pn, we, qn, R, zn, g, Xn, v, Vn, O, Yn, z, ot, Z, gn, ue, Ft, fe, It, Fe, pt, De, _n, ie, Lt, ge, Kn, xe, mn, We, Jn, ze, Zn, Ge, bn, de, Dt, J, gt;
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        var h, o, F, R, w, T, P, m, C, x, E, S, g, v, $, Bn, _, Un, D, jn, Y, qn, U, dn, V, Wn, st, un, yt, Hn, k, zn, u, Gn, b, Xn, O, Vn, z, ae, Z, pn, ht, Re, ft, xe, Rt, fe, It, gn, rt, De, pt, Yn, Tt, _n, Wt, Kn, zt, Jn, qt, mn, ut, Ie, Q, pe;
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.InkEditor = void 0;
-                        var n = i(1),
-                            s = i(4),
-                            l = i(29),
-                            h = i(6),
-                            _ = i(5);
-                        const Se = class Se extends s.AnnotationEditor {
-                            constructor(te) {
+                        }), t.InkEditor = void 0;
+                        var e = n(1),
+                            s = n(4),
+                            p = n(29),
+                            f = n(6),
+                            A = n(5);
+                        const wt = class wt extends s.AnnotationEditor {
+                            constructor(et) {
                                 super({
-                                    ...te,
+                                    ...et,
                                     name: "inkEditor"
                                 });
                                 W(this, $);
-                                W(this, m);
+                                W(this, _);
                                 W(this, D);
-                                W(this, G);
-                                W(this, B);
                                 W(this, Y);
-                                W(this, le);
-                                W(this, we);
-                                W(this, R);
-                                W(this, g);
-                                W(this, v);
+                                W(this, U);
+                                W(this, V);
+                                W(this, st);
+                                W(this, yt);
+                                W(this, k);
+                                W(this, u);
+                                W(this, b);
                                 W(this, O);
                                 W(this, z);
                                 W(this, Z);
-                                W(this, ue);
-                                W(this, fe);
-                                W(this, Fe);
-                                W(this, De);
-                                W(this, ie);
-                                W(this, ze);
-                                W(this, Ge);
-                                W(this, de);
-                                W(this, J);
+                                W(this, ht);
+                                W(this, ft);
+                                W(this, Rt);
+                                W(this, It);
+                                W(this, rt);
+                                W(this, zt);
+                                W(this, qt);
+                                W(this, ut);
+                                W(this, Q);
+                                W(this, h, 0);
                                 W(this, o, 0);
-                                W(this, r, 0);
-                                W(this, T, this.canvasPointermove.bind(this));
-                                W(this, S, this.canvasPointerleave.bind(this));
+                                W(this, F, this.canvasPointermove.bind(this));
+                                W(this, R, this.canvasPointerleave.bind(this));
                                 W(this, w, this.canvasPointerup.bind(this));
-                                W(this, C, this.canvasPointerdown.bind(this));
+                                W(this, T, this.canvasPointerdown.bind(this));
                                 W(this, P, new Path2D());
-                                W(this, b, !1);
-                                W(this, k, !1);
-                                W(this, F, !1);
-                                W(this, x, null);
-                                W(this, y, 0);
-                                W(this, p, 0);
+                                W(this, m, !1);
+                                W(this, C, !1);
+                                W(this, x, !1);
                                 W(this, E, null);
-                                this.color = te.color || null, this.thickness = te.thickness || null, this.opacity = te.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
+                                W(this, S, 0);
+                                W(this, g, 0);
+                                W(this, v, null);
+                                this.color = et.color || null, this.thickness = et.thickness || null, this.opacity = et.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
                             }
-                            static initialize(te) {
-                                s.AnnotationEditor.initialize(te, {
+                            static initialize(et) {
+                                s.AnnotationEditor.initialize(et, {
                                     strings: ["editor_ink_canvas_aria_label", "editor_ink2_aria_label"]
                                 });
                             }
-                            static updateDefaultParams(te, Te) {
-                                switch (te) {
-                                    case n.AnnotationEditorParamsType.INK_THICKNESS:
-                                        Se._defaultThickness = Te;
+                            static updateDefaultParams(et, Et) {
+                                switch (et) {
+                                    case e.AnnotationEditorParamsType.INK_THICKNESS:
+                                        wt._defaultThickness = Et;
                                         break;
-                                    case n.AnnotationEditorParamsType.INK_COLOR:
-                                        Se._defaultColor = Te;
+                                    case e.AnnotationEditorParamsType.INK_COLOR:
+                                        wt._defaultColor = Et;
                                         break;
-                                    case n.AnnotationEditorParamsType.INK_OPACITY:
-                                        Se._defaultOpacity = Te / 100;
+                                    case e.AnnotationEditorParamsType.INK_OPACITY:
+                                        wt._defaultOpacity = Et / 100;
                                         break;
                                 }
                             }
-                            updateParams(te, Te) {
-                                switch (te) {
-                                    case n.AnnotationEditorParamsType.INK_THICKNESS:
-                                        K(this, $, Hn).call(this, Te);
+                            updateParams(et, Et) {
+                                switch (et) {
+                                    case e.AnnotationEditorParamsType.INK_THICKNESS:
+                                        J(this, $, Bn).call(this, Et);
                                         break;
-                                    case n.AnnotationEditorParamsType.INK_COLOR:
-                                        K(this, m, Un).call(this, Te);
+                                    case e.AnnotationEditorParamsType.INK_COLOR:
+                                        J(this, _, Un).call(this, Et);
                                         break;
-                                    case n.AnnotationEditorParamsType.INK_OPACITY:
-                                        K(this, D, jn).call(this, Te);
+                                    case e.AnnotationEditorParamsType.INK_OPACITY:
+                                        J(this, D, jn).call(this, Et);
                                         break;
                                 }
                             }
                             static get defaultPropertiesToUpdate() {
                                 return [
-                                    [n.AnnotationEditorParamsType.INK_THICKNESS, Se._defaultThickness],
-                                    [n.AnnotationEditorParamsType.INK_COLOR, Se._defaultColor || s.AnnotationEditor._defaultLineColor],
-                                    [n.AnnotationEditorParamsType.INK_OPACITY, Math.round(Se._defaultOpacity * 100)]
+                                    [e.AnnotationEditorParamsType.INK_THICKNESS, wt._defaultThickness],
+                                    [e.AnnotationEditorParamsType.INK_COLOR, wt._defaultColor || s.AnnotationEditor._defaultLineColor],
+                                    [e.AnnotationEditorParamsType.INK_OPACITY, Math.round(wt._defaultOpacity * 100)]
                                 ];
                             }
                             get propertiesToUpdate() {
                                 return [
-                                    [n.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || Se._defaultThickness],
-                                    [n.AnnotationEditorParamsType.INK_COLOR, this.color || Se._defaultColor || s.AnnotationEditor._defaultLineColor],
-                                    [n.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? Se._defaultOpacity))]
+                                    [e.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || wt._defaultThickness],
+                                    [e.AnnotationEditorParamsType.INK_COLOR, this.color || wt._defaultColor || s.AnnotationEditor._defaultLineColor],
+                                    [e.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? wt._defaultOpacity))]
                                 ];
                             }
                             rebuild() {
-                                this.parent && (super.rebuild(), this.div !== null && (this.canvas || (K(this, ue, Ft).call(this), K(this, fe, It).call(this)), this.isAttachedToDOM || (this.parent.add(this), K(this, Fe, pt).call(this)), K(this, J, gt).call(this)));
+                                this.parent && (super.rebuild(), this.div !== null && (this.canvas || (J(this, ht, Re).call(this), J(this, ft, xe).call(this)), this.isAttachedToDOM || (this.parent.add(this), J(this, Rt, fe).call(this)), J(this, Q, pe).call(this)));
                             }
                             remove() {
-                                this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, a(this, x).disconnect(), oe(this, x, null), super.remove());
+                                this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, r(this, E).disconnect(), ot(this, E, null), super.remove());
                             }
-                            setParent(te) {
-                                !this.parent && te ? this._uiManager.removeShouldRescale(this) : this.parent && te === null && this._uiManager.addShouldRescale(this), super.setParent(te);
+                            setParent(et) {
+                                !this.parent && et ? this._uiManager.removeShouldRescale(this) : this.parent && et === null && this._uiManager.addShouldRescale(this), super.setParent(et);
                             }
                             onScaleChanging() {
-                                const [te, Te] = this.parentDimensions, Ne = this.width * te, ke = this.height * Te;
-                                this.setDimensions(Ne, ke);
+                                const [et, Et] = this.parentDimensions, Ot = this.width * et, Pt = this.height * Et;
+                                this.setDimensions(Ot, Pt);
                             }
                             enableEditMode() {
-                                a(this, b) || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, this.canvas.addEventListener("pointerdown", a(this, C)));
+                                r(this, m) || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, this.canvas.addEventListener("pointerdown", r(this, T)));
                             }
                             disableEditMode() {
-                                !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", a(this, C)));
+                                !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", r(this, T)));
                             }
                             onceAdded() {
                                 this._isDraggable = !this.isEmpty();
                             }
                             isEmpty() {
                                 return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
                             }
                             commit() {
-                                a(this, b) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), oe(this, b, !0), this.div.classList.add("disabled"), K(this, J, gt).call(this, !0), this.makeResizable(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({
+                                r(this, m) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), ot(this, m, !0), this.div.classList.add("disabled"), J(this, Q, pe).call(this, !0), this.makeResizable(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({
                                     preventScroll: !0
                                 }));
                             }
-                            focusin(te) {
-                                this._focusEventsAllowed && (super.focusin(te), this.enableEditMode());
+                            focusin(et) {
+                                this._focusEventsAllowed && (super.focusin(et), this.enableEditMode());
                             }
-                            canvasPointerdown(te) {
-                                te.button !== 0 || !this.isInEditMode() || a(this, b) || (this.setInForeground(), te.preventDefault(), te.type !== "mouse" && this.div.focus(), K(this, Y, Wn).call(this, te.offsetX, te.offsetY));
+                            canvasPointerdown(et) {
+                                et.button !== 0 || !this.isInEditMode() || r(this, m) || (this.setInForeground(), et.preventDefault(), et.type !== "mouse" && this.div.focus(), J(this, V, Wn).call(this, et.offsetX, et.offsetY));
                             }
-                            canvasPointermove(te) {
-                                te.preventDefault(), K(this, le, pn).call(this, te.offsetX, te.offsetY);
+                            canvasPointermove(et) {
+                                et.preventDefault(), J(this, st, un).call(this, et.offsetX, et.offsetY);
                             }
-                            canvasPointerup(te) {
-                                te.preventDefault(), K(this, Z, gn).call(this, te);
+                            canvasPointerup(et) {
+                                et.preventDefault(), J(this, Z, pn).call(this, et);
                             }
-                            canvasPointerleave(te) {
-                                K(this, Z, gn).call(this, te);
+                            canvasPointerleave(et) {
+                                J(this, Z, pn).call(this, et);
                             }
                             get isResizable() {
-                                return !this.isEmpty() && a(this, b);
+                                return !this.isEmpty() && r(this, m);
                             }
                             render() {
                                 if (this.div)
                                     return this.div;
-                                let te, Te;
-                                this.width && (te = this.x, Te = this.y), super.render(), s.AnnotationEditor._l10nPromise.get("editor_ink2_aria_label").then((Ze) => {
-                                    var Ae;
-                                    return (Ae = this.div) == null ? void 0 : Ae.setAttribute("aria-label", Ze);
-                                });
-                                const [Ne, ke, $e, Be] = K(this, G, Gn).call(this);
-                                if (this.setAt(Ne, ke, 0, 0), this.setDims($e, Be), K(this, ue, Ft).call(this), this.width) {
-                                    const [Ze, Ae] = this.parentDimensions;
-                                    this.setAspectRatio(this.width * Ze, this.height * Ae), this.setAt(te * Ze, Te * Ae, this.width * Ze, this.height * Ae), oe(this, F, !0), K(this, Fe, pt).call(this), this.setDims(this.width * Ze, this.height * Ae), K(this, z, ot).call(this), this.div.classList.add("disabled");
+                                let et, Et;
+                                this.width && (et = this.x, Et = this.y), super.render(), s.AnnotationEditor._l10nPromise.get("editor_ink2_aria_label").then((Jt) => {
+                                    var vt;
+                                    return (vt = this.div) == null ? void 0 : vt.setAttribute("aria-label", Jt);
+                                });
+                                const [Ot, Pt, $t, Nt] = J(this, Y, qn).call(this);
+                                if (this.setAt(Ot, Pt, 0, 0), this.setDims($t, Nt), J(this, ht, Re).call(this), this.width) {
+                                    const [Jt, vt] = this.parentDimensions;
+                                    this.setAspectRatio(this.width * Jt, this.height * vt), this.setAt(et * Jt, Et * vt, this.width * Jt, this.height * vt), ot(this, x, !0), J(this, Rt, fe).call(this), this.setDims(this.width * Jt, this.height * vt), J(this, z, ae).call(this), this.div.classList.add("disabled");
                                 } else
                                     this.div.classList.add("editing"), this.enableEditMode();
-                                return K(this, fe, It).call(this), this.div;
+                                return J(this, ft, xe).call(this), this.div;
                             }
-                            setDimensions(te, Te) {
-                                const Ne = Math.round(te),
-                                    ke = Math.round(Te);
-                                if (a(this, y) === Ne && a(this, p) === ke)
+                            setDimensions(et, Et) {
+                                const Ot = Math.round(et),
+                                    Pt = Math.round(Et);
+                                if (r(this, S) === Ot && r(this, g) === Pt)
                                     return;
-                                oe(this, y, Ne), oe(this, p, ke), this.canvas.style.visibility = "hidden";
-                                const [$e, Be] = this.parentDimensions;
-                                this.width = te / $e, this.height = Te / Be, this.fixAndSetPosition(), a(this, b) && K(this, De, _n).call(this, te, Te), K(this, Fe, pt).call(this), K(this, z, ot).call(this), this.canvas.style.visibility = "visible", this.fixDims();
-                            }
-                            static deserialize(te, Te, Ne) {
-                                var V, Q, he;
-                                if (te instanceof l.InkAnnotationElement)
+                                ot(this, S, Ot), ot(this, g, Pt), this.canvas.style.visibility = "hidden";
+                                const [$t, Nt] = this.parentDimensions;
+                                this.width = et / $t, this.height = Et / Nt, this.fixAndSetPosition(), r(this, m) && J(this, It, gn).call(this, et, Et), J(this, Rt, fe).call(this), J(this, z, ae).call(this), this.canvas.style.visibility = "visible", this.fixDims();
+                            }
+                            static deserialize(et, Et, Ot) {
+                                var K, tt, ct;
+                                if (et instanceof p.InkAnnotationElement)
                                     return null;
-                                const ke = super.deserialize(te, Te, Ne);
-                                ke.thickness = te.thickness, ke.color = n.Util.makeHexColor(...te.color), ke.opacity = te.opacity;
-                                const [$e, Be] = ke.pageDimensions, Ze = ke.width * $e, Ae = ke.height * Be, Ke = ke.parentScale, Oe = te.thickness / 2;
-                                oe(ke, b, !0), oe(ke, y, Math.round(Ze)), oe(ke, p, Math.round(Ae));
+                                const Pt = super.deserialize(et, Et, Ot);
+                                Pt.thickness = et.thickness, Pt.color = e.Util.makeHexColor(...et.color), Pt.opacity = et.opacity;
+                                const [$t, Nt] = Pt.pageDimensions, Jt = Pt.width * $t, vt = Pt.height * Nt, Yt = Pt.parentScale, Lt = et.thickness / 2;
+                                ot(Pt, m, !0), ot(Pt, S, Math.round(Jt)), ot(Pt, g, Math.round(vt));
                                 const {
-                                    paths: U,
-                                    rect: u,
+                                    paths: j,
+                                    rect: c,
                                     rotation: L
-                                } = te;
+                                } = et;
                                 for (let {
-                                        bezier: ye
+                                        bezier: bt
                                     }
-                                    of U) {
-                                    ye = K(V = Se, We, Jn).call(V, ye, u, L);
-                                    const Me = [];
-                                    ke.paths.push(Me);
-                                    let Re = Ke * (ye[0] - Oe),
-                                        qe = Ke * (ye[1] - Oe);
-                                    for (let Le = 2, Ue = ye.length; Le < Ue; Le += 6) {
-                                        const Ve = Ke * (ye[Le] - Oe),
-                                            Je = Ke * (ye[Le + 1] - Oe),
-                                            Qe = Ke * (ye[Le + 2] - Oe),
-                                            st = Ke * (ye[Le + 3] - Oe),
-                                            it = Ke * (ye[Le + 4] - Oe),
-                                            rt = Ke * (ye[Le + 5] - Oe);
-                                        Me.push([
-                                            [Re, qe],
-                                            [Ve, Je],
-                                            [Qe, st],
-                                            [it, rt]
-                                        ]), Re = it, qe = rt;
+                                    of j) {
+                                    bt = J(K = wt, Wt, Kn).call(K, bt, c, L);
+                                    const Mt = [];
+                                    Pt.paths.push(Mt);
+                                    let Ft = Yt * (bt[0] - Lt),
+                                        Ht = Yt * (bt[1] - Lt);
+                                    for (let Dt = 2, Ut = bt.length; Dt < Ut; Dt += 6) {
+                                        const Xt = Yt * (bt[Dt] - Lt),
+                                            Kt = Yt * (bt[Dt + 1] - Lt),
+                                            Zt = Yt * (bt[Dt + 2] - Lt),
+                                            ie = Yt * (bt[Dt + 3] - Lt),
+                                            ne = Yt * (bt[Dt + 4] - Lt),
+                                            se = Yt * (bt[Dt + 5] - Lt);
+                                        Mt.push([
+                                            [Ft, Ht],
+                                            [Xt, Kt],
+                                            [Zt, ie],
+                                            [ne, se]
+                                        ]), Ft = ne, Ht = se;
                                     }
-                                    const Ie = K(this, ge, Kn).call(this, Me);
-                                    ke.bezierPath2D.push(Ie);
+                                    const xt = J(this, pt, Yn).call(this, Mt);
+                                    Pt.bezierPath2D.push(xt);
                                 }
-                                const j = K(Q = ke, Ge, bn).call(Q);
-                                return oe(ke, r, Math.max(s.AnnotationEditor.MIN_SIZE, j[2] - j[0])), oe(ke, o, Math.max(s.AnnotationEditor.MIN_SIZE, j[3] - j[1])), K(he = ke, De, _n).call(he, Ze, Ae), ke;
+                                const q = J(tt = Pt, qt, mn).call(tt);
+                                return ot(Pt, o, Math.max(s.AnnotationEditor.MIN_SIZE, q[2] - q[0])), ot(Pt, h, Math.max(s.AnnotationEditor.MIN_SIZE, q[3] - q[1])), J(ct = Pt, It, gn).call(ct, Jt, vt), Pt;
                             }
                             serialize() {
                                 if (this.isEmpty())
                                     return null;
-                                const te = this.getRect(0, 0),
-                                    Te = s.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
+                                const et = this.getRect(0, 0),
+                                    Et = s.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
                                 return {
-                                    annotationType: n.AnnotationEditorType.INK,
-                                    color: Te,
+                                    annotationType: e.AnnotationEditorType.INK,
+                                    color: Et,
                                     thickness: this.thickness,
                                     opacity: this.opacity,
-                                    paths: K(this, ze, Zn).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, te),
+                                    paths: J(this, zt, Jn).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, et),
                                     pageIndex: this.pageIndex,
-                                    rect: te,
+                                    rect: et,
                                     rotation: this.rotation,
                                     structTreeParentId: this._structTreeParentId
                                 };
                             }
                         };
-                        o = new WeakMap(), r = new WeakMap(), T = new WeakMap(), S = new WeakMap(), w = new WeakMap(), C = new WeakMap(), P = new WeakMap(), b = new WeakMap(), k = new WeakMap(), F = new WeakMap(), x = new WeakMap(), y = new WeakMap(), p = new WeakMap(), E = new WeakMap(), $ = new WeakSet(), Hn = function(te) {
-                            const Te = this.thickness;
+                        h = new WeakMap(), o = new WeakMap(), F = new WeakMap(), R = new WeakMap(), w = new WeakMap(), T = new WeakMap(), P = new WeakMap(), m = new WeakMap(), C = new WeakMap(), x = new WeakMap(), E = new WeakMap(), S = new WeakMap(), g = new WeakMap(), v = new WeakMap(), $ = new WeakSet(), Bn = function(et) {
+                            const Et = this.thickness;
                             this.addCommands({
                                 cmd: () => {
-                                    this.thickness = te, K(this, J, gt).call(this);
+                                    this.thickness = et, J(this, Q, pe).call(this);
                                 },
                                 undo: () => {
-                                    this.thickness = Te, K(this, J, gt).call(this);
+                                    this.thickness = Et, J(this, Q, pe).call(this);
                                 },
                                 mustExec: !0,
-                                type: n.AnnotationEditorParamsType.INK_THICKNESS,
+                                type: e.AnnotationEditorParamsType.INK_THICKNESS,
                                 overwriteIfSameType: !0,
                                 keepUndo: !0
                             });
-                        }, m = new WeakSet(), Un = function(te) {
-                            const Te = this.color;
+                        }, _ = new WeakSet(), Un = function(et) {
+                            const Et = this.color;
                             this.addCommands({
                                 cmd: () => {
-                                    this.color = te, K(this, z, ot).call(this);
+                                    this.color = et, J(this, z, ae).call(this);
                                 },
                                 undo: () => {
-                                    this.color = Te, K(this, z, ot).call(this);
+                                    this.color = Et, J(this, z, ae).call(this);
                                 },
                                 mustExec: !0,
-                                type: n.AnnotationEditorParamsType.INK_COLOR,
+                                type: e.AnnotationEditorParamsType.INK_COLOR,
                                 overwriteIfSameType: !0,
                                 keepUndo: !0
                             });
-                        }, D = new WeakSet(), jn = function(te) {
-                            te /= 100;
-                            const Te = this.opacity;
+                        }, D = new WeakSet(), jn = function(et) {
+                            et /= 100;
+                            const Et = this.opacity;
                             this.addCommands({
                                 cmd: () => {
-                                    this.opacity = te, K(this, z, ot).call(this);
+                                    this.opacity = et, J(this, z, ae).call(this);
                                 },
                                 undo: () => {
-                                    this.opacity = Te, K(this, z, ot).call(this);
+                                    this.opacity = Et, J(this, z, ae).call(this);
                                 },
                                 mustExec: !0,
-                                type: n.AnnotationEditorParamsType.INK_OPACITY,
+                                type: e.AnnotationEditorParamsType.INK_OPACITY,
                                 overwriteIfSameType: !0,
                                 keepUndo: !0
                             });
-                        }, G = new WeakSet(), Gn = function() {
+                        }, Y = new WeakSet(), qn = function() {
                             const {
-                                parentRotation: te,
-                                parentDimensions: [Te, Ne]
+                                parentRotation: et,
+                                parentDimensions: [Et, Ot]
                             } = this;
-                            switch (te) {
+                            switch (et) {
                                 case 90:
-                                    return [0, Ne, Ne, Te];
+                                    return [0, Ot, Ot, Et];
                                 case 180:
-                                    return [Te, Ne, Te, Ne];
+                                    return [Et, Ot, Et, Ot];
                                 case 270:
-                                    return [Te, 0, Ne, Te];
+                                    return [Et, 0, Ot, Et];
                                 default:
-                                    return [0, 0, Te, Ne];
+                                    return [0, 0, Et, Ot];
                             }
-                        }, B = new WeakSet(), dn = function() {
+                        }, U = new WeakSet(), dn = function() {
                             const {
-                                ctx: te,
-                                color: Te,
-                                opacity: Ne,
-                                thickness: ke,
-                                parentScale: $e,
-                                scaleFactor: Be
+                                ctx: et,
+                                color: Et,
+                                opacity: Ot,
+                                thickness: Pt,
+                                parentScale: $t,
+                                scaleFactor: Nt
                             } = this;
-                            te.lineWidth = ke * $e / Be, te.lineCap = "round", te.lineJoin = "round", te.miterLimit = 10, te.strokeStyle = `${Te}${(0, _.opacityToHex)(Ne)}`;
-                        }, Y = new WeakSet(), Wn = function(te, Te) {
-                            this.canvas.addEventListener("contextmenu", h.noContextMenu), this.canvas.addEventListener("pointerleave", a(this, S)), this.canvas.addEventListener("pointermove", a(this, T)), this.canvas.addEventListener("pointerup", a(this, w)), this.canvas.removeEventListener("pointerdown", a(this, C)), this.isEditing = !0, a(this, F) || (oe(this, F, !0), K(this, Fe, pt).call(this), this.thickness || (this.thickness = Se._defaultThickness), this.color || (this.color = Se._defaultColor || s.AnnotationEditor._defaultLineColor), this.opacity ?? (this.opacity = Se._defaultOpacity)), this.currentPath.push([te, Te]), oe(this, k, !1), K(this, B, dn).call(this), oe(this, E, () => {
-                                K(this, g, Xn).call(this), a(this, E) && window.requestAnimationFrame(a(this, E));
-                            }), window.requestAnimationFrame(a(this, E));
-                        }, le = new WeakSet(), pn = function(te, Te) {
-                            const [Ne, ke] = this.currentPath.at(-1);
-                            if (this.currentPath.length > 1 && te === Ne && Te === ke)
+                            et.lineWidth = Pt * $t / Nt, et.lineCap = "round", et.lineJoin = "round", et.miterLimit = 10, et.strokeStyle = `${Et}${(0, A.opacityToHex)(Ot)}`;
+                        }, V = new WeakSet(), Wn = function(et, Et) {
+                            this.canvas.addEventListener("contextmenu", f.noContextMenu), this.canvas.addEventListener("pointerleave", r(this, R)), this.canvas.addEventListener("pointermove", r(this, F)), this.canvas.addEventListener("pointerup", r(this, w)), this.canvas.removeEventListener("pointerdown", r(this, T)), this.isEditing = !0, r(this, x) || (ot(this, x, !0), J(this, Rt, fe).call(this), this.thickness || (this.thickness = wt._defaultThickness), this.color || (this.color = wt._defaultColor || s.AnnotationEditor._defaultLineColor), this.opacity ?? (this.opacity = wt._defaultOpacity)), this.currentPath.push([et, Et]), ot(this, C, !1), J(this, U, dn).call(this), ot(this, v, () => {
+                                J(this, u, Gn).call(this), r(this, v) && window.requestAnimationFrame(r(this, v));
+                            }), window.requestAnimationFrame(r(this, v));
+                        }, st = new WeakSet(), un = function(et, Et) {
+                            const [Ot, Pt] = this.currentPath.at(-1);
+                            if (this.currentPath.length > 1 && et === Ot && Et === Pt)
                                 return;
-                            const $e = this.currentPath;
-                            let Be = a(this, P);
-                            if ($e.push([te, Te]), oe(this, k, !0), $e.length <= 2) {
-                                Be.moveTo(...$e[0]), Be.lineTo(te, Te);
+                            const $t = this.currentPath;
+                            let Nt = r(this, P);
+                            if ($t.push([et, Et]), ot(this, C, !0), $t.length <= 2) {
+                                Nt.moveTo(...$t[0]), Nt.lineTo(et, Et);
                                 return;
                             }
-                            $e.length === 3 && (oe(this, P, Be = new Path2D()), Be.moveTo(...$e[0])), K(this, v, Vn).call(this, Be, ...$e.at(-3), ...$e.at(-2), te, Te);
-                        }, we = new WeakSet(), qn = function() {
+                            $t.length === 3 && (ot(this, P, Nt = new Path2D()), Nt.moveTo(...$t[0])), J(this, b, Xn).call(this, Nt, ...$t.at(-3), ...$t.at(-2), et, Et);
+                        }, yt = new WeakSet(), Hn = function() {
                             if (this.currentPath.length === 0)
                                 return;
-                            const te = this.currentPath.at(-1);
-                            a(this, P).lineTo(...te);
-                        }, R = new WeakSet(), zn = function(te, Te) {
-                            oe(this, E, null), te = Math.min(Math.max(te, 0), this.canvas.width), Te = Math.min(Math.max(Te, 0), this.canvas.height), K(this, le, pn).call(this, te, Te), K(this, we, qn).call(this);
-                            let Ne;
+                            const et = this.currentPath.at(-1);
+                            r(this, P).lineTo(...et);
+                        }, k = new WeakSet(), zn = function(et, Et) {
+                            ot(this, v, null), et = Math.min(Math.max(et, 0), this.canvas.width), Et = Math.min(Math.max(Et, 0), this.canvas.height), J(this, st, un).call(this, et, Et), J(this, yt, Hn).call(this);
+                            let Ot;
                             if (this.currentPath.length !== 1)
-                                Ne = K(this, O, Yn).call(this);
+                                Ot = J(this, O, Vn).call(this);
                             else {
-                                const Ae = [te, Te];
-                                Ne = [
-                                    [Ae, Ae.slice(), Ae.slice(), Ae]
+                                const vt = [et, Et];
+                                Ot = [
+                                    [vt, vt.slice(), vt.slice(), vt]
                                 ];
                             }
-                            const ke = a(this, P),
-                                $e = this.currentPath;
-                            this.currentPath = [], oe(this, P, new Path2D());
-                            const Be = () => {
-                                    this.allRawPaths.push($e), this.paths.push(Ne), this.bezierPath2D.push(ke), this.rebuild();
+                            const Pt = r(this, P),
+                                $t = this.currentPath;
+                            this.currentPath = [], ot(this, P, new Path2D());
+                            const Nt = () => {
+                                    this.allRawPaths.push($t), this.paths.push(Ot), this.bezierPath2D.push(Pt), this.rebuild();
                                 },
-                                Ze = () => {
-                                    this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (K(this, ue, Ft).call(this), K(this, fe, It).call(this)), K(this, J, gt).call(this));
+                                Jt = () => {
+                                    this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (J(this, ht, Re).call(this), J(this, ft, xe).call(this)), J(this, Q, pe).call(this));
                                 };
                             this.addCommands({
-                                cmd: Be,
-                                undo: Ze,
+                                cmd: Nt,
+                                undo: Jt,
                                 mustExec: !0
                             });
-                        }, g = new WeakSet(), Xn = function() {
-                            if (!a(this, k))
+                        }, u = new WeakSet(), Gn = function() {
+                            if (!r(this, C))
                                 return;
-                            oe(this, k, !1);
-                            const te = Math.ceil(this.thickness * this.parentScale),
-                                Te = this.currentPath.slice(-3),
-                                Ne = Te.map((Be) => Be[0]),
-                                ke = Te.map((Be) => Be[1]);
-                            Math.min(...Ne) - te, Math.max(...Ne) + te, Math.min(...ke) - te, Math.max(...ke) + te;
+                            ot(this, C, !1);
+                            const et = Math.ceil(this.thickness * this.parentScale),
+                                Et = this.currentPath.slice(-3),
+                                Ot = Et.map((Nt) => Nt[0]),
+                                Pt = Et.map((Nt) => Nt[1]);
+                            Math.min(...Ot) - et, Math.max(...Ot) + et, Math.min(...Pt) - et, Math.max(...Pt) + et;
                             const {
-                                ctx: $e
+                                ctx: $t
                             } = this;
-                            $e.save(), $e.clearRect(0, 0, this.canvas.width, this.canvas.height);
-                            for (const Be of this.bezierPath2D)
-                                $e.stroke(Be);
-                            $e.stroke(a(this, P)), $e.restore();
-                        }, v = new WeakSet(), Vn = function(te, Te, Ne, ke, $e, Be, Ze) {
-                            const Ae = (Te + ke) / 2,
-                                Ke = (Ne + $e) / 2,
-                                Oe = (ke + Be) / 2,
-                                U = ($e + Ze) / 2;
-                            te.bezierCurveTo(Ae + 2 * (ke - Ae) / 3, Ke + 2 * ($e - Ke) / 3, Oe + 2 * (ke - Oe) / 3, U + 2 * ($e - U) / 3, Oe, U);
-                        }, O = new WeakSet(), Yn = function() {
-                            const te = this.currentPath;
-                            if (te.length <= 2)
+                            $t.save(), $t.clearRect(0, 0, this.canvas.width, this.canvas.height);
+                            for (const Nt of this.bezierPath2D)
+                                $t.stroke(Nt);
+                            $t.stroke(r(this, P)), $t.restore();
+                        }, b = new WeakSet(), Xn = function(et, Et, Ot, Pt, $t, Nt, Jt) {
+                            const vt = (Et + Pt) / 2,
+                                Yt = (Ot + $t) / 2,
+                                Lt = (Pt + Nt) / 2,
+                                j = ($t + Jt) / 2;
+                            et.bezierCurveTo(vt + 2 * (Pt - vt) / 3, Yt + 2 * ($t - Yt) / 3, Lt + 2 * (Pt - Lt) / 3, j + 2 * ($t - j) / 3, Lt, j);
+                        }, O = new WeakSet(), Vn = function() {
+                            const et = this.currentPath;
+                            if (et.length <= 2)
                                 return [
-                                    [te[0], te[0], te.at(-1), te.at(-1)]
+                                    [et[0], et[0], et.at(-1), et.at(-1)]
                                 ];
-                            const Te = [];
-                            let Ne, [ke, $e] = te[0];
-                            for (Ne = 1; Ne < te.length - 2; Ne++) {
-                                const [u, L] = te[Ne], [j, V] = te[Ne + 1], Q = (u + j) / 2, he = (L + V) / 2, ye = [ke + 2 * (u - ke) / 3, $e + 2 * (L - $e) / 3], Me = [Q + 2 * (u - Q) / 3, he + 2 * (L - he) / 3];
-                                Te.push([
-                                    [ke, $e], ye, Me, [Q, he]
-                                ]), [ke, $e] = [Q, he];
-                            }
-                            const [Be, Ze] = te[Ne], [Ae, Ke] = te[Ne + 1], Oe = [ke + 2 * (Be - ke) / 3, $e + 2 * (Ze - $e) / 3], U = [Ae + 2 * (Be - Ae) / 3, Ke + 2 * (Ze - Ke) / 3];
-                            return Te.push([
-                                [ke, $e], Oe, U, [Ae, Ke]
-                            ]), Te;
-                        }, z = new WeakSet(), ot = function() {
+                            const Et = [];
+                            let Ot, [Pt, $t] = et[0];
+                            for (Ot = 1; Ot < et.length - 2; Ot++) {
+                                const [c, L] = et[Ot], [q, K] = et[Ot + 1], tt = (c + q) / 2, ct = (L + K) / 2, bt = [Pt + 2 * (c - Pt) / 3, $t + 2 * (L - $t) / 3], Mt = [tt + 2 * (c - tt) / 3, ct + 2 * (L - ct) / 3];
+                                Et.push([
+                                    [Pt, $t], bt, Mt, [tt, ct]
+                                ]), [Pt, $t] = [tt, ct];
+                            }
+                            const [Nt, Jt] = et[Ot], [vt, Yt] = et[Ot + 1], Lt = [Pt + 2 * (Nt - Pt) / 3, $t + 2 * (Jt - $t) / 3], j = [vt + 2 * (Nt - vt) / 3, Yt + 2 * (Jt - Yt) / 3];
+                            return Et.push([
+                                [Pt, $t], Lt, j, [vt, Yt]
+                            ]), Et;
+                        }, z = new WeakSet(), ae = function() {
                             if (this.isEmpty()) {
-                                K(this, ie, Lt).call(this);
+                                J(this, rt, De).call(this);
                                 return;
                             }
-                            K(this, B, dn).call(this);
+                            J(this, U, dn).call(this);
                             const {
-                                canvas: te,
-                                ctx: Te
+                                canvas: et,
+                                ctx: Et
                             } = this;
-                            Te.setTransform(1, 0, 0, 1, 0, 0), Te.clearRect(0, 0, te.width, te.height), K(this, ie, Lt).call(this);
-                            for (const Ne of this.bezierPath2D)
-                                Te.stroke(Ne);
-                        }, Z = new WeakSet(), gn = function(te) {
-                            this.canvas.removeEventListener("pointerleave", a(this, S)), this.canvas.removeEventListener("pointermove", a(this, T)), this.canvas.removeEventListener("pointerup", a(this, w)), this.canvas.addEventListener("pointerdown", a(this, C)), setTimeout(() => {
-                                this.canvas.removeEventListener("contextmenu", h.noContextMenu);
-                            }, 10), K(this, R, zn).call(this, te.offsetX, te.offsetY), this.addToAnnotationStorage(), this.setInBackground();
-                        }, ue = new WeakSet(), Ft = function() {
-                            this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", s.AnnotationEditor._l10nPromise.get("editor_ink_canvas_aria_label").then((te) => {
-                                var Te;
-                                return (Te = this.canvas) == null ? void 0 : Te.setAttribute("aria-label", te);
+                            Et.setTransform(1, 0, 0, 1, 0, 0), Et.clearRect(0, 0, et.width, et.height), J(this, rt, De).call(this);
+                            for (const Ot of this.bezierPath2D)
+                                Et.stroke(Ot);
+                        }, Z = new WeakSet(), pn = function(et) {
+                            this.canvas.removeEventListener("pointerleave", r(this, R)), this.canvas.removeEventListener("pointermove", r(this, F)), this.canvas.removeEventListener("pointerup", r(this, w)), this.canvas.addEventListener("pointerdown", r(this, T)), setTimeout(() => {
+                                this.canvas.removeEventListener("contextmenu", f.noContextMenu);
+                            }, 10), J(this, k, zn).call(this, et.offsetX, et.offsetY), this.addToAnnotationStorage(), this.setInBackground();
+                        }, ht = new WeakSet(), Re = function() {
+                            this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", s.AnnotationEditor._l10nPromise.get("editor_ink_canvas_aria_label").then((et) => {
+                                var Et;
+                                return (Et = this.canvas) == null ? void 0 : Et.setAttribute("aria-label", et);
                             }), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
-                        }, fe = new WeakSet(), It = function() {
-                            oe(this, x, new ResizeObserver((te) => {
-                                const Te = te[0].contentRect;
-                                Te.width && Te.height && this.setDimensions(Te.width, Te.height);
-                            })), a(this, x).observe(this.div);
-                        }, Fe = new WeakSet(), pt = function() {
-                            if (!a(this, F))
+                        }, ft = new WeakSet(), xe = function() {
+                            ot(this, E, new ResizeObserver((et) => {
+                                const Et = et[0].contentRect;
+                                Et.width && Et.height && this.setDimensions(Et.width, Et.height);
+                            })), r(this, E).observe(this.div);
+                        }, Rt = new WeakSet(), fe = function() {
+                            if (!r(this, x))
                                 return;
-                            const [te, Te] = this.parentDimensions;
-                            this.canvas.width = Math.ceil(this.width * te), this.canvas.height = Math.ceil(this.height * Te), K(this, ie, Lt).call(this);
-                        }, De = new WeakSet(), _n = function(te, Te) {
-                            const Ne = K(this, de, Dt).call(this),
-                                ke = (te - Ne) / a(this, r),
-                                $e = (Te - Ne) / a(this, o);
-                            this.scaleFactor = Math.min(ke, $e);
-                        }, ie = new WeakSet(), Lt = function() {
-                            const te = K(this, de, Dt).call(this) / 2;
-                            this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + te, this.translationY * this.scaleFactor + te);
-                        }, ge = new WeakSet(), Kn = function(te) {
-                            const Te = new Path2D();
-                            for (let Ne = 0, ke = te.length; Ne < ke; Ne++) {
-                                const [$e, Be, Ze, Ae] = te[Ne];
-                                Ne === 0 && Te.moveTo(...$e), Te.bezierCurveTo(Be[0], Be[1], Ze[0], Ze[1], Ae[0], Ae[1]);
-                            }
-                            return Te;
-                        }, xe = new WeakSet(), mn = function(te, Te, Ne) {
-                            const [ke, $e, Be, Ze] = Te;
-                            switch (Ne) {
+                            const [et, Et] = this.parentDimensions;
+                            this.canvas.width = Math.ceil(this.width * et), this.canvas.height = Math.ceil(this.height * Et), J(this, rt, De).call(this);
+                        }, It = new WeakSet(), gn = function(et, Et) {
+                            const Ot = J(this, ut, Ie).call(this),
+                                Pt = (et - Ot) / r(this, o),
+                                $t = (Et - Ot) / r(this, h);
+                            this.scaleFactor = Math.min(Pt, $t);
+                        }, rt = new WeakSet(), De = function() {
+                            const et = J(this, ut, Ie).call(this) / 2;
+                            this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + et, this.translationY * this.scaleFactor + et);
+                        }, pt = new WeakSet(), Yn = function(et) {
+                            const Et = new Path2D();
+                            for (let Ot = 0, Pt = et.length; Ot < Pt; Ot++) {
+                                const [$t, Nt, Jt, vt] = et[Ot];
+                                Ot === 0 && Et.moveTo(...$t), Et.bezierCurveTo(Nt[0], Nt[1], Jt[0], Jt[1], vt[0], vt[1]);
+                            }
+                            return Et;
+                        }, Tt = new WeakSet(), _n = function(et, Et, Ot) {
+                            const [Pt, $t, Nt, Jt] = Et;
+                            switch (Ot) {
                                 case 0:
-                                    for (let Ae = 0, Ke = te.length; Ae < Ke; Ae += 2)
-                                        te[Ae] += ke, te[Ae + 1] = Ze - te[Ae + 1];
+                                    for (let vt = 0, Yt = et.length; vt < Yt; vt += 2)
+                                        et[vt] += Pt, et[vt + 1] = Jt - et[vt + 1];
                                     break;
                                 case 90:
-                                    for (let Ae = 0, Ke = te.length; Ae < Ke; Ae += 2) {
-                                        const Oe = te[Ae];
-                                        te[Ae] = te[Ae + 1] + ke, te[Ae + 1] = Oe + $e;
+                                    for (let vt = 0, Yt = et.length; vt < Yt; vt += 2) {
+                                        const Lt = et[vt];
+                                        et[vt] = et[vt + 1] + Pt, et[vt + 1] = Lt + $t;
                                     }
                                     break;
                                 case 180:
-                                    for (let Ae = 0, Ke = te.length; Ae < Ke; Ae += 2)
-                                        te[Ae] = Be - te[Ae], te[Ae + 1] += $e;
+                                    for (let vt = 0, Yt = et.length; vt < Yt; vt += 2)
+                                        et[vt] = Nt - et[vt], et[vt + 1] += $t;
                                     break;
                                 case 270:
-                                    for (let Ae = 0, Ke = te.length; Ae < Ke; Ae += 2) {
-                                        const Oe = te[Ae];
-                                        te[Ae] = Be - te[Ae + 1], te[Ae + 1] = Ze - Oe;
+                                    for (let vt = 0, Yt = et.length; vt < Yt; vt += 2) {
+                                        const Lt = et[vt];
+                                        et[vt] = Nt - et[vt + 1], et[vt + 1] = Jt - Lt;
                                     }
                                     break;
                                 default:
                                     throw new Error("Invalid rotation");
                             }
-                            return te;
-                        }, We = new WeakSet(), Jn = function(te, Te, Ne) {
-                            const [ke, $e, Be, Ze] = Te;
-                            switch (Ne) {
+                            return et;
+                        }, Wt = new WeakSet(), Kn = function(et, Et, Ot) {
+                            const [Pt, $t, Nt, Jt] = Et;
+                            switch (Ot) {
                                 case 0:
-                                    for (let Ae = 0, Ke = te.length; Ae < Ke; Ae += 2)
-                                        te[Ae] -= ke, te[Ae + 1] = Ze - te[Ae + 1];
+                                    for (let vt = 0, Yt = et.length; vt < Yt; vt += 2)
+                                        et[vt] -= Pt, et[vt + 1] = Jt - et[vt + 1];
                                     break;
                                 case 90:
-                                    for (let Ae = 0, Ke = te.length; Ae < Ke; Ae += 2) {
-                                        const Oe = te[Ae];
-                                        te[Ae] = te[Ae + 1] - $e, te[Ae + 1] = Oe - ke;
+                                    for (let vt = 0, Yt = et.length; vt < Yt; vt += 2) {
+                                        const Lt = et[vt];
+                                        et[vt] = et[vt + 1] - $t, et[vt + 1] = Lt - Pt;
                                     }
                                     break;
                                 case 180:
-                                    for (let Ae = 0, Ke = te.length; Ae < Ke; Ae += 2)
-                                        te[Ae] = Be - te[Ae], te[Ae + 1] -= $e;
+                                    for (let vt = 0, Yt = et.length; vt < Yt; vt += 2)
+                                        et[vt] = Nt - et[vt], et[vt + 1] -= $t;
                                     break;
                                 case 270:
-                                    for (let Ae = 0, Ke = te.length; Ae < Ke; Ae += 2) {
-                                        const Oe = te[Ae];
-                                        te[Ae] = Ze - te[Ae + 1], te[Ae + 1] = Be - Oe;
+                                    for (let vt = 0, Yt = et.length; vt < Yt; vt += 2) {
+                                        const Lt = et[vt];
+                                        et[vt] = Jt - et[vt + 1], et[vt + 1] = Nt - Lt;
                                     }
                                     break;
                                 default:
                                     throw new Error("Invalid rotation");
                             }
-                            return te;
-                        }, ze = new WeakSet(), Zn = function(te, Te, Ne, ke) {
-                            var Ke, Oe;
-                            const $e = [],
-                                Be = this.thickness / 2,
-                                Ze = te * Te + Be,
-                                Ae = te * Ne + Be;
-                            for (const U of this.paths) {
-                                const u = [],
+                            return et;
+                        }, zt = new WeakSet(), Jn = function(et, Et, Ot, Pt) {
+                            var Yt, Lt;
+                            const $t = [],
+                                Nt = this.thickness / 2,
+                                Jt = et * Et + Nt,
+                                vt = et * Ot + Nt;
+                            for (const j of this.paths) {
+                                const c = [],
                                     L = [];
-                                for (let j = 0, V = U.length; j < V; j++) {
-                                    const [Q, he, ye, Me] = U[j], Re = te * Q[0] + Ze, qe = te * Q[1] + Ae, Ie = te * he[0] + Ze, Le = te * he[1] + Ae, Ue = te * ye[0] + Ze, Ve = te * ye[1] + Ae, Je = te * Me[0] + Ze, Qe = te * Me[1] + Ae;
-                                    j === 0 && (u.push(Re, qe), L.push(Re, qe)), u.push(Ie, Le, Ue, Ve, Je, Qe), L.push(Ie, Le), j === V - 1 && L.push(Je, Qe);
-                                }
-                                $e.push({
-                                    bezier: K(Ke = Se, xe, mn).call(Ke, u, ke, this.rotation),
-                                    points: K(Oe = Se, xe, mn).call(Oe, L, ke, this.rotation)
-                                });
-                            }
-                            return $e;
-                        }, Ge = new WeakSet(), bn = function() {
-                            let te = 1 / 0,
-                                Te = -1 / 0,
-                                Ne = 1 / 0,
-                                ke = -1 / 0;
-                            for (const $e of this.paths)
-                                for (const [Be, Ze, Ae, Ke] of $e) {
-                                    const Oe = n.Util.bezierBoundingBox(...Be, ...Ze, ...Ae, ...Ke);
-                                    te = Math.min(te, Oe[0]), Ne = Math.min(Ne, Oe[1]), Te = Math.max(Te, Oe[2]), ke = Math.max(ke, Oe[3]);
-                                }
-                            return [te, Ne, Te, ke];
-                        }, de = new WeakSet(), Dt = function() {
-                            return a(this, b) ? Math.ceil(this.thickness * this.parentScale) : 0;
-                        }, J = new WeakSet(), gt = function(te = !1) {
+                                for (let q = 0, K = j.length; q < K; q++) {
+                                    const [tt, ct, bt, Mt] = j[q], Ft = et * tt[0] + Jt, Ht = et * tt[1] + vt, xt = et * ct[0] + Jt, Dt = et * ct[1] + vt, Ut = et * bt[0] + Jt, Xt = et * bt[1] + vt, Kt = et * Mt[0] + Jt, Zt = et * Mt[1] + vt;
+                                    q === 0 && (c.push(Ft, Ht), L.push(Ft, Ht)), c.push(xt, Dt, Ut, Xt, Kt, Zt), L.push(xt, Dt), q === K - 1 && L.push(Kt, Zt);
+                                }
+                                $t.push({
+                                    bezier: J(Yt = wt, Tt, _n).call(Yt, c, Pt, this.rotation),
+                                    points: J(Lt = wt, Tt, _n).call(Lt, L, Pt, this.rotation)
+                                });
+                            }
+                            return $t;
+                        }, qt = new WeakSet(), mn = function() {
+                            let et = 1 / 0,
+                                Et = -1 / 0,
+                                Ot = 1 / 0,
+                                Pt = -1 / 0;
+                            for (const $t of this.paths)
+                                for (const [Nt, Jt, vt, Yt] of $t) {
+                                    const Lt = e.Util.bezierBoundingBox(...Nt, ...Jt, ...vt, ...Yt);
+                                    et = Math.min(et, Lt[0]), Ot = Math.min(Ot, Lt[1]), Et = Math.max(Et, Lt[2]), Pt = Math.max(Pt, Lt[3]);
+                                }
+                            return [et, Ot, Et, Pt];
+                        }, ut = new WeakSet(), Ie = function() {
+                            return r(this, m) ? Math.ceil(this.thickness * this.parentScale) : 0;
+                        }, Q = new WeakSet(), pe = function(et = !1) {
                             if (this.isEmpty())
                                 return;
-                            if (!a(this, b)) {
-                                K(this, z, ot).call(this);
+                            if (!r(this, m)) {
+                                J(this, z, ae).call(this);
                                 return;
                             }
-                            const Te = K(this, Ge, bn).call(this),
-                                Ne = K(this, de, Dt).call(this);
-                            oe(this, r, Math.max(s.AnnotationEditor.MIN_SIZE, Te[2] - Te[0])), oe(this, o, Math.max(s.AnnotationEditor.MIN_SIZE, Te[3] - Te[1]));
-                            const ke = Math.ceil(Ne + a(this, r) * this.scaleFactor),
-                                $e = Math.ceil(Ne + a(this, o) * this.scaleFactor),
-                                [Be, Ze] = this.parentDimensions;
-                            this.width = ke / Be, this.height = $e / Ze, this.setAspectRatio(ke, $e);
-                            const Ae = this.translationX,
-                                Ke = this.translationY;
-                            this.translationX = -Te[0], this.translationY = -Te[1], K(this, Fe, pt).call(this), K(this, z, ot).call(this), oe(this, y, ke), oe(this, p, $e), this.setDims(ke, $e);
-                            const Oe = te ? Ne / this.scaleFactor / 2 : 0;
-                            this.translate(Ae - this.translationX - Oe, Ke - this.translationY - Oe);
-                        }, W(Se, ge), W(Se, xe), W(Se, We), nt(Se, "_defaultColor", null), nt(Se, "_defaultOpacity", 1), nt(Se, "_defaultThickness", 1), nt(Se, "_type", "ink");
-                        let c = Se;
-                        e.InkEditor = c;
+                            const Et = J(this, qt, mn).call(this),
+                                Ot = J(this, ut, Ie).call(this);
+                            ot(this, o, Math.max(s.AnnotationEditor.MIN_SIZE, Et[2] - Et[0])), ot(this, h, Math.max(s.AnnotationEditor.MIN_SIZE, Et[3] - Et[1]));
+                            const Pt = Math.ceil(Ot + r(this, o) * this.scaleFactor),
+                                $t = Math.ceil(Ot + r(this, h) * this.scaleFactor),
+                                [Nt, Jt] = this.parentDimensions;
+                            this.width = Pt / Nt, this.height = $t / Jt, this.setAspectRatio(Pt, $t);
+                            const vt = this.translationX,
+                                Yt = this.translationY;
+                            this.translationX = -Et[0], this.translationY = -Et[1], J(this, Rt, fe).call(this), J(this, z, ae).call(this), ot(this, S, Pt), ot(this, g, $t), this.setDims(Pt, $t);
+                            const Lt = et ? Ot / this.scaleFactor / 2 : 0;
+                            this.translate(vt - this.translationX - Lt, Yt - this.translationY - Lt);
+                        }, W(wt, pt), W(wt, Tt), W(wt, Wt), ee(wt, "_defaultColor", null), ee(wt, "_defaultOpacity", 1), ee(wt, "_defaultThickness", 1), ee(wt, "_type", "ink");
+                        let a = wt;
+                        t.InkEditor = a;
                     },
                     /* 34 */
                     /***/
-                    (t, e, i) => {
-                        var c, o, r, T, S, w, C, P, b, k, F, Et, y, St, E, Ot, M, yn, N, Qn, X, ei, I, vn, ee, Nt, q, ti;
-                        Object.defineProperty(e, "__esModule", {
+                    (i, t, n) => {
+                        var a, h, o, F, R, w, T, P, m, C, x, ve, S, Se, v, Le, M, bn, N, Zn, X, Qn, I, yn, G, Oe, H, ti;
+                        Object.defineProperty(t, "__esModule", {
                             value: !0
-                        }), e.StampEditor = void 0;
-                        var n = i(1),
-                            s = i(4),
-                            l = i(6),
-                            h = i(29);
-                        const pe = class pe extends s.AnnotationEditor {
-                            constructor(R) {
+                        }), t.StampEditor = void 0;
+                        var e = n(1),
+                            s = n(4),
+                            p = n(6),
+                            f = n(29);
+                        const dt = class dt extends s.AnnotationEditor {
+                            constructor(k) {
                                 super({
-                                    ...R,
+                                    ...k,
                                     name: "stampEditor"
                                 });
-                                W(this, F);
-                                W(this, y);
-                                W(this, E);
+                                W(this, x);
+                                W(this, S);
+                                W(this, v);
                                 W(this, M);
                                 W(this, N);
                                 W(this, X);
                                 W(this, I);
-                                W(this, ee);
-                                W(this, q);
-                                W(this, c, null);
+                                W(this, G);
+                                W(this, H);
+                                W(this, a, null);
+                                W(this, h, null);
                                 W(this, o, null);
-                                W(this, r, null);
-                                W(this, T, null);
-                                W(this, S, null);
+                                W(this, F, null);
+                                W(this, R, null);
                                 W(this, w, null);
-                                W(this, C, null);
+                                W(this, T, null);
                                 W(this, P, null);
-                                W(this, b, !1);
-                                W(this, k, !1);
-                                oe(this, T, R.bitmapUrl), oe(this, S, R.bitmapFile);
+                                W(this, m, !1);
+                                W(this, C, !1);
+                                ot(this, F, k.bitmapUrl), ot(this, R, k.bitmapFile);
                             }
-                            static initialize(R) {
-                                s.AnnotationEditor.initialize(R);
+                            static initialize(k) {
+                                s.AnnotationEditor.initialize(k);
                             }
                             static get supportedTypes() {
-                                const R = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"];
-                                return (0, n.shadow)(this, "supportedTypes", R.map((d) => `image/${d}`));
+                                const k = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"];
+                                return (0, e.shadow)(this, "supportedTypes", k.map((l) => `image/${l}`));
                             }
                             static get supportedTypesStr() {
-                                return (0, n.shadow)(this, "supportedTypesStr", this.supportedTypes.join(","));
+                                return (0, e.shadow)(this, "supportedTypesStr", this.supportedTypes.join(","));
                             }
-                            static isHandlingMimeForPasting(R) {
-                                return this.supportedTypes.includes(R);
+                            static isHandlingMimeForPasting(k) {
+                                return this.supportedTypes.includes(k);
                             }
-                            static paste(R, d) {
-                                d.pasteEditor(n.AnnotationEditorType.STAMP, {
-                                    bitmapFile: R.getAsFile()
+                            static paste(k, l) {
+                                l.pasteEditor(e.AnnotationEditorType.STAMP, {
+                                    bitmapFile: k.getAsFile()
                                 });
                             }
                             remove() {
-                                var R, d;
-                                a(this, o) && (oe(this, c, null), this._uiManager.imageManager.deleteId(a(this, o)), (R = a(this, w)) == null || R.remove(), oe(this, w, null), (d = a(this, C)) == null || d.disconnect(), oe(this, C, null)), super.remove();
+                                var k, l;
+                                r(this, h) && (ot(this, a, null), this._uiManager.imageManager.deleteId(r(this, h)), (k = r(this, w)) == null || k.remove(), ot(this, w, null), (l = r(this, T)) == null || l.disconnect(), ot(this, T, null)), super.remove();
                             }
                             rebuild() {
                                 if (!this.parent) {
-                                    a(this, o) && K(this, E, Ot).call(this);
+                                    r(this, h) && J(this, v, Le).call(this);
                                     return;
                                 }
-                                super.rebuild(), this.div !== null && (a(this, o) && K(this, E, Ot).call(this), this.isAttachedToDOM || this.parent.add(this));
+                                super.rebuild(), this.div !== null && (r(this, h) && J(this, v, Le).call(this), this.isAttachedToDOM || this.parent.add(this));
                             }
                             onceAdded() {
                                 this._isDraggable = !0, this.div.focus();
                             }
                             isEmpty() {
-                                return !(a(this, r) || a(this, c) || a(this, T) || a(this, S));
+                                return !(r(this, o) || r(this, a) || r(this, F) || r(this, R));
                             }
                             get isResizable() {
                                 return !0;
                             }
                             render() {
                                 if (this.div)
                                     return this.div;
-                                let R, d;
-                                if (this.width && (R = this.x, d = this.y), super.render(), this.div.hidden = !0, a(this, c) ? K(this, M, yn).call(this) : K(this, E, Ot).call(this), this.width) {
-                                    const [g, f] = this.parentDimensions;
-                                    this.setAt(R * g, d * f, this.width * g, this.height * f);
+                                let k, l;
+                                if (this.width && (k = this.x, l = this.y), super.render(), this.div.hidden = !0, r(this, a) ? J(this, M, bn).call(this) : J(this, v, Le).call(this), this.width) {
+                                    const [u, d] = this.parentDimensions;
+                                    this.setAt(k * u, l * d, this.width * u, this.height * d);
                                 }
                                 return this.div;
                             }
-                            static deserialize(R, d, g) {
-                                if (R instanceof h.StampAnnotationElement)
+                            static deserialize(k, l, u) {
+                                if (k instanceof f.StampAnnotationElement)
                                     return null;
-                                const f = super.deserialize(R, d, g),
+                                const d = super.deserialize(k, l, u),
                                     {
-                                        rect: v,
-                                        bitmapUrl: A,
+                                        rect: b,
+                                        bitmapUrl: y,
                                         bitmapId: O,
-                                        isSvg: H,
+                                        isSvg: B,
                                         accessibilityData: z
-                                    } = R;
-                                O && g.imageManager.isValidId(O) ? oe(f, o, O) : oe(f, T, A), oe(f, b, H);
-                                const [ae, Z] = f.pageDimensions;
-                                return f.width = (v[2] - v[0]) / ae, f.height = (v[3] - v[1]) / Z, z && (f.altTextData = z), f;
+                                    } = k;
+                                O && u.imageManager.isValidId(O) ? ot(d, h, O) : ot(d, F, y), ot(d, m, B);
+                                const [it, Z] = d.pageDimensions;
+                                return d.width = (b[2] - b[0]) / it, d.height = (b[3] - b[1]) / Z, z && (d.altTextData = z), d;
                             }
-                            serialize(R = !1, d = null) {
+                            serialize(k = !1, l = null) {
                                 if (this.isEmpty())
                                     return null;
-                                const g = {
-                                    annotationType: n.AnnotationEditorType.STAMP,
-                                    bitmapId: a(this, o),
+                                const u = {
+                                    annotationType: e.AnnotationEditorType.STAMP,
+                                    bitmapId: r(this, h),
                                     pageIndex: this.pageIndex,
                                     rect: this.getRect(0, 0),
                                     rotation: this.rotation,
-                                    isSvg: a(this, b),
+                                    isSvg: r(this, m),
                                     structTreeParentId: this._structTreeParentId
                                 };
-                                if (R)
-                                    return g.bitmapUrl = K(this, ee, Nt).call(this, !0), g.accessibilityData = this.altTextData, g;
+                                if (k)
+                                    return u.bitmapUrl = J(this, G, Oe).call(this, !0), u.accessibilityData = this.altTextData, u;
                                 const {
-                                    decorative: f,
-                                    altText: v
+                                    decorative: d,
+                                    altText: b
                                 } = this.altTextData;
-                                if (!f && v && (g.accessibilityData = {
+                                if (!d && b && (u.accessibilityData = {
                                         type: "Figure",
-                                        alt: v
-                                    }), d === null)
-                                    return g;
-                                d.stamps || (d.stamps = /* @__PURE__ */ new Map());
-                                const A = a(this, b) ? (g.rect[2] - g.rect[0]) * (g.rect[3] - g.rect[1]) : null;
-                                if (!d.stamps.has(a(this, o)))
-                                    d.stamps.set(a(this, o), {
-                                        area: A,
-                                        serialized: g
-                                    }), g.bitmap = K(this, ee, Nt).call(this, !1);
-                                else if (a(this, b)) {
-                                    const O = d.stamps.get(a(this, o));
-                                    A > O.area && (O.area = A, O.serialized.bitmap.close(), O.serialized.bitmap = K(this, ee, Nt).call(this, !1));
+                                        alt: b
+                                    }), l === null)
+                                    return u;
+                                l.stamps || (l.stamps = /* @__PURE__ */ new Map());
+                                const y = r(this, m) ? (u.rect[2] - u.rect[0]) * (u.rect[3] - u.rect[1]) : null;
+                                if (!l.stamps.has(r(this, h)))
+                                    l.stamps.set(r(this, h), {
+                                        area: y,
+                                        serialized: u
+                                    }), u.bitmap = J(this, G, Oe).call(this, !1);
+                                else if (r(this, m)) {
+                                    const O = l.stamps.get(r(this, h));
+                                    y > O.area && (O.area = y, O.serialized.bitmap.close(), O.serialized.bitmap = J(this, G, Oe).call(this, !1));
                                 }
-                                return g;
+                                return u;
                             }
                         };
-                        c = new WeakMap(), o = new WeakMap(), r = new WeakMap(), T = new WeakMap(), S = new WeakMap(), w = new WeakMap(), C = new WeakMap(), P = new WeakMap(), b = new WeakMap(), k = new WeakMap(), F = new WeakSet(), Et = function(R, d = !1) {
-                            if (!R) {
+                        a = new WeakMap(), h = new WeakMap(), o = new WeakMap(), F = new WeakMap(), R = new WeakMap(), w = new WeakMap(), T = new WeakMap(), P = new WeakMap(), m = new WeakMap(), C = new WeakMap(), x = new WeakSet(), ve = function(k, l = !1) {
+                            if (!k) {
                                 this.remove();
                                 return;
                             }
-                            oe(this, c, R.bitmap), d || (oe(this, o, R.id), oe(this, b, R.isSvg)), K(this, M, yn).call(this);
-                        }, y = new WeakSet(), St = function() {
-                            oe(this, r, null), this._uiManager.enableWaiting(!1), a(this, w) && this.div.focus();
-                        }, E = new WeakSet(), Ot = function() {
-                            if (a(this, o)) {
-                                this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(a(this, o)).then((d) => K(this, F, Et).call(this, d, !0)).finally(() => K(this, y, St).call(this));
+                            ot(this, a, k.bitmap), l || (ot(this, h, k.id), ot(this, m, k.isSvg)), J(this, M, bn).call(this);
+                        }, S = new WeakSet(), Se = function() {
+                            ot(this, o, null), this._uiManager.enableWaiting(!1), r(this, w) && this.div.focus();
+                        }, v = new WeakSet(), Le = function() {
+                            if (r(this, h)) {
+                                this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(r(this, h)).then((l) => J(this, x, ve).call(this, l, !0)).finally(() => J(this, S, Se).call(this));
                                 return;
                             }
-                            if (a(this, T)) {
-                                const d = a(this, T);
-                                oe(this, T, null), this._uiManager.enableWaiting(!0), oe(this, r, this._uiManager.imageManager.getFromUrl(d).then((g) => K(this, F, Et).call(this, g)).finally(() => K(this, y, St).call(this)));
+                            if (r(this, F)) {
+                                const l = r(this, F);
+                                ot(this, F, null), this._uiManager.enableWaiting(!0), ot(this, o, this._uiManager.imageManager.getFromUrl(l).then((u) => J(this, x, ve).call(this, u)).finally(() => J(this, S, Se).call(this)));
                                 return;
                             }
-                            if (a(this, S)) {
-                                const d = a(this, S);
-                                oe(this, S, null), this._uiManager.enableWaiting(!0), oe(this, r, this._uiManager.imageManager.getFromFile(d).then((g) => K(this, F, Et).call(this, g)).finally(() => K(this, y, St).call(this)));
+                            if (r(this, R)) {
+                                const l = r(this, R);
+                                ot(this, R, null), this._uiManager.enableWaiting(!0), ot(this, o, this._uiManager.imageManager.getFromFile(l).then((u) => J(this, x, ve).call(this, u)).finally(() => J(this, S, Se).call(this)));
                                 return;
                             }
-                            const R = document.createElement("input");
-                            R.type = "file", R.accept = pe.supportedTypesStr, oe(this, r, new Promise((d) => {
-                                R.addEventListener("change", async () => {
-                                    if (!R.files || R.files.length === 0)
+                            const k = document.createElement("input");
+                            k.type = "file", k.accept = dt.supportedTypesStr, ot(this, o, new Promise((l) => {
+                                k.addEventListener("change", async () => {
+                                    if (!k.files || k.files.length === 0)
                                         this.remove();
                                     else {
                                         this._uiManager.enableWaiting(!0);
-                                        const g = await this._uiManager.imageManager.getFromFile(R.files[0]);
-                                        K(this, F, Et).call(this, g);
+                                        const u = await this._uiManager.imageManager.getFromFile(k.files[0]);
+                                        J(this, x, ve).call(this, u);
                                     }
-                                    d();
-                                }), R.addEventListener("cancel", () => {
-                                    this.remove(), d();
+                                    l();
+                                }), k.addEventListener("cancel", () => {
+                                    this.remove(), l();
                                 });
-                            }).finally(() => K(this, y, St).call(this))), R.click();
-                        }, M = new WeakSet(), yn = function() {
+                            }).finally(() => J(this, S, Se).call(this))), k.click();
+                        }, M = new WeakSet(), bn = function() {
                             const {
-                                div: R
+                                div: k
                             } = this;
                             let {
-                                width: d,
-                                height: g
-                            } = a(this, c);
-                            const [f, v] = this.pageDimensions, A = 0.75;
+                                width: l,
+                                height: u
+                            } = r(this, a);
+                            const [d, b] = this.pageDimensions, y = 0.75;
                             if (this.width)
-                                d = this.width * f, g = this.height * v;
-                            else if (d > A * f || g > A * v) {
-                                const ae = Math.min(A * f / d, A * v / g);
-                                d *= ae, g *= ae;
-                            }
-                            const [O, H] = this.parentDimensions;
-                            this.setDims(d * O / f, g * H / v), this._uiManager.enableWaiting(!1);
-                            const z = oe(this, w, document.createElement("canvas"));
-                            R.append(z), R.hidden = !1, K(this, I, vn).call(this, d, g), K(this, q, ti).call(this), a(this, k) || (this.parent.addUndoableEditor(this), oe(this, k, !0)), this._uiManager._eventBus.dispatch("reporttelemetry", {
+                                l = this.width * d, u = this.height * b;
+                            else if (l > y * d || u > y * b) {
+                                const it = Math.min(y * d / l, y * b / u);
+                                l *= it, u *= it;
+                            }
+                            const [O, B] = this.parentDimensions;
+                            this.setDims(l * O / d, u * B / b), this._uiManager.enableWaiting(!1);
+                            const z = ot(this, w, document.createElement("canvas"));
+                            k.append(z), k.hidden = !1, J(this, I, yn).call(this, l, u), J(this, H, ti).call(this), r(this, C) || (this.parent.addUndoableEditor(this), ot(this, C, !0)), this._uiManager._eventBus.dispatch("reporttelemetry", {
                                 source: this,
                                 details: {
                                     type: "editing",
                                     subtype: this.editorType,
                                     data: {
                                         action: "inserted_image"
                                     }
                                 }
                             }), this.addAltTextButton();
-                        }, N = new WeakSet(), Qn = function(R, d) {
-                            var A;
-                            const [g, f] = this.parentDimensions;
-                            this.width = R / g, this.height = d / f, this.setDims(R, d), (A = this._initialOptions) != null && A.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, a(this, P) !== null && clearTimeout(a(this, P)), oe(this, P, setTimeout(() => {
-                                oe(this, P, null), K(this, I, vn).call(this, R, d);
+                        }, N = new WeakSet(), Zn = function(k, l) {
+                            var y;
+                            const [u, d] = this.parentDimensions;
+                            this.width = k / u, this.height = l / d, this.setDims(k, l), (y = this._initialOptions) != null && y.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, r(this, P) !== null && clearTimeout(r(this, P)), ot(this, P, setTimeout(() => {
+                                ot(this, P, null), J(this, I, yn).call(this, k, l);
                             }, 200));
-                        }, X = new WeakSet(), ei = function(R, d) {
+                        }, X = new WeakSet(), Qn = function(k, l) {
                             const {
-                                width: g,
-                                height: f
-                            } = a(this, c);
-                            let v = g,
-                                A = f,
-                                O = a(this, c);
-                            for (; v > 2 * R || A > 2 * d;) {
-                                const H = v,
-                                    z = A;
-                                v > 2 * R && (v = v >= 16384 ? Math.floor(v / 2) - 1 : Math.ceil(v / 2)), A > 2 * d && (A = A >= 16384 ? Math.floor(A / 2) - 1 : Math.ceil(A / 2));
-                                const ae = new OffscreenCanvas(v, A);
-                                ae.getContext("2d").drawImage(O, 0, 0, H, z, 0, 0, v, A), O = ae.transferToImageBitmap();
+                                width: u,
+                                height: d
+                            } = r(this, a);
+                            let b = u,
+                                y = d,
+                                O = r(this, a);
+                            for (; b > 2 * k || y > 2 * l;) {
+                                const B = b,
+                                    z = y;
+                                b > 2 * k && (b = b >= 16384 ? Math.floor(b / 2) - 1 : Math.ceil(b / 2)), y > 2 * l && (y = y >= 16384 ? Math.floor(y / 2) - 1 : Math.ceil(y / 2));
+                                const it = new OffscreenCanvas(b, y);
+                                it.getContext("2d").drawImage(O, 0, 0, B, z, 0, 0, b, y), O = it.transferToImageBitmap();
                             }
                             return O;
-                        }, I = new WeakSet(), vn = function(R, d) {
-                            R = Math.ceil(R), d = Math.ceil(d);
-                            const g = a(this, w);
-                            if (!g || g.width === R && g.height === d)
+                        }, I = new WeakSet(), yn = function(k, l) {
+                            k = Math.ceil(k), l = Math.ceil(l);
+                            const u = r(this, w);
+                            if (!u || u.width === k && u.height === l)
                                 return;
-                            g.width = R, g.height = d;
-                            const f = a(this, b) ? a(this, c) : K(this, X, ei).call(this, R, d),
-                                v = g.getContext("2d");
-                            v.filter = this._uiManager.hcmFilter, v.drawImage(f, 0, 0, f.width, f.height, 0, 0, R, d);
-                        }, ee = new WeakSet(), Nt = function(R) {
-                            if (R) {
-                                if (a(this, b)) {
-                                    const f = this._uiManager.imageManager.getSvgUrl(a(this, o));
-                                    if (f)
-                                        return f;
+                            u.width = k, u.height = l;
+                            const d = r(this, m) ? r(this, a) : J(this, X, Qn).call(this, k, l),
+                                b = u.getContext("2d");
+                            b.filter = this._uiManager.hcmFilter, b.drawImage(d, 0, 0, d.width, d.height, 0, 0, k, l);
+                        }, G = new WeakSet(), Oe = function(k) {
+                            if (k) {
+                                if (r(this, m)) {
+                                    const d = this._uiManager.imageManager.getSvgUrl(r(this, h));
+                                    if (d)
+                                        return d;
                                 }
-                                const d = document.createElement("canvas");
+                                const l = document.createElement("canvas");
                                 return {
-                                    width: d.width,
-                                    height: d.height
-                                } = a(this, c), d.getContext("2d").drawImage(a(this, c), 0, 0), d.toDataURL();
-                            }
-                            if (a(this, b)) {
-                                const [d, g] = this.pageDimensions, f = Math.round(this.width * d * l.PixelsPerInch.PDF_TO_CSS_UNITS), v = Math.round(this.height * g * l.PixelsPerInch.PDF_TO_CSS_UNITS), A = new OffscreenCanvas(f, v);
-                                return A.getContext("2d").drawImage(a(this, c), 0, 0, a(this, c).width, a(this, c).height, 0, 0, f, v), A.transferToImageBitmap();
-                            }
-                            return structuredClone(a(this, c));
-                        }, q = new WeakSet(), ti = function() {
-                            oe(this, C, new ResizeObserver((R) => {
-                                const d = R[0].contentRect;
-                                d.width && d.height && K(this, N, Qn).call(this, d.width, d.height);
-                            })), a(this, C).observe(this.div);
-                        }, nt(pe, "_type", "stamp");
-                        let _ = pe;
-                        e.StampEditor = _;
+                                    width: l.width,
+                                    height: l.height
+                                } = r(this, a), l.getContext("2d").drawImage(r(this, a), 0, 0), l.toDataURL();
+                            }
+                            if (r(this, m)) {
+                                const [l, u] = this.pageDimensions, d = Math.round(this.width * l * p.PixelsPerInch.PDF_TO_CSS_UNITS), b = Math.round(this.height * u * p.PixelsPerInch.PDF_TO_CSS_UNITS), y = new OffscreenCanvas(d, b);
+                                return y.getContext("2d").drawImage(r(this, a), 0, 0, r(this, a).width, r(this, a).height, 0, 0, d, b), y.transferToImageBitmap();
+                            }
+                            return structuredClone(r(this, a));
+                        }, H = new WeakSet(), ti = function() {
+                            ot(this, T, new ResizeObserver((k) => {
+                                const l = k[0].contentRect;
+                                l.width && l.height && J(this, N, Zn).call(this, l.width, l.height);
+                            })), r(this, T).observe(this.div);
+                        }, ee(dt, "_type", "stamp");
+                        let A = dt;
+                        t.StampEditor = A;
                     }
                     /******/
                 ],
                 __webpack_module_cache__ = {};
 
-            function __w_pdfjs_require__(t) {
-                var e = __webpack_module_cache__[t];
-                if (e !== void 0)
-                    return e.exports;
-                var i = __webpack_module_cache__[t] = {
+            function __w_pdfjs_require__(i) {
+                var t = __webpack_module_cache__[i];
+                if (t !== void 0)
+                    return t.exports;
+                var n = __webpack_module_cache__[i] = {
                     /******/
                     // no module.id needed
                     /******/
                     // no module.loaded needed
                     /******/
                     exports: {}
                     /******/
                 };
-                return __webpack_modules__[t](i, i.exports, __w_pdfjs_require__), i.exports;
+                return __webpack_modules__[i](n, n.exports, __w_pdfjs_require__), n.exports;
             }
             var __webpack_exports__ = {};
             return (() => {
-                var t = __webpack_exports__;
-                Object.defineProperty(t, "__esModule", {
+                var i = __webpack_exports__;
+                Object.defineProperty(i, "__esModule", {
                     value: !0
-                }), Object.defineProperty(t, "AbortException", {
+                }), Object.defineProperty(i, "AbortException", {
                     enumerable: !0,
                     get: function() {
-                        return e.AbortException;
+                        return t.AbortException;
                     }
-                }), Object.defineProperty(t, "AnnotationEditorLayer", {
+                }), Object.defineProperty(i, "AnnotationEditorLayer", {
                     enumerable: !0,
                     get: function() {
-                        return l.AnnotationEditorLayer;
+                        return p.AnnotationEditorLayer;
                     }
-                }), Object.defineProperty(t, "AnnotationEditorParamsType", {
+                }), Object.defineProperty(i, "AnnotationEditorParamsType", {
                     enumerable: !0,
                     get: function() {
-                        return e.AnnotationEditorParamsType;
+                        return t.AnnotationEditorParamsType;
                     }
-                }), Object.defineProperty(t, "AnnotationEditorType", {
+                }), Object.defineProperty(i, "AnnotationEditorType", {
                     enumerable: !0,
                     get: function() {
-                        return e.AnnotationEditorType;
+                        return t.AnnotationEditorType;
                     }
-                }), Object.defineProperty(t, "AnnotationEditorUIManager", {
+                }), Object.defineProperty(i, "AnnotationEditorUIManager", {
                     enumerable: !0,
                     get: function() {
-                        return h.AnnotationEditorUIManager;
+                        return f.AnnotationEditorUIManager;
                     }
-                }), Object.defineProperty(t, "AnnotationLayer", {
+                }), Object.defineProperty(i, "AnnotationLayer", {
                     enumerable: !0,
                     get: function() {
-                        return _.AnnotationLayer;
+                        return A.AnnotationLayer;
                     }
-                }), Object.defineProperty(t, "AnnotationMode", {
+                }), Object.defineProperty(i, "AnnotationMode", {
                     enumerable: !0,
                     get: function() {
-                        return e.AnnotationMode;
+                        return t.AnnotationMode;
                     }
-                }), Object.defineProperty(t, "CMapCompressionType", {
+                }), Object.defineProperty(i, "CMapCompressionType", {
                     enumerable: !0,
                     get: function() {
-                        return e.CMapCompressionType;
+                        return t.CMapCompressionType;
                     }
-                }), Object.defineProperty(t, "DOMSVGFactory", {
+                }), Object.defineProperty(i, "DOMSVGFactory", {
                     enumerable: !0,
                     get: function() {
-                        return n.DOMSVGFactory;
+                        return e.DOMSVGFactory;
                     }
-                }), Object.defineProperty(t, "FeatureTest", {
+                }), Object.defineProperty(i, "FeatureTest", {
                     enumerable: !0,
                     get: function() {
-                        return e.FeatureTest;
+                        return t.FeatureTest;
                     }
-                }), Object.defineProperty(t, "GlobalWorkerOptions", {
+                }), Object.defineProperty(i, "GlobalWorkerOptions", {
                     enumerable: !0,
                     get: function() {
-                        return c.GlobalWorkerOptions;
+                        return a.GlobalWorkerOptions;
                     }
-                }), Object.defineProperty(t, "ImageKind", {
+                }), Object.defineProperty(i, "ImageKind", {
                     enumerable: !0,
                     get: function() {
-                        return e.ImageKind;
+                        return t.ImageKind;
                     }
-                }), Object.defineProperty(t, "InvalidPDFException", {
+                }), Object.defineProperty(i, "InvalidPDFException", {
                     enumerable: !0,
                     get: function() {
-                        return e.InvalidPDFException;
+                        return t.InvalidPDFException;
                     }
-                }), Object.defineProperty(t, "MissingPDFException", {
+                }), Object.defineProperty(i, "MissingPDFException", {
                     enumerable: !0,
                     get: function() {
-                        return e.MissingPDFException;
+                        return t.MissingPDFException;
                     }
-                }), Object.defineProperty(t, "OPS", {
+                }), Object.defineProperty(i, "OPS", {
                     enumerable: !0,
                     get: function() {
-                        return e.OPS;
+                        return t.OPS;
                     }
-                }), Object.defineProperty(t, "PDFDataRangeTransport", {
+                }), Object.defineProperty(i, "PDFDataRangeTransport", {
                     enumerable: !0,
                     get: function() {
-                        return i.PDFDataRangeTransport;
+                        return n.PDFDataRangeTransport;
                     }
-                }), Object.defineProperty(t, "PDFDateString", {
+                }), Object.defineProperty(i, "PDFDateString", {
                     enumerable: !0,
                     get: function() {
-                        return n.PDFDateString;
+                        return e.PDFDateString;
                     }
-                }), Object.defineProperty(t, "PDFWorker", {
+                }), Object.defineProperty(i, "PDFWorker", {
                     enumerable: !0,
                     get: function() {
-                        return i.PDFWorker;
+                        return n.PDFWorker;
                     }
-                }), Object.defineProperty(t, "PasswordResponses", {
+                }), Object.defineProperty(i, "PasswordResponses", {
                     enumerable: !0,
                     get: function() {
-                        return e.PasswordResponses;
+                        return t.PasswordResponses;
                     }
-                }), Object.defineProperty(t, "PermissionFlag", {
+                }), Object.defineProperty(i, "PermissionFlag", {
                     enumerable: !0,
                     get: function() {
-                        return e.PermissionFlag;
+                        return t.PermissionFlag;
                     }
-                }), Object.defineProperty(t, "PixelsPerInch", {
+                }), Object.defineProperty(i, "PixelsPerInch", {
                     enumerable: !0,
                     get: function() {
-                        return n.PixelsPerInch;
+                        return e.PixelsPerInch;
                     }
-                }), Object.defineProperty(t, "PromiseCapability", {
+                }), Object.defineProperty(i, "PromiseCapability", {
                     enumerable: !0,
                     get: function() {
-                        return e.PromiseCapability;
+                        return t.PromiseCapability;
                     }
-                }), Object.defineProperty(t, "RenderingCancelledException", {
+                }), Object.defineProperty(i, "RenderingCancelledException", {
                     enumerable: !0,
                     get: function() {
-                        return n.RenderingCancelledException;
+                        return e.RenderingCancelledException;
                     }
-                }), Object.defineProperty(t, "SVGGraphics", {
+                }), Object.defineProperty(i, "SVGGraphics", {
                     enumerable: !0,
                     get: function() {
-                        return i.SVGGraphics;
+                        return n.SVGGraphics;
                     }
-                }), Object.defineProperty(t, "UnexpectedResponseException", {
+                }), Object.defineProperty(i, "UnexpectedResponseException", {
                     enumerable: !0,
                     get: function() {
-                        return e.UnexpectedResponseException;
+                        return t.UnexpectedResponseException;
                     }
-                }), Object.defineProperty(t, "Util", {
+                }), Object.defineProperty(i, "Util", {
                     enumerable: !0,
                     get: function() {
-                        return e.Util;
+                        return t.Util;
                     }
-                }), Object.defineProperty(t, "VerbosityLevel", {
+                }), Object.defineProperty(i, "VerbosityLevel", {
                     enumerable: !0,
                     get: function() {
-                        return e.VerbosityLevel;
+                        return t.VerbosityLevel;
                     }
-                }), Object.defineProperty(t, "XfaLayer", {
+                }), Object.defineProperty(i, "XfaLayer", {
                     enumerable: !0,
                     get: function() {
-                        return o.XfaLayer;
+                        return h.XfaLayer;
                     }
-                }), Object.defineProperty(t, "build", {
+                }), Object.defineProperty(i, "build", {
                     enumerable: !0,
                     get: function() {
-                        return i.build;
+                        return n.build;
                     }
-                }), Object.defineProperty(t, "createValidAbsoluteUrl", {
+                }), Object.defineProperty(i, "createValidAbsoluteUrl", {
                     enumerable: !0,
                     get: function() {
-                        return e.createValidAbsoluteUrl;
+                        return t.createValidAbsoluteUrl;
                     }
-                }), Object.defineProperty(t, "getDocument", {
+                }), Object.defineProperty(i, "getDocument", {
                     enumerable: !0,
                     get: function() {
-                        return i.getDocument;
+                        return n.getDocument;
                     }
-                }), Object.defineProperty(t, "getFilenameFromUrl", {
+                }), Object.defineProperty(i, "getFilenameFromUrl", {
                     enumerable: !0,
                     get: function() {
-                        return n.getFilenameFromUrl;
+                        return e.getFilenameFromUrl;
                     }
-                }), Object.defineProperty(t, "getPdfFilenameFromUrl", {
+                }), Object.defineProperty(i, "getPdfFilenameFromUrl", {
                     enumerable: !0,
                     get: function() {
-                        return n.getPdfFilenameFromUrl;
+                        return e.getPdfFilenameFromUrl;
                     }
-                }), Object.defineProperty(t, "getXfaPageViewport", {
+                }), Object.defineProperty(i, "getXfaPageViewport", {
                     enumerable: !0,
                     get: function() {
-                        return n.getXfaPageViewport;
+                        return e.getXfaPageViewport;
                     }
-                }), Object.defineProperty(t, "isDataScheme", {
+                }), Object.defineProperty(i, "isDataScheme", {
                     enumerable: !0,
                     get: function() {
-                        return n.isDataScheme;
+                        return e.isDataScheme;
                     }
-                }), Object.defineProperty(t, "isPdfFile", {
+                }), Object.defineProperty(i, "isPdfFile", {
                     enumerable: !0,
                     get: function() {
-                        return n.isPdfFile;
+                        return e.isPdfFile;
                     }
-                }), Object.defineProperty(t, "loadScript", {
+                }), Object.defineProperty(i, "loadScript", {
                     enumerable: !0,
                     get: function() {
-                        return n.loadScript;
+                        return e.loadScript;
                     }
-                }), Object.defineProperty(t, "noContextMenu", {
+                }), Object.defineProperty(i, "noContextMenu", {
                     enumerable: !0,
                     get: function() {
-                        return n.noContextMenu;
+                        return e.noContextMenu;
                     }
-                }), Object.defineProperty(t, "normalizeUnicode", {
+                }), Object.defineProperty(i, "normalizeUnicode", {
                     enumerable: !0,
                     get: function() {
-                        return e.normalizeUnicode;
+                        return t.normalizeUnicode;
                     }
-                }), Object.defineProperty(t, "renderTextLayer", {
+                }), Object.defineProperty(i, "renderTextLayer", {
                     enumerable: !0,
                     get: function() {
                         return s.renderTextLayer;
                     }
-                }), Object.defineProperty(t, "setLayerDimensions", {
+                }), Object.defineProperty(i, "setLayerDimensions", {
                     enumerable: !0,
                     get: function() {
-                        return n.setLayerDimensions;
+                        return e.setLayerDimensions;
                     }
-                }), Object.defineProperty(t, "shadow", {
+                }), Object.defineProperty(i, "shadow", {
                     enumerable: !0,
                     get: function() {
-                        return e.shadow;
+                        return t.shadow;
                     }
-                }), Object.defineProperty(t, "updateTextLayer", {
+                }), Object.defineProperty(i, "updateTextLayer", {
                     enumerable: !0,
                     get: function() {
                         return s.updateTextLayer;
                     }
-                }), Object.defineProperty(t, "version", {
+                }), Object.defineProperty(i, "version", {
                     enumerable: !0,
                     get: function() {
-                        return i.version;
+                        return n.version;
                     }
                 });
-                var e = __w_pdfjs_require__(1),
-                    i = __w_pdfjs_require__(2),
-                    n = __w_pdfjs_require__(6),
+                var t = __w_pdfjs_require__(1),
+                    n = __w_pdfjs_require__(2),
+                    e = __w_pdfjs_require__(6),
                     s = __w_pdfjs_require__(26),
-                    l = __w_pdfjs_require__(27),
-                    h = __w_pdfjs_require__(5),
-                    _ = __w_pdfjs_require__(29),
-                    c = __w_pdfjs_require__(14),
-                    o = __w_pdfjs_require__(32);
+                    p = __w_pdfjs_require__(27),
+                    f = __w_pdfjs_require__(5),
+                    A = __w_pdfjs_require__(29),
+                    a = __w_pdfjs_require__(14),
+                    h = __w_pdfjs_require__(32);
             })(), __webpack_exports__;
         })()
     ));
 })(pdf);
 var pdfExports = pdf.exports;
-const pdfjsLib = /* @__PURE__ */ getDefaultExportFromCjs(pdfExports),
-    Index_svelte_svelte_type_style_lang = "",
-    {
-        SvelteComponent,
-        append,
-        assign,
-        attr,
-        binding_callbacks,
-        check_outros,
-        create_component,
-        destroy_component,
-        detach,
-        element,
-        empty,
-        get_spread_object,
-        get_spread_update,
-        group_outros,
-        init,
-        insert,
-        mount_component,
-        safe_not_equal,
-        set_data,
-        set_style,
-        space,
-        text,
-        transition_in,
-        transition_out
-    } = window.__gradio__svelte__internal,
-    {
-        tick
-    } = window.__gradio__svelte__internal;
-
-function create_if_block_1(t) {
-    let e, i;
-    const n = [{
+const {
+    SvelteComponent,
+    append,
+    assign,
+    attr,
+    binding_callbacks,
+    check_outros,
+    create_component,
+    destroy_component,
+    detach,
+    element,
+    empty,
+    get_spread_object,
+    get_spread_update,
+    group_outros,
+    init,
+    insert,
+    mount_component,
+    safe_not_equal,
+    set_data,
+    set_style,
+    space,
+    text,
+    transition_in,
+    transition_out
+} = window.__gradio__svelte__internal, {
+    tick
+} = window.__gradio__svelte__internal;
+
+function create_if_block_1(i) {
+    let t, n;
+    const e = [{
             autoscroll: (
                 /*gradio*/
-                t[11].autoscroll
+                i[11].autoscroll
             )
         }, {
             i18n: (
                 /*gradio*/
-                t[11].i18n
+                i[11].i18n
             )
         },
         /*loading_status*/
-        t[10]
+        i[10]
     ];
     let s = {};
-    for (let l = 0; l < n.length; l += 1)
-        s = assign(s, n[l]);
-    return e = new Static({
+    for (let p = 0; p < e.length; p += 1)
+        s = assign(s, e[p]);
+    return t = new Static({
         props: s
     }), {
         c() {
-            create_component(e.$$.fragment);
+            create_component(t.$$.fragment);
         },
-        m(l, h) {
-            mount_component(e, l, h), i = !0;
+        m(p, f) {
+            mount_component(t, p, f), n = !0;
         },
-        p(l, h) {
-            const _ = h & /*gradio, loading_status*/
-                3072 ? get_spread_update(n, [
-                    h & /*gradio*/
+        p(p, f) {
+            const A = f & /*gradio, loading_status*/
+                3072 ? get_spread_update(e, [
+                    f & /*gradio*/
                     2048 && {
                         autoscroll: (
                             /*gradio*/
-                            l[11].autoscroll
+                            p[11].autoscroll
                         )
                     },
-                    h & /*gradio*/
+                    f & /*gradio*/
                     2048 && {
                         i18n: (
                             /*gradio*/
-                            l[11].i18n
+                            p[11].i18n
                         )
                     },
-                    h & /*loading_status*/
+                    f & /*loading_status*/
                     1024 && get_spread_object(
                         /*loading_status*/
-                        l[10]
+                        p[10]
                     )
                 ]) : {};
-            e.$set(_);
+            t.$set(A);
         },
-        i(l) {
-            i || (transition_in(e.$$.fragment, l), i = !0);
+        i(p) {
+            n || (transition_in(t.$$.fragment, p), n = !0);
         },
-        o(l) {
-            transition_out(e.$$.fragment, l), i = !1;
+        o(p) {
+            transition_out(t.$$.fragment, p), n = !1;
         },
-        d(l) {
-            destroy_component(e, l);
+        d(p) {
+            destroy_component(t, p);
         }
     };
 }
 
-function create_else_block(t) {
-    let e, i;
-    return e = new Upload({
+function create_else_block(i) {
+    let t, n;
+    return t = new Upload({
         props: {
             filetype: "application/pdf",
             file_count: "single",
             root: (
                 /*root*/
-                t[7]
+                i[7]
             ),
             $$slots: {
                 default: [create_default_slot_3]
             },
             $$scope: {
-                ctx: t
+                ctx: i
             }
         }
-    }), e.$on(
+    }), t.$on(
         "load",
         /*handle_upload*/
-        t[17]
+        i[17]
     ), {
         c() {
-            create_component(e.$$.fragment);
+            create_component(t.$$.fragment);
         },
-        m(n, s) {
-            mount_component(e, n, s), i = !0;
+        m(e, s) {
+            mount_component(t, e, s), n = !0;
         },
-        p(n, s) {
-            const l = {};
+        p(e, s) {
+            const p = {};
             s & /*root*/
-                128 && (l.root = /*root*/
-                    n[7]), s & /*$$scope*/
-                134217728 && (l.$$scope = {
+                128 && (p.root = /*root*/
+                    e[7]), s & /*$$scope*/
+                536870912 && (p.$$scope = {
                     dirty: s,
-                    ctx: n
-                }), e.$set(l);
+                    ctx: e
+                }), t.$set(p);
         },
-        i(n) {
-            i || (transition_in(e.$$.fragment, n), i = !0);
+        i(e) {
+            n || (transition_in(t.$$.fragment, e), n = !0);
         },
-        o(n) {
-            transition_out(e.$$.fragment, n), i = !1;
+        o(e) {
+            transition_out(t.$$.fragment, e), n = !1;
         },
-        d(n) {
-            destroy_component(e, n);
+        d(e) {
+            destroy_component(t, e);
         }
     };
 }
 
-function create_if_block(t) {
-    let e, i, n, s, l, h, _, c, o, r, T, S, w, C, P;
-    return e = new ModifyUpload({
+function create_if_block(i) {
+    let t, n, e, s, p, f, A, a, h, o, F, R, w, T, P;
+    return t = new ModifyUpload({
         props: {
             i18n: (
                 /*gradio*/
-                t[11].i18n
+                i[11].i18n
             ),
             absolute: !0
         }
-    }), e.$on(
+    }), t.$on(
         "clear",
         /*handle_clear*/
-        t[16]
-    ), _ = new Button({
+        i[16]
+    ), A = new Button({
         props: {
             $$slots: {
                 default: [create_default_slot_2]
             },
             $$scope: {
-                ctx: t
+                ctx: i
             }
         }
-    }), _.$on(
+    }), A.$on(
         "click",
         /*prev_page*/
-        t[19]
-    ), C = new Button({
+        i[19]
+    ), T = new Button({
         props: {
             $$slots: {
                 default: [create_default_slot_1]
             },
             $$scope: {
-                ctx: t
+                ctx: i
             }
         }
-    }), C.$on(
+    }), T.$on(
         "click",
         /*next_page*/
-        t[18]
+        i[18]
     ), {
         c() {
-            create_component(e.$$.fragment), i = space(), n = element("div"), s = element("canvas"), l = space(), h = element("div"), create_component(_.$$.fragment), c = space(), o = element("span"), r = text(
+            create_component(t.$$.fragment), n = space(), e = element("div"), s = element("canvas"), p = space(), f = element("div"), create_component(A.$$.fragment), a = space(), h = element("span"), o = text(
                 /*currentPage*/
-                t[14]
-            ), T = text(" / "), S = text(
+                i[15]
+            ), F = text(" / "), R = text(
                 /*numPages*/
-                t[13]
-            ), w = space(), create_component(C.$$.fragment), attr(n, "class", "pdf-canvas svelte-qxsbof"), set_style(
-                n,
+                i[13]
+            ), w = space(), create_component(T.$$.fragment), attr(e, "class", "pdf-canvas svelte-qxsbof"), set_style(
+                e,
                 "height",
                 /*height*/
-                t[1] + "px"
-            ), attr(o, "class", "page-count svelte-qxsbof"), attr(h, "class", "button-row svelte-qxsbof");
+                i[1] + "px"
+            ), attr(h, "class", "page-count svelte-qxsbof"), attr(f, "class", "button-row svelte-qxsbof");
         },
-        m(b, k) {
-            mount_component(e, b, k), insert(b, i, k), insert(b, n, k), append(n, s), t[22](s), insert(b, l, k), insert(b, h, k), mount_component(_, h, null), append(h, c), append(h, o), append(o, r), append(o, T), append(o, S), append(h, w), mount_component(C, h, null), P = !0;
+        m(m, C) {
+            mount_component(t, m, C), insert(m, n, C), insert(m, e, C), append(e, s), i[23](s), insert(m, p, C), insert(m, f, C), mount_component(A, f, null), append(f, a), append(f, h), append(h, o), append(h, F), append(h, R), append(f, w), mount_component(T, f, null), P = !0;
         },
-        p(b, k) {
-            const F = {};
-            k & /*gradio*/
-                2048 && (F.i18n = /*gradio*/
-                    b[11].i18n), e.$set(F), (!P || k & /*height*/
+        p(m, C) {
+            const x = {};
+            C & /*gradio*/
+                2048 && (x.i18n = /*gradio*/
+                    m[11].i18n), t.$set(x), (!P || C & /*height*/
                     2) && set_style(
-                    n,
+                    e,
                     "height",
                     /*height*/
-                    b[1] + "px"
+                    m[1] + "px"
                 );
-            const x = {};
-            k & /*$$scope*/
-                134217728 && (x.$$scope = {
-                    dirty: k,
-                    ctx: b
-                }), _.$set(x), (!P || k & /*currentPage*/
-                    16384) && set_data(
-                    r,
+            const E = {};
+            C & /*$$scope*/
+                536870912 && (E.$$scope = {
+                    dirty: C,
+                    ctx: m
+                }), A.$set(E), (!P || C & /*currentPage*/
+                    32768) && set_data(
+                    o,
                     /*currentPage*/
-                    b[14]
-                ), (!P || k & /*numPages*/
+                    m[15]
+                ), (!P || C & /*numPages*/
                     8192) && set_data(
-                    S,
+                    R,
                     /*numPages*/
-                    b[13]
+                    m[13]
                 );
-            const y = {};
-            k & /*$$scope*/
-                134217728 && (y.$$scope = {
-                    dirty: k,
-                    ctx: b
-                }), C.$set(y);
+            const S = {};
+            C & /*$$scope*/
+                536870912 && (S.$$scope = {
+                    dirty: C,
+                    ctx: m
+                }), T.$set(S);
         },
-        i(b) {
-            P || (transition_in(e.$$.fragment, b), transition_in(_.$$.fragment, b), transition_in(C.$$.fragment, b), P = !0);
+        i(m) {
+            P || (transition_in(t.$$.fragment, m), transition_in(A.$$.fragment, m), transition_in(T.$$.fragment, m), P = !0);
         },
-        o(b) {
-            transition_out(e.$$.fragment, b), transition_out(_.$$.fragment, b), transition_out(C.$$.fragment, b), P = !1;
+        o(m) {
+            transition_out(t.$$.fragment, m), transition_out(A.$$.fragment, m), transition_out(T.$$.fragment, m), P = !1;
         },
-        d(b) {
-            b && (detach(i), detach(n), detach(l), detach(h)), destroy_component(e, b), t[22](null), destroy_component(_), destroy_component(C);
+        d(m) {
+            m && (detach(n), detach(e), detach(p), detach(f)), destroy_component(t, m), i[23](null), destroy_component(A), destroy_component(T);
         }
     };
 }
 
-function create_default_slot_3(t) {
-    let e, i;
-    return e = new PdfUploadText({}), {
+function create_default_slot_3(i) {
+    let t, n;
+    return t = new PdfUploadText({}), {
         c() {
-            create_component(e.$$.fragment);
+            create_component(t.$$.fragment);
         },
-        m(n, s) {
-            mount_component(e, n, s), i = !0;
+        m(e, s) {
+            mount_component(t, e, s), n = !0;
         },
-        i(n) {
-            i || (transition_in(e.$$.fragment, n), i = !0);
+        i(e) {
+            n || (transition_in(t.$$.fragment, e), n = !0);
         },
-        o(n) {
-            transition_out(e.$$.fragment, n), i = !1;
+        o(e) {
+            transition_out(t.$$.fragment, e), n = !1;
         },
-        d(n) {
-            destroy_component(e, n);
+        d(e) {
+            destroy_component(t, e);
         }
     };
 }
 
-function create_default_slot_2(t) {
-    let e;
+function create_default_slot_2(i) {
+    let t;
     return {
         c() {
-            e = text("⬅️");
+            t = text("⬅️");
         },
-        m(i, n) {
-            insert(i, e, n);
+        m(n, e) {
+            insert(n, t, e);
         },
-        d(i) {
-            i && detach(e);
+        d(n) {
+            n && detach(t);
         }
     };
 }
 
-function create_default_slot_1(t) {
-    let e;
+function create_default_slot_1(i) {
+    let t;
     return {
         c() {
-            e = text("➡️");
+            t = text("➡️");
         },
-        m(i, n) {
-            insert(i, e, n);
+        m(n, e) {
+            insert(n, t, e);
         },
-        d(i) {
-            i && detach(e);
+        d(n) {
+            n && detach(t);
         }
     };
 }
 
-function create_default_slot(t) {
-    let e, i, n, s, l, h, _, c = (
+function create_default_slot(i) {
+    let t, n, e, s, p, f, A, a = (
         /*loading_status*/
-        t[10] && create_if_block_1(t)
+        i[10] && create_if_block_1(i)
     );
-    i = new BlockLabel({
+    n = new BlockLabel({
         props: {
             show_label: (
                 /*label*/
-                t[8] !== null
+                i[8] !== null
             ),
             Icon: File$1,
             float: (
                 /*value*/
-                t[0] === null
+                i[0] === null
             ),
             label: (
                 /*label*/
-                t[8] || "File"
+                i[8] || "File"
             )
         }
     });
-    const o = [create_if_block, create_else_block],
-        r = [];
+    const h = [create_if_block, create_else_block],
+        o = [];
 
-    function T(S, w) {
+    function F(R, w) {
         return (
             /*_value*/
-            S[12] ? 0 : 1
+            R[12] ? 0 : 1
         );
     }
-    return s = T(t), l = r[s] = o[s](t), {
+    return s = F(i), p = o[s] = h[s](i), {
         c() {
-            c && c.c(), e = space(), create_component(i.$$.fragment), n = space(), l.c(), h = empty();
+            a && a.c(), t = space(), create_component(n.$$.fragment), e = space(), p.c(), f = empty();
         },
-        m(S, w) {
-            c && c.m(S, w), insert(S, e, w), mount_component(i, S, w), insert(S, n, w), r[s].m(S, w), insert(S, h, w), _ = !0;
+        m(R, w) {
+            a && a.m(R, w), insert(R, t, w), mount_component(n, R, w), insert(R, e, w), o[s].m(R, w), insert(R, f, w), A = !0;
         },
-        p(S, w) {
+        p(R, w) {
             /*loading_status*/
-            S[10] ? c ? (c.p(S, w), w & /*loading_status*/
-                1024 && transition_in(c, 1)) : (c = create_if_block_1(S), c.c(), transition_in(c, 1), c.m(e.parentNode, e)) : c && (group_outros(), transition_out(c, 1, 1, () => {
-                c = null;
+            R[10] ? a ? (a.p(R, w), w & /*loading_status*/
+                1024 && transition_in(a, 1)) : (a = create_if_block_1(R), a.c(), transition_in(a, 1), a.m(t.parentNode, t)) : a && (group_outros(), transition_out(a, 1, 1, () => {
+                a = null;
             }), check_outros());
-            const C = {};
+            const T = {};
             w & /*label*/
-                256 && (C.show_label = /*label*/
-                    S[8] !== null), w & /*value*/
-                1 && (C.float = /*value*/
-                    S[0] === null), w & /*label*/
-                256 && (C.label = /*label*/
-                    S[8] || "File"), i.$set(C);
+                256 && (T.show_label = /*label*/
+                    R[8] !== null), w & /*value*/
+                1 && (T.float = /*value*/
+                    R[0] === null), w & /*label*/
+                256 && (T.label = /*label*/
+                    R[8] || "File"), n.$set(T);
             let P = s;
-            s = T(S), s === P ? r[s].p(S, w) : (group_outros(), transition_out(r[P], 1, 1, () => {
-                r[P] = null;
-            }), check_outros(), l = r[s], l ? l.p(S, w) : (l = r[s] = o[s](S), l.c()), transition_in(l, 1), l.m(h.parentNode, h));
+            s = F(R), s === P ? o[s].p(R, w) : (group_outros(), transition_out(o[P], 1, 1, () => {
+                o[P] = null;
+            }), check_outros(), p = o[s], p ? p.p(R, w) : (p = o[s] = h[s](R), p.c()), transition_in(p, 1), p.m(f.parentNode, f));
         },
-        i(S) {
-            _ || (transition_in(c), transition_in(i.$$.fragment, S), transition_in(l), _ = !0);
+        i(R) {
+            A || (transition_in(a), transition_in(n.$$.fragment, R), transition_in(p), A = !0);
         },
-        o(S) {
-            transition_out(c), transition_out(i.$$.fragment, S), transition_out(l), _ = !1;
+        o(R) {
+            transition_out(a), transition_out(n.$$.fragment, R), transition_out(p), A = !1;
         },
-        d(S) {
-            S && (detach(e), detach(n), detach(h)), c && c.d(S), destroy_component(i, S), r[s].d(S);
+        d(R) {
+            R && (detach(t), detach(e), detach(f)), a && a.d(R), destroy_component(n, R), o[s].d(R);
         }
     };
 }
 
-function create_fragment(t) {
-    let e, i;
-    return e = new Block({
+function create_fragment(i) {
+    let t, n;
+    return t = new Block({
         props: {
             visible: (
                 /*visible*/
-                t[4]
+                i[4]
             ),
             elem_id: (
                 /*elem_id*/
-                t[2]
+                i[2]
             ),
             elem_classes: (
                 /*elem_classes*/
-                t[3]
+                i[3]
             ),
             container: (
                 /*container*/
-                t[5]
+                i[5]
             ),
             scale: (
                 /*scale*/
-                t[6]
+                i[6]
             ),
             min_width: (
                 /*min_width*/
-                t[9]
+                i[9]
             ),
             $$slots: {
                 default: [create_default_slot]
             },
             $$scope: {
-                ctx: t
+                ctx: i
             }
         }
     }), {
         c() {
-            create_component(e.$$.fragment);
+            create_component(t.$$.fragment);
         },
-        m(n, s) {
-            mount_component(e, n, s), i = !0;
+        m(e, s) {
+            mount_component(t, e, s), n = !0;
         },
-        p(n, [s]) {
-            const l = {};
+        p(e, [s]) {
+            const p = {};
             s & /*visible*/
-                16 && (l.visible = /*visible*/
-                    n[4]), s & /*elem_id*/
-                4 && (l.elem_id = /*elem_id*/
-                    n[2]), s & /*elem_classes*/
-                8 && (l.elem_classes = /*elem_classes*/
-                    n[3]), s & /*container*/
-                32 && (l.container = /*container*/
-                    n[5]), s & /*scale*/
-                64 && (l.scale = /*scale*/
-                    n[6]), s & /*min_width*/
-                512 && (l.min_width = /*min_width*/
-                    n[9]), s & /*$$scope, numPages, currentPage, height, canvasRef, gradio, _value, root, label, value, loading_status*/
-                134282627 && (l.$$scope = {
+                16 && (p.visible = /*visible*/
+                    e[4]), s & /*elem_id*/
+                4 && (p.elem_id = /*elem_id*/
+                    e[2]), s & /*elem_classes*/
+                8 && (p.elem_classes = /*elem_classes*/
+                    e[3]), s & /*container*/
+                32 && (p.container = /*container*/
+                    e[5]), s & /*scale*/
+                64 && (p.scale = /*scale*/
+                    e[6]), s & /*min_width*/
+                512 && (p.min_width = /*min_width*/
+                    e[9]), s & /*$$scope, numPages, currentPage, height, canvasRef, gradio, _value, root, label, value, loading_status*/
+                536935811 && (p.$$scope = {
                     dirty: s,
-                    ctx: n
-                }), e.$set(l);
+                    ctx: e
+                }), t.$set(p);
         },
-        i(n) {
-            i || (transition_in(e.$$.fragment, n), i = !0);
+        i(e) {
+            n || (transition_in(t.$$.fragment, e), n = !0);
         },
-        o(n) {
-            transition_out(e.$$.fragment, n), i = !1;
+        o(e) {
+            transition_out(t.$$.fragment, e), n = !1;
         },
-        d(n) {
-            destroy_component(e, n);
+        d(e) {
+            destroy_component(t, e);
         }
     };
 }
 
-function instance(t, e, i) {
+function instance(i, t, n) {
+    let e;
+    var s = this && this.__awaiter || function(U, G, V, H) {
+        function st(dt) {
+            return dt instanceof V ? dt : new V(function(yt) {
+                yt(dt);
+            });
+        }
+        return new(V || (V = Promise))(function(dt, yt) {
+            function gt(u) {
+                try {
+                    l(H.next(u));
+                } catch (d) {
+                    yt(d);
+                }
+            }
+
+            function k(u) {
+                try {
+                    l(H.throw(u));
+                } catch (d) {
+                    yt(d);
+                }
+            }
+
+            function l(u) {
+                u.done ? dt(u.value) : st(u.value).then(gt, k);
+            }
+            l((H = H.apply(U, G || [])).next());
+        });
+    };
     let {
-        elem_id: n = ""
-    } = e, {
-        elem_classes: s = []
-    } = e, {
-        visible: l = !0
-    } = e, {
-        value: h = null
-    } = e, {
-        container: _ = !0
-    } = e, {
-        scale: c = null
-    } = e, {
-        root: o
-    } = e, {
-        height: r = 500
-    } = e, {
+        elem_id: p = ""
+    } = t, {
+        elem_classes: f = []
+    } = t, {
+        visible: A = !0
+    } = t, {
+        value: a = null
+    } = t, {
+        container: h = !0
+    } = t, {
+        scale: o = null
+    } = t, {
+        root: F
+    } = t, {
+        height: R = 500
+    } = t, {
+        starting_page: w
+    } = t, {
         label: T
-    } = e, {
-        proxy_url: S
-    } = e, {
-        min_width: w = void 0
-    } = e, {
+    } = t, {
+        proxy_url: P
+    } = t, {
+        min_width: m = void 0
+    } = t, {
         loading_status: C
-    } = e, {
-        gradio: P
-    } = e;
-    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdn.bootcss.com/pdf.js/3.11.174/pdf.worker.js";
-    let b = h,
-        k = b,
-        F, x = 1,
-        y = 1,
-        p;
-    async function E() {
-        i(12, b = null), await tick(), P.dispatch("change"), i(14, y = 1);
+    } = t, {
+        gradio: x
+    } = t;
+    pdfExports.GlobalWorkerOptions.workerSrc = "https://cdn.bootcss.com/pdf.js/3.11.174/pdf.worker.js";
+    let E = a,
+        S = E,
+        g, v = 1,
+        $;
+
+    function M() {
+        return s(this, void 0, void 0, function*() {
+            n(12, E = null), yield tick(), x.dispatch("change");
+        });
     }
-    async function $({
-        detail: G
-    }) {
-        i(0, h = G), await tick(), P.dispatch("change"), P.dispatch("upload"), i(14, y = 1);
+
+    function _(U) {
+        return s(this, arguments, void 0, function*({
+            detail: G
+        }) {
+            n(0, a = G), yield tick(), x.dispatch("change"), x.dispatch("upload");
+        });
     }
-    async function M(G) {
-        F = await pdfjsLib.getDocument(G.url).promise, i(13, x = F.numPages), m();
+
+    function N(U) {
+        return s(this, void 0, void 0, function*() {
+            g = yield pdfExports.getDocument(U.url).promise, n(13, v = g.numPages), D();
+        });
     }
 
-    function m() {
-        F.getPage(y).then((G) => {
-            const I = p.getContext("2d");
-            I.clearRect(0, 0, p.width, p.height);
-            let B = G.getViewport({
+    function D() {
+        g.getPage(e).then((U) => {
+            const G = $.getContext("2d");
+            G.clearRect(0, 0, $.width, $.height);
+            let V = U.getViewport({
                     scale: 1
                 }),
-                ee = r / B.height;
-            B = G.getViewport({
-                scale: ee
+                H = R / V.height;
+            V = U.getViewport({
+                scale: H
             });
-            const Y = {
-                canvasContext: I,
-                viewport: B
+            const st = {
+                canvasContext: G,
+                viewport: V
             };
-            i(15, p.width = B.width, p), i(15, p.height = B.height, p), G.render(Y);
+            n(14, $.width = V.width, $), n(14, $.height = V.height, $), U.render(st);
         });
     }
 
-    function N() {
-        y >= x || (i(14, y++, y), m());
+    function X() {
+        e >= v || (n(15, e++, e), D());
     }
 
-    function D() {
-        y != 1 && (i(14, y--, y), m());
+    function Y() {
+        e != 1 && (n(15, e--, e), D());
     }
 
-    function X(G) {
-        binding_callbacks[G ? "unshift" : "push"](() => {
-            p = G, i(15, p);
+    function I(U) {
+        binding_callbacks[U ? "unshift" : "push"](() => {
+            $ = U, n(14, $);
         });
     }
-    return t.$$set = (G) => {
-        "elem_id" in G && i(2, n = G.elem_id), "elem_classes" in G && i(3, s = G.elem_classes), "visible" in G && i(4, l = G.visible), "value" in G && i(0, h = G.value), "container" in G && i(5, _ = G.container), "scale" in G && i(6, c = G.scale), "root" in G && i(7, o = G.root), "height" in G && i(1, r = G.height), "label" in G && i(8, T = G.label), "proxy_url" in G && i(20, S = G.proxy_url), "min_width" in G && i(9, w = G.min_width), "loading_status" in G && i(10, C = G.loading_status), "gradio" in G && i(11, P = G.gradio);
-    }, t.$$.update = () => {
-        t.$$.dirty & /*height*/
-            2 && i(1, r = r || 500), t.$$.dirty & /*value, root, proxy_url*/
-            1048705 && i(12, b = normalise_file(h, o, S)), t.$$.dirty & /*old_value, _value, gradio*/
-            2103296 && JSON.stringify(k) != JSON.stringify(b) && (b && M(b), i(21, k = b), P.dispatch("change"));
+    return i.$$set = (U) => {
+        "elem_id" in U && n(2, p = U.elem_id), "elem_classes" in U && n(3, f = U.elem_classes), "visible" in U && n(4, A = U.visible), "value" in U && n(0, a = U.value), "container" in U && n(5, h = U.container), "scale" in U && n(6, o = U.scale), "root" in U && n(7, F = U.root), "height" in U && n(1, R = U.height), "starting_page" in U && n(20, w = U.starting_page), "label" in U && n(8, T = U.label), "proxy_url" in U && n(21, P = U.proxy_url), "min_width" in U && n(9, m = U.min_width), "loading_status" in U && n(10, C = U.loading_status), "gradio" in U && n(11, x = U.gradio);
+    }, i.$$.update = () => {
+        i.$$.dirty & /*starting_page, numPages*/
+            1056768 && n(15, e = Math.min(Math.max(w, 1), v)), i.$$.dirty & /*height*/
+            2 && n(1, R = R || 500), i.$$.dirty & /*value, root, proxy_url*/
+            2097281 && n(12, E = normalise_file(a, F, P)), i.$$.dirty & /*old_value, _value, gradio*/
+            4200448 && JSON.stringify(S) != JSON.stringify(E) && (E && N(E), n(22, S = E), x.dispatch("change"));
     }, [
+        a,
+        R,
+        p,
+        f,
+        A,
         h,
-        r,
-        n,
-        s,
-        l,
-        _,
-        c,
         o,
+        F,
         T,
-        w,
+        m,
         C,
-        P,
-        b,
         x,
-        y,
-        p,
         E,
+        v,
         $,
-        N,
-        D,
+        e,
+        M,
+        _,
+        X,
+        Y,
+        w,
+        P,
         S,
-        k,
-        X
+        I
     ];
 }
 class Index extends SvelteComponent {
-    constructor(e) {
-        super(), init(this, e, instance, create_fragment, safe_not_equal, {
+    constructor(t) {
+        super(), init(this, t, instance, create_fragment, safe_not_equal, {
             elem_id: 2,
             elem_classes: 3,
             visible: 4,
             value: 0,
             container: 5,
             scale: 6,
             root: 7,
             height: 1,
+            starting_page: 20,
             label: 8,
-            proxy_url: 20,
+            proxy_url: 21,
             min_width: 9,
             loading_status: 10,
             gradio: 11
         });
     }
 }
 export {
```

### Comparing `gradio_pdf-0.0.7/backend/gradio_pdf/templates/component/style.css` & `gradio_pdf-0.0.8/backend/gradio_pdf/templates/component/style.css`

 * *Files identical despite different names*

### Comparing `gradio_pdf-0.0.7/backend/gradio_pdf/templates/component/wrapper-98f94c21-d1a5537c.js` & `gradio_pdf-0.0.8/backend/gradio_pdf/templates/component/wrapper-98f94c21-DqR3tIm1.js`

 * *Files 0% similar despite different names*

#### js-beautify {}

```diff
@@ -1,10 +1,10 @@
 import {
     r as S
-} from "./Index-94e506c5.js";
+} from "./Index-BYwJN1i6.js";
 
 function z(s) {
     return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
 }
 
 function gt(s) {
     if (s.__esModule)
```

### Comparing `gradio_pdf-0.0.7/backend/gradio_pdf/templates/example/index.js` & `gradio_pdf-0.0.8/backend/gradio_pdf/templates/example/index.js`

 * *Files 3% similar despite different names*

#### js-beautify {}

```diff
@@ -7,59 +7,53 @@
 }) : dt[d] = et;
 var ee = (dt, d, et) => (ts(dt, typeof d != "symbol" ? d + "" : d, et), et),
     Ne = (dt, d, et) => {
         if (!d.has(dt))
             throw TypeError("Cannot " + et);
     };
 var t = (dt, d, et) => (Ne(dt, d, "read from private field"), et ? et.call(dt) : d.get(dt)),
-    L = (dt, d, et) => {
+    I = (dt, d, et) => {
         if (d.has(dt))
             throw TypeError("Cannot add the same private member more than once");
         d instanceof WeakSet ? d.add(dt) : d.set(dt, et);
     },
-    Z = (dt, d, et, l) => (Ne(dt, d, "write to private field"), l ? l.call(dt, et) : d.set(dt, et), et);
-var ge = (dt, d, et, l) => ({
+    Z = (dt, d, et, c) => (Ne(dt, d, "write to private field"), c ? c.call(dt, et) : d.set(dt, et), et);
+var ge = (dt, d, et, c) => ({
         set _(P) {
             Z(dt, d, P, et);
         },
         get _() {
-            return t(dt, d, l);
+            return t(dt, d, c);
         }
     }),
     W = (dt, d, et) => (Ne(dt, d, "access private method"), et);
 
 function getDefaultExportFromCjs(dt) {
     return dt && dt.__esModule && Object.prototype.hasOwnProperty.call(dt, "default") ? dt.default : dt;
 }
 
 function getAugmentedNamespace(dt) {
     if (dt.__esModule)
         return dt;
     var d = dt.default;
     if (typeof d == "function") {
-        var et = function l() {
-            if (this instanceof l) {
-                var P = [null];
-                P.push.apply(P, arguments);
-                var rt = Function.bind.apply(d, P);
-                return new rt();
-            }
-            return d.apply(this, arguments);
+        var et = function c() {
+            return this instanceof c ? Reflect.construct(d, arguments, this.constructor) : d.apply(this, arguments);
         };
         et.prototype = d.prototype;
     } else
         et = {};
     return Object.defineProperty(et, "__esModule", {
         value: !0
-    }), Object.keys(dt).forEach(function(l) {
-        var P = Object.getOwnPropertyDescriptor(dt, l);
-        Object.defineProperty(et, l, P.get ? P : {
+    }), Object.keys(dt).forEach(function(c) {
+        var P = Object.getOwnPropertyDescriptor(dt, c);
+        Object.defineProperty(et, c, P.get ? P : {
             enumerable: !0,
             get: function() {
-                return dt[l];
+                return dt[c];
             }
         });
     }), et;
 }
 
 function commonjsRequire(dt) {
     throw new Error('Could not dynamically require "' + dt + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
@@ -84,19 +78,19 @@
             var __webpack_modules__ = [,
                     /* 1 */
                     /***/
                     (dt, d) => {
                         var $t;
                         Object.defineProperty(d, "__esModule", {
                             value: !0
-                        }), d.VerbosityLevel = d.Util = d.UnknownErrorException = d.UnexpectedResponseException = d.TextRenderingMode = d.RenderingIntentFlag = d.PromiseCapability = d.PermissionFlag = d.PasswordResponses = d.PasswordException = d.PageActionEventType = d.OPS = d.MissingPDFException = d.MAX_IMAGE_SIZE_TO_CACHE = d.LINE_FACTOR = d.LINE_DESCENT_FACTOR = d.InvalidPDFException = d.ImageKind = d.IDENTITY_MATRIX = d.FormatError = d.FeatureTest = d.FONT_IDENTITY_MATRIX = d.DocumentActionEventType = d.CMapCompressionType = d.BaseException = d.BASELINE_FACTOR = d.AnnotationType = d.AnnotationReplyType = d.AnnotationPrefix = d.AnnotationMode = d.AnnotationFlag = d.AnnotationFieldFlag = d.AnnotationEditorType = d.AnnotationEditorPrefix = d.AnnotationEditorParamsType = d.AnnotationBorderStyleType = d.AnnotationActionEventType = d.AbortException = void 0, d.assert = lt, d.bytesToString = N, d.createValidAbsoluteUrl = wt, d.getModificationDate = Ct, d.getUuid = Vt, d.getVerbosityLevel = V, d.info = st, d.isArrayBuffer = ht, d.isArrayEqual = Et, d.isNodeJS = void 0, d.normalizeUnicode = Xt, d.objectFromMap = ct, d.objectSize = nt, d.setVerbosityLevel = E, d.shadow = xt, d.string32 = Q, d.stringToBytes = tt, d.stringToPDFString = ft, d.stringToUTF8String = K, d.unreachable = H, d.utf8StringToString = J, d.warn = at;
+                        }), d.VerbosityLevel = d.Util = d.UnknownErrorException = d.UnexpectedResponseException = d.TextRenderingMode = d.RenderingIntentFlag = d.PromiseCapability = d.PermissionFlag = d.PasswordResponses = d.PasswordException = d.PageActionEventType = d.OPS = d.MissingPDFException = d.MAX_IMAGE_SIZE_TO_CACHE = d.LINE_FACTOR = d.LINE_DESCENT_FACTOR = d.InvalidPDFException = d.ImageKind = d.IDENTITY_MATRIX = d.FormatError = d.FeatureTest = d.FONT_IDENTITY_MATRIX = d.DocumentActionEventType = d.CMapCompressionType = d.BaseException = d.BASELINE_FACTOR = d.AnnotationType = d.AnnotationReplyType = d.AnnotationPrefix = d.AnnotationMode = d.AnnotationFlag = d.AnnotationFieldFlag = d.AnnotationEditorType = d.AnnotationEditorPrefix = d.AnnotationEditorParamsType = d.AnnotationBorderStyleType = d.AnnotationActionEventType = d.AbortException = void 0, d.assert = lt, d.bytesToString = N, d.createValidAbsoluteUrl = wt, d.getModificationDate = Ct, d.getUuid = Vt, d.getVerbosityLevel = V, d.info = st, d.isArrayBuffer = ht, d.isArrayEqual = Et, d.isNodeJS = void 0, d.normalizeUnicode = Xt, d.objectFromMap = ct, d.objectSize = nt, d.setVerbosityLevel = C, d.shadow = Pt, d.string32 = Q, d.stringToBytes = tt, d.stringToPDFString = ft, d.stringToUTF8String = K, d.unreachable = H, d.utf8StringToString = J, d.warn = at;
                         const et = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
                         d.isNodeJS = et;
-                        const l = [1, 0, 0, 1, 0, 0];
-                        d.IDENTITY_MATRIX = l;
+                        const c = [1, 0, 0, 1, 0, 0];
+                        d.IDENTITY_MATRIX = c;
                         const P = [1e-3, 0, 0, 1e-3, 0, 0];
                         d.FONT_IDENTITY_MATRIX = P;
                         const rt = 1e7;
                         d.MAX_IMAGE_SIZE_TO_CACHE = rt;
                         const X = 1.35;
                         d.LINE_FACTOR = X;
                         const pt = 0.35;
@@ -117,35 +111,35 @@
                         const g = {
                             DISABLE: 0,
                             ENABLE: 1,
                             ENABLE_FORMS: 2,
                             ENABLE_STORAGE: 3
                         };
                         d.AnnotationMode = g;
-                        const O = "pdfjs_internal_editor_";
-                        d.AnnotationEditorPrefix = O;
-                        const I = {
+                        const L = "pdfjs_internal_editor_";
+                        d.AnnotationEditorPrefix = L;
+                        const O = {
                             DISABLE: -1,
                             NONE: 0,
                             FREETEXT: 3,
                             STAMP: 13,
                             INK: 15
                         };
-                        d.AnnotationEditorType = I;
-                        const x = {
+                        d.AnnotationEditorType = O;
+                        const T = {
                             RESIZE: 1,
                             CREATE: 2,
                             FREETEXT_SIZE: 11,
                             FREETEXT_COLOR: 12,
                             FREETEXT_OPACITY: 13,
                             INK_COLOR: 21,
                             INK_THICKNESS: 22,
                             INK_OPACITY: 23
                         };
-                        d.AnnotationEditorParamsType = x;
+                        d.AnnotationEditorParamsType = T;
                         const v = {
                             PRINT: 4,
                             MODIFY_CONTENTS: 8,
                             COPY: 16,
                             MODIFY_ANNOTATIONS: 32,
                             FILL_INTERACTIVE_FORMS: 256,
                             COPY_FOR_ACCESSIBILITY: 512,
@@ -168,15 +162,15 @@
                         d.TextRenderingMode = A;
                         const u = {
                             GRAYSCALE_1BPP: 1,
                             RGB_24BPP: 2,
                             RGBA_32BPP: 3
                         };
                         d.ImageKind = u;
-                        const _ = {
+                        const b = {
                             TEXT: 1,
                             LINK: 2,
                             FREETEXT: 3,
                             LINE: 4,
                             SQUARE: 5,
                             CIRCLE: 6,
                             POLYGON: 7,
@@ -196,33 +190,33 @@
                             SCREEN: 21,
                             PRINTERMARK: 22,
                             TRAPNET: 23,
                             WATERMARK: 24,
                             THREED: 25,
                             REDACT: 26
                         };
-                        d.AnnotationType = _;
-                        const w = {
+                        d.AnnotationType = b;
+                        const E = {
                             GROUP: "Group",
                             REPLY: "R"
                         };
-                        d.AnnotationReplyType = w;
-                        const C = {
+                        d.AnnotationReplyType = E;
+                        const w = {
                             INVISIBLE: 1,
                             HIDDEN: 2,
                             PRINT: 4,
                             NOZOOM: 8,
                             NOROTATE: 16,
                             NOVIEW: 32,
                             READONLY: 64,
                             LOCKED: 128,
                             TOGGLENOVIEW: 256,
                             LOCKEDCONTENTS: 512
                         };
-                        d.AnnotationFlag = C;
+                        d.AnnotationFlag = w;
                         const y = {
                             READONLY: 1,
                             REQUIRED: 2,
                             NOEXPORT: 4,
                             MULTILINE: 4096,
                             PASSWORD: 8192,
                             NOTOGGLETOOFF: 16384,
@@ -245,15 +239,15 @@
                             SOLID: 1,
                             DASHED: 2,
                             BEVELED: 3,
                             INSET: 4,
                             UNDERLINE: 5
                         };
                         d.AnnotationBorderStyleType = a;
-                        const c = {
+                        const l = {
                             E: "Mouse Enter",
                             X: "Mouse Exit",
                             D: "Mouse Down",
                             U: "Mouse Up",
                             Fo: "Focus",
                             Bl: "Blur",
                             PO: "PageOpen",
@@ -261,15 +255,15 @@
                             PV: "PageVisible",
                             PI: "PageInvisible",
                             K: "Keystroke",
                             F: "Format",
                             V: "Validate",
                             C: "Calculate"
                         };
-                        d.AnnotationActionEventType = c;
+                        d.AnnotationActionEventType = l;
                         const k = {
                             WC: "WillClose",
                             WS: "WillSave",
                             DS: "DidSave",
                             WP: "WillPrint",
                             DP: "DidPrint"
                         };
@@ -281,19 +275,19 @@
                         d.PageActionEventType = p;
                         const r = {
                             ERRORS: 0,
                             WARNINGS: 1,
                             INFOS: 5
                         };
                         d.VerbosityLevel = r;
-                        const T = {
+                        const x = {
                             NONE: 0,
                             BINARY: 1
                         };
-                        d.CMapCompressionType = T;
+                        d.CMapCompressionType = x;
                         const m = {
                             dependency: 1,
                             setLineWidth: 2,
                             setLineCap: 3,
                             setLineJoin: 4,
                             setMiterLimit: 5,
                             setDash: 6,
@@ -384,15 +378,15 @@
                         const U = {
                             NEED_PASSWORD: 1,
                             INCORRECT_PASSWORD: 2
                         };
                         d.PasswordResponses = U;
                         let z = r.WARNINGS;
 
-                        function E(ot) {
+                        function C(ot) {
                             Number.isInteger(ot) && (z = ot);
                         }
 
                         function V() {
                             return z;
                         }
 
@@ -442,15 +436,15 @@
                                 const bt = Y ? new URL(ot, Y) : new URL(ot);
                                 if (gt(bt))
                                     return bt;
                             } catch {}
                             return null;
                         }
 
-                        function xt(ot, Y, G, bt = !1) {
+                        function Pt(ot, Y, G, bt = !1) {
                             return Object.defineProperty(ot, Y, {
                                 value: G,
                                 enumerable: !bt,
                                 configurable: !0,
                                 writable: !1
                             }), G;
                         }
@@ -487,20 +481,20 @@
                         d.MissingPDFException = o;
                         class h extends S {
                             constructor(Y, G) {
                                 super(Y, "UnexpectedResponseException"), this.status = G;
                             }
                         }
                         d.UnexpectedResponseException = h;
-                        class b extends S {
+                        class _ extends S {
                             constructor(Y) {
                                 super(Y, "FormatError");
                             }
                         }
-                        d.FormatError = b;
+                        d.FormatError = _;
                         class M extends S {
                             constructor(Y) {
                                 super(Y, "AbortException");
                             }
                         }
                         d.AbortException = M;
 
@@ -553,34 +547,34 @@
                                 return new Function(""), !0;
                             } catch {
                                 return !1;
                             }
                         }
                         class Ft {
                             static get isLittleEndian() {
-                                return xt(this, "isLittleEndian", yt());
+                                return Pt(this, "isLittleEndian", yt());
                             }
                             static get isEvalSupported() {
-                                return xt(this, "isEvalSupported", ut());
+                                return Pt(this, "isEvalSupported", ut());
                             }
                             static get isOffscreenCanvasSupported() {
-                                return xt(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
+                                return Pt(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
                             }
                             static get platform() {
-                                return typeof navigator > "u" ? xt(this, "platform", {
+                                return typeof navigator > "u" ? Pt(this, "platform", {
                                     isWin: !1,
                                     isMac: !1
-                                }) : xt(this, "platform", {
+                                }) : Pt(this, "platform", {
                                     isWin: navigator.platform.includes("Win"),
                                     isMac: navigator.platform.includes("Mac")
                                 });
                             }
                             static get isCSSRoundSupported() {
                                 var Y, G;
-                                return xt(this, "isCSSRoundSupported", (G = (Y = globalThis.CSS) == null ? void 0 : Y.supports) == null ? void 0 : G.call(Y, "width: round(1.5px, 1px)"));
+                                return Pt(this, "isCSSRoundSupported", (G = (Y = globalThis.CSS) == null ? void 0 : Y.supports) == null ? void 0 : G.call(Y, "width: round(1.5px, 1px)"));
                             }
                         }
                         d.FeatureTest = Ft;
                         const Bt = [...Array(256).keys()].map((ot) => ot.toString(16).padStart(2, "0"));
                         class St {
                             static makeHexColor(Y, G, bt) {
                                 return `#${Bt[Y]}${Bt[G]}${Bt[bt]}`;
@@ -710,15 +704,15 @@
                         }
 
                         function Ct(ot = /* @__PURE__ */ new Date()) {
                             return [ot.getUTCFullYear().toString(), (ot.getUTCMonth() + 1).toString().padStart(2, "0"), ot.getUTCDate().toString().padStart(2, "0"), ot.getUTCHours().toString().padStart(2, "0"), ot.getUTCMinutes().toString().padStart(2, "0"), ot.getUTCSeconds().toString().padStart(2, "0")].join("");
                         }
                         class Ut {
                             constructor() {
-                                L(this, $t, !1);
+                                I(this, $t, !1);
                                 this.promise = new Promise((Y, G) => {
                                     this.resolve = (bt) => {
                                         Z(this, $t, !0), Y(bt);
                                     }, this.reject = (bt) => {
                                         Z(this, $t, !0), G(bt);
                                     };
                                 });
@@ -750,15 +744,15 @@
                         }
                         const Wt = "pdfjs_internal_id_";
                         d.AnnotationPrefix = Wt;
                     },
                     /* 2 */
                     /***/
                     (__unused_webpack_module, exports, __w_pdfjs_require__) => {
-                        var dt, et, l, P, he, X, Ee, B, F, g, O, I, x, v, A, u, we, w, C, Be, a, c;
+                        var dt, et, c, P, he, X, Ee, B, F, g, L, O, T, v, A, u, we, E, w, Be, a, l;
                         Object.defineProperty(exports, "__esModule", {
                             value: !0
                         }), exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0, Object.defineProperty(exports, "SVGGraphics", {
                             enumerable: !0,
                             get: function() {
                                 return _displaySvg.SVGGraphics;
                             }
@@ -798,35 +792,35 @@
                                     data: p
                                 }), typeof p != "object")
                                 throw new Error("Invalid parameter in getDocument, need parameter object.");
                             if (!p.url && !p.data && !p.range)
                                 throw new Error("Invalid parameter object: need either .data, .range or .url");
                             const r = new PDFDocumentLoadingTask(),
                                 {
-                                    docId: T
+                                    docId: x
                                 } = r,
                                 m = p.url ? getUrlProp(p.url) : null,
                                 U = p.data ? getDataProp(p.data) : null,
                                 z = p.httpHeaders || null,
-                                E = p.withCredentials === !0,
+                                C = p.withCredentials === !0,
                                 V = p.password ?? null,
                                 st = p.range instanceof PDFDataRangeTransport ? p.range : null,
                                 at = Number.isInteger(p.rangeChunkSize) && p.rangeChunkSize > 0 ? p.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
                             let H = p.worker instanceof PDFWorker ? p.worker : null;
                             const lt = p.verbosity,
                                 gt = typeof p.docBaseUrl == "string" && !(0, _display_utils.isDataScheme)(p.docBaseUrl) ? p.docBaseUrl : null,
                                 wt = typeof p.cMapUrl == "string" ? p.cMapUrl : null,
-                                xt = p.cMapPacked !== !1,
+                                Pt = p.cMapPacked !== !1,
                                 S = p.CMapReaderFactory || DefaultCMapReaderFactory,
                                 i = typeof p.standardFontDataUrl == "string" ? p.standardFontDataUrl : null,
                                 n = p.StandardFontDataFactory || DefaultStandardFontDataFactory,
                                 s = p.stopAtErrors !== !0,
                                 o = Number.isInteger(p.maxImageSize) && p.maxImageSize > -1 ? p.maxImageSize : -1,
                                 h = p.isEvalSupported !== !1,
-                                b = typeof p.isOffscreenCanvasSupported == "boolean" ? p.isOffscreenCanvasSupported : !_util.isNodeJS,
+                                _ = typeof p.isOffscreenCanvasSupported == "boolean" ? p.isOffscreenCanvasSupported : !_util.isNodeJS,
                                 M = Number.isInteger(p.canvasMaxAreaInBytes) ? p.canvasMaxAreaInBytes : -1,
                                 N = typeof p.disableFontFace == "boolean" ? p.disableFontFace : _util.isNodeJS,
                                 tt = p.fontExtraProperties === !0,
                                 Q = p.enableXfa === !0,
                                 nt = p.ownerDocument || globalThis.document,
                                 ct = p.disableRange === !0,
                                 yt = p.disableStream === !0,
@@ -835,51 +829,51 @@
                                 Bt = st ? st.length : p.length ?? NaN,
                                 St = typeof p.useSystemFonts == "boolean" ? p.useSystemFonts : !_util.isNodeJS && !N,
                                 Dt = typeof p.useWorkerFetch == "boolean" ? p.useWorkerFetch : S === _display_utils.DOMCMapReaderFactory && n === _display_utils.DOMStandardFontDataFactory && wt && i && (0, _display_utils.isValidFetchUrl)(wt, document.baseURI) && (0, _display_utils.isValidFetchUrl)(i, document.baseURI),
                                 ft = p.canvasFactory || new DefaultCanvasFactory({
                                     ownerDocument: nt
                                 }),
                                 K = p.filterFactory || new DefaultFilterFactory({
-                                    docId: T,
+                                    docId: x,
                                     ownerDocument: nt
                                 }),
                                 J = null;
                             (0, _util.setVerbosityLevel)(lt);
                             const ht = {
                                 canvasFactory: ft,
                                 filterFactory: K
                             };
                             if (Dt || (ht.cMapReaderFactory = new S({
                                     baseUrl: wt,
-                                    isCompressed: xt
+                                    isCompressed: Pt
                                 }), ht.standardFontDataFactory = new n({
                                     baseUrl: i
                                 })), !H) {
                                 const Ut = {
                                     verbosity: lt,
                                     port: _worker_options.GlobalWorkerOptions.workerPort
                                 };
                                 H = Ut.port ? PDFWorker.fromPort(Ut) : new PDFWorker(Ut), r._worker = H;
                             }
                             const Et = {
-                                    docId: T,
+                                    docId: x,
                                     apiVersion: "3.11.174",
                                     data: U,
                                     password: V,
                                     disableAutoFetch: ut,
                                     rangeChunkSize: at,
                                     length: Bt,
                                     docBaseUrl: gt,
                                     enableXfa: Q,
                                     evaluatorOptions: {
                                         maxImageSize: o,
                                         disableFontFace: N,
                                         ignoreErrors: s,
                                         isEvalSupported: h,
-                                        isOffscreenCanvasSupported: b,
+                                        isOffscreenCanvasSupported: _,
                                         canvasMaxAreaInBytes: M,
                                         fontExtraProperties: tt,
                                         useSystemFonts: St,
                                         cMapUrl: Dt ? wt : null,
                                         standardFontDataUrl: Dt ? i : null
                                     }
                                 },
@@ -907,36 +901,36 @@
                                             contentDispositionFilename: st.contentDispositionFilename,
                                             disableRange: ct,
                                             disableStream: yt
                                         }, st) : U || (Xt = ((Wt) => _util.isNodeJS ? new _displayNode_stream.PDFNodeStream(Wt) : (0, _display_utils.isValidFetchUrl)(Wt.url) ? new _displayFetch_stream.PDFFetchStream(Wt) : new _displayNetwork.PDFNetworkStream(Wt))({
                                             url: m,
                                             length: Bt,
                                             httpHeaders: z,
-                                            withCredentials: E,
+                                            withCredentials: C,
                                             rangeChunkSize: at,
                                             disableRange: ct,
                                             disableStream: yt
                                         })), Ht(Xt);
                                     });
                                 return Promise.all([Ut, Gt]).then(function([Ht, Xt]) {
                                     if (r.destroyed)
                                         throw new Error("Loading aborted");
-                                    const Vt = new _message_handler.MessageHandler(T, Ht, H.port),
+                                    const Vt = new _message_handler.MessageHandler(x, Ht, H.port),
                                         Wt = new WorkerTransport(Vt, r, Xt, Ct, ht);
                                     r._transport = Wt, Vt.send("Ready", null);
                                 });
                             }).catch(r._capability.reject), r;
                         }
                         async function _fetchDocument(p, r) {
                             if (p.destroyed)
                                 throw new Error("Worker was destroyed");
-                            const T = await p.messageHandler.sendWithPromise("GetDocRequest", r, r.data ? [r.data.buffer] : null);
+                            const x = await p.messageHandler.sendWithPromise("GetDocRequest", r, r.data ? [r.data.buffer] : null);
                             if (p.destroyed)
                                 throw new Error("Worker was destroyed");
-                            return T;
+                            return x;
                         }
 
                         function getUrlProp(p) {
                             if (p instanceof URL)
                                 return p.href;
                             try {
                                 return new URL(p, window.location).href;
@@ -962,77 +956,77 @@
                             constructor() {
                                 this._capability = new _util.PromiseCapability(), this._transport = null, this._worker = null, this.docId = `d${ge(d, dt)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
                             }
                             get promise() {
                                 return this._capability.promise;
                             }
                             async destroy() {
-                                var r, T, m;
+                                var r, x, m;
                                 this.destroyed = !0;
                                 try {
-                                    (r = this._worker) != null && r.port && (this._worker._pendingDestroy = !0), await ((T = this._transport) == null ? void 0 : T.destroy());
+                                    (r = this._worker) != null && r.port && (this._worker._pendingDestroy = !0), await ((x = this._transport) == null ? void 0 : x.destroy());
                                 } catch (U) {
                                     throw (m = this._worker) != null && m.port && delete this._worker._pendingDestroy, U;
                                 }
                                 this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
                             }
                         };
-                        dt = new WeakMap(), L(d, dt, 0);
+                        dt = new WeakMap(), I(d, dt, 0);
                         let PDFDocumentLoadingTask = d;
                         exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
                         class PDFDataRangeTransport {
-                            constructor(r, T, m = !1, U = null) {
-                                this.length = r, this.initialData = T, this.progressiveDone = m, this.contentDispositionFilename = U, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = new _util.PromiseCapability();
+                            constructor(r, x, m = !1, U = null) {
+                                this.length = r, this.initialData = x, this.progressiveDone = m, this.contentDispositionFilename = U, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = new _util.PromiseCapability();
                             }
                             addRangeListener(r) {
                                 this._rangeListeners.push(r);
                             }
                             addProgressListener(r) {
                                 this._progressListeners.push(r);
                             }
                             addProgressiveReadListener(r) {
                                 this._progressiveReadListeners.push(r);
                             }
                             addProgressiveDoneListener(r) {
                                 this._progressiveDoneListeners.push(r);
                             }
-                            onDataRange(r, T) {
+                            onDataRange(r, x) {
                                 for (const m of this._rangeListeners)
-                                    m(r, T);
+                                    m(r, x);
                             }
-                            onDataProgress(r, T) {
+                            onDataProgress(r, x) {
                                 this._readyCapability.promise.then(() => {
                                     for (const m of this._progressListeners)
-                                        m(r, T);
+                                        m(r, x);
                                 });
                             }
                             onDataProgressiveRead(r) {
                                 this._readyCapability.promise.then(() => {
-                                    for (const T of this._progressiveReadListeners)
-                                        T(r);
+                                    for (const x of this._progressiveReadListeners)
+                                        x(r);
                                 });
                             }
                             onDataProgressiveDone() {
                                 this._readyCapability.promise.then(() => {
                                     for (const r of this._progressiveDoneListeners)
                                         r();
                                 });
                             }
                             transportReady() {
                                 this._readyCapability.resolve();
                             }
-                            requestDataRange(r, T) {
+                            requestDataRange(r, x) {
                                 (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
                             }
                             abort() {}
                         }
                         exports.PDFDataRangeTransport = PDFDataRangeTransport;
                         class PDFDocumentProxy {
-                            constructor(r, T) {
-                                this._pdfInfo = r, this._transport = T, Object.defineProperty(this, "getJavaScript", {
+                            constructor(r, x) {
+                                this._pdfInfo = r, this._transport = x, Object.defineProperty(this, "getJavaScript", {
                                     value: () => ((0, _display_utils.deprecated)("`PDFDocumentProxy.getJavaScript`, please use `PDFDocumentProxy.getJSActions` instead."), this.getJSActions().then((m) => {
                                         if (!m)
                                             return m;
                                         const U = [];
                                         for (const z in m)
                                             U.push(...m[z]);
                                         return U;
@@ -1134,20 +1128,20 @@
                             }
                             getCalculationOrderIds() {
                                 return this._transport.getCalculationOrderIds();
                             }
                         }
                         exports.PDFDocumentProxy = PDFDocumentProxy;
                         class PDFPageProxy {
-                            constructor(r, T, m, U = !1) {
-                                L(this, P);
-                                L(this, X);
-                                L(this, et, null);
-                                L(this, l, !1);
-                                this._pageIndex = r, this._pageInfo = T, this._transport = m, this._stats = U ? new _display_utils.StatTimer() : null, this._pdfBug = U, this.commonObjs = m.commonObjs, this.objs = new PDFObjects(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
+                            constructor(r, x, m, U = !1) {
+                                I(this, P);
+                                I(this, X);
+                                I(this, et, null);
+                                I(this, c, !1);
+                                this._pageIndex = r, this._pageInfo = x, this._transport = m, this._stats = U ? new _display_utils.StatTimer() : null, this._pdfBug = U, this.commonObjs = m.commonObjs, this.objs = new PDFObjects(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
                             }
                             get pageNumber() {
                                 return this._pageIndex + 1;
                             }
                             get rotate() {
                                 return this._pageInfo.rotate;
                             }
@@ -1158,33 +1152,33 @@
                                 return this._pageInfo.userUnit;
                             }
                             get view() {
                                 return this._pageInfo.view;
                             }
                             getViewport({
                                 scale: r,
-                                rotation: T = this.rotate,
+                                rotation: x = this.rotate,
                                 offsetX: m = 0,
                                 offsetY: U = 0,
                                 dontFlip: z = !1
                             } = {}) {
                                 return new _display_utils.PageViewport({
                                     viewBox: this.view,
                                     scale: r,
-                                    rotation: T,
+                                    rotation: x,
                                     offsetX: m,
                                     offsetY: U,
                                     dontFlip: z
                                 });
                             }
                             getAnnotations({
                                 intent: r = "display"
                             } = {}) {
-                                const T = this._transport.getRenderingIntent(r);
-                                return this._transport.getAnnotations(this._pageIndex, T.renderingIntent);
+                                const x = this._transport.getRenderingIntent(r);
+                                return this._transport.getAnnotations(this._pageIndex, x.renderingIntent);
                             }
                             getJSActions() {
                                 return this._transport.getPageJSActions(this._pageIndex);
                             }
                             get filterFactory() {
                                 return this._transport.filterFactory;
                             }
@@ -1193,51 +1187,51 @@
                             }
                             async getXfa() {
                                 var r;
                                 return ((r = this._transport._htmlForXfa) == null ? void 0 : r.children[this._pageIndex]) || null;
                             }
                             render({
                                 canvasContext: r,
-                                viewport: T,
+                                viewport: x,
                                 intent: m = "display",
                                 annotationMode: U = _util.AnnotationMode.ENABLE,
                                 transform: z = null,
-                                background: E = null,
+                                background: C = null,
                                 optionalContentConfigPromise: V = null,
                                 annotationCanvasMap: st = null,
                                 pageColors: at = null,
                                 printAnnotationStorage: H = null
                             }) {
                                 var n, s;
                                 (n = this._stats) == null || n.time("Overall");
                                 const lt = this._transport.getRenderingIntent(m, U, H);
-                                Z(this, l, !1), W(this, X, Ee).call(this), V || (V = this._transport.getOptionalContentConfig());
+                                Z(this, c, !1), W(this, X, Ee).call(this), V || (V = this._transport.getOptionalContentConfig());
                                 let gt = this._intentStates.get(lt.cacheKey);
                                 gt || (gt = /* @__PURE__ */ Object.create(null), this._intentStates.set(lt.cacheKey, gt)), gt.streamReaderCancelTimeout && (clearTimeout(gt.streamReaderCancelTimeout), gt.streamReaderCancelTimeout = null);
                                 const wt = !!(lt.renderingIntent & _util.RenderingIntentFlag.PRINT);
                                 gt.displayReadyCapability || (gt.displayReadyCapability = new _util.PromiseCapability(), gt.operatorList = {
                                     fnArray: [],
                                     argsArray: [],
                                     lastChunk: !1,
                                     separateAnnots: null
                                 }, (s = this._stats) == null || s.time("Page Request"), this._pumpOperatorList(lt));
-                                const xt = (o) => {
-                                        var h, b;
-                                        gt.renderTasks.delete(S), (this._maybeCleanupAfterRender || wt) && Z(this, l, !0), W(this, P, he).call(this, !wt), o ? (S.capability.reject(o), this._abortOperatorList({
+                                const Pt = (o) => {
+                                        var h, _;
+                                        gt.renderTasks.delete(S), (this._maybeCleanupAfterRender || wt) && Z(this, c, !0), W(this, P, he).call(this, !wt), o ? (S.capability.reject(o), this._abortOperatorList({
                                             intentState: gt,
                                             reason: o instanceof Error ? o : new Error(o)
-                                        })) : S.capability.resolve(), (h = this._stats) == null || h.timeEnd("Rendering"), (b = this._stats) == null || b.timeEnd("Overall");
+                                        })) : S.capability.resolve(), (h = this._stats) == null || h.timeEnd("Rendering"), (_ = this._stats) == null || _.timeEnd("Overall");
                                     },
                                     S = new InternalRenderTask({
-                                        callback: xt,
+                                        callback: Pt,
                                         params: {
                                             canvasContext: r,
-                                            viewport: T,
+                                            viewport: x,
                                             transform: z,
-                                            background: E
+                                            background: C
                                         },
                                         objs: this.objs,
                                         commonObjs: this.commonObjs,
                                         annotationCanvasMap: st,
                                         operatorList: gt.operatorList,
                                         pageIndex: this._pageIndex,
                                         canvasFactory: this._transport.canvasFactory,
@@ -1245,134 +1239,134 @@
                                         useRequestAnimationFrame: !wt,
                                         pdfBug: this._pdfBug,
                                         pageColors: at
                                     });
                                 (gt.renderTasks || (gt.renderTasks = /* @__PURE__ */ new Set())).add(S);
                                 const i = S.task;
                                 return Promise.all([gt.displayReadyCapability.promise, V]).then(([o, h]) => {
-                                    var b;
+                                    var _;
                                     if (this.destroyed) {
-                                        xt();
+                                        Pt();
                                         return;
                                     }
-                                    (b = this._stats) == null || b.time("Rendering"), S.initializeGraphics({
+                                    (_ = this._stats) == null || _.time("Rendering"), S.initializeGraphics({
                                         transparency: o,
                                         optionalContentConfig: h
                                     }), S.operatorListChanged();
-                                }).catch(xt), i;
+                                }).catch(Pt), i;
                             }
                             getOperatorList({
                                 intent: r = "display",
-                                annotationMode: T = _util.AnnotationMode.ENABLE,
+                                annotationMode: x = _util.AnnotationMode.ENABLE,
                                 printAnnotationStorage: m = null
                             } = {}) {
                                 var st;
 
                                 function U() {
-                                    E.operatorList.lastChunk && (E.opListReadCapability.resolve(E.operatorList), E.renderTasks.delete(V));
+                                    C.operatorList.lastChunk && (C.opListReadCapability.resolve(C.operatorList), C.renderTasks.delete(V));
                                 }
-                                const z = this._transport.getRenderingIntent(r, T, m, !0);
-                                let E = this._intentStates.get(z.cacheKey);
-                                E || (E = /* @__PURE__ */ Object.create(null), this._intentStates.set(z.cacheKey, E));
+                                const z = this._transport.getRenderingIntent(r, x, m, !0);
+                                let C = this._intentStates.get(z.cacheKey);
+                                C || (C = /* @__PURE__ */ Object.create(null), this._intentStates.set(z.cacheKey, C));
                                 let V;
-                                return E.opListReadCapability || (V = /* @__PURE__ */ Object.create(null), V.operatorListChanged = U, E.opListReadCapability = new _util.PromiseCapability(), (E.renderTasks || (E.renderTasks = /* @__PURE__ */ new Set())).add(V), E.operatorList = {
+                                return C.opListReadCapability || (V = /* @__PURE__ */ Object.create(null), V.operatorListChanged = U, C.opListReadCapability = new _util.PromiseCapability(), (C.renderTasks || (C.renderTasks = /* @__PURE__ */ new Set())).add(V), C.operatorList = {
                                     fnArray: [],
                                     argsArray: [],
                                     lastChunk: !1,
                                     separateAnnots: null
-                                }, (st = this._stats) == null || st.time("Page Request"), this._pumpOperatorList(z)), E.opListReadCapability.promise;
+                                }, (st = this._stats) == null || st.time("Page Request"), this._pumpOperatorList(z)), C.opListReadCapability.promise;
                             }
                             streamTextContent({
                                 includeMarkedContent: r = !1,
-                                disableNormalization: T = !1
+                                disableNormalization: x = !1
                             } = {}) {
                                 return this._transport.messageHandler.sendWithStream("GetTextContent", {
                                     pageIndex: this._pageIndex,
                                     includeMarkedContent: r === !0,
-                                    disableNormalization: T === !0
+                                    disableNormalization: x === !0
                                 }, {
                                     highWaterMark: 100,
                                     size(U) {
                                         return U.items.length;
                                     }
                                 });
                             }
                             getTextContent(r = {}) {
                                 if (this._transport._htmlForXfa)
                                     return this.getXfa().then((m) => _xfa_text.XfaText.textContent(m));
-                                const T = this.streamTextContent(r);
+                                const x = this.streamTextContent(r);
                                 return new Promise(function(m, U) {
                                     function z() {
-                                        E.read().then(function({
+                                        C.read().then(function({
                                             value: st,
                                             done: at
                                         }) {
                                             if (at) {
                                                 m(V);
                                                 return;
                                             }
                                             Object.assign(V.styles, st.styles), V.items.push(...st.items), z();
                                         }, U);
                                     }
-                                    const E = T.getReader(),
+                                    const C = x.getReader(),
                                         V = {
                                             items: [],
                                             styles: /* @__PURE__ */ Object.create(null)
                                         };
                                     z();
                                 });
                             }
                             getStructTree() {
                                 return this._transport.getStructTree(this._pageIndex);
                             }
                             _destroy() {
                                 this.destroyed = !0;
                                 const r = [];
-                                for (const T of this._intentStates.values())
+                                for (const x of this._intentStates.values())
                                     if (this._abortOperatorList({
-                                            intentState: T,
+                                            intentState: x,
                                             reason: new Error("Page was destroyed."),
                                             force: !0
-                                        }), !T.opListReadCapability)
-                                        for (const m of T.renderTasks)
+                                        }), !x.opListReadCapability)
+                                        for (const m of x.renderTasks)
                                             r.push(m.completed), m.cancel();
-                                return this.objs.clear(), Z(this, l, !1), W(this, X, Ee).call(this), Promise.all(r);
+                                return this.objs.clear(), Z(this, c, !1), W(this, X, Ee).call(this), Promise.all(r);
                             }
                             cleanup(r = !1) {
-                                Z(this, l, !0);
-                                const T = W(this, P, he).call(this, !1);
-                                return r && T && this._stats && (this._stats = new _display_utils.StatTimer()), T;
+                                Z(this, c, !0);
+                                const x = W(this, P, he).call(this, !1);
+                                return r && x && this._stats && (this._stats = new _display_utils.StatTimer()), x;
                             }
-                            _startRenderPage(r, T) {
+                            _startRenderPage(r, x) {
                                 var U, z;
-                                const m = this._intentStates.get(T);
+                                const m = this._intentStates.get(x);
                                 m && ((U = this._stats) == null || U.timeEnd("Page Request"), (z = m.displayReadyCapability) == null || z.resolve(r));
                             }
-                            _renderPageChunk(r, T) {
+                            _renderPageChunk(r, x) {
                                 for (let m = 0, U = r.length; m < U; m++)
-                                    T.operatorList.fnArray.push(r.fnArray[m]), T.operatorList.argsArray.push(r.argsArray[m]);
-                                T.operatorList.lastChunk = r.lastChunk, T.operatorList.separateAnnots = r.separateAnnots;
-                                for (const m of T.renderTasks)
+                                    x.operatorList.fnArray.push(r.fnArray[m]), x.operatorList.argsArray.push(r.argsArray[m]);
+                                x.operatorList.lastChunk = r.lastChunk, x.operatorList.separateAnnots = r.separateAnnots;
+                                for (const m of x.renderTasks)
                                     m.operatorListChanged();
                                 r.lastChunk && W(this, P, he).call(this, !0);
                             }
                             _pumpOperatorList({
                                 renderingIntent: r,
-                                cacheKey: T,
+                                cacheKey: x,
                                 annotationStorageSerializable: m
                             }) {
                                 const {
                                     map: U,
                                     transfers: z
                                 } = m, V = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                                     pageIndex: this._pageIndex,
                                     intent: r,
-                                    cacheKey: T,
+                                    cacheKey: x,
                                     annotationStorage: U
-                                }, z).getReader(), st = this._intentStates.get(T);
+                                }, z).getReader(), st = this._intentStates.get(x);
                                 st.streamReader = V;
                                 const at = () => {
                                     V.read().then(({
                                         value: H,
                                         done: lt
                                     }) => {
                                         if (lt) {
@@ -1397,86 +1391,86 @@
                                         }
                                     });
                                 };
                                 at();
                             }
                             _abortOperatorList({
                                 intentState: r,
-                                reason: T,
+                                reason: x,
                                 force: m = !1
                             }) {
                                 if (r.streamReader) {
                                     if (r.streamReaderCancelTimeout && (clearTimeout(r.streamReaderCancelTimeout), r.streamReaderCancelTimeout = null), !m) {
                                         if (r.renderTasks.size > 0)
                                             return;
-                                        if (T instanceof _display_utils.RenderingCancelledException) {
+                                        if (x instanceof _display_utils.RenderingCancelledException) {
                                             let U = RENDERING_CANCELLED_TIMEOUT;
-                                            T.extraDelay > 0 && T.extraDelay < 1e3 && (U += T.extraDelay), r.streamReaderCancelTimeout = setTimeout(() => {
+                                            x.extraDelay > 0 && x.extraDelay < 1e3 && (U += x.extraDelay), r.streamReaderCancelTimeout = setTimeout(() => {
                                                 r.streamReaderCancelTimeout = null, this._abortOperatorList({
                                                     intentState: r,
-                                                    reason: T,
+                                                    reason: x,
                                                     force: !0
                                                 });
                                             }, U);
                                             return;
                                         }
                                     }
-                                    if (r.streamReader.cancel(new _util.AbortException(T.message)).catch(() => {}), r.streamReader = null, !this._transport.destroyed) {
+                                    if (r.streamReader.cancel(new _util.AbortException(x.message)).catch(() => {}), r.streamReader = null, !this._transport.destroyed) {
                                         for (const [U, z] of this._intentStates)
                                             if (z === r) {
                                                 this._intentStates.delete(U);
                                                 break;
                                             }
                                         this.cleanup();
                                     }
                                 }
                             }
                             get stats() {
                                 return this._stats;
                             }
                         }
-                        et = new WeakMap(), l = new WeakMap(), P = new WeakSet(), he = function(r = !1) {
-                            if (W(this, X, Ee).call(this), !t(this, l) || this.destroyed)
+                        et = new WeakMap(), c = new WeakMap(), P = new WeakSet(), he = function(r = !1) {
+                            if (W(this, X, Ee).call(this), !t(this, c) || this.destroyed)
                                 return !1;
                             if (r)
                                 return Z(this, et, setTimeout(() => {
                                     Z(this, et, null), W(this, P, he).call(this, !1);
                                 }, DELAYED_CLEANUP_TIMEOUT)), !1;
                             for (const {
-                                    renderTasks: T,
+                                    renderTasks: x,
                                     operatorList: m
                                 }
                                 of this._intentStates.values())
-                                if (T.size > 0 || !m.lastChunk)
+                                if (x.size > 0 || !m.lastChunk)
                                     return !1;
-                            return this._intentStates.clear(), this.objs.clear(), Z(this, l, !1), !0;
+                            return this._intentStates.clear(), this.objs.clear(), Z(this, c, !1), !0;
                         }, X = new WeakSet(), Ee = function() {
                             t(this, et) && (clearTimeout(t(this, et)), Z(this, et, null));
                         }, exports.PDFPageProxy = PDFPageProxy;
                         class LoopbackPort {
                             constructor() {
-                                L(this, B, /* @__PURE__ */ new Set());
-                                L(this, F, Promise.resolve());
+                                I(this, B, /* @__PURE__ */ new Set());
+                                I(this, F, Promise.resolve());
                             }
-                            postMessage(r, T) {
+                            postMessage(r, x) {
                                 const m = {
-                                    data: structuredClone(r, T ? {
-                                        transfer: T
+                                    data: structuredClone(r, x ? {
+                                        transfer: x
                                     } : null)
                                 };
                                 t(this, F).then(() => {
                                     for (const U of t(this, B))
                                         U.call(this, m);
                                 });
                             }
-                            addEventListener(r, T) {
-                                t(this, B).add(T);
+                            addEventListener(r, x) {
+                                t(this, B).add(x);
                             }
-                            removeEventListener(r, T) {
-                                t(this, B).delete(T);
+                            removeEventListener(r, x) {
+                                t(this, B).delete(x);
                             }
                             terminate() {
                                 t(this, B).clear();
                             }
                         }
                         B = new WeakMap(), F = new WeakMap(), exports.LoopbackPort = LoopbackPort;
                         const PDFWorkerUtil = {
@@ -1489,39 +1483,39 @@
                             if (_util.isNodeJS && typeof commonjsRequire == "function")
                                 PDFWorkerUtil.isWorkerDisabled = !0, PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
                             else if (typeof document == "object") {
                                 const p = (g = document == null ? void 0 : document.currentScript) == null ? void 0 : g.src;
                                 p && (PDFWorkerUtil.fallbackWorkerSrc = p.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"));
                             }
                             PDFWorkerUtil.isSameOrigin = function(p, r) {
-                                let T;
+                                let x;
                                 try {
-                                    if (T = new URL(p), !T.origin || T.origin === "null")
+                                    if (x = new URL(p), !x.origin || x.origin === "null")
                                         return !1;
                                 } catch {
                                     return !1;
                                 }
-                                const m = new URL(r, T);
-                                return T.origin === m.origin;
+                                const m = new URL(r, x);
+                                return x.origin === m.origin;
                             }, PDFWorkerUtil.createCDNWrapper = function(p) {
                                 const r = `importScripts("${p}");`;
                                 return URL.createObjectURL(new Blob([r]));
                             };
                         }
                         const _PDFWorker = class _PDFWorker {
                             constructor({
                                 name: p = null,
                                 port: r = null,
-                                verbosity: T = (0, _util.getVerbosityLevel)()
+                                verbosity: x = (0, _util.getVerbosityLevel)()
                             } = {}) {
                                 var m;
-                                if (this.name = p, this.destroyed = !1, this.verbosity = T, this._readyCapability = new _util.PromiseCapability(), this._port = null, this._webWorker = null, this._messageHandler = null, r) {
-                                    if ((m = t(_PDFWorker, O)) != null && m.has(r))
+                                if (this.name = p, this.destroyed = !1, this.verbosity = x, this._readyCapability = new _util.PromiseCapability(), this._port = null, this._webWorker = null, this._messageHandler = null, r) {
+                                    if ((m = t(_PDFWorker, L)) != null && m.has(r))
                                         throw new Error("Cannot use more than one PDFWorker per port.");
-                                    (t(_PDFWorker, O) || Z(_PDFWorker, O, /* @__PURE__ */ new WeakMap())).set(r, this), this._initializeFromPort(r);
+                                    (t(_PDFWorker, L) || Z(_PDFWorker, L, /* @__PURE__ */ new WeakMap())).set(r, this), this._initializeFromPort(r);
                                     return;
                                 }
                                 this._initialize();
                             }
                             get promise() {
                                 return this._readyCapability.promise;
                             }
@@ -1540,43 +1534,43 @@
                                 if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                                     let {
                                         workerSrc: p
                                     } = _PDFWorker;
                                     try {
                                         PDFWorkerUtil.isSameOrigin(window.location.href, p) || (p = PDFWorkerUtil.createCDNWrapper(new URL(p, window.location).href));
                                         const r = new Worker(p),
-                                            T = new _message_handler.MessageHandler("main", "worker", r),
+                                            x = new _message_handler.MessageHandler("main", "worker", r),
                                             m = () => {
-                                                r.removeEventListener("error", U), T.destroy(), r.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
+                                                r.removeEventListener("error", U), x.destroy(), r.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
                                             },
                                             U = () => {
                                                 this._webWorker || m();
                                             };
-                                        r.addEventListener("error", U), T.on("test", (E) => {
+                                        r.addEventListener("error", U), x.on("test", (C) => {
                                             if (r.removeEventListener("error", U), this.destroyed) {
                                                 m();
                                                 return;
                                             }
-                                            E ? (this._messageHandler = T, this._port = r, this._webWorker = r, this._readyCapability.resolve(), T.send("configure", {
+                                            C ? (this._messageHandler = x, this._port = r, this._webWorker = r, this._readyCapability.resolve(), x.send("configure", {
                                                 verbosity: this.verbosity
-                                            })) : (this._setupFakeWorker(), T.destroy(), r.terminate());
-                                        }), T.on("ready", (E) => {
+                                            })) : (this._setupFakeWorker(), x.destroy(), r.terminate());
+                                        }), x.on("ready", (C) => {
                                             if (r.removeEventListener("error", U), this.destroyed) {
                                                 m();
                                                 return;
                                             }
                                             try {
                                                 z();
                                             } catch {
                                                 this._setupFakeWorker();
                                             }
                                         });
                                         const z = () => {
-                                            const E = new Uint8Array();
-                                            T.send("test", E, [E.buffer]);
+                                            const C = new Uint8Array();
+                                            x.send("test", C, [C.buffer]);
                                         };
                                         z();
                                         return;
                                     } catch {
                                         (0, _util.info)("The worker has been disabled.");
                                     }
                                 }
@@ -1586,34 +1580,34 @@
                                 PDFWorkerUtil.isWorkerDisabled || ((0, _util.warn)("Setting up fake worker."), PDFWorkerUtil.isWorkerDisabled = !0), _PDFWorker._setupFakeWorkerGlobal.then((p) => {
                                     if (this.destroyed) {
                                         this._readyCapability.reject(new Error("Worker was destroyed"));
                                         return;
                                     }
                                     const r = new LoopbackPort();
                                     this._port = r;
-                                    const T = `fake${PDFWorkerUtil.fakeWorkerId++}`,
-                                        m = new _message_handler.MessageHandler(T + "_worker", T, r);
+                                    const x = `fake${PDFWorkerUtil.fakeWorkerId++}`,
+                                        m = new _message_handler.MessageHandler(x + "_worker", x, r);
                                     p.setup(m, r);
-                                    const U = new _message_handler.MessageHandler(T, T + "_worker", r);
+                                    const U = new _message_handler.MessageHandler(x, x + "_worker", r);
                                     this._messageHandler = U, this._readyCapability.resolve(), U.send("configure", {
                                         verbosity: this.verbosity
                                     });
                                 }).catch((p) => {
                                     this._readyCapability.reject(new Error(`Setting up fake worker failed: "${p.message}".`));
                                 });
                             }
                             destroy() {
                                 var p;
-                                this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), (p = t(_PDFWorker, O)) == null || p.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
+                                this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), (p = t(_PDFWorker, L)) == null || p.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
                             }
                             static fromPort(p) {
-                                var T;
+                                var x;
                                 if (!(p != null && p.port))
                                     throw new Error("PDFWorker.fromPort - invalid method signature.");
-                                const r = (T = t(this, O)) == null ? void 0 : T.get(p.port);
+                                const r = (x = t(this, L)) == null ? void 0 : x.get(p.port);
                                 if (r) {
                                     if (r._pendingDestroy)
                                         throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
                                     return r;
                                 }
                                 return new _PDFWorker(p);
                             }
@@ -1642,121 +1636,121 @@
                                         return worker.WorkerMessageHandler;
                                     }
                                     return await (0, _display_utils.loadScript)(this.workerSrc), window.pdfjsWorker.WorkerMessageHandler;
                                 };
                                 return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
                             }
                         };
-                        O = new WeakMap(), L(_PDFWorker, O, void 0);
+                        L = new WeakMap(), I(_PDFWorker, L, void 0);
                         let PDFWorker = _PDFWorker;
                         exports.PDFWorker = PDFWorker;
                         class WorkerTransport {
-                            constructor(r, T, m, U, z) {
-                                L(this, u);
-                                L(this, I, /* @__PURE__ */ new Map());
-                                L(this, x, /* @__PURE__ */ new Map());
-                                L(this, v, /* @__PURE__ */ new Map());
-                                L(this, A, null);
-                                this.messageHandler = r, this.loadingTask = T, this.commonObjs = new PDFObjects(), this.fontLoader = new _font_loader.FontLoader({
+                            constructor(r, x, m, U, z) {
+                                I(this, u);
+                                I(this, O, /* @__PURE__ */ new Map());
+                                I(this, T, /* @__PURE__ */ new Map());
+                                I(this, v, /* @__PURE__ */ new Map());
+                                I(this, A, null);
+                                this.messageHandler = r, this.loadingTask = x, this.commonObjs = new PDFObjects(), this.fontLoader = new _font_loader.FontLoader({
                                     ownerDocument: U.ownerDocument,
                                     styleElement: U.styleElement
                                 }), this._params = U, this.canvasFactory = z.canvasFactory, this.filterFactory = z.filterFactory, this.cMapReaderFactory = z.cMapReaderFactory, this.standardFontDataFactory = z.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = m, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = new _util.PromiseCapability(), this.setupMessageHandler();
                             }
                             get annotationStorage() {
                                 return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
                             }
-                            getRenderingIntent(r, T = _util.AnnotationMode.ENABLE, m = null, U = !1) {
+                            getRenderingIntent(r, x = _util.AnnotationMode.ENABLE, m = null, U = !1) {
                                 let z = _util.RenderingIntentFlag.DISPLAY,
-                                    E = _annotation_storage.SerializableEmpty;
+                                    C = _annotation_storage.SerializableEmpty;
                                 switch (r) {
                                     case "any":
                                         z = _util.RenderingIntentFlag.ANY;
                                         break;
                                     case "display":
                                         break;
                                     case "print":
                                         z = _util.RenderingIntentFlag.PRINT;
                                         break;
                                     default:
                                         (0, _util.warn)(`getRenderingIntent - invalid intent: ${r}`);
                                 }
-                                switch (T) {
+                                switch (x) {
                                     case _util.AnnotationMode.DISABLE:
                                         z += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                                         break;
                                     case _util.AnnotationMode.ENABLE:
                                         break;
                                     case _util.AnnotationMode.ENABLE_FORMS:
                                         z += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                                         break;
                                     case _util.AnnotationMode.ENABLE_STORAGE:
-                                        z += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE, E = (z & _util.RenderingIntentFlag.PRINT && m instanceof _annotation_storage.PrintAnnotationStorage ? m : this.annotationStorage).serializable;
+                                        z += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE, C = (z & _util.RenderingIntentFlag.PRINT && m instanceof _annotation_storage.PrintAnnotationStorage ? m : this.annotationStorage).serializable;
                                         break;
                                     default:
-                                        (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${T}`);
+                                        (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${x}`);
                                 }
                                 return U && (z += _util.RenderingIntentFlag.OPLIST), {
                                     renderingIntent: z,
-                                    cacheKey: `${z}_${E.hash}`,
-                                    annotationStorageSerializable: E
+                                    cacheKey: `${z}_${C.hash}`,
+                                    annotationStorageSerializable: C
                                 };
                             }
                             destroy() {
                                 var m;
                                 if (this.destroyCapability)
                                     return this.destroyCapability.promise;
                                 this.destroyed = !0, this.destroyCapability = new _util.PromiseCapability(), (m = t(this, A)) == null || m.reject(new Error("Worker was destroyed during onPassword callback"));
                                 const r = [];
-                                for (const U of t(this, x).values())
+                                for (const U of t(this, T).values())
                                     r.push(U._destroy());
-                                t(this, x).clear(), t(this, v).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
-                                const T = this.messageHandler.sendWithPromise("Terminate", null);
-                                return r.push(T), Promise.all(r).then(() => {
+                                t(this, T).clear(), t(this, v).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
+                                const x = this.messageHandler.sendWithPromise("Terminate", null);
+                                return r.push(x), Promise.all(r).then(() => {
                                     var U;
-                                    this.commonObjs.clear(), this.fontLoader.clear(), t(this, I).clear(), this.filterFactory.destroy(), (U = this._networkStream) == null || U.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
+                                    this.commonObjs.clear(), this.fontLoader.clear(), t(this, O).clear(), this.filterFactory.destroy(), (U = this._networkStream) == null || U.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
                                 }, this.destroyCapability.reject), this.destroyCapability.promise;
                             }
                             setupMessageHandler() {
                                 const {
                                     messageHandler: r,
-                                    loadingTask: T
+                                    loadingTask: x
                                 } = this;
                                 r.on("GetReader", (m, U) => {
                                     (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (z) => {
                                         this._lastProgress = {
                                             loaded: z.loaded,
                                             total: z.total
                                         };
                                     }, U.onPull = () => {
                                         this._fullReader.read().then(function({
                                             value: z,
-                                            done: E
+                                            done: C
                                         }) {
-                                            if (E) {
+                                            if (C) {
                                                 U.close();
                                                 return;
                                             }
                                             (0, _util.assert)(z instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), U.enqueue(new Uint8Array(z), 1, [z]);
                                         }).catch((z) => {
                                             U.error(z);
                                         });
                                     }, U.onCancel = (z) => {
-                                        this._fullReader.cancel(z), U.ready.catch((E) => {
+                                        this._fullReader.cancel(z), U.ready.catch((C) => {
                                             if (!this.destroyed)
-                                                throw E;
+                                                throw C;
                                         });
                                     };
                                 }), r.on("ReaderHeadersReady", (m) => {
                                     const U = new _util.PromiseCapability(),
                                         z = this._fullReader;
                                     return z.headersReady.then(() => {
-                                        var E;
-                                        (!z.isStreamingSupported || !z.isRangeSupported) && (this._lastProgress && ((E = T.onProgress) == null || E.call(T, this._lastProgress)), z.onProgress = (V) => {
+                                        var C;
+                                        (!z.isStreamingSupported || !z.isRangeSupported) && (this._lastProgress && ((C = x.onProgress) == null || C.call(x, this._lastProgress)), z.onProgress = (V) => {
                                             var st;
-                                            (st = T.onProgress) == null || st.call(T, {
+                                            (st = x.onProgress) == null || st.call(x, {
                                                 loaded: V.loaded,
                                                 total: V.total
                                             });
                                         }), U.resolve({
                                             isStreamingSupported: z.isStreamingSupported,
                                             isRangeSupported: z.isRangeSupported,
                                             contentLength: z.contentLength
@@ -1767,35 +1761,35 @@
                                     const z = this._networkStream.getRangeReader(m.begin, m.end);
                                     if (!z) {
                                         U.close();
                                         return;
                                     }
                                     U.onPull = () => {
                                         z.read().then(function({
-                                            value: E,
+                                            value: C,
                                             done: V
                                         }) {
                                             if (V) {
                                                 U.close();
                                                 return;
                                             }
-                                            (0, _util.assert)(E instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), U.enqueue(new Uint8Array(E), 1, [E]);
-                                        }).catch((E) => {
-                                            U.error(E);
+                                            (0, _util.assert)(C instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), U.enqueue(new Uint8Array(C), 1, [C]);
+                                        }).catch((C) => {
+                                            U.error(C);
                                         });
-                                    }, U.onCancel = (E) => {
-                                        z.cancel(E), U.ready.catch((V) => {
+                                    }, U.onCancel = (C) => {
+                                        z.cancel(C), U.ready.catch((V) => {
                                             if (!this.destroyed)
                                                 throw V;
                                         });
                                     };
                                 }), r.on("GetDoc", ({
                                     pdfInfo: m
                                 }) => {
-                                    this._numPages = m.numPages, this._htmlForXfa = m.htmlForXfa, delete m.htmlForXfa, T._capability.resolve(new PDFDocumentProxy(m, this));
+                                    this._numPages = m.numPages, this._htmlForXfa = m.htmlForXfa, delete m.htmlForXfa, x._capability.resolve(new PDFDocumentProxy(m, this));
                                 }), r.on("DocException", function(m) {
                                     let U;
                                     switch (m.name) {
                                         case "PasswordException":
                                             U = new _util.PasswordException(m.message, m.code);
                                             break;
                                         case "InvalidPDFException":
@@ -1809,52 +1803,52 @@
                                             break;
                                         case "UnknownErrorException":
                                             U = new _util.UnknownErrorException(m.message, m.details);
                                             break;
                                         default:
                                             (0, _util.unreachable)("DocException - expected a valid Error.");
                                     }
-                                    T._capability.reject(U);
+                                    x._capability.reject(U);
                                 }), r.on("PasswordRequest", (m) => {
-                                    if (Z(this, A, new _util.PromiseCapability()), T.onPassword) {
+                                    if (Z(this, A, new _util.PromiseCapability()), x.onPassword) {
                                         const U = (z) => {
                                             z instanceof Error ? t(this, A).reject(z) : t(this, A).resolve({
                                                 password: z
                                             });
                                         };
                                         try {
-                                            T.onPassword(U, m.code);
+                                            x.onPassword(U, m.code);
                                         } catch (z) {
                                             t(this, A).reject(z);
                                         }
                                     } else
                                         t(this, A).reject(new _util.PasswordException(m.message, m.code));
                                     return t(this, A).promise;
                                 }), r.on("DataLoaded", (m) => {
                                     var U;
-                                    (U = T.onProgress) == null || U.call(T, {
+                                    (U = x.onProgress) == null || U.call(x, {
                                         loaded: m.length,
                                         total: m.length
                                     }), this.downloadInfoCapability.resolve(m);
                                 }), r.on("StartRenderPage", (m) => {
                                     if (this.destroyed)
                                         return;
-                                    t(this, x).get(m.pageIndex)._startRenderPage(m.transparency, m.cacheKey);
+                                    t(this, T).get(m.pageIndex)._startRenderPage(m.transparency, m.cacheKey);
                                 }), r.on("commonobj", ([m, U, z]) => {
-                                    var E;
+                                    var C;
                                     if (!this.destroyed && !this.commonObjs.has(m))
                                         switch (U) {
                                             case "Font":
                                                 const V = this._params;
                                                 if ("error" in z) {
                                                     const H = z.error;
                                                     (0, _util.warn)(`Error during font loading: ${H}`), this.commonObjs.resolve(m, H);
                                                     break;
                                                 }
-                                                const st = V.pdfBug && ((E = globalThis.FontInspector) != null && E.enabled) ? (H, lt) => globalThis.FontInspector.fontAdded(H, lt) : null,
+                                                const st = V.pdfBug && ((C = globalThis.FontInspector) != null && C.enabled) ? (H, lt) => globalThis.FontInspector.fontAdded(H, lt) : null,
                                                     at = new _font_loader.FontFaceObject(z, {
                                                         isEvalSupported: V.isEvalSupported,
                                                         disableFontFace: V.disableFontFace,
                                                         ignoreErrors: V.ignoreErrors,
                                                         inspectFont: st
                                                     });
                                                 this.fontLoader.bind(at).catch((H) => r.sendWithPromise("FontFallback", {
@@ -1867,95 +1861,95 @@
                                             case "Image":
                                             case "Pattern":
                                                 this.commonObjs.resolve(m, z);
                                                 break;
                                             default:
                                                 throw new Error(`Got unknown common object type ${U}`);
                                         }
-                                }), r.on("obj", ([m, U, z, E]) => {
+                                }), r.on("obj", ([m, U, z, C]) => {
                                     var st;
                                     if (this.destroyed)
                                         return;
-                                    const V = t(this, x).get(U);
+                                    const V = t(this, T).get(U);
                                     if (!V.objs.has(m))
                                         switch (z) {
                                             case "Image":
-                                                if (V.objs.resolve(m, E), E) {
+                                                if (V.objs.resolve(m, C), C) {
                                                     let at;
-                                                    if (E.bitmap) {
+                                                    if (C.bitmap) {
                                                         const {
                                                             width: H,
                                                             height: lt
-                                                        } = E;
+                                                        } = C;
                                                         at = H * lt * 4;
                                                     } else
-                                                        at = ((st = E.data) == null ? void 0 : st.length) || 0;
+                                                        at = ((st = C.data) == null ? void 0 : st.length) || 0;
                                                     at > _util.MAX_IMAGE_SIZE_TO_CACHE && (V._maybeCleanupAfterRender = !0);
                                                 }
                                                 break;
                                             case "Pattern":
-                                                V.objs.resolve(m, E);
+                                                V.objs.resolve(m, C);
                                                 break;
                                             default:
                                                 throw new Error(`Got unknown object type ${z}`);
                                         }
                                 }), r.on("DocProgress", (m) => {
                                     var U;
-                                    this.destroyed || (U = T.onProgress) == null || U.call(T, {
+                                    this.destroyed || (U = x.onProgress) == null || U.call(x, {
                                         loaded: m.loaded,
                                         total: m.total
                                     });
                                 }), r.on("FetchBuiltInCMap", (m) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(m) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), r.on("FetchStandardFontData", (m) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(m) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
                             }
                             getData() {
                                 return this.messageHandler.sendWithPromise("GetData", null);
                             }
                             saveDocument() {
                                 var m;
                                 this.annotationStorage.size <= 0 && (0, _util.warn)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
                                 const {
                                     map: r,
-                                    transfers: T
+                                    transfers: x
                                 } = this.annotationStorage.serializable;
                                 return this.messageHandler.sendWithPromise("SaveDocument", {
                                     isPureXfa: !!this._htmlForXfa,
                                     numPages: this._numPages,
                                     annotationStorage: r,
                                     filename: ((m = this._fullReader) == null ? void 0 : m.filename) ?? null
-                                }, T).finally(() => {
+                                }, x).finally(() => {
                                     this.annotationStorage.resetModified();
                                 });
                             }
                             getPage(r) {
                                 if (!Number.isInteger(r) || r <= 0 || r > this._numPages)
                                     return Promise.reject(new Error("Invalid page request."));
-                                const T = r - 1,
-                                    m = t(this, v).get(T);
+                                const x = r - 1,
+                                    m = t(this, v).get(x);
                                 if (m)
                                     return m;
                                 const U = this.messageHandler.sendWithPromise("GetPage", {
-                                    pageIndex: T
+                                    pageIndex: x
                                 }).then((z) => {
                                     if (this.destroyed)
                                         throw new Error("Transport destroyed");
-                                    const E = new PDFPageProxy(T, z, this, this._params.pdfBug);
-                                    return t(this, x).set(T, E), E;
+                                    const C = new PDFPageProxy(x, z, this, this._params.pdfBug);
+                                    return t(this, T).set(x, C), C;
                                 });
-                                return t(this, v).set(T, U), U;
+                                return t(this, v).set(x, U), U;
                             }
                             getPageIndex(r) {
                                 return typeof r != "object" || r === null || !Number.isInteger(r.num) || r.num < 0 || !Number.isInteger(r.gen) || r.gen < 0 ? Promise.reject(new Error("Invalid pageIndex request.")) : this.messageHandler.sendWithPromise("GetPageIndex", {
                                     num: r.num,
                                     gen: r.gen
                                 });
                             }
-                            getAnnotations(r, T) {
+                            getAnnotations(r, x) {
                                 return this.messageHandler.sendWithPromise("GetAnnotations", {
                                     pageIndex: r,
-                                    intent: T
+                                    intent: x
                                 });
                             }
                             getFieldObjects() {
                                 return W(this, u, we).call(this, "GetFieldObjects");
                             }
                             hasJSActions() {
                                 return W(this, u, we).call(this, "HasJSActions");
@@ -2009,102 +2003,102 @@
                                 return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((r) => new _optional_content_config.OptionalContentConfig(r));
                             }
                             getPermissions() {
                                 return this.messageHandler.sendWithPromise("GetPermissions", null);
                             }
                             getMetadata() {
                                 const r = "GetMetadata",
-                                    T = t(this, I).get(r);
-                                if (T)
-                                    return T;
+                                    x = t(this, O).get(r);
+                                if (x)
+                                    return x;
                                 const m = this.messageHandler.sendWithPromise(r, null).then((U) => {
-                                    var z, E;
+                                    var z, C;
                                     return {
                                         info: U[0],
                                         metadata: U[1] ? new _metadata.Metadata(U[1]) : null,
                                         contentDispositionFilename: ((z = this._fullReader) == null ? void 0 : z.filename) ?? null,
-                                        contentLength: ((E = this._fullReader) == null ? void 0 : E.contentLength) ?? null
+                                        contentLength: ((C = this._fullReader) == null ? void 0 : C.contentLength) ?? null
                                     };
                                 });
-                                return t(this, I).set(r, m), m;
+                                return t(this, O).set(r, m), m;
                             }
                             getMarkInfo() {
                                 return this.messageHandler.sendWithPromise("GetMarkInfo", null);
                             }
                             async startCleanup(r = !1) {
                                 if (!this.destroyed) {
                                     await this.messageHandler.sendWithPromise("Cleanup", null);
-                                    for (const T of t(this, x).values())
-                                        if (!T.cleanup())
-                                            throw new Error(`startCleanup: Page ${T.pageNumber} is currently rendering.`);
-                                    this.commonObjs.clear(), r || this.fontLoader.clear(), t(this, I).clear(), this.filterFactory.destroy(!0);
+                                    for (const x of t(this, T).values())
+                                        if (!x.cleanup())
+                                            throw new Error(`startCleanup: Page ${x.pageNumber} is currently rendering.`);
+                                    this.commonObjs.clear(), r || this.fontLoader.clear(), t(this, O).clear(), this.filterFactory.destroy(!0);
                                 }
                             }
                             get loadingParams() {
                                 const {
                                     disableAutoFetch: r,
-                                    enableXfa: T
+                                    enableXfa: x
                                 } = this._params;
                                 return (0, _util.shadow)(this, "loadingParams", {
                                     disableAutoFetch: r,
-                                    enableXfa: T
+                                    enableXfa: x
                                 });
                             }
                         }
-                        I = new WeakMap(), x = new WeakMap(), v = new WeakMap(), A = new WeakMap(), u = new WeakSet(), we = function(r, T = null) {
-                            const m = t(this, I).get(r);
+                        O = new WeakMap(), T = new WeakMap(), v = new WeakMap(), A = new WeakMap(), u = new WeakSet(), we = function(r, x = null) {
+                            const m = t(this, O).get(r);
                             if (m)
                                 return m;
-                            const U = this.messageHandler.sendWithPromise(r, T);
-                            return t(this, I).set(r, U), U;
+                            const U = this.messageHandler.sendWithPromise(r, x);
+                            return t(this, O).set(r, U), U;
                         };
                         class PDFObjects {
                             constructor() {
-                                L(this, C);
-                                L(this, w, /* @__PURE__ */ Object.create(null));
+                                I(this, w);
+                                I(this, E, /* @__PURE__ */ Object.create(null));
                             }
-                            get(r, T = null) {
-                                if (T) {
-                                    const U = W(this, C, Be).call(this, r);
-                                    return U.capability.promise.then(() => T(U.data)), null;
+                            get(r, x = null) {
+                                if (x) {
+                                    const U = W(this, w, Be).call(this, r);
+                                    return U.capability.promise.then(() => x(U.data)), null;
                                 }
-                                const m = t(this, w)[r];
+                                const m = t(this, E)[r];
                                 if (!(m != null && m.capability.settled))
                                     throw new Error(`Requesting object that isn't resolved yet ${r}.`);
                                 return m.data;
                             }
                             has(r) {
-                                const T = t(this, w)[r];
-                                return (T == null ? void 0 : T.capability.settled) || !1;
+                                const x = t(this, E)[r];
+                                return (x == null ? void 0 : x.capability.settled) || !1;
                             }
-                            resolve(r, T = null) {
-                                const m = W(this, C, Be).call(this, r);
-                                m.data = T, m.capability.resolve();
+                            resolve(r, x = null) {
+                                const m = W(this, w, Be).call(this, r);
+                                m.data = x, m.capability.resolve();
                             }
                             clear() {
                                 var r;
-                                for (const T in t(this, w)) {
+                                for (const x in t(this, E)) {
                                     const {
                                         data: m
-                                    } = t(this, w)[T];
+                                    } = t(this, E)[x];
                                     (r = m == null ? void 0 : m.bitmap) == null || r.close();
                                 }
-                                Z(this, w, /* @__PURE__ */ Object.create(null));
+                                Z(this, E, /* @__PURE__ */ Object.create(null));
                             }
                         }
-                        w = new WeakMap(), C = new WeakSet(), Be = function(r) {
-                            var T;
-                            return (T = t(this, w))[r] || (T[r] = {
+                        E = new WeakMap(), w = new WeakSet(), Be = function(r) {
+                            var x;
+                            return (x = t(this, E))[r] || (x[r] = {
                                 capability: new _util.PromiseCapability(),
                                 data: null
                             });
                         };
                         class RenderTask {
                             constructor(r) {
-                                L(this, a, null);
+                                I(this, a, null);
                                 Z(this, a, r), this.onContinue = null;
                             }
                             get promise() {
                                 return t(this, a).capability.promise;
                             }
                             cancel(r = 0) {
                                 t(this, a).cancel(null, r);
@@ -2112,71 +2106,71 @@
                             get separateAnnots() {
                                 const {
                                     separateAnnots: r
                                 } = t(this, a).operatorList;
                                 if (!r)
                                     return !1;
                                 const {
-                                    annotationCanvasMap: T
+                                    annotationCanvasMap: x
                                 } = t(this, a);
-                                return r.form || r.canvas && (T == null ? void 0 : T.size) > 0;
+                                return r.form || r.canvas && (x == null ? void 0 : x.size) > 0;
                             }
                         }
                         a = new WeakMap(), exports.RenderTask = RenderTask;
                         const k = class k {
                             constructor({
                                 callback: r,
-                                params: T,
+                                params: x,
                                 objs: m,
                                 commonObjs: U,
                                 annotationCanvasMap: z,
-                                operatorList: E,
+                                operatorList: C,
                                 pageIndex: V,
                                 canvasFactory: st,
                                 filterFactory: at,
                                 useRequestAnimationFrame: H = !1,
                                 pdfBug: lt = !1,
                                 pageColors: gt = null
                             }) {
-                                this.callback = r, this.params = T, this.objs = m, this.commonObjs = U, this.annotationCanvasMap = z, this.operatorListIdx = null, this.operatorList = E, this._pageIndex = V, this.canvasFactory = st, this.filterFactory = at, this._pdfBug = lt, this.pageColors = gt, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = H === !0 && typeof window < "u", this.cancelled = !1, this.capability = new _util.PromiseCapability(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = T.canvasContext.canvas;
+                                this.callback = r, this.params = x, this.objs = m, this.commonObjs = U, this.annotationCanvasMap = z, this.operatorListIdx = null, this.operatorList = C, this._pageIndex = V, this.canvasFactory = st, this.filterFactory = at, this._pdfBug = lt, this.pageColors = gt, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = H === !0 && typeof window < "u", this.cancelled = !1, this.capability = new _util.PromiseCapability(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = x.canvasContext.canvas;
                             }
                             get completed() {
                                 return this.capability.promise.catch(function() {});
                             }
                             initializeGraphics({
                                 transparency: r = !1,
-                                optionalContentConfig: T
+                                optionalContentConfig: x
                             }) {
                                 var V, st;
                                 if (this.cancelled)
                                     return;
                                 if (this._canvas) {
-                                    if (t(k, c).has(this._canvas))
+                                    if (t(k, l).has(this._canvas))
                                         throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
-                                    t(k, c).add(this._canvas);
+                                    t(k, l).add(this._canvas);
                                 }
                                 this._pdfBug && ((V = globalThis.StepperManager) != null && V.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
                                 const {
                                     canvasContext: m,
                                     viewport: U,
                                     transform: z,
-                                    background: E
+                                    background: C
                                 } = this.params;
                                 this.gfx = new _canvas.CanvasGraphics(m, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
-                                    optionalContentConfig: T
+                                    optionalContentConfig: x
                                 }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
                                     transform: z,
                                     viewport: U,
                                     transparency: r,
-                                    background: E
+                                    background: C
                                 }), this.operatorListIdx = 0, this.graphicsReady = !0, (st = this.graphicsReadyCallback) == null || st.call(this);
                             }
-                            cancel(r = null, T = 0) {
+                            cancel(r = null, x = 0) {
                                 var m;
-                                this.running = !1, this.cancelled = !0, (m = this.gfx) == null || m.endDrawing(), t(k, c).delete(this._canvas), this.callback(r || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, T));
+                                this.running = !1, this.cancelled = !0, (m = this.gfx) == null || m.endDrawing(), t(k, l).delete(this._canvas), this.callback(r || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, x));
                             }
                             operatorListChanged() {
                                 var r;
                                 if (!this.graphicsReady) {
                                     this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
                                     return;
                                 }
@@ -2187,81 +2181,81 @@
                             }
                             _scheduleNext() {
                                 this._useRequestAnimationFrame ? window.requestAnimationFrame(() => {
                                     this._nextBound().catch(this._cancelBound);
                                 }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
                             }
                             async _next() {
-                                this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), t(k, c).delete(this._canvas), this.callback())));
+                                this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), t(k, l).delete(this._canvas), this.callback())));
                             }
                         };
-                        c = new WeakMap(), L(k, c, /* @__PURE__ */ new WeakSet());
+                        l = new WeakMap(), I(k, l, /* @__PURE__ */ new WeakSet());
                         let InternalRenderTask = k;
                         const version = "3.11.174";
                         exports.version = version;
                         const build = "ce8716743";
                         exports.build = build;
                     },
                     /* 3 */
                     /***/
                     (dt, d, et) => {
-                        var F, g, O, Ai, x;
+                        var F, g, L, Ai, T;
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.SerializableEmpty = d.PrintAnnotationStorage = d.AnnotationStorage = void 0;
-                        var l = et(1),
+                        var c = et(1),
                             P = et(4),
                             rt = et(8);
                         const X = Object.freeze({
                             map: null,
                             hash: "",
                             transfers: void 0
                         });
                         d.SerializableEmpty = X;
                         class pt {
                             constructor() {
-                                L(this, O);
-                                L(this, F, !1);
-                                L(this, g, /* @__PURE__ */ new Map());
+                                I(this, L);
+                                I(this, F, !1);
+                                I(this, g, /* @__PURE__ */ new Map());
                                 this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
                             }
                             getValue(A, u) {
-                                const _ = t(this, g).get(A);
-                                return _ === void 0 ? u : Object.assign(u, _);
+                                const b = t(this, g).get(A);
+                                return b === void 0 ? u : Object.assign(u, b);
                             }
                             getRawValue(A) {
                                 return t(this, g).get(A);
                             }
                             remove(A) {
                                 if (t(this, g).delete(A), t(this, g).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
                                     for (const u of t(this, g).values())
                                         if (u instanceof P.AnnotationEditor)
                                             return;
                                     this.onAnnotationEditor(null);
                                 }
                             }
                             setValue(A, u) {
-                                const _ = t(this, g).get(A);
-                                let w = !1;
-                                if (_ !== void 0)
-                                    for (const [C, y] of Object.entries(u))
-                                        _[C] !== y && (w = !0, _[C] = y);
+                                const b = t(this, g).get(A);
+                                let E = !1;
+                                if (b !== void 0)
+                                    for (const [w, y] of Object.entries(u))
+                                        b[w] !== y && (E = !0, b[w] = y);
                                 else
-                                    w = !0, t(this, g).set(A, u);
-                                w && W(this, O, Ai).call(this), u instanceof P.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(u.constructor._type);
+                                    E = !0, t(this, g).set(A, u);
+                                E && W(this, L, Ai).call(this), u instanceof P.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(u.constructor._type);
                             }
                             has(A) {
                                 return t(this, g).has(A);
                             }
                             getAll() {
-                                return t(this, g).size > 0 ? (0, l.objectFromMap)(t(this, g)) : null;
+                                return t(this, g).size > 0 ? (0, c.objectFromMap)(t(this, g)) : null;
                             }
                             setAll(A) {
-                                for (const [u, _] of Object.entries(A))
-                                    this.setValue(u, _);
+                                for (const [u, b] of Object.entries(A))
+                                    this.setValue(u, b);
                             }
                             get size() {
                                 return t(this, g).size;
                             }
                             resetModified() {
                                 t(this, F) && (Z(this, F, !1), typeof this.onResetModified == "function" && this.onResetModified());
                             }
@@ -2269,109 +2263,109 @@
                                 return new B(this);
                             }
                             get serializable() {
                                 if (t(this, g).size === 0)
                                     return X;
                                 const A = /* @__PURE__ */ new Map(),
                                     u = new rt.MurmurHash3_64(),
-                                    _ = [],
-                                    w = /* @__PURE__ */ Object.create(null);
-                                let C = !1;
+                                    b = [],
+                                    E = /* @__PURE__ */ Object.create(null);
+                                let w = !1;
                                 for (const [y, a] of t(this, g)) {
-                                    const c = a instanceof P.AnnotationEditor ? a.serialize(!1, w) : a;
-                                    c && (A.set(y, c), u.update(`${y}:${JSON.stringify(c)}`), C || (C = !!c.bitmap));
+                                    const l = a instanceof P.AnnotationEditor ? a.serialize(!1, E) : a;
+                                    l && (A.set(y, l), u.update(`${y}:${JSON.stringify(l)}`), w || (w = !!l.bitmap));
                                 }
-                                if (C)
+                                if (w)
                                     for (const y of A.values())
-                                        y.bitmap && _.push(y.bitmap);
+                                        y.bitmap && b.push(y.bitmap);
                                 return A.size > 0 ? {
                                     map: A,
                                     hash: u.hexdigest(),
-                                    transfers: _
+                                    transfers: b
                                 } : X;
                             }
                         }
-                        F = new WeakMap(), g = new WeakMap(), O = new WeakSet(), Ai = function() {
+                        F = new WeakMap(), g = new WeakMap(), L = new WeakSet(), Ai = function() {
                             t(this, F) || (Z(this, F, !0), typeof this.onSetModified == "function" && this.onSetModified());
                         }, d.AnnotationStorage = pt;
                         class B extends pt {
                             constructor(u) {
                                 super();
-                                L(this, x, void 0);
+                                I(this, T, void 0);
                                 const {
-                                    map: _,
-                                    hash: w,
-                                    transfers: C
-                                } = u.serializable, y = structuredClone(_, C ? {
-                                    transfer: C
+                                    map: b,
+                                    hash: E,
+                                    transfers: w
+                                } = u.serializable, y = structuredClone(b, w ? {
+                                    transfer: w
                                 } : null);
-                                Z(this, x, {
+                                Z(this, T, {
                                     map: y,
-                                    hash: w,
-                                    transfers: C
+                                    hash: E,
+                                    transfers: w
                                 });
                             }
                             get print() {
-                                (0, l.unreachable)("Should not call PrintAnnotationStorage.print");
+                                (0, c.unreachable)("Should not call PrintAnnotationStorage.print");
                             }
                             get serializable() {
-                                return t(this, x);
+                                return t(this, T);
                             }
                         }
-                        x = new WeakMap(), d.PrintAnnotationStorage = B;
+                        T = new WeakMap(), d.PrintAnnotationStorage = B;
                     },
                     /* 4 */
                     /***/
                     (dt, d, et) => {
-                        var B, F, g, O, I, x, v, A, u, _, w, C, y, a, c, Ue, p, je, T, He, U, We, E, yi, st, vi, H, Si, gt, Ge, xt, Ei;
+                        var B, F, g, L, O, T, v, A, u, b, E, w, y, a, l, Ue, p, je, x, He, U, We, C, yi, st, vi, H, Si, gt, Ge, Pt, Ei;
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.AnnotationEditor = void 0;
-                        var l = et(5),
+                        var c = et(5),
                             P = et(1),
                             rt = et(6);
                         const i = class i {
                             constructor(s) {
-                                L(this, c);
-                                L(this, p);
-                                L(this, U);
-                                L(this, E);
-                                L(this, st);
-                                L(this, H);
-                                L(this, gt);
-                                L(this, xt);
-                                L(this, B, "");
-                                L(this, F, !1);
-                                L(this, g, null);
-                                L(this, O, null);
-                                L(this, I, null);
-                                L(this, x, !1);
-                                L(this, v, null);
-                                L(this, A, this.focusin.bind(this));
-                                L(this, u, this.focusout.bind(this));
-                                L(this, _, !1);
-                                L(this, w, !1);
-                                L(this, C, !1);
+                                I(this, l);
+                                I(this, p);
+                                I(this, U);
+                                I(this, C);
+                                I(this, st);
+                                I(this, H);
+                                I(this, gt);
+                                I(this, Pt);
+                                I(this, B, "");
+                                I(this, F, !1);
+                                I(this, g, null);
+                                I(this, L, null);
+                                I(this, O, null);
+                                I(this, T, !1);
+                                I(this, v, null);
+                                I(this, A, this.focusin.bind(this));
+                                I(this, u, this.focusout.bind(this));
+                                I(this, b, !1);
+                                I(this, E, !1);
+                                I(this, w, !1);
                                 ee(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
                                 ee(this, "_uiManager", null);
                                 ee(this, "_focusEventsAllowed", !0);
                                 ee(this, "_l10nPromise", null);
-                                L(this, y, !1);
-                                L(this, a, i._zIndex++);
+                                I(this, y, !1);
+                                I(this, a, i._zIndex++);
                                 this.constructor === i && (0, P.unreachable)("Cannot initialize AnnotationEditor."), this.parent = s.parent, this.id = s.id, this.width = this.height = null, this.pageIndex = s.parent.pageIndex, this.name = s.name, this.div = null, this._uiManager = s.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = s.isCentered, this._structTreeParentId = null;
                                 const {
                                     rotation: o,
                                     rawDims: {
                                         pageWidth: h,
-                                        pageHeight: b,
+                                        pageHeight: _,
                                         pageX: M,
                                         pageY: N
                                     }
                                 } = this.parent.viewport;
-                                this.rotation = o, this.pageRotation = (360 + o - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [h, b], this.pageTranslation = [M, N];
+                                this.rotation = o, this.pageRotation = (360 + o - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [h, _], this.pageTranslation = [M, N];
                                 const [tt, Q] = this.parentDimensions;
                                 this.x = s.x / tt, this.y = s.y / Q, this.isAttachedToDOM = !1, this.deleted = !1;
                             }
                             get editorType() {
                                 return Object.getPrototypeOf(this).constructor._type;
                             }
                             static get _defaultLineColor() {
@@ -2382,17 +2376,17 @@
                                     id: s.parent.getNextId(),
                                     parent: s.parent,
                                     uiManager: s._uiManager
                                 });
                                 o.annotationElementId = s.annotationElementId, o.deleted = !0, o._uiManager.addToAnnotationStorage(o);
                             }
                             static initialize(s, o = null) {
-                                if (i._l10nPromise || (i._l10nPromise = new Map(["editor_alt_text_button_label", "editor_alt_text_edit_button_label", "editor_alt_text_decorative_tooltip"].map((b) => [b, s.get(b)]))), o != null && o.strings)
-                                    for (const b of o.strings)
-                                        i._l10nPromise.set(b, s.get(b));
+                                if (i._l10nPromise || (i._l10nPromise = new Map(["editor_alt_text_button_label", "editor_alt_text_edit_button_label", "editor_alt_text_decorative_tooltip"].map((_) => [_, s.get(_)]))), o != null && o.strings)
+                                    for (const _ of o.strings)
+                                        i._l10nPromise.set(_, s.get(_));
                                 if (i._borderLineWidth !== -1)
                                     return;
                                 const h = getComputedStyle(document.documentElement);
                                 i._borderLineWidth = parseFloat(h.getPropertyValue("--outline-width")) || 0;
                             }
                             static updateDefaultParams(s, o) {}
                             static get defaultPropertiesToUpdate() {
@@ -2444,15 +2438,15 @@
                             setInForeground() {
                                 this.div.style.zIndex = t(this, a);
                             }
                             setParent(s) {
                                 s !== null && (this.pageIndex = s.pageIndex, this.pageDimensions = s.pageDimensions), this.parent = s;
                             }
                             focusin(s) {
-                                this._focusEventsAllowed && (t(this, _) ? Z(this, _, !1) : this.parent.setSelected(this));
+                                this._focusEventsAllowed && (t(this, b) ? Z(this, b, !1) : this.parent.setSelected(this));
                             }
                             focusout(s) {
                                 var h;
                                 if (!this._focusEventsAllowed || !this.isAttachedToDOM)
                                     return;
                                 const o = s.relatedTarget;
                                 o != null && o.closest(`#${this.id}`) || (s.preventDefault(), (h = this.parent) != null && h.isMultipleSelection || this.commitOrRemove());
@@ -2462,29 +2456,29 @@
                             }
                             commit() {
                                 this.addToAnnotationStorage();
                             }
                             addToAnnotationStorage() {
                                 this._uiManager.addToAnnotationStorage(this);
                             }
-                            setAt(s, o, h, b) {
+                            setAt(s, o, h, _) {
                                 const [M, N] = this.parentDimensions;
-                                [h, b] = this.screenToPageTranslation(h, b), this.x = (s + h) / M, this.y = (o + b) / N, this.fixAndSetPosition();
+                                [h, _] = this.screenToPageTranslation(h, _), this.x = (s + h) / M, this.y = (o + _) / N, this.fixAndSetPosition();
                             }
                             translate(s, o) {
-                                W(this, c, Ue).call(this, this.parentDimensions, s, o);
+                                W(this, l, Ue).call(this, this.parentDimensions, s, o);
                             }
                             translateInPage(s, o) {
-                                W(this, c, Ue).call(this, this.pageDimensions, s, o), this.div.scrollIntoView({
+                                W(this, l, Ue).call(this, this.pageDimensions, s, o), this.div.scrollIntoView({
                                     block: "nearest"
                                 });
                             }
                             drag(s, o) {
-                                const [h, b] = this.parentDimensions;
-                                if (this.x += s / h, this.y += o / b, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
+                                const [h, _] = this.parentDimensions;
+                                if (this.x += s / h, this.y += o / _, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
                                     const {
                                         x: nt,
                                         y: ct
                                     } = this.div.getBoundingClientRect();
                                     this.parent.findNewParent(this, nt, ct) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
                                 }
                                 let {
@@ -2496,77 +2490,77 @@
                                     block: "nearest"
                                 });
                             }
                             fixAndSetPosition() {
                                 const [s, o] = this.pageDimensions;
                                 let {
                                     x: h,
-                                    y: b,
+                                    y: _,
                                     width: M,
                                     height: N
                                 } = this;
-                                switch (M *= s, N *= o, h *= s, b *= o, this.rotation) {
+                                switch (M *= s, N *= o, h *= s, _ *= o, this.rotation) {
                                     case 0:
-                                        h = Math.max(0, Math.min(s - M, h)), b = Math.max(0, Math.min(o - N, b));
+                                        h = Math.max(0, Math.min(s - M, h)), _ = Math.max(0, Math.min(o - N, _));
                                         break;
                                     case 90:
-                                        h = Math.max(0, Math.min(s - N, h)), b = Math.min(o, Math.max(M, b));
+                                        h = Math.max(0, Math.min(s - N, h)), _ = Math.min(o, Math.max(M, _));
                                         break;
                                     case 180:
-                                        h = Math.min(s, Math.max(M, h)), b = Math.min(o, Math.max(N, b));
+                                        h = Math.min(s, Math.max(M, h)), _ = Math.min(o, Math.max(N, _));
                                         break;
                                     case 270:
-                                        h = Math.min(s, Math.max(N, h)), b = Math.max(0, Math.min(o - M, b));
+                                        h = Math.min(s, Math.max(N, h)), _ = Math.max(0, Math.min(o - M, _));
                                         break;
                                 }
-                                this.x = h /= s, this.y = b /= o;
+                                this.x = h /= s, this.y = _ /= o;
                                 const [tt, Q] = W(this, p, je).call(this);
-                                h += tt, b += Q;
+                                h += tt, _ += Q;
                                 const {
                                     style: nt
                                 } = this.div;
-                                nt.left = `${(100 * h).toFixed(2)}%`, nt.top = `${(100 * b).toFixed(2)}%`, this.moveInDOM();
+                                nt.left = `${(100 * h).toFixed(2)}%`, nt.top = `${(100 * _).toFixed(2)}%`, this.moveInDOM();
                             }
                             screenToPageTranslation(s, o) {
                                 var h;
-                                return W(h = i, T, He).call(h, s, o, this.parentRotation);
+                                return W(h = i, x, He).call(h, s, o, this.parentRotation);
                             }
                             pageTranslationToScreen(s, o) {
                                 var h;
-                                return W(h = i, T, He).call(h, s, o, 360 - this.parentRotation);
+                                return W(h = i, x, He).call(h, s, o, 360 - this.parentRotation);
                             }
                             get parentScale() {
                                 return this._uiManager.viewParameters.realScale;
                             }
                             get parentRotation() {
                                 return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
                             }
                             get parentDimensions() {
                                 const {
                                     parentScale: s,
                                     pageDimensions: [o, h]
-                                } = this, b = o * s, M = h * s;
-                                return P.FeatureTest.isCSSRoundSupported ? [Math.round(b), Math.round(M)] : [b, M];
+                                } = this, _ = o * s, M = h * s;
+                                return P.FeatureTest.isCSSRoundSupported ? [Math.round(_), Math.round(M)] : [_, M];
                             }
                             setDims(s, o) {
                                 var M;
-                                const [h, b] = this.parentDimensions;
-                                this.div.style.width = `${(100 * s / h).toFixed(2)}%`, t(this, x) || (this.div.style.height = `${(100 * o / b).toFixed(2)}%`), (M = t(this, g)) == null || M.classList.toggle("small", s < i.SMALL_EDITOR_SIZE || o < i.SMALL_EDITOR_SIZE);
+                                const [h, _] = this.parentDimensions;
+                                this.div.style.width = `${(100 * s / h).toFixed(2)}%`, t(this, T) || (this.div.style.height = `${(100 * o / _).toFixed(2)}%`), (M = t(this, g)) == null || M.classList.toggle("small", s < i.SMALL_EDITOR_SIZE || o < i.SMALL_EDITOR_SIZE);
                             }
                             fixDims() {
                                 const {
                                     style: s
                                 } = this.div, {
                                     height: o,
                                     width: h
-                                } = s, b = h.endsWith("%"), M = !t(this, x) && o.endsWith("%");
-                                if (b && M)
+                                } = s, _ = h.endsWith("%"), M = !t(this, T) && o.endsWith("%");
+                                if (_ && M)
                                     return;
                                 const [N, tt] = this.parentDimensions;
-                                b || (s.width = `${(100 * parseFloat(h) / N).toFixed(2)}%`), !t(this, x) && !M && (s.height = `${(100 * parseFloat(o) / tt).toFixed(2)}%`);
+                                _ || (s.width = `${(100 * parseFloat(h) / N).toFixed(2)}%`), !t(this, T) && !M && (s.height = `${(100 * parseFloat(o) / tt).toFixed(2)}%`);
                             }
                             getInitialTranslation() {
                                 return [0, 0];
                             }
                             async addAltTextButton() {
                                 if (t(this, g))
                                     return;
@@ -2596,43 +2590,43 @@
                             }) {
                                 t(this, B) === s && t(this, F) === o || (Z(this, B, s), Z(this, F, o), W(this, gt, Ge).call(this));
                             }
                             render() {
                                 this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.setAttribute("tabIndex", 0), this.setInForeground(), this.div.addEventListener("focusin", t(this, A)), this.div.addEventListener("focusout", t(this, u));
                                 const [s, o] = this.parentDimensions;
                                 this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * o / s).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * s / o).toFixed(2)}%`);
-                                const [h, b] = this.getInitialTranslation();
-                                return this.translate(h, b), (0, l.bindEvents)(this, this.div, ["pointerdown"]), this.div;
+                                const [h, _] = this.getInitialTranslation();
+                                return this.translate(h, _), (0, c.bindEvents)(this, this.div, ["pointerdown"]), this.div;
                             }
                             pointerdown(s) {
                                 const {
                                     isMac: o
                                 } = P.FeatureTest.platform;
                                 if (s.button !== 0 || s.ctrlKey && o) {
                                     s.preventDefault();
                                     return;
                                 }
-                                Z(this, _, !0), W(this, xt, Ei).call(this, s);
+                                Z(this, b, !0), W(this, Pt, Ei).call(this, s);
                             }
                             moveInDOM() {
                                 var s;
                                 (s = this.parent) == null || s.moveEditorInDOM(this);
                             }
                             _setParentAndPosition(s, o, h) {
                                 s.changeParent(this), this.x = o, this.y = h, this.fixAndSetPosition();
                             }
                             getRect(s, o) {
                                 const h = this.parentScale,
-                                    [b, M] = this.pageDimensions,
+                                    [_, M] = this.pageDimensions,
                                     [N, tt] = this.pageTranslation,
                                     Q = s / h,
                                     nt = o / h,
-                                    ct = this.x * b,
+                                    ct = this.x * _,
                                     yt = this.y * M,
-                                    ut = this.width * b,
+                                    ut = this.width * _,
                                     Ft = this.height * M;
                                 switch (this.rotation) {
                                     case 0:
                                         return [ct + Q + N, M - yt - nt - Ft + tt, ct + Q + ut + N, M - yt - nt + tt];
                                     case 90:
                                         return [ct + nt + N, M - yt + Q + tt, ct + nt + Ft + N, M - yt + Q + ut + tt];
                                     case 180:
@@ -2640,40 +2634,40 @@
                                     case 270:
                                         return [ct - nt - Ft + N, M - yt - Q - ut + tt, ct - nt + N, M - yt - Q + tt];
                                     default:
                                         throw new Error("Invalid rotation");
                                 }
                             }
                             getRectInCurrentCoords(s, o) {
-                                const [h, b, M, N] = s, tt = M - h, Q = N - b;
+                                const [h, _, M, N] = s, tt = M - h, Q = N - _;
                                 switch (this.rotation) {
                                     case 0:
                                         return [h, o - N, tt, Q];
                                     case 90:
-                                        return [h, o - b, Q, tt];
+                                        return [h, o - _, Q, tt];
                                     case 180:
-                                        return [M, o - b, tt, Q];
+                                        return [M, o - _, tt, Q];
                                     case 270:
                                         return [M, o - N, Q, tt];
                                     default:
                                         throw new Error("Invalid rotation");
                                 }
                             }
                             onceAdded() {}
                             isEmpty() {
                                 return !1;
                             }
                             enableEditMode() {
-                                Z(this, C, !0);
+                                Z(this, w, !0);
                             }
                             disableEditMode() {
-                                Z(this, C, !1);
+                                Z(this, w, !1);
                             }
                             isInEditMode() {
-                                return t(this, C);
+                                return t(this, w);
                             }
                             shouldGetKeyboardEvents() {
                                 return !1;
                             }
                             needsToBeRebuilt() {
                                 return this.div && !this.isAttachedToDOM;
                             }
@@ -2681,32 +2675,32 @@
                                 var s, o;
                                 (s = this.div) == null || s.addEventListener("focusin", t(this, A)), (o = this.div) == null || o.addEventListener("focusout", t(this, u));
                             }
                             serialize(s = !1, o = null) {
                                 (0, P.unreachable)("An editor must be serializable");
                             }
                             static deserialize(s, o, h) {
-                                const b = new this.prototype.constructor({
+                                const _ = new this.prototype.constructor({
                                     parent: o,
                                     id: o.getNextId(),
                                     uiManager: h
                                 });
-                                b.rotation = s.rotation;
-                                const [M, N] = b.pageDimensions, [tt, Q, nt, ct] = b.getRectInCurrentCoords(s.rect, N);
-                                return b.x = tt / M, b.y = Q / N, b.width = nt / M, b.height = ct / N, b;
+                                _.rotation = s.rotation;
+                                const [M, N] = _.pageDimensions, [tt, Q, nt, ct] = _.getRectInCurrentCoords(s.rect, N);
+                                return _.x = tt / M, _.y = Q / N, _.width = nt / M, _.height = ct / N, _;
                             }
                             remove() {
                                 var s;
-                                this.div.removeEventListener("focusin", t(this, A)), this.div.removeEventListener("focusout", t(this, u)), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), (s = t(this, g)) == null || s.remove(), Z(this, g, null), Z(this, O, null);
+                                this.div.removeEventListener("focusin", t(this, A)), this.div.removeEventListener("focusout", t(this, u)), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), (s = t(this, g)) == null || s.remove(), Z(this, g, null), Z(this, L, null);
                             }
                             get isResizable() {
                                 return !1;
                             }
                             makeResizable() {
-                                this.isResizable && (W(this, E, yi).call(this), t(this, v).classList.remove("hidden"));
+                                this.isResizable && (W(this, C, yi).call(this), t(this, v).classList.remove("hidden"));
                             }
                             select() {
                                 var s;
                                 this.makeResizable(), (s = this.div) == null || s.classList.add("selectedEditor");
                             }
                             unselect() {
                                 var s, o, h;
@@ -2720,48 +2714,48 @@
                                 t(this, g) && (t(this, g).hidden = !1);
                             }
                             enterInEditMode() {}
                             get contentDiv() {
                                 return this.div;
                             }
                             get isEditing() {
-                                return t(this, w);
+                                return t(this, E);
                             }
                             set isEditing(s) {
-                                Z(this, w, s), this.parent && (s ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
+                                Z(this, E, s), this.parent && (s ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
                             }
                             setAspectRatio(s, o) {
-                                Z(this, x, !0);
+                                Z(this, T, !0);
                                 const h = s / o,
                                     {
-                                        style: b
+                                        style: _
                                     } = this.div;
-                                b.aspectRatio = h, b.height = "auto";
+                                _.aspectRatio = h, _.height = "auto";
                             }
                             static get MIN_SIZE() {
                                 return 16;
                             }
                         };
-                        B = new WeakMap(), F = new WeakMap(), g = new WeakMap(), O = new WeakMap(), I = new WeakMap(), x = new WeakMap(), v = new WeakMap(), A = new WeakMap(), u = new WeakMap(), _ = new WeakMap(), w = new WeakMap(), C = new WeakMap(), y = new WeakMap(), a = new WeakMap(), c = new WeakSet(), Ue = function([s, o], h, b) {
-                            [h, b] = this.screenToPageTranslation(h, b), this.x += h / s, this.y += b / o, this.fixAndSetPosition();
+                        B = new WeakMap(), F = new WeakMap(), g = new WeakMap(), L = new WeakMap(), O = new WeakMap(), T = new WeakMap(), v = new WeakMap(), A = new WeakMap(), u = new WeakMap(), b = new WeakMap(), E = new WeakMap(), w = new WeakMap(), y = new WeakMap(), a = new WeakMap(), l = new WeakSet(), Ue = function([s, o], h, _) {
+                            [h, _] = this.screenToPageTranslation(h, _), this.x += h / s, this.y += _ / o, this.fixAndSetPosition();
                         }, p = new WeakSet(), je = function() {
                             const [s, o] = this.parentDimensions, {
                                 _borderLineWidth: h
-                            } = i, b = h / s, M = h / o;
+                            } = i, _ = h / s, M = h / o;
                             switch (this.rotation) {
                                 case 90:
-                                    return [-b, M];
+                                    return [-_, M];
                                 case 180:
-                                    return [b, M];
+                                    return [_, M];
                                 case 270:
-                                    return [b, -M];
+                                    return [_, -M];
                                 default:
-                                    return [-b, -M];
+                                    return [-_, -M];
                             }
-                        }, T = new WeakSet(), He = function(s, o, h) {
+                        }, x = new WeakSet(), He = function(s, o, h) {
                             switch (h) {
                                 case 90:
                                     return [o, -s];
                                 case 180:
                                     return [-s, -o];
                                 case 270:
                                     return [-o, s];
@@ -2779,15 +2773,15 @@
                                 case 270: {
                                     const [o, h] = this.pageDimensions;
                                     return [0, o / h, -h / o, 0];
                                 }
                                 default:
                                     return [1, 0, 0, 1];
                             }
-                        }, E = new WeakSet(), yi = function() {
+                        }, C = new WeakSet(), yi = function() {
                             if (t(this, v))
                                 return;
                             Z(this, v, document.createElement("div")), t(this, v).classList.add("resizers");
                             const s = ["topLeft", "topRight", "bottomRight", "bottomLeft"];
                             this._willKeepAspectRatio || s.push("topMiddle", "middleRight", "bottomMiddle", "middleLeft");
                             for (const o of s) {
                                 const h = document.createElement("div");
@@ -2797,31 +2791,31 @@
                         }, st = new WeakSet(), vi = function(s, o) {
                             o.preventDefault();
                             const {
                                 isMac: h
                             } = P.FeatureTest.platform;
                             if (o.button !== 0 || o.ctrlKey && h)
                                 return;
-                            const b = W(this, H, Si).bind(this, s),
+                            const _ = W(this, H, Si).bind(this, s),
                                 M = this._isDraggable;
                             this._isDraggable = !1;
                             const N = {
                                 passive: !0,
                                 capture: !0
                             };
-                            window.addEventListener("pointermove", b, N);
+                            window.addEventListener("pointermove", _, N);
                             const tt = this.x,
                                 Q = this.y,
                                 nt = this.width,
                                 ct = this.height,
                                 yt = this.parent.div.style.cursor,
                                 ut = this.div.style.cursor;
                             this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(o.target).cursor;
                             const Ft = () => {
-                                this._isDraggable = M, window.removeEventListener("pointerup", Ft), window.removeEventListener("blur", Ft), window.removeEventListener("pointermove", b, N), this.parent.div.style.cursor = yt, this.div.style.cursor = ut;
+                                this._isDraggable = M, window.removeEventListener("pointerup", Ft), window.removeEventListener("blur", Ft), window.removeEventListener("pointermove", _, N), this.parent.div.style.cursor = yt, this.div.style.cursor = ut;
                                 const Bt = this.x,
                                     St = this.y,
                                     Dt = this.width,
                                     ft = this.height;
                                 Bt === tt && St === Q && Dt === nt && ft === ct || this.addCommands({
                                     cmd: () => {
                                         this.width = Dt, this.height = ft, this.x = Bt, this.y = St;
@@ -2834,15 +2828,15 @@
                                         this.setDims(K * nt, J * ct), this.fixAndSetPosition();
                                     },
                                     mustExec: !0
                                 });
                             };
                             window.addEventListener("pointerup", Ft), window.addEventListener("blur", Ft);
                         }, H = new WeakSet(), Si = function(s, o) {
-                            const [h, b] = this.parentDimensions, M = this.x, N = this.y, tt = this.width, Q = this.height, nt = i.MIN_SIZE / h, ct = i.MIN_SIZE / b, yt = (bt) => Math.round(bt * 1e4) / 1e4, ut = W(this, U, We).call(this, this.rotation), Ft = (bt, At) => [ut[0] * bt + ut[2] * At, ut[1] * bt + ut[3] * At], Bt = W(this, U, We).call(this, 360 - this.rotation), St = (bt, At) => [Bt[0] * bt + Bt[2] * At, Bt[1] * bt + Bt[3] * At];
+                            const [h, _] = this.parentDimensions, M = this.x, N = this.y, tt = this.width, Q = this.height, nt = i.MIN_SIZE / h, ct = i.MIN_SIZE / _, yt = (bt) => Math.round(bt * 1e4) / 1e4, ut = W(this, U, We).call(this, this.rotation), Ft = (bt, At) => [ut[0] * bt + ut[2] * At, ut[1] * bt + ut[3] * At], Bt = W(this, U, We).call(this, 360 - this.rotation), St = (bt, At) => [Bt[0] * bt + Bt[2] * At, Bt[1] * bt + Bt[3] * At];
                             let Dt, ft, K = !1,
                                 J = !1;
                             switch (s) {
                                 case "topLeft":
                                     K = !0, Dt = (bt, At) => [0, 0], ft = (bt, At) => [bt, At];
                                     break;
                                 case "topMiddle":
@@ -2871,85 +2865,85 @@
                                 Et = ft(tt, Q);
                             let Ct = Ft(...Et);
                             const Ut = yt(M + Ct[0]),
                                 Gt = yt(N + Ct[1]);
                             let Ht = 1,
                                 Xt = 1,
                                 [Vt, Wt] = this.screenToPageTranslation(o.movementX, o.movementY);
-                            if ([Vt, Wt] = St(Vt / h, Wt / b), K) {
+                            if ([Vt, Wt] = St(Vt / h, Wt / _), K) {
                                 const bt = Math.hypot(tt, Q);
                                 Ht = Xt = Math.max(Math.min(Math.hypot(Et[0] - ht[0] - Vt, Et[1] - ht[1] - Wt) / bt, 1 / tt, 1 / Q), nt / tt, ct / Q);
                             } else
                                 J ? Ht = Math.max(nt, Math.min(1, Math.abs(Et[0] - ht[0] - Vt))) / tt : Xt = Math.max(ct, Math.min(1, Math.abs(Et[1] - ht[1] - Wt))) / Q;
                             const $t = yt(tt * Ht),
                                 ot = yt(Q * Xt);
                             Ct = Ft(...ft($t, ot));
                             const Y = Ut - Ct[0],
                                 G = Gt - Ct[1];
-                            this.width = $t, this.height = ot, this.x = Y, this.y = G, this.setDims(h * $t, b * ot), this.fixAndSetPosition();
+                            this.width = $t, this.height = ot, this.x = Y, this.y = G, this.setDims(h * $t, _ * ot), this.fixAndSetPosition();
                         }, gt = new WeakSet(), Ge = async function() {
                             var h;
                             const s = t(this, g);
                             if (!s)
                                 return;
                             if (!t(this, B) && !t(this, F)) {
-                                s.classList.remove("done"), (h = t(this, O)) == null || h.remove();
+                                s.classList.remove("done"), (h = t(this, L)) == null || h.remove();
                                 return;
                             }
-                            i._l10nPromise.get("editor_alt_text_edit_button_label").then((b) => {
-                                s.setAttribute("aria-label", b);
+                            i._l10nPromise.get("editor_alt_text_edit_button_label").then((_) => {
+                                s.setAttribute("aria-label", _);
                             });
-                            let o = t(this, O);
+                            let o = t(this, L);
                             if (!o) {
-                                Z(this, O, o = document.createElement("span")), o.className = "tooltip", o.setAttribute("role", "tooltip");
-                                const b = o.id = `alt-text-tooltip-${this.id}`;
-                                s.setAttribute("aria-describedby", b);
+                                Z(this, L, o = document.createElement("span")), o.className = "tooltip", o.setAttribute("role", "tooltip");
+                                const _ = o.id = `alt-text-tooltip-${this.id}`;
+                                s.setAttribute("aria-describedby", _);
                                 const M = 100;
                                 s.addEventListener("mouseenter", () => {
-                                    Z(this, I, setTimeout(() => {
-                                        Z(this, I, null), t(this, O).classList.add("show"), this._uiManager._eventBus.dispatch("reporttelemetry", {
+                                    Z(this, O, setTimeout(() => {
+                                        Z(this, O, null), t(this, L).classList.add("show"), this._uiManager._eventBus.dispatch("reporttelemetry", {
                                             source: this,
                                             details: {
                                                 type: "editing",
                                                 subtype: this.editorType,
                                                 data: {
                                                     action: "alt_text_tooltip"
                                                 }
                                             }
                                         });
                                     }, M));
                                 }), s.addEventListener("mouseleave", () => {
                                     var N;
-                                    clearTimeout(t(this, I)), Z(this, I, null), (N = t(this, O)) == null || N.classList.remove("show");
+                                    clearTimeout(t(this, O)), Z(this, O, null), (N = t(this, L)) == null || N.classList.remove("show");
                                 });
                             }
                             s.classList.add("done"), o.innerText = t(this, F) ? await i._l10nPromise.get("editor_alt_text_decorative_tooltip") : t(this, B), o.parentNode || s.append(o);
-                        }, xt = new WeakSet(), Ei = function(s) {
+                        }, Pt = new WeakSet(), Ei = function(s) {
                             if (!this._isDraggable)
                                 return;
                             const o = this._uiManager.isSelected(this);
                             this._uiManager.setUpDragSession();
-                            let h, b;
+                            let h, _;
                             o && (h = {
                                 passive: !0,
                                 capture: !0
-                            }, b = (N) => {
+                            }, _ = (N) => {
                                 const [tt, Q] = this.screenToPageTranslation(N.movementX, N.movementY);
                                 this._uiManager.dragSelectedEditors(tt, Q);
-                            }, window.addEventListener("pointermove", b, h));
+                            }, window.addEventListener("pointermove", _, h));
                             const M = () => {
-                                if (window.removeEventListener("pointerup", M), window.removeEventListener("blur", M), o && window.removeEventListener("pointermove", b, h), Z(this, _, !1), !this._uiManager.endDragSession()) {
+                                if (window.removeEventListener("pointerup", M), window.removeEventListener("blur", M), o && window.removeEventListener("pointermove", _, h), Z(this, b, !1), !this._uiManager.endDragSession()) {
                                     const {
                                         isMac: N
                                     } = P.FeatureTest.platform;
                                     s.ctrlKey && !N || s.shiftKey || s.metaKey && N ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
                                 }
                             };
                             window.addEventListener("pointerup", M), window.addEventListener("blur", M);
-                        }, L(i, T), ee(i, "_borderLineWidth", -1), ee(i, "_colorManager", new l.ColorManager()), ee(i, "_zIndex", 1), ee(i, "SMALL_EDITOR_SIZE", 0);
+                        }, I(i, x), ee(i, "_borderLineWidth", -1), ee(i, "_colorManager", new c.ColorManager()), ee(i, "_zIndex", 1), ee(i, "SMALL_EDITOR_SIZE", 0);
                         let X = i;
                         d.AnnotationEditor = X;
                         class pt extends X {
                             constructor(s) {
                                 super(s), this.annotationElementId = s.annotationElementId, this.deleted = !0;
                             }
                             serialize() {
@@ -2960,64 +2954,64 @@
                                 };
                             }
                         }
                     },
                     /* 5 */
                     /***/
                     (dt, d, et) => {
-                        var x, v, A, u, _, ze, y, a, c, k, p, wi, m, U, z, E, V, st, at, H, lt, gt, wt, xt, S, i, n, s, o, h, b, M, N, tt, Q, nt, ct, yt, ut, Ft, Bt, St, Dt, ft, K, J, ht, Ci, Ct, Xe, Gt, Ve, Xt, Ce, Wt, qe, ot, $e, G, re, At, me, Zt, Ti, vt, Pi, Tt, Ye, Nt, be, _t, Ke;
+                        var T, v, A, u, b, ze, y, a, l, k, p, wi, m, U, z, C, V, st, at, H, lt, gt, wt, Pt, S, i, n, s, o, h, _, M, N, tt, Q, nt, ct, yt, ut, Ft, Bt, St, Dt, ft, K, J, ht, Ci, Ct, Xe, Gt, Ve, Xt, Ce, Wt, qe, ot, $e, G, re, At, me, Zt, Ti, vt, xi, Tt, Ye, Nt, be, _t, Ke;
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.KeyboardManager = d.CommandManager = d.ColorManager = d.AnnotationEditorUIManager = void 0, d.bindEvents = rt, d.opacityToHex = X;
-                        var l = et(1),
+                        var c = et(1),
                             P = et(6);
 
                         function rt(R, e, f) {
                             for (const D of f)
                                 e.addEventListener(D, R[D].bind(R));
                         }
 
                         function X(R) {
                             return Math.round(Math.min(255, Math.max(1, 255 * R))).toString(16).padStart(2, "0");
                         }
                         class pt {
                             constructor() {
-                                L(this, x, 0);
+                                I(this, T, 0);
                             }
                             getId() {
-                                return `${l.AnnotationEditorPrefix}${ge(this, x)._++}`;
+                                return `${c.AnnotationEditorPrefix}${ge(this, T)._++}`;
                             }
                         }
-                        x = new WeakMap();
-                        const C = class C {
+                        T = new WeakMap();
+                        const w = class w {
                             constructor() {
-                                L(this, _);
-                                L(this, v, (0, l.getUuid)());
-                                L(this, A, 0);
-                                L(this, u, null);
+                                I(this, b);
+                                I(this, v, (0, c.getUuid)());
+                                I(this, A, 0);
+                                I(this, u, null);
                             }
                             static get _isSVGFittingCanvas() {
                                 const e = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>',
                                     D = new OffscreenCanvas(1, 3).getContext("2d"),
                                     j = new Image();
                                 j.src = e;
                                 const q = j.decode().then(() => (D.drawImage(j, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(D.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
-                                return (0, l.shadow)(this, "_isSVGFittingCanvas", q);
+                                return (0, c.shadow)(this, "_isSVGFittingCanvas", q);
                             }
                             async getFromFile(e) {
                                 const {
                                     lastModified: f,
                                     name: D,
                                     size: j,
                                     type: q
                                 } = e;
-                                return W(this, _, ze).call(this, `${f}_${D}_${j}_${q}`, e);
+                                return W(this, b, ze).call(this, `${f}_${D}_${j}_${q}`, e);
                             }
                             async getFromUrl(e) {
-                                return W(this, _, ze).call(this, e, e);
+                                return W(this, b, ze).call(this, e, e);
                             }
                             async getFromId(e) {
                                 t(this, u) || Z(this, u, /* @__PURE__ */ new Map());
                                 const f = t(this, u).get(e);
                                 return f ? f.bitmap ? (f.refCounter += 1, f) : f.file ? this.getFromFile(f.file) : this.getFromUrl(f.url) : null;
                             }
                             getSvgUrl(e) {
@@ -3029,15 +3023,15 @@
                                 const f = t(this, u).get(e);
                                 f && (f.refCounter -= 1, f.refCounter === 0 && (f.bitmap = null));
                             }
                             isValidId(e) {
                                 return e.startsWith(`image_${t(this, v)}_`);
                             }
                         };
-                        v = new WeakMap(), A = new WeakMap(), u = new WeakMap(), _ = new WeakSet(), ze = async function(e, f) {
+                        v = new WeakMap(), A = new WeakMap(), u = new WeakMap(), b = new WeakSet(), ze = async function(e, f) {
                             t(this, u) || Z(this, u, /* @__PURE__ */ new Map());
                             let D = t(this, u).get(e);
                             if (D === null)
                                 return null;
                             if (D != null && D.bitmap)
                                 return D.refCounter += 1, D;
                             try {
@@ -3053,42 +3047,42 @@
                                     const q = await fetch(f);
                                     if (!q.ok)
                                         throw new Error(q.statusText);
                                     j = await q.blob();
                                 } else
                                     j = D.file = f;
                                 if (j.type === "image/svg+xml") {
-                                    const q = C._isSVGFittingCanvas,
+                                    const q = w._isSVGFittingCanvas,
                                         it = new FileReader(),
                                         mt = new Image(),
-                                        kt = new Promise((Pt, zt) => {
+                                        kt = new Promise((xt, zt) => {
                                             mt.onload = () => {
-                                                D.bitmap = mt, D.isSvg = !0, Pt();
+                                                D.bitmap = mt, D.isSvg = !0, xt();
                                             }, it.onload = async () => {
                                                 const Mt = D.svgUrl = it.result;
                                                 mt.src = await q ? `${Mt}#svgView(preserveAspectRatio(none))` : Mt;
                                             }, mt.onerror = it.onerror = zt;
                                         });
                                     it.readAsDataURL(j), await kt;
                                 } else
                                     D.bitmap = await createImageBitmap(j);
                                 D.refCounter = 1;
                             } catch (j) {
                                 console.error(j), D = null;
                             }
                             return t(this, u).set(e, D), D && t(this, u).set(D.id, D), D;
                         };
-                        let B = C;
+                        let B = w;
                         class F {
                             constructor(e = 128) {
-                                L(this, y, []);
-                                L(this, a, !1);
-                                L(this, c, void 0);
-                                L(this, k, -1);
-                                Z(this, c, e);
+                                I(this, y, []);
+                                I(this, a, !1);
+                                I(this, l, void 0);
+                                I(this, k, -1);
+                                Z(this, l, e);
                             }
                             add({
                                 cmd: e,
                                 undo: f,
                                 mustExec: D,
                                 type: j = NaN,
                                 overwriteIfSameType: q = !1,
@@ -3106,15 +3100,15 @@
                                     return;
                                 }
                                 if (q && t(this, y)[t(this, k)].type === j) {
                                     it && (mt.undo = t(this, y)[t(this, k)].undo), t(this, y)[t(this, k)] = mt;
                                     return;
                                 }
                                 const kt = t(this, k) + 1;
-                                kt === t(this, c) ? t(this, y).splice(0, 1) : (Z(this, k, kt), kt < t(this, y).length && t(this, y).splice(kt)), t(this, y).push(mt);
+                                kt === t(this, l) ? t(this, y).splice(0, 1) : (Z(this, k, kt), kt < t(this, y).length && t(this, y).splice(kt)), t(this, y).push(mt);
                             }
                             undo() {
                                 t(this, k) !== -1 && (Z(this, a, !0), t(this, y)[t(this, k)].undo(), Z(this, a, !1), Z(this, k, t(this, k) - 1));
                             }
                             redo() {
                                 t(this, k) < t(this, y).length - 1 && (Z(this, k, t(this, k) + 1), Z(this, a, !0), t(this, y)[t(this, k)].cmd(), Z(this, a, !1));
                             }
@@ -3124,22 +3118,22 @@
                             hasSomethingToRedo() {
                                 return t(this, k) < t(this, y).length - 1;
                             }
                             destroy() {
                                 Z(this, y, null);
                             }
                         }
-                        y = new WeakMap(), a = new WeakMap(), c = new WeakMap(), k = new WeakMap(), d.CommandManager = F;
+                        y = new WeakMap(), a = new WeakMap(), l = new WeakMap(), k = new WeakMap(), d.CommandManager = F;
                         class g {
                             constructor(e) {
-                                L(this, p);
+                                I(this, p);
                                 this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
                                 const {
                                     isMac: f
-                                } = l.FeatureTest.platform;
+                                } = c.FeatureTest.platform;
                                 for (const [D, j, q = {}] of e)
                                     for (const it of D) {
                                         const mt = it.startsWith("mac+");
                                         f && mt ? (this.callbacks.set(it.slice(4), {
                                             callback: j,
                                             options: q
                                         }), this.allKeys.add(it.split("+").at(-1))) : !f && !mt && (this.callbacks.set(it, {
@@ -3166,113 +3160,113 @@
                             }
                         }
                         p = new WeakSet(), wi = function(e) {
                             e.altKey && this.buffer.push("alt"), e.ctrlKey && this.buffer.push("ctrl"), e.metaKey && this.buffer.push("meta"), e.shiftKey && this.buffer.push("shift"), this.buffer.push(e.key);
                             const f = this.buffer.join("+");
                             return this.buffer.length = 0, f;
                         }, d.KeyboardManager = g;
-                        const T = class T {
+                        const x = class x {
                             get _colors() {
                                 const e = /* @__PURE__ */ new Map([
                                     ["CanvasText", null],
                                     ["Canvas", null]
                                 ]);
-                                return (0, P.getColorValues)(e), (0, l.shadow)(this, "_colors", e);
+                                return (0, P.getColorValues)(e), (0, c.shadow)(this, "_colors", e);
                             }
                             convert(e) {
                                 const f = (0, P.getRGB)(e);
                                 if (!window.matchMedia("(forced-colors: active)").matches)
                                     return f;
                                 for (const [D, j] of this._colors)
                                     if (j.every((q, it) => q === f[it]))
-                                        return T._colorsMapping.get(D);
+                                        return x._colorsMapping.get(D);
                                 return f;
                             }
                             getHexCode(e) {
                                 const f = this._colors.get(e);
-                                return f ? l.Util.makeHexColor(...f) : e;
+                                return f ? c.Util.makeHexColor(...f) : e;
                             }
                         };
-                        ee(T, "_colorsMapping", /* @__PURE__ */ new Map([
+                        ee(x, "_colorsMapping", /* @__PURE__ */ new Map([
                             ["CanvasText", [0, 0, 0]],
                             ["Canvas", [255, 255, 255]]
                         ]));
-                        let O = T;
-                        d.ColorManager = O;
+                        let L = x;
+                        d.ColorManager = L;
                         const It = class It {
                             constructor(e, f, D, j, q, it) {
-                                L(this, ht);
-                                L(this, Ct);
-                                L(this, Gt);
-                                L(this, Xt);
-                                L(this, Wt);
-                                L(this, ot);
-                                L(this, G);
-                                L(this, At);
-                                L(this, Zt);
-                                L(this, vt);
-                                L(this, Tt);
-                                L(this, Nt);
-                                L(this, _t);
-                                L(this, m, null);
-                                L(this, U, /* @__PURE__ */ new Map());
-                                L(this, z, /* @__PURE__ */ new Map());
-                                L(this, E, null);
-                                L(this, V, null);
-                                L(this, st, new F());
-                                L(this, at, 0);
-                                L(this, H, /* @__PURE__ */ new Set());
-                                L(this, lt, null);
-                                L(this, gt, null);
-                                L(this, wt, /* @__PURE__ */ new Set());
-                                L(this, xt, null);
-                                L(this, S, new pt());
-                                L(this, i, !1);
-                                L(this, n, !1);
-                                L(this, s, null);
-                                L(this, o, l.AnnotationEditorType.NONE);
-                                L(this, h, /* @__PURE__ */ new Set());
-                                L(this, b, null);
-                                L(this, M, this.blur.bind(this));
-                                L(this, N, this.focus.bind(this));
-                                L(this, tt, this.copy.bind(this));
-                                L(this, Q, this.cut.bind(this));
-                                L(this, nt, this.paste.bind(this));
-                                L(this, ct, this.keydown.bind(this));
-                                L(this, yt, this.onEditingAction.bind(this));
-                                L(this, ut, this.onPageChanging.bind(this));
-                                L(this, Ft, this.onScaleChanging.bind(this));
-                                L(this, Bt, this.onRotationChanging.bind(this));
-                                L(this, St, {
+                                I(this, ht);
+                                I(this, Ct);
+                                I(this, Gt);
+                                I(this, Xt);
+                                I(this, Wt);
+                                I(this, ot);
+                                I(this, G);
+                                I(this, At);
+                                I(this, Zt);
+                                I(this, vt);
+                                I(this, Tt);
+                                I(this, Nt);
+                                I(this, _t);
+                                I(this, m, null);
+                                I(this, U, /* @__PURE__ */ new Map());
+                                I(this, z, /* @__PURE__ */ new Map());
+                                I(this, C, null);
+                                I(this, V, null);
+                                I(this, st, new F());
+                                I(this, at, 0);
+                                I(this, H, /* @__PURE__ */ new Set());
+                                I(this, lt, null);
+                                I(this, gt, null);
+                                I(this, wt, /* @__PURE__ */ new Set());
+                                I(this, Pt, null);
+                                I(this, S, new pt());
+                                I(this, i, !1);
+                                I(this, n, !1);
+                                I(this, s, null);
+                                I(this, o, c.AnnotationEditorType.NONE);
+                                I(this, h, /* @__PURE__ */ new Set());
+                                I(this, _, null);
+                                I(this, M, this.blur.bind(this));
+                                I(this, N, this.focus.bind(this));
+                                I(this, tt, this.copy.bind(this));
+                                I(this, Q, this.cut.bind(this));
+                                I(this, nt, this.paste.bind(this));
+                                I(this, ct, this.keydown.bind(this));
+                                I(this, yt, this.onEditingAction.bind(this));
+                                I(this, ut, this.onPageChanging.bind(this));
+                                I(this, Ft, this.onScaleChanging.bind(this));
+                                I(this, Bt, this.onRotationChanging.bind(this));
+                                I(this, St, {
                                     isEditing: !1,
                                     isEmpty: !0,
                                     hasSomethingToUndo: !1,
                                     hasSomethingToRedo: !1,
                                     hasSelectedEditor: !1
                                 });
-                                L(this, Dt, [0, 0]);
-                                L(this, ft, null);
-                                L(this, K, null);
-                                L(this, J, null);
-                                Z(this, K, e), Z(this, J, f), Z(this, E, D), this._eventBus = j, this._eventBus._on("editingaction", t(this, yt)), this._eventBus._on("pagechanging", t(this, ut)), this._eventBus._on("scalechanging", t(this, Ft)), this._eventBus._on("rotationchanging", t(this, Bt)), Z(this, V, q.annotationStorage), Z(this, xt, q.filterFactory), Z(this, b, it), this.viewParameters = {
+                                I(this, Dt, [0, 0]);
+                                I(this, ft, null);
+                                I(this, K, null);
+                                I(this, J, null);
+                                Z(this, K, e), Z(this, J, f), Z(this, C, D), this._eventBus = j, this._eventBus._on("editingaction", t(this, yt)), this._eventBus._on("pagechanging", t(this, ut)), this._eventBus._on("scalechanging", t(this, Ft)), this._eventBus._on("rotationchanging", t(this, Bt)), Z(this, V, q.annotationStorage), Z(this, Pt, q.filterFactory), Z(this, _, it), this.viewParameters = {
                                     realScale: P.PixelsPerInch.PDF_TO_CSS_UNITS,
                                     rotation: 0
                                 };
                             }
                             static get _keyboardManager() {
                                 const e = It.prototype,
                                     f = (q) => {
                                         const {
                                             activeElement: it
                                         } = document;
                                         return it && t(q, K).contains(it) && q.hasSomethingToControl();
                                     },
                                     D = this.TRANSLATE_SMALL,
                                     j = this.TRANSLATE_BIG;
-                                return (0, l.shadow)(this, "_keyboardManager", new g([
+                                return (0, c.shadow)(this, "_keyboardManager", new g([
                                     [
                                         ["ctrl+a", "mac+meta+a"], e.selectAll
                                     ],
                                     [
                                         ["ctrl+z", "mac+meta+z"], e.undo
                                     ],
                                     [
@@ -3334,25 +3328,25 @@
                                     ]
                                 ]));
                             }
                             destroy() {
                                 W(this, Xt, Ce).call(this), W(this, Ct, Xe).call(this), this._eventBus._off("editingaction", t(this, yt)), this._eventBus._off("pagechanging", t(this, ut)), this._eventBus._off("scalechanging", t(this, Ft)), this._eventBus._off("rotationchanging", t(this, Bt));
                                 for (const e of t(this, z).values())
                                     e.destroy();
-                                t(this, z).clear(), t(this, U).clear(), t(this, wt).clear(), Z(this, m, null), t(this, h).clear(), t(this, st).destroy(), t(this, E).destroy();
+                                t(this, z).clear(), t(this, U).clear(), t(this, wt).clear(), Z(this, m, null), t(this, h).clear(), t(this, st).destroy(), t(this, C).destroy();
                             }
                             get hcmFilter() {
-                                return (0, l.shadow)(this, "hcmFilter", t(this, b) ? t(this, xt).addHCMFilter(t(this, b).foreground, t(this, b).background) : "none");
+                                return (0, c.shadow)(this, "hcmFilter", t(this, _) ? t(this, Pt).addHCMFilter(t(this, _).foreground, t(this, _).background) : "none");
                             }
                             get direction() {
-                                return (0, l.shadow)(this, "direction", getComputedStyle(t(this, K)).direction);
+                                return (0, c.shadow)(this, "direction", getComputedStyle(t(this, K)).direction);
                             }
                             editAltText(e) {
                                 var f;
-                                (f = t(this, E)) == null || f.editAltText(this, e);
+                                (f = t(this, C)) == null || f.editAltText(this, e);
                             }
                             onPageChanging({
                                 pageNumber: e
                             }) {
                                 Z(this, at, e - 1);
                             }
                             focusMainContainer() {
@@ -3450,28 +3444,28 @@
                                         }
                                 let D = f.getData("application/pdfjs");
                                 if (!D)
                                     return;
                                 try {
                                     D = JSON.parse(D);
                                 } catch (q) {
-                                    (0, l.warn)(`paste: "${q.message}".`);
+                                    (0, c.warn)(`paste: "${q.message}".`);
                                     return;
                                 }
                                 if (!Array.isArray(D))
                                     return;
                                 this.unselectAll();
                                 const j = this.currentLayer;
                                 try {
                                     const q = [];
                                     for (const kt of D) {
-                                        const Pt = j.deserialize(kt);
-                                        if (!Pt)
+                                        const xt = j.deserialize(kt);
+                                        if (!xt)
                                             return;
-                                        q.push(Pt);
+                                        q.push(xt);
                                     }
                                     const it = () => {
                                             for (const kt of q)
                                                 W(this, Tt, Ye).call(this, kt);
                                             W(this, _t, Ke).call(this, q);
                                         },
                                         mt = () => {
@@ -3480,27 +3474,27 @@
                                         };
                                     this.addCommands({
                                         cmd: it,
                                         undo: mt,
                                         mustExec: !0
                                     });
                                 } catch (q) {
-                                    (0, l.warn)(`paste: "${q.message}".`);
+                                    (0, c.warn)(`paste: "${q.message}".`);
                                 }
                             }
                             keydown(e) {
                                 var f;
                                 (f = this.getActive()) != null && f.shouldGetKeyboardEvents() || It._keyboardManager.exec(this, e);
                             }
                             onEditingAction(e) {
                                 ["undo", "redo", "delete", "selectAll"].includes(e.name) && this[e.name]();
                             }
                             setEditingState(e) {
                                 e ? (W(this, ht, Ci).call(this), W(this, Gt, Ve).call(this), W(this, Wt, qe).call(this), W(this, G, re).call(this, {
-                                    isEditing: t(this, o) !== l.AnnotationEditorType.NONE,
+                                    isEditing: t(this, o) !== c.AnnotationEditorType.NONE,
                                     isEmpty: W(this, Nt, be).call(this),
                                     hasSomethingToUndo: t(this, st).hasSomethingToUndo(),
                                     hasSomethingToRedo: t(this, st).hasSomethingToRedo(),
                                     hasSelectedEditor: !1
                                 })) : (W(this, Ct, Xe).call(this), W(this, Xt, Ce).call(this), W(this, ot, $e).call(this), W(this, G, re).call(this, {
                                     isEditing: !1
                                 }), this.disableUserSelect(!1));
@@ -3528,16 +3522,16 @@
                                 t(this, z).set(e.pageIndex, e), t(this, i) ? e.enable() : e.disable();
                             }
                             removeLayer(e) {
                                 t(this, z).delete(e.pageIndex);
                             }
                             updateMode(e, f = null) {
                                 if (t(this, o) !== e) {
-                                    if (Z(this, o, e), e === l.AnnotationEditorType.NONE) {
-                                        this.setEditingState(!1), W(this, vt, Pi).call(this);
+                                    if (Z(this, o, e), e === c.AnnotationEditorType.NONE) {
+                                        this.setEditingState(!1), W(this, vt, xi).call(this);
                                         return;
                                     }
                                     this.setEditingState(!0), W(this, Zt, Ti).call(this), this.unselectAll();
                                     for (const D of t(this, z).values())
                                         D.updateMode(e);
                                     if (f) {
                                         for (const D of t(this, U).values())
@@ -3552,15 +3546,15 @@
                                 e !== t(this, o) && this._eventBus.dispatch("switchannotationeditormode", {
                                     source: this,
                                     mode: e
                                 });
                             }
                             updateParams(e, f) {
                                 if (t(this, gt)) {
-                                    if (e === l.AnnotationEditorParamsType.CREATE) {
+                                    if (e === c.AnnotationEditorParamsType.CREATE) {
                                         this.currentLayer.addNewEditor(e);
                                         return;
                                     }
                                     for (const D of t(this, h))
                                         D.updateParams(e, f);
                                     for (const D of t(this, gt))
                                         D.updateDefaultParams(e, f);
@@ -3788,18 +3782,18 @@
                             getActive() {
                                 return t(this, m);
                             }
                             getMode() {
                                 return t(this, o);
                             }
                             get imageManager() {
-                                return (0, l.shadow)(this, "imageManager", new B());
+                                return (0, c.shadow)(this, "imageManager", new B());
                             }
                         };
-                        m = new WeakMap(), U = new WeakMap(), z = new WeakMap(), E = new WeakMap(), V = new WeakMap(), st = new WeakMap(), at = new WeakMap(), H = new WeakMap(), lt = new WeakMap(), gt = new WeakMap(), wt = new WeakMap(), xt = new WeakMap(), S = new WeakMap(), i = new WeakMap(), n = new WeakMap(), s = new WeakMap(), o = new WeakMap(), h = new WeakMap(), b = new WeakMap(), M = new WeakMap(), N = new WeakMap(), tt = new WeakMap(), Q = new WeakMap(), nt = new WeakMap(), ct = new WeakMap(), yt = new WeakMap(), ut = new WeakMap(), Ft = new WeakMap(), Bt = new WeakMap(), St = new WeakMap(), Dt = new WeakMap(), ft = new WeakMap(), K = new WeakMap(), J = new WeakMap(), ht = new WeakSet(), Ci = function() {
+                        m = new WeakMap(), U = new WeakMap(), z = new WeakMap(), C = new WeakMap(), V = new WeakMap(), st = new WeakMap(), at = new WeakMap(), H = new WeakMap(), lt = new WeakMap(), gt = new WeakMap(), wt = new WeakMap(), Pt = new WeakMap(), S = new WeakMap(), i = new WeakMap(), n = new WeakMap(), s = new WeakMap(), o = new WeakMap(), h = new WeakMap(), _ = new WeakMap(), M = new WeakMap(), N = new WeakMap(), tt = new WeakMap(), Q = new WeakMap(), nt = new WeakMap(), ct = new WeakMap(), yt = new WeakMap(), ut = new WeakMap(), Ft = new WeakMap(), Bt = new WeakMap(), St = new WeakMap(), Dt = new WeakMap(), ft = new WeakMap(), K = new WeakMap(), J = new WeakMap(), ht = new WeakSet(), Ci = function() {
                             window.addEventListener("focus", t(this, N)), window.addEventListener("blur", t(this, M));
                         }, Ct = new WeakSet(), Xe = function() {
                             window.removeEventListener("focus", t(this, N)), window.removeEventListener("blur", t(this, M));
                         }, Gt = new WeakSet(), Ve = function() {
                             window.addEventListener("keydown", t(this, ct), {
                                 capture: !0
                             });
@@ -3823,15 +3817,15 @@
                             });
                         }, Zt = new WeakSet(), Ti = function() {
                             if (!t(this, i)) {
                                 Z(this, i, !0);
                                 for (const e of t(this, z).values())
                                     e.enable();
                             }
-                        }, vt = new WeakSet(), Pi = function() {
+                        }, vt = new WeakSet(), xi = function() {
                             if (this.unselectAll(), t(this, i)) {
                                 Z(this, i, !1);
                                 for (const e of t(this, z).values())
                                     e.disable();
                             }
                         }, Tt = new WeakSet(), Ye = function(e) {
                             const f = t(this, z).get(e.pageIndex);
@@ -3847,55 +3841,55 @@
                             t(this, h).clear();
                             for (const f of e)
                                 f.isEmpty() || (t(this, h).add(f), f.select());
                             W(this, G, re).call(this, {
                                 hasSelectedEditor: !0
                             });
                         }, ee(It, "TRANSLATE_SMALL", 1), ee(It, "TRANSLATE_BIG", 10);
-                        let I = It;
-                        d.AnnotationEditorUIManager = I;
+                        let O = It;
+                        d.AnnotationEditorUIManager = O;
                     },
                     /* 6 */
                     /***/
                     (dt, d, et) => {
-                        var at, H, lt, gt, wt, xt, S, i, n, s, o, h, de, M, ue, tt, Je, nt, Te, yt, Pe, Ft, _e, St, Ae;
+                        var at, H, lt, gt, wt, Pt, S, i, n, s, o, h, de, M, ue, tt, Je, nt, Te, yt, xe, Ft, _e, St, Ae;
                         Object.defineProperty(d, "__esModule", {
                             value: !0
-                        }), d.StatTimer = d.RenderingCancelledException = d.PixelsPerInch = d.PageViewport = d.PDFDateString = d.DOMStandardFontDataFactory = d.DOMSVGFactory = d.DOMFilterFactory = d.DOMCanvasFactory = d.DOMCMapReaderFactory = void 0, d.deprecated = k, d.getColorValues = U, d.getCurrentTransform = z, d.getCurrentTransformInverse = E, d.getFilenameFromUrl = _, d.getPdfFilenameFromUrl = w, d.getRGB = m, d.getXfaPageViewport = T, d.isDataScheme = A, d.isPdfFile = u, d.isValidFetchUrl = y, d.loadScript = c, d.noContextMenu = a, d.setLayerDimensions = V;
-                        var l = et(7),
+                        }), d.StatTimer = d.RenderingCancelledException = d.PixelsPerInch = d.PageViewport = d.PDFDateString = d.DOMStandardFontDataFactory = d.DOMSVGFactory = d.DOMFilterFactory = d.DOMCanvasFactory = d.DOMCMapReaderFactory = void 0, d.deprecated = k, d.getColorValues = U, d.getCurrentTransform = z, d.getCurrentTransformInverse = C, d.getFilenameFromUrl = b, d.getPdfFilenameFromUrl = E, d.getRGB = m, d.getXfaPageViewport = x, d.isDataScheme = A, d.isPdfFile = u, d.isValidFetchUrl = y, d.loadScript = l, d.noContextMenu = a, d.setLayerDimensions = V;
+                        var c = et(7),
                             P = et(1);
                         const rt = "http://www.w3.org/2000/svg",
                             st = class st {};
                         ee(st, "CSS", 96), ee(st, "PDF", 72), ee(st, "PDF_TO_CSS_UNITS", st.CSS / st.PDF);
                         let X = st;
                         d.PixelsPerInch = X;
-                        class pt extends l.BaseFilterFactory {
+                        class pt extends c.BaseFilterFactory {
                             constructor({
                                 docId: J,
                                 ownerDocument: ht = globalThis.document
                             } = {}) {
                                 super();
-                                L(this, h);
-                                L(this, M);
-                                L(this, tt);
-                                L(this, nt);
-                                L(this, yt);
-                                L(this, Ft);
-                                L(this, St);
-                                L(this, at, void 0);
-                                L(this, H, void 0);
-                                L(this, lt, void 0);
-                                L(this, gt, void 0);
-                                L(this, wt, void 0);
-                                L(this, xt, void 0);
-                                L(this, S, void 0);
-                                L(this, i, void 0);
-                                L(this, n, void 0);
-                                L(this, s, void 0);
-                                L(this, o, 0);
+                                I(this, h);
+                                I(this, M);
+                                I(this, tt);
+                                I(this, nt);
+                                I(this, yt);
+                                I(this, Ft);
+                                I(this, St);
+                                I(this, at, void 0);
+                                I(this, H, void 0);
+                                I(this, lt, void 0);
+                                I(this, gt, void 0);
+                                I(this, wt, void 0);
+                                I(this, Pt, void 0);
+                                I(this, S, void 0);
+                                I(this, i, void 0);
+                                I(this, n, void 0);
+                                I(this, s, void 0);
+                                I(this, o, 0);
                                 Z(this, lt, J), Z(this, gt, ht);
                             }
                             addFilter(J) {
                                 if (!J)
                                     return "none";
                                 let ht = t(this, h, de).get(J);
                                 if (ht)
@@ -3920,17 +3914,17 @@
                                 t(this, h, de).set(J, Xt), t(this, h, de).set(Gt, Xt);
                                 const Vt = W(this, nt, Te).call(this, Ht);
                                 return W(this, Ft, _e).call(this, Et, Ct, Ut, Vt), Xt;
                             }
                             addHCMFilter(J, ht) {
                                 var $t;
                                 const Et = `${J}-${ht}`;
-                                if (t(this, xt) === Et)
+                                if (t(this, Pt) === Et)
                                     return t(this, S);
-                                if (Z(this, xt, Et), Z(this, S, "none"), ($t = t(this, wt)) == null || $t.remove(), !J || !ht)
+                                if (Z(this, Pt, Et), Z(this, S, "none"), ($t = t(this, wt)) == null || $t.remove(), !J || !ht)
                                     return t(this, S);
                                 const Ct = W(this, St, Ae).call(this, J);
                                 J = P.Util.makeHexColor(...Ct);
                                 const Ut = W(this, St, Ae).call(this, ht);
                                 if (ht = P.Util.makeHexColor(...Ut), t(this, M, ue).style.color = "", J === "#000000" && ht === "#ffffff" || J === ht)
                                     return t(this, S);
                                 const Gt = new Array(256);
@@ -3985,15 +3979,15 @@
                                     G = Z(this, i, W(this, nt, Te).call(this, Y));
                                 return W(this, tt, Je).call(this, G), W(this, Ft, _e).call(this, ot(Wt[0], $t[0], 5), ot(Wt[1], $t[1], 5), ot(Wt[2], $t[2], 5), G), Z(this, s, `url(#${Y})`), t(this, s);
                             }
                             destroy(J = !1) {
                                 J && (t(this, S) || t(this, s)) || (t(this, H) && (t(this, H).parentNode.parentNode.remove(), Z(this, H, null)), t(this, at) && (t(this, at).clear(), Z(this, at, null)), Z(this, o, 0));
                             }
                         }
-                        at = new WeakMap(), H = new WeakMap(), lt = new WeakMap(), gt = new WeakMap(), wt = new WeakMap(), xt = new WeakMap(), S = new WeakMap(), i = new WeakMap(), n = new WeakMap(), s = new WeakMap(), o = new WeakMap(), h = new WeakSet(), de = function() {
+                        at = new WeakMap(), H = new WeakMap(), lt = new WeakMap(), gt = new WeakMap(), wt = new WeakMap(), Pt = new WeakMap(), S = new WeakMap(), i = new WeakMap(), n = new WeakMap(), s = new WeakMap(), o = new WeakMap(), h = new WeakSet(), de = function() {
                             return t(this, at) || Z(this, at, /* @__PURE__ */ new Map());
                         }, M = new WeakSet(), ue = function() {
                             if (!t(this, H)) {
                                 const J = t(this, gt).createElement("div"),
                                     {
                                         style: ht
                                     } = J;
@@ -4004,24 +3998,24 @@
                             return t(this, H);
                         }, tt = new WeakSet(), Je = function(J) {
                             const ht = t(this, gt).createElementNS(rt, "feColorMatrix");
                             ht.setAttribute("type", "matrix"), ht.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), J.append(ht);
                         }, nt = new WeakSet(), Te = function(J) {
                             const ht = t(this, gt).createElementNS(rt, "filter");
                             return ht.setAttribute("color-interpolation-filters", "sRGB"), ht.setAttribute("id", J), t(this, M, ue).append(ht), ht;
-                        }, yt = new WeakSet(), Pe = function(J, ht, Et) {
+                        }, yt = new WeakSet(), xe = function(J, ht, Et) {
                             const Ct = t(this, gt).createElementNS(rt, ht);
                             Ct.setAttribute("type", "discrete"), Ct.setAttribute("tableValues", Et), J.append(Ct);
                         }, Ft = new WeakSet(), _e = function(J, ht, Et, Ct) {
                             const Ut = t(this, gt).createElementNS(rt, "feComponentTransfer");
-                            Ct.append(Ut), W(this, yt, Pe).call(this, Ut, "feFuncR", J), W(this, yt, Pe).call(this, Ut, "feFuncG", ht), W(this, yt, Pe).call(this, Ut, "feFuncB", Et);
+                            Ct.append(Ut), W(this, yt, xe).call(this, Ut, "feFuncR", J), W(this, yt, xe).call(this, Ut, "feFuncG", ht), W(this, yt, xe).call(this, Ut, "feFuncB", Et);
                         }, St = new WeakSet(), Ae = function(J) {
                             return t(this, M, ue).style.color = J, m(getComputedStyle(t(this, M, ue)).getPropertyValue("color"));
                         }, d.DOMFilterFactory = pt;
-                        class B extends l.BaseCanvasFactory {
+                        class B extends c.BaseCanvasFactory {
                             constructor({
                                 ownerDocument: K = globalThis.document
                             } = {}) {
                                 super(), this._document = K;
                             }
                             _createCanvas(K, J) {
                                 const ht = this._document.createElement("canvas");
@@ -4048,36 +4042,36 @@
                                             }
                                         }
                                         ht(new Error(Et.statusText));
                                     }
                                 }, Et.send(null);
                             });
                         }
-                        class g extends l.BaseCMapReaderFactory {
+                        class g extends c.BaseCMapReaderFactory {
                             _fetchData(K, J) {
                                 return F(K, this.isCompressed).then((ht) => ({
                                     cMapData: ht,
                                     compressionType: J
                                 }));
                             }
                         }
                         d.DOMCMapReaderFactory = g;
-                        class O extends l.BaseStandardFontDataFactory {
+                        class L extends c.BaseStandardFontDataFactory {
                             _fetchData(K) {
                                 return F(K, !0);
                             }
                         }
-                        d.DOMStandardFontDataFactory = O;
-                        class I extends l.BaseSVGFactory {
+                        d.DOMStandardFontDataFactory = L;
+                        class O extends c.BaseSVGFactory {
                             _createSVG(K) {
                                 return document.createElementNS(rt, K);
                             }
                         }
-                        d.DOMSVGFactory = I;
-                        class x {
+                        d.DOMSVGFactory = O;
+                        class T {
                             constructor({
                                 viewBox: K,
                                 scale: J,
                                 rotation: ht,
                                 offsetX: Et = 0,
                                 offsetY: Ct = 0,
                                 dontFlip: Ut = !1
@@ -4120,15 +4114,15 @@
                             clone({
                                 scale: K = this.scale,
                                 rotation: J = this.rotation,
                                 offsetX: ht = this.offsetX,
                                 offsetY: Et = this.offsetY,
                                 dontFlip: Ct = !1
                             } = {}) {
-                                return new x({
+                                return new T({
                                     viewBox: this.viewBox.slice(),
                                     scale: K,
                                     rotation: J,
                                     offsetX: ht,
                                     offsetY: Et,
                                     dontFlip: Ct
                                 });
@@ -4141,15 +4135,15 @@
                                     ht = P.Util.applyTransform([K[2], K[3]], this.transform);
                                 return [J[0], J[1], ht[0], ht[1]];
                             }
                             convertToPdfPoint(K, J) {
                                 return P.Util.applyInverseTransform([K, J], this.transform);
                             }
                         }
-                        d.PageViewport = x;
+                        d.PageViewport = T;
                         class v extends P.BaseException {
                             constructor(K, J = 0) {
                                 super(K, "RenderingCancelledException"), this.extraDelay = J;
                             }
                         }
                         d.RenderingCancelledException = v;
 
@@ -4161,34 +4155,34 @@
                             return ft.substring(J, J + 5).toLowerCase() === "data:";
                         }
 
                         function u(ft) {
                             return typeof ft == "string" && /\.pdf$/i.test(ft);
                         }
 
-                        function _(ft, K = !1) {
+                        function b(ft, K = !1) {
                             return K || ([ft] = ft.split(/[#?]/, 1)), ft.substring(ft.lastIndexOf("/") + 1);
                         }
 
-                        function w(ft, K = "document.pdf") {
+                        function E(ft, K = "document.pdf") {
                             if (typeof ft != "string")
                                 return K;
                             if (A(ft))
                                 return (0, P.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), K;
                             const J = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/,
                                 ht = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i,
                                 Et = J.exec(ft);
                             let Ct = ht.exec(Et[1]) || ht.exec(Et[2]) || ht.exec(Et[3]);
                             if (Ct && (Ct = Ct[0], Ct.includes("%")))
                                 try {
                                     Ct = ht.exec(decodeURIComponent(Ct))[0];
                                 } catch {}
                             return Ct || K;
                         }
-                        class C {
+                        class w {
                             constructor() {
                                 ee(this, "started", /* @__PURE__ */ Object.create(null));
                                 ee(this, "times", []);
                             }
                             time(K) {
                                 K in this.started && (0, P.warn)(`Timer is already running for ${K}`), this.started[K] = Date.now();
                             }
@@ -4214,15 +4208,15 @@
                                     }
                                     of this.times)
                                     K.push(`${ht.padEnd(J)} ${Ct - Et}ms
 `);
                                 return K.join("");
                             }
                         }
-                        d.StatTimer = C;
+                        d.StatTimer = w;
 
                         function y(ft, K) {
                             try {
                                 const {
                                     protocol: J
                                 } = K ? new URL(ft, K) : new URL(ft);
                                 return J === "http:" || J === "https:";
@@ -4231,15 +4225,15 @@
                             }
                         }
 
                         function a(ft) {
                             ft.preventDefault();
                         }
 
-                        function c(ft, K = !1) {
+                        function l(ft, K = !1) {
                             return new Promise((J, ht) => {
                                 const Et = document.createElement("script");
                                 Et.src = ft, Et.onload = function(Ct) {
                                     K && Et.remove(), J(Ct);
                                 }, Et.onerror = function() {
                                     ht(new Error(`Cannot load script at: ${Et.src}`));
                                 }, (document.head || document.documentElement).append(Et);
@@ -4274,23 +4268,23 @@
                                 Vt = Vt >= 0 && Vt <= 23 ? Vt : 0;
                                 let Wt = parseInt(J[9], 10) || 0;
                                 return Wt = Wt >= 0 && Wt <= 59 ? Wt : 0, Xt === "-" ? (Ut += Vt, Gt += Wt) : Xt === "+" && (Ut -= Vt, Gt -= Wt), new Date(Date.UTC(ht, Et, Ct, Ut, Gt, Ht));
                             }
                         }
                         d.PDFDateString = r;
 
-                        function T(ft, {
+                        function x(ft, {
                             scale: K = 1,
                             rotation: J = 0
                         }) {
                             const {
                                 width: ht,
                                 height: Et
                             } = ft.attributes.style, Ct = [0, 0, parseInt(ht), parseInt(Et)];
-                            return new x({
+                            return new T({
                                 viewBox: Ct,
                                 scale: K,
                                 rotation: J
                             });
                         }
 
                         function m(ft) {
@@ -4320,28 +4314,28 @@
                                 d: Et,
                                 e: Ct,
                                 f: Ut
                             } = ft.getTransform();
                             return [K, J, ht, Et, Ct, Ut];
                         }
 
-                        function E(ft) {
+                        function C(ft) {
                             const {
                                 a: K,
                                 b: J,
                                 c: ht,
                                 d: Et,
                                 e: Ct,
                                 f: Ut
                             } = ft.getTransform().invertSelf();
                             return [K, J, ht, Et, Ct, Ut];
                         }
 
                         function V(ft, K, J = !1, ht = !0) {
-                            if (K instanceof x) {
+                            if (K instanceof T) {
                                 const {
                                     pageWidth: Et,
                                     pageHeight: Ct
                                 } = K.rawDims, {
                                     style: Ut
                                 } = ft, Gt = P.FeatureTest.isCSSRoundSupported, Ht = `var(--scale-factor) * ${Et}px`, Xt = `var(--scale-factor) * ${Ct}px`, Vt = Gt ? `round(${Ht}, 1px)` : `calc(${Ht})`, Wt = Gt ? `round(${Xt}, 1px)` : `calc(${Xt})`;
                                 !J || K.rotation % 180 === 0 ? (Ut.width = Vt, Ut.height = Wt) : (Ut.width = Wt, Ut.height = Vt);
@@ -4351,178 +4345,178 @@
                     },
                     /* 7 */
                     /***/
                     (dt, d, et) => {
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.BaseStandardFontDataFactory = d.BaseSVGFactory = d.BaseFilterFactory = d.BaseCanvasFactory = d.BaseCMapReaderFactory = void 0;
-                        var l = et(1);
+                        var c = et(1);
                         class P {
                             constructor() {
-                                this.constructor === P && (0, l.unreachable)("Cannot initialize BaseFilterFactory.");
+                                this.constructor === P && (0, c.unreachable)("Cannot initialize BaseFilterFactory.");
                             }
                             addFilter(g) {
                                 return "none";
                             }
-                            addHCMFilter(g, O) {
+                            addHCMFilter(g, L) {
                                 return "none";
                             }
-                            addHighlightHCMFilter(g, O, I, x) {
+                            addHighlightHCMFilter(g, L, O, T) {
                                 return "none";
                             }
                             destroy(g = !1) {}
                         }
                         d.BaseFilterFactory = P;
                         class rt {
                             constructor() {
-                                this.constructor === rt && (0, l.unreachable)("Cannot initialize BaseCanvasFactory.");
+                                this.constructor === rt && (0, c.unreachable)("Cannot initialize BaseCanvasFactory.");
                             }
-                            create(g, O) {
-                                if (g <= 0 || O <= 0)
+                            create(g, L) {
+                                if (g <= 0 || L <= 0)
                                     throw new Error("Invalid canvas size");
-                                const I = this._createCanvas(g, O);
+                                const O = this._createCanvas(g, L);
                                 return {
-                                    canvas: I,
-                                    context: I.getContext("2d")
+                                    canvas: O,
+                                    context: O.getContext("2d")
                                 };
                             }
-                            reset(g, O, I) {
+                            reset(g, L, O) {
                                 if (!g.canvas)
                                     throw new Error("Canvas is not specified");
-                                if (O <= 0 || I <= 0)
+                                if (L <= 0 || O <= 0)
                                     throw new Error("Invalid canvas size");
-                                g.canvas.width = O, g.canvas.height = I;
+                                g.canvas.width = L, g.canvas.height = O;
                             }
                             destroy(g) {
                                 if (!g.canvas)
                                     throw new Error("Canvas is not specified");
                                 g.canvas.width = 0, g.canvas.height = 0, g.canvas = null, g.context = null;
                             }
-                            _createCanvas(g, O) {
-                                (0, l.unreachable)("Abstract method `_createCanvas` called.");
+                            _createCanvas(g, L) {
+                                (0, c.unreachable)("Abstract method `_createCanvas` called.");
                             }
                         }
                         d.BaseCanvasFactory = rt;
                         class X {
                             constructor({
                                 baseUrl: g = null,
-                                isCompressed: O = !0
+                                isCompressed: L = !0
                             }) {
-                                this.constructor === X && (0, l.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = g, this.isCompressed = O;
+                                this.constructor === X && (0, c.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = g, this.isCompressed = L;
                             }
                             async fetch({
                                 name: g
                             }) {
                                 if (!this.baseUrl)
                                     throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                                 if (!g)
                                     throw new Error("CMap name must be specified.");
-                                const O = this.baseUrl + g + (this.isCompressed ? ".bcmap" : ""),
-                                    I = this.isCompressed ? l.CMapCompressionType.BINARY : l.CMapCompressionType.NONE;
-                                return this._fetchData(O, I).catch((x) => {
-                                    throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${O}`);
+                                const L = this.baseUrl + g + (this.isCompressed ? ".bcmap" : ""),
+                                    O = this.isCompressed ? c.CMapCompressionType.BINARY : c.CMapCompressionType.NONE;
+                                return this._fetchData(L, O).catch((T) => {
+                                    throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${L}`);
                                 });
                             }
-                            _fetchData(g, O) {
-                                (0, l.unreachable)("Abstract method `_fetchData` called.");
+                            _fetchData(g, L) {
+                                (0, c.unreachable)("Abstract method `_fetchData` called.");
                             }
                         }
                         d.BaseCMapReaderFactory = X;
                         class pt {
                             constructor({
                                 baseUrl: g = null
                             }) {
-                                this.constructor === pt && (0, l.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = g;
+                                this.constructor === pt && (0, c.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = g;
                             }
                             async fetch({
                                 filename: g
                             }) {
                                 if (!this.baseUrl)
                                     throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
                                 if (!g)
                                     throw new Error("Font filename must be specified.");
-                                const O = `${this.baseUrl}${g}`;
-                                return this._fetchData(O).catch((I) => {
-                                    throw new Error(`Unable to load font data at: ${O}`);
+                                const L = `${this.baseUrl}${g}`;
+                                return this._fetchData(L).catch((O) => {
+                                    throw new Error(`Unable to load font data at: ${L}`);
                                 });
                             }
                             _fetchData(g) {
-                                (0, l.unreachable)("Abstract method `_fetchData` called.");
+                                (0, c.unreachable)("Abstract method `_fetchData` called.");
                             }
                         }
                         d.BaseStandardFontDataFactory = pt;
                         class B {
                             constructor() {
-                                this.constructor === B && (0, l.unreachable)("Cannot initialize BaseSVGFactory.");
+                                this.constructor === B && (0, c.unreachable)("Cannot initialize BaseSVGFactory.");
                             }
-                            create(g, O, I = !1) {
-                                if (g <= 0 || O <= 0)
+                            create(g, L, O = !1) {
+                                if (g <= 0 || L <= 0)
                                     throw new Error("Invalid SVG dimensions");
-                                const x = this._createSVG("svg:svg");
-                                return x.setAttribute("version", "1.1"), I || (x.setAttribute("width", `${g}px`), x.setAttribute("height", `${O}px`)), x.setAttribute("preserveAspectRatio", "none"), x.setAttribute("viewBox", `0 0 ${g} ${O}`), x;
+                                const T = this._createSVG("svg:svg");
+                                return T.setAttribute("version", "1.1"), O || (T.setAttribute("width", `${g}px`), T.setAttribute("height", `${L}px`)), T.setAttribute("preserveAspectRatio", "none"), T.setAttribute("viewBox", `0 0 ${g} ${L}`), T;
                             }
                             createElement(g) {
                                 if (typeof g != "string")
                                     throw new Error("Invalid SVG element type");
                                 return this._createSVG(g);
                             }
                             _createSVG(g) {
-                                (0, l.unreachable)("Abstract method `_createSVG` called.");
+                                (0, c.unreachable)("Abstract method `_createSVG` called.");
                             }
                         }
                         d.BaseSVGFactory = B;
                     },
                     /* 8 */
                     /***/
                     (dt, d, et) => {
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.MurmurHash3_64 = void 0;
-                        var l = et(1);
+                        var c = et(1);
                         const P = 3285377520,
                             rt = 4294901760,
                             X = 65535;
                         class pt {
                             constructor(F) {
                                 this.h1 = F ? F & 4294967295 : P, this.h2 = F ? F & 4294967295 : P;
                             }
                             update(F) {
-                                let g, O;
+                                let g, L;
                                 if (typeof F == "string") {
-                                    g = new Uint8Array(F.length * 2), O = 0;
+                                    g = new Uint8Array(F.length * 2), L = 0;
                                     for (let k = 0, p = F.length; k < p; k++) {
                                         const r = F.charCodeAt(k);
-                                        r <= 255 ? g[O++] = r : (g[O++] = r >>> 8, g[O++] = r & 255);
+                                        r <= 255 ? g[L++] = r : (g[L++] = r >>> 8, g[L++] = r & 255);
                                     }
-                                } else if ((0, l.isArrayBuffer)(F))
-                                    g = F.slice(), O = g.byteLength;
+                                } else if ((0, c.isArrayBuffer)(F))
+                                    g = F.slice(), L = g.byteLength;
                                 else
                                     throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
-                                const I = O >> 2,
-                                    x = O - I * 4,
-                                    v = new Uint32Array(g.buffer, 0, I);
+                                const O = L >> 2,
+                                    T = L - O * 4,
+                                    v = new Uint32Array(g.buffer, 0, O);
                                 let A = 0,
                                     u = 0,
-                                    _ = this.h1,
-                                    w = this.h2;
-                                const C = 3432918353,
+                                    b = this.h1,
+                                    E = this.h2;
+                                const w = 3432918353,
                                     y = 461845907,
-                                    a = C & X,
-                                    c = y & X;
-                                for (let k = 0; k < I; k++)
-                                    k & 1 ? (A = v[k], A = A * C & rt | A * a & X, A = A << 15 | A >>> 17, A = A * y & rt | A * c & X, _ ^= A, _ = _ << 13 | _ >>> 19, _ = _ * 5 + 3864292196) : (u = v[k], u = u * C & rt | u * a & X, u = u << 15 | u >>> 17, u = u * y & rt | u * c & X, w ^= u, w = w << 13 | w >>> 19, w = w * 5 + 3864292196);
-                                switch (A = 0, x) {
+                                    a = w & X,
+                                    l = y & X;
+                                for (let k = 0; k < O; k++)
+                                    k & 1 ? (A = v[k], A = A * w & rt | A * a & X, A = A << 15 | A >>> 17, A = A * y & rt | A * l & X, b ^= A, b = b << 13 | b >>> 19, b = b * 5 + 3864292196) : (u = v[k], u = u * w & rt | u * a & X, u = u << 15 | u >>> 17, u = u * y & rt | u * l & X, E ^= u, E = E << 13 | E >>> 19, E = E * 5 + 3864292196);
+                                switch (A = 0, T) {
                                     case 3:
-                                        A ^= g[I * 4 + 2] << 16;
+                                        A ^= g[O * 4 + 2] << 16;
                                     case 2:
-                                        A ^= g[I * 4 + 1] << 8;
+                                        A ^= g[O * 4 + 1] << 8;
                                     case 1:
-                                        A ^= g[I * 4], A = A * C & rt | A * a & X, A = A << 15 | A >>> 17, A = A * y & rt | A * c & X, I & 1 ? _ ^= A : w ^= A;
+                                        A ^= g[O * 4], A = A * w & rt | A * a & X, A = A << 15 | A >>> 17, A = A * y & rt | A * l & X, O & 1 ? b ^= A : E ^= A;
                                 }
-                                this.h1 = _, this.h2 = w;
+                                this.h1 = b, this.h2 = E;
                             }
                             hexdigest() {
                                 let F = this.h1,
                                     g = this.h2;
                                 return F ^= g >>> 1, F = F * 3981806797 & rt | F * 36045 & X, g = g * 4283543511 & rt | ((g << 16 | F >>> 16) * 2950163797 & rt) >>> 16, F ^= g >>> 1, F = F * 444984403 & rt | F * 60499 & X, g = g * 3301882366 & rt | ((g << 16 | F >>> 16) * 3120437893 & rt) >>> 16, F ^= g >>> 1, (F >>> 0).toString(16).padStart(8, "0") + (g >>> 0).toString(16).padStart(8, "0");
                             }
                         }
@@ -4531,21 +4525,21 @@
                     /* 9 */
                     /***/
                     (dt, d, et) => {
                         var X;
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.FontLoader = d.FontFaceObject = void 0;
-                        var l = et(1);
+                        var c = et(1);
                         class P {
                             constructor({
                                 ownerDocument: B = globalThis.document,
                                 styleElement: F = null
                             }) {
-                                L(this, X, /* @__PURE__ */ new Set());
+                                I(this, X, /* @__PURE__ */ new Set());
                                 this._document = B, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
                             }
                             addNativeFontFace(B) {
                                 this.nativeFontFaces.add(B), this._document.fonts.add(B);
                             }
                             removeNativeFontFace(B) {
                                 this.nativeFontFaces.delete(B), this._document.fonts.delete(B);
@@ -4558,29 +4552,29 @@
                             clear() {
                                 for (const B of this.nativeFontFaces)
                                     this._document.fonts.delete(B);
                                 this.nativeFontFaces.clear(), t(this, X).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
                             }
                             async loadSystemFont(B) {
                                 if (!(!B || t(this, X).has(B.loadedName))) {
-                                    if ((0, l.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
+                                    if ((0, c.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
                                         const {
                                             loadedName: F,
                                             src: g,
-                                            style: O
-                                        } = B, I = new FontFace(F, g, O);
-                                        this.addNativeFontFace(I);
+                                            style: L
+                                        } = B, O = new FontFace(F, g, L);
+                                        this.addNativeFontFace(O);
                                         try {
-                                            await I.load(), t(this, X).add(F);
+                                            await O.load(), t(this, X).add(F);
                                         } catch {
-                                            (0, l.warn)(`Cannot load system font: ${B.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(I);
+                                            (0, c.warn)(`Cannot load system font: ${B.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(O);
                                         }
                                         return;
                                     }
-                                    (0, l.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
+                                    (0, c.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
                                 }
                             }
                             async bind(B) {
                                 if (B.attached || B.missingFile && !B.systemFontInfo)
                                     return;
                                 if (B.attached = !0, B.systemFontInfo) {
                                     await this.loadSystemFont(B.systemFontInfo);
@@ -4588,121 +4582,121 @@
                                 }
                                 if (this.isFontLoadingAPISupported) {
                                     const g = B.createNativeFontFace();
                                     if (g) {
                                         this.addNativeFontFace(g);
                                         try {
                                             await g.loaded;
-                                        } catch (O) {
-                                            throw (0, l.warn)(`Failed to load font '${g.family}': '${O}'.`), B.disableFontFace = !0, O;
+                                        } catch (L) {
+                                            throw (0, c.warn)(`Failed to load font '${g.family}': '${L}'.`), B.disableFontFace = !0, L;
                                         }
                                     }
                                     return;
                                 }
                                 const F = B.createFontFaceRule();
                                 if (F) {
                                     if (this.insertRule(F), this.isSyncFontLoadingSupported)
                                         return;
                                     await new Promise((g) => {
-                                        const O = this._queueLoadingCallback(g);
-                                        this._prepareFontLoadEvent(B, O);
+                                        const L = this._queueLoadingCallback(g);
+                                        this._prepareFontLoadEvent(B, L);
                                     });
                                 }
                             }
                             get isFontLoadingAPISupported() {
                                 var F;
                                 const B = !!((F = this._document) != null && F.fonts);
-                                return (0, l.shadow)(this, "isFontLoadingAPISupported", B);
+                                return (0, c.shadow)(this, "isFontLoadingAPISupported", B);
                             }
                             get isSyncFontLoadingSupported() {
                                 let B = !1;
-                                return (l.isNodeJS || typeof navigator < "u" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (B = !0), (0, l.shadow)(this, "isSyncFontLoadingSupported", B);
+                                return (c.isNodeJS || typeof navigator < "u" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (B = !0), (0, c.shadow)(this, "isSyncFontLoadingSupported", B);
                             }
                             _queueLoadingCallback(B) {
                                 function F() {
-                                    for ((0, l.assert)(!O.done, "completeRequest() cannot be called twice."), O.done = !0; g.length > 0 && g[0].done;) {
-                                        const I = g.shift();
-                                        setTimeout(I.callback, 0);
+                                    for ((0, c.assert)(!L.done, "completeRequest() cannot be called twice."), L.done = !0; g.length > 0 && g[0].done;) {
+                                        const O = g.shift();
+                                        setTimeout(O.callback, 0);
                                     }
                                 }
                                 const {
                                     loadingRequests: g
-                                } = this, O = {
+                                } = this, L = {
                                     done: !1,
                                     complete: F,
                                     callback: B
                                 };
-                                return g.push(O), O;
+                                return g.push(L), L;
                             }
                             get _loadTestFont() {
                                 const B = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
-                                return (0, l.shadow)(this, "_loadTestFont", B);
+                                return (0, c.shadow)(this, "_loadTestFont", B);
                             }
                             _prepareFontLoadEvent(B, F) {
                                 function g(m, U) {
                                     return m.charCodeAt(U) << 24 | m.charCodeAt(U + 1) << 16 | m.charCodeAt(U + 2) << 8 | m.charCodeAt(U + 3) & 255;
                                 }
 
-                                function O(m, U, z, E) {
+                                function L(m, U, z, C) {
                                     const V = m.substring(0, U),
                                         st = m.substring(U + z);
-                                    return V + E + st;
+                                    return V + C + st;
                                 }
-                                let I, x;
+                                let O, T;
                                 const v = this._document.createElement("canvas");
                                 v.width = 1, v.height = 1;
                                 const A = v.getContext("2d");
                                 let u = 0;
 
-                                function _(m, U) {
+                                function b(m, U) {
                                     if (++u > 30) {
-                                        (0, l.warn)("Load test font never loaded."), U();
+                                        (0, c.warn)("Load test font never loaded."), U();
                                         return;
                                     }
                                     if (A.font = "30px " + m, A.fillText(".", 0, 20), A.getImageData(0, 0, 1, 1).data[3] > 0) {
                                         U();
                                         return;
                                     }
-                                    setTimeout(_.bind(null, m, U));
+                                    setTimeout(b.bind(null, m, U));
                                 }
-                                const w = `lt${Date.now()}${this.loadTestFontId++}`;
-                                let C = this._loadTestFont;
-                                C = O(C, 976, w.length, w);
+                                const E = `lt${Date.now()}${this.loadTestFontId++}`;
+                                let w = this._loadTestFont;
+                                w = L(w, 976, E.length, E);
                                 const a = 16,
-                                    c = 1482184792;
-                                let k = g(C, a);
-                                for (I = 0, x = w.length - 3; I < x; I += 4)
-                                    k = k - c + g(w, I) | 0;
-                                I < w.length && (k = k - c + g(w + "XXX", I) | 0), C = O(C, a, 4, (0, l.string32)(k));
-                                const p = `url(data:font/opentype;base64,${btoa(C)});`,
-                                    r = `@font-face {font-family:"${w}";src:${p}}`;
+                                    l = 1482184792;
+                                let k = g(w, a);
+                                for (O = 0, T = E.length - 3; O < T; O += 4)
+                                    k = k - l + g(E, O) | 0;
+                                O < E.length && (k = k - l + g(E + "XXX", O) | 0), w = L(w, a, 4, (0, c.string32)(k));
+                                const p = `url(data:font/opentype;base64,${btoa(w)});`,
+                                    r = `@font-face {font-family:"${E}";src:${p}}`;
                                 this.insertRule(r);
-                                const T = this._document.createElement("div");
-                                T.style.visibility = "hidden", T.style.width = T.style.height = "10px", T.style.position = "absolute", T.style.top = T.style.left = "0px";
-                                for (const m of [B.loadedName, w]) {
+                                const x = this._document.createElement("div");
+                                x.style.visibility = "hidden", x.style.width = x.style.height = "10px", x.style.position = "absolute", x.style.top = x.style.left = "0px";
+                                for (const m of [B.loadedName, E]) {
                                     const U = this._document.createElement("span");
-                                    U.textContent = "Hi", U.style.fontFamily = m, T.append(U);
+                                    U.textContent = "Hi", U.style.fontFamily = m, x.append(U);
                                 }
-                                this._document.body.append(T), _(w, () => {
-                                    T.remove(), F.complete();
+                                this._document.body.append(x), b(E, () => {
+                                    x.remove(), F.complete();
                                 });
                             }
                         }
                         X = new WeakMap(), d.FontLoader = P;
                         class rt {
                             constructor(B, {
                                 isEvalSupported: F = !0,
                                 disableFontFace: g = !1,
-                                ignoreErrors: O = !1,
-                                inspectFont: I = null
+                                ignoreErrors: L = !1,
+                                inspectFont: O = null
                             }) {
                                 this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
-                                for (const x in B)
-                                    this[x] = B[x];
-                                this.isEvalSupported = F !== !1, this.disableFontFace = g === !0, this.ignoreErrors = O === !0, this._inspectFont = I;
+                                for (const T in B)
+                                    this[T] = B[T];
+                                this.isEvalSupported = F !== !1, this.disableFontFace = g === !0, this.ignoreErrors = L === !0, this._inspectFont = O;
                             }
                             createNativeFontFace() {
                                 var F;
                                 if (!this.data || this.disableFontFace)
                                     return null;
                                 let B;
                                 if (!this.cssFontInfo)
@@ -4712,147 +4706,147 @@
                                         weight: this.cssFontInfo.fontWeight
                                     };
                                     this.cssFontInfo.italicAngle && (g.style = `oblique ${this.cssFontInfo.italicAngle}deg`), B = new FontFace(this.cssFontInfo.fontFamily, this.data, g);
                                 }
                                 return (F = this._inspectFont) == null || F.call(this, this), B;
                             }
                             createFontFaceRule() {
-                                var O;
+                                var L;
                                 if (!this.data || this.disableFontFace)
                                     return null;
-                                const B = (0, l.bytesToString)(this.data),
+                                const B = (0, c.bytesToString)(this.data),
                                     F = `url(data:${this.mimetype};base64,${btoa(B)});`;
                                 let g;
                                 if (!this.cssFontInfo)
                                     g = `@font-face {font-family:"${this.loadedName}";src:${F}}`;
                                 else {
-                                    let I = `font-weight: ${this.cssFontInfo.fontWeight};`;
-                                    this.cssFontInfo.italicAngle && (I += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), g = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${I}src:${F}}`;
+                                    let O = `font-weight: ${this.cssFontInfo.fontWeight};`;
+                                    this.cssFontInfo.italicAngle && (O += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), g = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${O}src:${F}}`;
                                 }
-                                return (O = this._inspectFont) == null || O.call(this, this, F), g;
+                                return (L = this._inspectFont) == null || L.call(this, this, F), g;
                             }
                             getPathGenerator(B, F) {
                                 if (this.compiledGlyphs[F] !== void 0)
                                     return this.compiledGlyphs[F];
                                 let g;
                                 try {
                                     g = B.get(this.loadedName + "_path_" + F);
-                                } catch (O) {
+                                } catch (L) {
                                     if (!this.ignoreErrors)
-                                        throw O;
-                                    return (0, l.warn)(`getPathGenerator - ignoring character: "${O}".`), this.compiledGlyphs[F] = function(I, x) {};
+                                        throw L;
+                                    return (0, c.warn)(`getPathGenerator - ignoring character: "${L}".`), this.compiledGlyphs[F] = function(O, T) {};
                                 }
-                                if (this.isEvalSupported && l.FeatureTest.isEvalSupported) {
-                                    const O = [];
-                                    for (const I of g) {
-                                        const x = I.args !== void 0 ? I.args.join(",") : "";
-                                        O.push("c.", I.cmd, "(", x, `);
+                                if (this.isEvalSupported && c.FeatureTest.isEvalSupported) {
+                                    const L = [];
+                                    for (const O of g) {
+                                        const T = O.args !== void 0 ? O.args.join(",") : "";
+                                        L.push("c.", O.cmd, "(", T, `);
 `);
                                     }
-                                    return this.compiledGlyphs[F] = new Function("c", "size", O.join(""));
+                                    return this.compiledGlyphs[F] = new Function("c", "size", L.join(""));
                                 }
-                                return this.compiledGlyphs[F] = function(O, I) {
-                                    for (const x of g)
-                                        x.cmd === "scale" && (x.args = [I, -I]), O[x.cmd].apply(O, x.args);
+                                return this.compiledGlyphs[F] = function(L, O) {
+                                    for (const T of g)
+                                        T.cmd === "scale" && (T.args = [O, -O]), L[T.cmd].apply(L, T.args);
                                 };
                             }
                         }
                         d.FontFaceObject = rt;
                     },
                     /* 10 */
                     /***/
                     (dt, d, et) => {
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.NodeStandardFontDataFactory = d.NodeFilterFactory = d.NodeCanvasFactory = d.NodeCMapReaderFactory = void 0;
-                        var l = et(7);
+                        var c = et(7);
                         et(1);
                         const P = function(F) {
-                            return new Promise((g, O) => {
-                                require$$5.readFile(F, (x, v) => {
-                                    if (x || !v) {
-                                        O(new Error(x));
+                            return new Promise((g, L) => {
+                                require$$5.readFile(F, (T, v) => {
+                                    if (T || !v) {
+                                        L(new Error(T));
                                         return;
                                     }
                                     g(new Uint8Array(v));
                                 });
                             });
                         };
-                        class rt extends l.BaseFilterFactory {}
+                        class rt extends c.BaseFilterFactory {}
                         d.NodeFilterFactory = rt;
-                        class X extends l.BaseCanvasFactory {
-                            _createCanvas(g, O) {
-                                return require$$5.createCanvas(g, O);
+                        class X extends c.BaseCanvasFactory {
+                            _createCanvas(g, L) {
+                                return require$$5.createCanvas(g, L);
                             }
                         }
                         d.NodeCanvasFactory = X;
-                        class pt extends l.BaseCMapReaderFactory {
-                            _fetchData(g, O) {
-                                return P(g).then((I) => ({
-                                    cMapData: I,
-                                    compressionType: O
+                        class pt extends c.BaseCMapReaderFactory {
+                            _fetchData(g, L) {
+                                return P(g).then((O) => ({
+                                    cMapData: O,
+                                    compressionType: L
                                 }));
                             }
                         }
                         d.NodeCMapReaderFactory = pt;
-                        class B extends l.BaseStandardFontDataFactory {
+                        class B extends c.BaseStandardFontDataFactory {
                             _fetchData(g) {
                                 return P(g);
                             }
                         }
                         d.NodeStandardFontDataFactory = B;
                     },
                     /* 11 */
                     /***/
                     (dt, d, et) => {
                         var H, Qe, gt, Ze;
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.CanvasGraphics = void 0;
-                        var l = et(1),
+                        var c = et(1),
                             P = et(6),
                             rt = et(12),
                             X = et(13);
                         const pt = 16,
                             B = 100,
                             F = 4096,
                             g = 15,
-                            O = 10,
-                            I = 1e3,
-                            x = 16;
+                            L = 10,
+                            O = 1e3,
+                            T = 16;
 
                         function v(S, i) {
                             if (S._removeMirroring)
                                 throw new Error("Context is already forwarding operations.");
                             S.__originalSave = S.save, S.__originalRestore = S.restore, S.__originalRotate = S.rotate, S.__originalScale = S.scale, S.__originalTranslate = S.translate, S.__originalTransform = S.transform, S.__originalSetTransform = S.setTransform, S.__originalResetTransform = S.resetTransform, S.__originalClip = S.clip, S.__originalMoveTo = S.moveTo, S.__originalLineTo = S.lineTo, S.__originalBezierCurveTo = S.bezierCurveTo, S.__originalRect = S.rect, S.__originalClosePath = S.closePath, S.__originalBeginPath = S.beginPath, S._removeMirroring = () => {
                                 S.save = S.__originalSave, S.restore = S.__originalRestore, S.rotate = S.__originalRotate, S.scale = S.__originalScale, S.translate = S.__originalTranslate, S.transform = S.__originalTransform, S.setTransform = S.__originalSetTransform, S.resetTransform = S.__originalResetTransform, S.clip = S.__originalClip, S.moveTo = S.__originalMoveTo, S.lineTo = S.__originalLineTo, S.bezierCurveTo = S.__originalBezierCurveTo, S.rect = S.__originalRect, S.closePath = S.__originalClosePath, S.beginPath = S.__originalBeginPath, delete S._removeMirroring;
                             }, S.save = function() {
                                 i.save(), this.__originalSave();
                             }, S.restore = function() {
                                 i.restore(), this.__originalRestore();
                             }, S.translate = function(s, o) {
                                 i.translate(s, o), this.__originalTranslate(s, o);
                             }, S.scale = function(s, o) {
                                 i.scale(s, o), this.__originalScale(s, o);
-                            }, S.transform = function(s, o, h, b, M, N) {
-                                i.transform(s, o, h, b, M, N), this.__originalTransform(s, o, h, b, M, N);
-                            }, S.setTransform = function(s, o, h, b, M, N) {
-                                i.setTransform(s, o, h, b, M, N), this.__originalSetTransform(s, o, h, b, M, N);
+                            }, S.transform = function(s, o, h, _, M, N) {
+                                i.transform(s, o, h, _, M, N), this.__originalTransform(s, o, h, _, M, N);
+                            }, S.setTransform = function(s, o, h, _, M, N) {
+                                i.setTransform(s, o, h, _, M, N), this.__originalSetTransform(s, o, h, _, M, N);
                             }, S.resetTransform = function() {
                                 i.resetTransform(), this.__originalResetTransform();
                             }, S.rotate = function(s) {
                                 i.rotate(s), this.__originalRotate(s);
                             }, S.clip = function(s) {
                                 i.clip(s), this.__originalClip(s);
                             }, S.moveTo = function(n, s) {
                                 i.moveTo(n, s), this.__originalMoveTo(n, s);
                             }, S.lineTo = function(n, s) {
                                 i.lineTo(n, s), this.__originalLineTo(n, s);
-                            }, S.bezierCurveTo = function(n, s, o, h, b, M) {
-                                i.bezierCurveTo(n, s, o, h, b, M), this.__originalBezierCurveTo(n, s, o, h, b, M);
+                            }, S.bezierCurveTo = function(n, s, o, h, _, M) {
+                                i.bezierCurveTo(n, s, o, h, _, M), this.__originalBezierCurveTo(n, s, o, h, _, M);
                             }, S.rect = function(n, s, o, h) {
                                 i.rect(n, s, o, h), this.__originalRect(n, s, o, h);
                             }, S.closePath = function() {
                                 i.closePath(), this.__originalClosePath();
                             }, S.beginPath = function() {
                                 i.beginPath(), this.__originalBeginPath();
                             };
@@ -4872,378 +4866,378 @@
                                 for (const i in this.cache) {
                                     const n = this.cache[i];
                                     this.canvasFactory.destroy(n), delete this.cache[i];
                                 }
                             }
                         }
 
-                        function u(S, i, n, s, o, h, b, M, N, tt) {
+                        function u(S, i, n, s, o, h, _, M, N, tt) {
                             const [Q, nt, ct, yt, ut, Ft] = (0, P.getCurrentTransform)(S);
                             if (nt === 0 && ct === 0) {
-                                const Dt = b * Q + ut,
+                                const Dt = _ * Q + ut,
                                     ft = Math.round(Dt),
                                     K = M * yt + Ft,
                                     J = Math.round(K),
-                                    ht = (b + N) * Q + ut,
+                                    ht = (_ + N) * Q + ut,
                                     Et = Math.abs(Math.round(ht) - ft) || 1,
                                     Ct = (M + tt) * yt + Ft,
                                     Ut = Math.abs(Math.round(Ct) - J) || 1;
                                 return S.setTransform(Math.sign(Q), 0, 0, Math.sign(yt), ft, J), S.drawImage(i, n, s, o, h, 0, 0, Et, Ut), S.setTransform(Q, nt, ct, yt, ut, Ft), [Et, Ut];
                             }
                             if (Q === 0 && yt === 0) {
                                 const Dt = M * ct + ut,
                                     ft = Math.round(Dt),
-                                    K = b * nt + Ft,
+                                    K = _ * nt + Ft,
                                     J = Math.round(K),
                                     ht = (M + tt) * ct + ut,
                                     Et = Math.abs(Math.round(ht) - ft) || 1,
-                                    Ct = (b + N) * nt + Ft,
+                                    Ct = (_ + N) * nt + Ft,
                                     Ut = Math.abs(Math.round(Ct) - J) || 1;
                                 return S.setTransform(0, Math.sign(nt), Math.sign(ct), 0, ft, J), S.drawImage(i, n, s, o, h, 0, 0, Ut, Et), S.setTransform(Q, nt, ct, yt, ut, Ft), [Ut, Et];
                             }
-                            S.drawImage(i, n, s, o, h, b, M, N, tt);
+                            S.drawImage(i, n, s, o, h, _, M, N, tt);
                             const Bt = Math.hypot(Q, nt),
                                 St = Math.hypot(ct, yt);
                             return [Bt * N, St * tt];
                         }
 
-                        function _(S) {
+                        function b(S) {
                             const {
                                 width: i,
                                 height: n
                             } = S;
-                            if (i > I || n > I)
+                            if (i > O || n > O)
                                 return null;
                             const s = 1e3,
                                 o = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]),
                                 h = i + 1;
-                            let b = new Uint8Array(h * (n + 1)),
+                            let _ = new Uint8Array(h * (n + 1)),
                                 M, N, tt;
                             const Q = i + 7 & -8;
                             let nt = new Uint8Array(Q * n),
                                 ct = 0;
                             for (const St of S.data) {
                                 let Dt = 128;
                                 for (; Dt > 0;)
                                     nt[ct++] = St & Dt ? 0 : 255, Dt >>= 1;
                             }
                             let yt = 0;
-                            for (ct = 0, nt[ct] !== 0 && (b[0] = 1, ++yt), N = 1; N < i; N++)
-                                nt[ct] !== nt[ct + 1] && (b[N] = nt[ct] ? 2 : 1, ++yt), ct++;
-                            for (nt[ct] !== 0 && (b[N] = 2, ++yt), M = 1; M < n; M++) {
-                                ct = M * Q, tt = M * h, nt[ct - Q] !== nt[ct] && (b[tt] = nt[ct] ? 1 : 8, ++yt);
+                            for (ct = 0, nt[ct] !== 0 && (_[0] = 1, ++yt), N = 1; N < i; N++)
+                                nt[ct] !== nt[ct + 1] && (_[N] = nt[ct] ? 2 : 1, ++yt), ct++;
+                            for (nt[ct] !== 0 && (_[N] = 2, ++yt), M = 1; M < n; M++) {
+                                ct = M * Q, tt = M * h, nt[ct - Q] !== nt[ct] && (_[tt] = nt[ct] ? 1 : 8, ++yt);
                                 let St = (nt[ct] ? 4 : 0) + (nt[ct - Q] ? 8 : 0);
                                 for (N = 1; N < i; N++)
-                                    St = (St >> 2) + (nt[ct + 1] ? 4 : 0) + (nt[ct - Q + 1] ? 8 : 0), o[St] && (b[tt + N] = o[St], ++yt), ct++;
-                                if (nt[ct - Q] !== nt[ct] && (b[tt + N] = nt[ct] ? 2 : 4, ++yt), yt > s)
+                                    St = (St >> 2) + (nt[ct + 1] ? 4 : 0) + (nt[ct - Q + 1] ? 8 : 0), o[St] && (_[tt + N] = o[St], ++yt), ct++;
+                                if (nt[ct - Q] !== nt[ct] && (_[tt + N] = nt[ct] ? 2 : 4, ++yt), yt > s)
                                     return null;
                             }
-                            for (ct = Q * (n - 1), tt = M * h, nt[ct] !== 0 && (b[tt] = 8, ++yt), N = 1; N < i; N++)
-                                nt[ct] !== nt[ct + 1] && (b[tt + N] = nt[ct] ? 4 : 8, ++yt), ct++;
-                            if (nt[ct] !== 0 && (b[tt + N] = 4, ++yt), yt > s)
+                            for (ct = Q * (n - 1), tt = M * h, nt[ct] !== 0 && (_[tt] = 8, ++yt), N = 1; N < i; N++)
+                                nt[ct] !== nt[ct + 1] && (_[tt + N] = nt[ct] ? 4 : 8, ++yt), ct++;
+                            if (nt[ct] !== 0 && (_[tt + N] = 4, ++yt), yt > s)
                                 return null;
                             const ut = new Int32Array([0, h, -1, 0, -h, 0, 0, 0, 1]),
                                 Ft = new Path2D();
                             for (M = 0; yt && M <= n; M++) {
                                 let St = M * h;
                                 const Dt = St + i;
-                                for (; St < Dt && !b[St];)
+                                for (; St < Dt && !_[St];)
                                     St++;
                                 if (St === Dt)
                                     continue;
                                 Ft.moveTo(St % h, M);
                                 const ft = St;
-                                let K = b[St];
+                                let K = _[St];
                                 do {
                                     const J = ut[K];
                                     do
                                         St += J;
-                                    while (!b[St]);
-                                    const ht = b[St];
-                                    ht !== 5 && ht !== 10 ? (K = ht, b[St] = 0) : (K = ht & 51 * K >> 4, b[St] &= K >> 2 | K << 2), Ft.lineTo(St % h, St / h | 0), b[St] || --yt;
+                                    while (!_[St]);
+                                    const ht = _[St];
+                                    ht !== 5 && ht !== 10 ? (K = ht, _[St] = 0) : (K = ht & 51 * K >> 4, _[St] &= K >> 2 | K << 2), Ft.lineTo(St % h, St / h | 0), _[St] || --yt;
                                 } while (ft !== St);
                                 --M;
                             }
-                            return nt = null, b = null,
+                            return nt = null, _ = null,
                                 function(St) {
                                     St.save(), St.scale(1 / i, -1 / n), St.translate(0, -n), St.fill(Ft), St.beginPath(), St.restore();
                                 };
                         }
-                        class w {
+                        class E {
                             constructor(i, n) {
-                                this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = l.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = l.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = l.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, i, n]);
+                                this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = c.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = c.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = c.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, i, n]);
                             }
                             clone() {
                                 const i = Object.create(this);
                                 return i.clipBox = this.clipBox.slice(), i;
                             }
                             setCurrentPoint(i, n) {
                                 this.x = i, this.y = n;
                             }
                             updatePathMinMax(i, n, s) {
-                                [n, s] = l.Util.applyTransform([n, s], i), this.minX = Math.min(this.minX, n), this.minY = Math.min(this.minY, s), this.maxX = Math.max(this.maxX, n), this.maxY = Math.max(this.maxY, s);
+                                [n, s] = c.Util.applyTransform([n, s], i), this.minX = Math.min(this.minX, n), this.minY = Math.min(this.minY, s), this.maxX = Math.max(this.maxX, n), this.maxY = Math.max(this.maxY, s);
                             }
                             updateRectMinMax(i, n) {
-                                const s = l.Util.applyTransform(n, i),
-                                    o = l.Util.applyTransform(n.slice(2), i);
+                                const s = c.Util.applyTransform(n, i),
+                                    o = c.Util.applyTransform(n.slice(2), i);
                                 this.minX = Math.min(this.minX, s[0], o[0]), this.minY = Math.min(this.minY, s[1], o[1]), this.maxX = Math.max(this.maxX, s[0], o[0]), this.maxY = Math.max(this.maxY, s[1], o[1]);
                             }
                             updateScalingPathMinMax(i, n) {
-                                l.Util.scaleMinMax(i, n), this.minX = Math.min(this.minX, n[0]), this.maxX = Math.max(this.maxX, n[1]), this.minY = Math.min(this.minY, n[2]), this.maxY = Math.max(this.maxY, n[3]);
+                                c.Util.scaleMinMax(i, n), this.minX = Math.min(this.minX, n[0]), this.maxX = Math.max(this.maxX, n[1]), this.minY = Math.min(this.minY, n[2]), this.maxY = Math.max(this.maxY, n[3]);
                             }
-                            updateCurvePathMinMax(i, n, s, o, h, b, M, N, tt, Q) {
-                                const nt = l.Util.bezierBoundingBox(n, s, o, h, b, M, N, tt);
+                            updateCurvePathMinMax(i, n, s, o, h, _, M, N, tt, Q) {
+                                const nt = c.Util.bezierBoundingBox(n, s, o, h, _, M, N, tt);
                                 if (Q) {
                                     Q[0] = Math.min(Q[0], nt[0], nt[2]), Q[1] = Math.max(Q[1], nt[0], nt[2]), Q[2] = Math.min(Q[2], nt[1], nt[3]), Q[3] = Math.max(Q[3], nt[1], nt[3]);
                                     return;
                                 }
                                 this.updateRectMinMax(i, nt);
                             }
                             getPathBoundingBox(i = rt.PathType.FILL, n = null) {
                                 const s = [this.minX, this.minY, this.maxX, this.maxY];
                                 if (i === rt.PathType.STROKE) {
-                                    n || (0, l.unreachable)("Stroke bounding box must include transform.");
-                                    const o = l.Util.singularValueDecompose2dScale(n),
+                                    n || (0, c.unreachable)("Stroke bounding box must include transform.");
+                                    const o = c.Util.singularValueDecompose2dScale(n),
                                         h = o[0] * this.lineWidth / 2,
-                                        b = o[1] * this.lineWidth / 2;
-                                    s[0] -= h, s[1] -= b, s[2] += h, s[3] += b;
+                                        _ = o[1] * this.lineWidth / 2;
+                                    s[0] -= h, s[1] -= _, s[2] += h, s[3] += _;
                                 }
                                 return s;
                             }
                             updateClipFromPath() {
-                                const i = l.Util.intersect(this.clipBox, this.getPathBoundingBox());
+                                const i = c.Util.intersect(this.clipBox, this.getPathBoundingBox());
                                 this.startNewPathAndClipBox(i || [0, 0, 0, 0]);
                             }
                             isEmptyClip() {
                                 return this.minX === 1 / 0;
                             }
                             startNewPathAndClipBox(i) {
                                 this.clipBox = i, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
                             }
                             getClippedPathBoundingBox(i = rt.PathType.FILL, n = null) {
-                                return l.Util.intersect(this.clipBox, this.getPathBoundingBox(i, n));
+                                return c.Util.intersect(this.clipBox, this.getPathBoundingBox(i, n));
                             }
                         }
 
-                        function C(S, i) {
+                        function w(S, i) {
                             if (typeof ImageData < "u" && i instanceof ImageData) {
                                 S.putImageData(i, 0, 0);
                                 return;
                             }
                             const n = i.height,
                                 s = i.width,
-                                o = n % x,
-                                h = (n - o) / x,
-                                b = o === 0 ? h : h + 1,
-                                M = S.createImageData(s, x);
+                                o = n % T,
+                                h = (n - o) / T,
+                                _ = o === 0 ? h : h + 1,
+                                M = S.createImageData(s, T);
                             let N = 0,
                                 tt;
                             const Q = i.data,
                                 nt = M.data;
                             let ct, yt, ut, Ft;
-                            if (i.kind === l.ImageKind.GRAYSCALE_1BPP) {
+                            if (i.kind === c.ImageKind.GRAYSCALE_1BPP) {
                                 const Bt = Q.byteLength,
                                     St = new Uint32Array(nt.buffer, 0, nt.byteLength >> 2),
                                     Dt = St.length,
                                     ft = s + 7 >> 3,
                                     K = 4294967295,
-                                    J = l.FeatureTest.isLittleEndian ? 4278190080 : 255;
-                                for (ct = 0; ct < b; ct++) {
-                                    for (ut = ct < h ? x : o, tt = 0, yt = 0; yt < ut; yt++) {
+                                    J = c.FeatureTest.isLittleEndian ? 4278190080 : 255;
+                                for (ct = 0; ct < _; ct++) {
+                                    for (ut = ct < h ? T : o, tt = 0, yt = 0; yt < ut; yt++) {
                                         const ht = Bt - N;
                                         let Et = 0;
                                         const Ct = ht > ft ? s : ht * 8 - 7,
                                             Ut = Ct & -8;
                                         let Gt = 0,
                                             Ht = 0;
                                         for (; Et < Ut; Et += 8)
                                             Ht = Q[N++], St[tt++] = Ht & 128 ? K : J, St[tt++] = Ht & 64 ? K : J, St[tt++] = Ht & 32 ? K : J, St[tt++] = Ht & 16 ? K : J, St[tt++] = Ht & 8 ? K : J, St[tt++] = Ht & 4 ? K : J, St[tt++] = Ht & 2 ? K : J, St[tt++] = Ht & 1 ? K : J;
                                         for (; Et < Ct; Et++)
                                             Gt === 0 && (Ht = Q[N++], Gt = 128), St[tt++] = Ht & Gt ? K : J, Gt >>= 1;
                                     }
                                     for (; tt < Dt;)
                                         St[tt++] = 0;
-                                    S.putImageData(M, 0, ct * x);
+                                    S.putImageData(M, 0, ct * T);
                                 }
-                            } else if (i.kind === l.ImageKind.RGBA_32BPP) {
-                                for (yt = 0, Ft = s * x * 4, ct = 0; ct < h; ct++)
-                                    nt.set(Q.subarray(N, N + Ft)), N += Ft, S.putImageData(M, 0, yt), yt += x;
-                                ct < b && (Ft = s * o * 4, nt.set(Q.subarray(N, N + Ft)), S.putImageData(M, 0, yt));
-                            } else if (i.kind === l.ImageKind.RGB_24BPP)
-                                for (ut = x, Ft = s * ut, ct = 0; ct < b; ct++) {
+                            } else if (i.kind === c.ImageKind.RGBA_32BPP) {
+                                for (yt = 0, Ft = s * T * 4, ct = 0; ct < h; ct++)
+                                    nt.set(Q.subarray(N, N + Ft)), N += Ft, S.putImageData(M, 0, yt), yt += T;
+                                ct < _ && (Ft = s * o * 4, nt.set(Q.subarray(N, N + Ft)), S.putImageData(M, 0, yt));
+                            } else if (i.kind === c.ImageKind.RGB_24BPP)
+                                for (ut = T, Ft = s * ut, ct = 0; ct < _; ct++) {
                                     for (ct >= h && (ut = o, Ft = s * ut), tt = 0, yt = Ft; yt--;)
                                         nt[tt++] = Q[N++], nt[tt++] = Q[N++], nt[tt++] = Q[N++], nt[tt++] = 255;
-                                    S.putImageData(M, 0, ct * x);
+                                    S.putImageData(M, 0, ct * T);
                                 }
                             else
                                 throw new Error(`bad image kind: ${i.kind}`);
                         }
 
                         function y(S, i) {
                             if (i.bitmap) {
                                 S.drawImage(i.bitmap, 0, 0);
                                 return;
                             }
                             const n = i.height,
                                 s = i.width,
-                                o = n % x,
-                                h = (n - o) / x,
-                                b = o === 0 ? h : h + 1,
-                                M = S.createImageData(s, x);
+                                o = n % T,
+                                h = (n - o) / T,
+                                _ = o === 0 ? h : h + 1,
+                                M = S.createImageData(s, T);
                             let N = 0;
                             const tt = i.data,
                                 Q = M.data;
-                            for (let nt = 0; nt < b; nt++) {
-                                const ct = nt < h ? x : o;
+                            for (let nt = 0; nt < _; nt++) {
+                                const ct = nt < h ? T : o;
                                 ({
                                     srcPos: N
                                 } = (0, X.convertBlackAndWhiteToRGBA)({
                                     src: tt,
                                     srcPos: N,
                                     dest: Q,
                                     width: s,
                                     height: ct,
                                     nonBlackColor: 0
-                                })), S.putImageData(M, 0, nt * x);
+                                })), S.putImageData(M, 0, nt * T);
                             }
                         }
 
                         function a(S, i) {
                             const n = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
                             for (const s of n)
                                 S[s] !== void 0 && (i[s] = S[s]);
                             S.setLineDash !== void 0 && (i.setLineDash(S.getLineDash()), i.lineDashOffset = S.lineDashOffset);
                         }
 
-                        function c(S) {
-                            if (S.strokeStyle = S.fillStyle = "#000000", S.fillRule = "nonzero", S.globalAlpha = 1, S.lineWidth = 1, S.lineCap = "butt", S.lineJoin = "miter", S.miterLimit = 10, S.globalCompositeOperation = "source-over", S.font = "10px sans-serif", S.setLineDash !== void 0 && (S.setLineDash([]), S.lineDashOffset = 0), !l.isNodeJS) {
+                        function l(S) {
+                            if (S.strokeStyle = S.fillStyle = "#000000", S.fillRule = "nonzero", S.globalAlpha = 1, S.lineWidth = 1, S.lineCap = "butt", S.lineJoin = "miter", S.miterLimit = 10, S.globalCompositeOperation = "source-over", S.font = "10px sans-serif", S.setLineDash !== void 0 && (S.setLineDash([]), S.lineDashOffset = 0), !c.isNodeJS) {
                                 const {
                                     filter: i
                                 } = S;
                                 i !== "none" && i !== "" && (S.filter = "none");
                             }
                         }
 
                         function k(S, i, n, s) {
                             const o = S.length;
                             for (let h = 3; h < o; h += 4) {
-                                const b = S[h];
-                                if (b === 0)
+                                const _ = S[h];
+                                if (_ === 0)
                                     S[h - 3] = i, S[h - 2] = n, S[h - 1] = s;
-                                else if (b < 255) {
-                                    const M = 255 - b;
-                                    S[h - 3] = S[h - 3] * b + i * M >> 8, S[h - 2] = S[h - 2] * b + n * M >> 8, S[h - 1] = S[h - 1] * b + s * M >> 8;
+                                else if (_ < 255) {
+                                    const M = 255 - _;
+                                    S[h - 3] = S[h - 3] * _ + i * M >> 8, S[h - 2] = S[h - 2] * _ + n * M >> 8, S[h - 1] = S[h - 1] * _ + s * M >> 8;
                                 }
                             }
                         }
 
                         function p(S, i, n) {
                             const s = S.length,
                                 o = 1 / 255;
                             for (let h = 3; h < s; h += 4) {
-                                const b = n ? n[S[h]] : S[h];
-                                i[h] = i[h] * b * o | 0;
+                                const _ = n ? n[S[h]] : S[h];
+                                i[h] = i[h] * _ * o | 0;
                             }
                         }
 
                         function r(S, i, n) {
                             const s = S.length;
                             for (let o = 3; o < s; o += 4) {
                                 const h = S[o - 3] * 77 + S[o - 2] * 152 + S[o - 1] * 28;
                                 i[o] = n ? i[o] * n[h >> 8] >> 8 : i[o] * h >> 16;
                             }
                         }
 
-                        function T(S, i, n, s, o, h, b, M, N, tt, Q) {
+                        function x(S, i, n, s, o, h, _, M, N, tt, Q) {
                             const nt = !!h,
                                 ct = nt ? h[0] : 0,
                                 yt = nt ? h[1] : 0,
                                 ut = nt ? h[2] : 0,
                                 Ft = o === "Luminosity" ? r : p,
                                 St = Math.min(s, Math.ceil(1048576 / n));
                             for (let Dt = 0; Dt < s; Dt += St) {
                                 const ft = Math.min(St, s - Dt),
                                     K = S.getImageData(M - tt, Dt + (N - Q), n, ft),
                                     J = i.getImageData(M, Dt + N, n, ft);
-                                nt && k(K.data, ct, yt, ut), Ft(K.data, J.data, b), i.putImageData(J, M, Dt + N);
+                                nt && k(K.data, ct, yt, ut), Ft(K.data, J.data, _), i.putImageData(J, M, Dt + N);
                             }
                         }
 
                         function m(S, i, n, s) {
                             const o = s[0],
                                 h = s[1],
-                                b = s[2] - o,
+                                _ = s[2] - o,
                                 M = s[3] - h;
-                            b === 0 || M === 0 || (T(i.context, n, b, M, i.subtype, i.backdrop, i.transferMap, o, h, i.offsetX, i.offsetY), S.save(), S.globalAlpha = 1, S.globalCompositeOperation = "source-over", S.setTransform(1, 0, 0, 1, 0, 0), S.drawImage(n.canvas, 0, 0), S.restore());
+                            _ === 0 || M === 0 || (x(i.context, n, _, M, i.subtype, i.backdrop, i.transferMap, o, h, i.offsetX, i.offsetY), S.save(), S.globalAlpha = 1, S.globalCompositeOperation = "source-over", S.setTransform(1, 0, 0, 1, 0, 0), S.drawImage(n.canvas, 0, 0), S.restore());
                         }
 
                         function U(S, i) {
-                            const n = l.Util.singularValueDecompose2dScale(S);
+                            const n = c.Util.singularValueDecompose2dScale(S);
                             n[0] = Math.fround(n[0]), n[1] = Math.fround(n[1]);
                             const s = Math.fround((globalThis.devicePixelRatio || 1) * P.PixelsPerInch.PDF_TO_CSS_UNITS);
                             return i !== void 0 ? i : n[0] <= s || n[1] <= s;
                         }
                         const z = ["butt", "round", "square"],
-                            E = ["miter", "round", "bevel"],
+                            C = ["miter", "round", "bevel"],
                             V = {},
                             st = {},
-                            xt = class xt {
+                            Pt = class Pt {
                                 constructor(i, n, s, o, h, {
-                                    optionalContentConfig: b,
+                                    optionalContentConfig: _,
                                     markedContentStack: M = null
                                 }, N, tt) {
-                                    L(this, H);
-                                    L(this, gt);
-                                    this.ctx = i, this.current = new w(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = n, this.objs = s, this.canvasFactory = o, this.filterFactory = h, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = M || [], this.optionalContentConfig = b, this.cachedCanvases = new A(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = N, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = tt, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
+                                    I(this, H);
+                                    I(this, gt);
+                                    this.ctx = i, this.current = new E(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = n, this.objs = s, this.canvasFactory = o, this.filterFactory = h, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = M || [], this.optionalContentConfig = _, this.cachedCanvases = new A(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = N, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = tt, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
                                 }
                                 getObject(i, n = null) {
                                     return typeof i == "string" ? i.startsWith("g_") ? this.commonObjs.get(i) : this.objs.get(i) : n;
                                 }
                                 beginDrawing({
                                     transform: i,
                                     viewport: n,
                                     transparency: s = !1,
                                     background: o = null
                                 }) {
                                     const h = this.ctx.canvas.width,
-                                        b = this.ctx.canvas.height,
+                                        _ = this.ctx.canvas.height,
                                         M = this.ctx.fillStyle;
-                                    if (this.ctx.fillStyle = o || "#ffffff", this.ctx.fillRect(0, 0, h, b), this.ctx.fillStyle = M, s) {
-                                        const N = this.cachedCanvases.getCanvas("transparent", h, b);
+                                    if (this.ctx.fillStyle = o || "#ffffff", this.ctx.fillRect(0, 0, h, _), this.ctx.fillStyle = M, s) {
+                                        const N = this.cachedCanvases.getCanvas("transparent", h, _);
                                         this.compositeCtx = this.ctx, this.transparentCanvas = N.canvas, this.ctx = N.context, this.ctx.save(), this.ctx.transform(...(0, P.getCurrentTransform)(this.compositeCtx));
                                     }
-                                    this.ctx.save(), c(this.ctx), i && (this.ctx.transform(...i), this.outputScaleX = i[0], this.outputScaleY = i[0]), this.ctx.transform(...n.transform), this.viewportScale = n.scale, this.baseTransform = (0, P.getCurrentTransform)(this.ctx);
+                                    this.ctx.save(), l(this.ctx), i && (this.ctx.transform(...i), this.outputScaleX = i[0], this.outputScaleY = i[0]), this.ctx.transform(...n.transform), this.viewportScale = n.scale, this.baseTransform = (0, P.getCurrentTransform)(this.ctx);
                                 }
                                 executeOperatorList(i, n, s, o) {
                                     const h = i.argsArray,
-                                        b = i.fnArray;
+                                        _ = i.fnArray;
                                     let M = n || 0;
                                     const N = h.length;
                                     if (N === M)
                                         return M;
-                                    const tt = N - M > O && typeof s == "function",
+                                    const tt = N - M > L && typeof s == "function",
                                         Q = tt ? Date.now() + g : 0;
                                     let nt = 0;
                                     const ct = this.commonObjs,
                                         yt = this.objs;
                                     let ut;
                                     for (;;) {
                                         if (o !== void 0 && M === o.nextBreakPoint)
                                             return o.breakIt(M, s), M;
-                                        if (ut = b[M], ut !== l.OPS.dependency)
+                                        if (ut = _[M], ut !== c.OPS.dependency)
                                             this[ut].apply(this, h[M]);
                                         else
                                             for (const Ft of h[M]) {
                                                 const Bt = Ft.startsWith("g_") ? ct : yt;
                                                 if (!Bt.has(Ft))
                                                     return Bt.get(Ft, s), M;
                                             }
                                         if (M++, M === N)
                                             return M;
-                                        if (tt && ++nt > O) {
+                                        if (tt && ++nt > L) {
                                             if (Date.now() > Q)
                                                 return s(), M;
                                             nt = 0;
                                         }
                                     }
                                 }
                                 endDrawing() {
@@ -5255,83 +5249,83 @@
                                     }
                                     this._cachedBitmapsMap.clear(), W(this, gt, Ze).call(this);
                                 }
                                 _scaleImage(i, n) {
                                     const s = i.width,
                                         o = i.height;
                                     let h = Math.max(Math.hypot(n[0], n[1]), 1),
-                                        b = Math.max(Math.hypot(n[2], n[3]), 1),
+                                        _ = Math.max(Math.hypot(n[2], n[3]), 1),
                                         M = s,
                                         N = o,
                                         tt = "prescale1",
                                         Q, nt;
-                                    for (; h > 2 && M > 1 || b > 2 && N > 1;) {
+                                    for (; h > 2 && M > 1 || _ > 2 && N > 1;) {
                                         let ct = M,
                                             yt = N;
-                                        h > 2 && M > 1 && (ct = M >= 16384 ? Math.floor(M / 2) - 1 || 1 : Math.ceil(M / 2), h /= M / ct), b > 2 && N > 1 && (yt = N >= 16384 ? Math.floor(N / 2) - 1 || 1 : Math.ceil(N) / 2, b /= N / yt), Q = this.cachedCanvases.getCanvas(tt, ct, yt), nt = Q.context, nt.clearRect(0, 0, ct, yt), nt.drawImage(i, 0, 0, M, N, 0, 0, ct, yt), i = Q.canvas, M = ct, N = yt, tt = tt === "prescale1" ? "prescale2" : "prescale1";
+                                        h > 2 && M > 1 && (ct = M >= 16384 ? Math.floor(M / 2) - 1 || 1 : Math.ceil(M / 2), h /= M / ct), _ > 2 && N > 1 && (yt = N >= 16384 ? Math.floor(N / 2) - 1 || 1 : Math.ceil(N) / 2, _ /= N / yt), Q = this.cachedCanvases.getCanvas(tt, ct, yt), nt = Q.context, nt.clearRect(0, 0, ct, yt), nt.drawImage(i, 0, 0, M, N, 0, 0, ct, yt), i = Q.canvas, M = ct, N = yt, tt = tt === "prescale1" ? "prescale2" : "prescale1";
                                     }
                                     return {
                                         img: i,
                                         paintWidth: M,
                                         paintHeight: N
                                     };
                                 }
                                 _createMaskCanvas(i) {
                                     const n = this.ctx,
                                         {
                                             width: s,
                                             height: o
                                         } = i,
                                         h = this.current.fillColor,
-                                        b = this.current.patternFill,
+                                        _ = this.current.patternFill,
                                         M = (0, P.getCurrentTransform)(n);
                                     let N, tt, Q, nt;
                                     if ((i.bitmap || i.data) && i.count > 1) {
                                         const Et = i.bitmap || i.data.buffer;
-                                        tt = JSON.stringify(b ? M : [M.slice(0, 4), h]), N = this._cachedBitmapsMap.get(Et), N || (N = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(Et, N));
+                                        tt = JSON.stringify(_ ? M : [M.slice(0, 4), h]), N = this._cachedBitmapsMap.get(Et), N || (N = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(Et, N));
                                         const Ct = N.get(tt);
-                                        if (Ct && !b) {
+                                        if (Ct && !_) {
                                             const Ut = Math.round(Math.min(M[0], M[2]) + M[4]),
                                                 Gt = Math.round(Math.min(M[1], M[3]) + M[5]);
                                             return {
                                                 canvas: Ct,
                                                 offsetX: Ut,
                                                 offsetY: Gt
                                             };
                                         }
                                         Q = Ct;
                                     }
                                     Q || (nt = this.cachedCanvases.getCanvas("maskCanvas", s, o), y(nt.context, i));
-                                    let ct = l.Util.transform(M, [1 / s, 0, 0, -1 / o, 0, 0]);
-                                    ct = l.Util.transform(ct, [1, 0, 0, 1, 0, -o]);
-                                    const yt = l.Util.applyTransform([0, 0], ct),
-                                        ut = l.Util.applyTransform([s, o], ct),
-                                        Ft = l.Util.normalizeRect([yt[0], yt[1], ut[0], ut[1]]),
+                                    let ct = c.Util.transform(M, [1 / s, 0, 0, -1 / o, 0, 0]);
+                                    ct = c.Util.transform(ct, [1, 0, 0, 1, 0, -o]);
+                                    const yt = c.Util.applyTransform([0, 0], ct),
+                                        ut = c.Util.applyTransform([s, o], ct),
+                                        Ft = c.Util.normalizeRect([yt[0], yt[1], ut[0], ut[1]]),
                                         Bt = Math.round(Ft[2] - Ft[0]) || 1,
                                         St = Math.round(Ft[3] - Ft[1]) || 1,
                                         Dt = this.cachedCanvases.getCanvas("fillCanvas", Bt, St),
                                         ft = Dt.context,
                                         K = Math.min(yt[0], ut[0]),
                                         J = Math.min(yt[1], ut[1]);
-                                    ft.translate(-K, -J), ft.transform(...ct), Q || (Q = this._scaleImage(nt.canvas, (0, P.getCurrentTransformInverse)(ft)), Q = Q.img, N && b && N.set(tt, Q)), ft.imageSmoothingEnabled = U((0, P.getCurrentTransform)(ft), i.interpolate), u(ft, Q, 0, 0, Q.width, Q.height, 0, 0, s, o), ft.globalCompositeOperation = "source-in";
-                                    const ht = l.Util.transform((0, P.getCurrentTransformInverse)(ft), [1, 0, 0, 1, -K, -J]);
-                                    return ft.fillStyle = b ? h.getPattern(n, this, ht, rt.PathType.FILL) : h, ft.fillRect(0, 0, s, o), N && !b && (this.cachedCanvases.delete("fillCanvas"), N.set(tt, Dt.canvas)), {
+                                    ft.translate(-K, -J), ft.transform(...ct), Q || (Q = this._scaleImage(nt.canvas, (0, P.getCurrentTransformInverse)(ft)), Q = Q.img, N && _ && N.set(tt, Q)), ft.imageSmoothingEnabled = U((0, P.getCurrentTransform)(ft), i.interpolate), u(ft, Q, 0, 0, Q.width, Q.height, 0, 0, s, o), ft.globalCompositeOperation = "source-in";
+                                    const ht = c.Util.transform((0, P.getCurrentTransformInverse)(ft), [1, 0, 0, 1, -K, -J]);
+                                    return ft.fillStyle = _ ? h.getPattern(n, this, ht, rt.PathType.FILL) : h, ft.fillRect(0, 0, s, o), N && !_ && (this.cachedCanvases.delete("fillCanvas"), N.set(tt, Dt.canvas)), {
                                         canvas: Dt.canvas,
                                         offsetX: Math.round(K),
                                         offsetY: Math.round(J)
                                     };
                                 }
                                 setLineWidth(i) {
                                     i !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = i, this.ctx.lineWidth = i;
                                 }
                                 setLineCap(i) {
                                     this.ctx.lineCap = z[i];
                                 }
                                 setLineJoin(i) {
-                                    this.ctx.lineJoin = E[i];
+                                    this.ctx.lineJoin = C[i];
                                 }
                                 setMiterLimit(i) {
                                     this.ctx.miterLimit = i;
                                 }
                                 setDash(i, n) {
                                     const s = this.ctx;
                                     s.setLineDash !== void 0 && (s.setLineDash(i), s.lineDashOffset = n);
@@ -5421,56 +5415,56 @@
                                     this.inSMaskMode ? (a(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
                                     const i = this.current;
                                     this.stateStack.push(i), this.current = i.clone();
                                 }
                                 restore() {
                                     this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), a(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
                                 }
-                                transform(i, n, s, o, h, b) {
-                                    this.ctx.transform(i, n, s, o, h, b), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
+                                transform(i, n, s, o, h, _) {
+                                    this.ctx.transform(i, n, s, o, h, _), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
                                 }
                                 constructPath(i, n, s) {
                                     const o = this.ctx,
                                         h = this.current;
-                                    let b = h.x,
+                                    let _ = h.x,
                                         M = h.y,
                                         N, tt;
                                     const Q = (0, P.getCurrentTransform)(o),
                                         nt = Q[0] === 0 && Q[3] === 0 || Q[1] === 0 && Q[2] === 0,
                                         ct = nt ? s.slice(0) : null;
                                     for (let yt = 0, ut = 0, Ft = i.length; yt < Ft; yt++)
                                         switch (i[yt] | 0) {
-                                            case l.OPS.rectangle:
-                                                b = n[ut++], M = n[ut++];
+                                            case c.OPS.rectangle:
+                                                _ = n[ut++], M = n[ut++];
                                                 const Bt = n[ut++],
                                                     St = n[ut++],
-                                                    Dt = b + Bt,
+                                                    Dt = _ + Bt,
                                                     ft = M + St;
-                                                o.moveTo(b, M), Bt === 0 || St === 0 ? o.lineTo(Dt, ft) : (o.lineTo(Dt, M), o.lineTo(Dt, ft), o.lineTo(b, ft)), nt || h.updateRectMinMax(Q, [b, M, Dt, ft]), o.closePath();
+                                                o.moveTo(_, M), Bt === 0 || St === 0 ? o.lineTo(Dt, ft) : (o.lineTo(Dt, M), o.lineTo(Dt, ft), o.lineTo(_, ft)), nt || h.updateRectMinMax(Q, [_, M, Dt, ft]), o.closePath();
                                                 break;
-                                            case l.OPS.moveTo:
-                                                b = n[ut++], M = n[ut++], o.moveTo(b, M), nt || h.updatePathMinMax(Q, b, M);
+                                            case c.OPS.moveTo:
+                                                _ = n[ut++], M = n[ut++], o.moveTo(_, M), nt || h.updatePathMinMax(Q, _, M);
                                                 break;
-                                            case l.OPS.lineTo:
-                                                b = n[ut++], M = n[ut++], o.lineTo(b, M), nt || h.updatePathMinMax(Q, b, M);
+                                            case c.OPS.lineTo:
+                                                _ = n[ut++], M = n[ut++], o.lineTo(_, M), nt || h.updatePathMinMax(Q, _, M);
                                                 break;
-                                            case l.OPS.curveTo:
-                                                N = b, tt = M, b = n[ut + 4], M = n[ut + 5], o.bezierCurveTo(n[ut], n[ut + 1], n[ut + 2], n[ut + 3], b, M), h.updateCurvePathMinMax(Q, N, tt, n[ut], n[ut + 1], n[ut + 2], n[ut + 3], b, M, ct), ut += 6;
+                                            case c.OPS.curveTo:
+                                                N = _, tt = M, _ = n[ut + 4], M = n[ut + 5], o.bezierCurveTo(n[ut], n[ut + 1], n[ut + 2], n[ut + 3], _, M), h.updateCurvePathMinMax(Q, N, tt, n[ut], n[ut + 1], n[ut + 2], n[ut + 3], _, M, ct), ut += 6;
                                                 break;
-                                            case l.OPS.curveTo2:
-                                                N = b, tt = M, o.bezierCurveTo(b, M, n[ut], n[ut + 1], n[ut + 2], n[ut + 3]), h.updateCurvePathMinMax(Q, N, tt, b, M, n[ut], n[ut + 1], n[ut + 2], n[ut + 3], ct), b = n[ut + 2], M = n[ut + 3], ut += 4;
+                                            case c.OPS.curveTo2:
+                                                N = _, tt = M, o.bezierCurveTo(_, M, n[ut], n[ut + 1], n[ut + 2], n[ut + 3]), h.updateCurvePathMinMax(Q, N, tt, _, M, n[ut], n[ut + 1], n[ut + 2], n[ut + 3], ct), _ = n[ut + 2], M = n[ut + 3], ut += 4;
                                                 break;
-                                            case l.OPS.curveTo3:
-                                                N = b, tt = M, b = n[ut + 2], M = n[ut + 3], o.bezierCurveTo(n[ut], n[ut + 1], b, M, b, M), h.updateCurvePathMinMax(Q, N, tt, n[ut], n[ut + 1], b, M, b, M, ct), ut += 4;
+                                            case c.OPS.curveTo3:
+                                                N = _, tt = M, _ = n[ut + 2], M = n[ut + 3], o.bezierCurveTo(n[ut], n[ut + 1], _, M, _, M), h.updateCurvePathMinMax(Q, N, tt, n[ut], n[ut + 1], _, M, _, M, ct), ut += 4;
                                                 break;
-                                            case l.OPS.closePath:
+                                            case c.OPS.closePath:
                                                 o.closePath();
                                                 break;
                                         }
-                                    nt && h.updateScalingPathMinMax(Q, ct), h.setCurrentPoint(b, M);
+                                    nt && h.updateScalingPathMinMax(Q, ct), h.setCurrentPoint(_, M);
                                 }
                                 closePath() {
                                     this.ctx.closePath();
                                 }
                                 stroke(i = !0) {
                                     const n = this.ctx,
                                         s = this.current.strokeColor;
@@ -5481,16 +5475,16 @@
                                 }
                                 fill(i = !0) {
                                     const n = this.ctx,
                                         s = this.current.fillColor,
                                         o = this.current.patternFill;
                                     let h = !1;
                                     o && (n.save(), n.fillStyle = s.getPattern(n, this, (0, P.getCurrentTransformInverse)(n), rt.PathType.FILL), h = !0);
-                                    const b = this.current.getClippedPathBoundingBox();
-                                    this.contentVisible && b !== null && (this.pendingEOFill ? (n.fill("evenodd"), this.pendingEOFill = !1) : n.fill()), h && n.restore(), i && this.consumePath(b);
+                                    const _ = this.current.getClippedPathBoundingBox();
+                                    this.contentVisible && _ !== null && (this.pendingEOFill ? (n.fill("evenodd"), this.pendingEOFill = !1) : n.fill()), h && n.restore(), i && this.consumePath(_);
                                 }
                                 eoFill() {
                                     this.pendingEOFill = !0, this.fill();
                                 }
                                 fillStroke() {
                                     this.fill(!1), this.stroke(!1), this.consumePath();
                                 }
@@ -5509,15 +5503,15 @@
                                 clip() {
                                     this.pendingClip = V;
                                 }
                                 eoClip() {
                                     this.pendingClip = st;
                                 }
                                 beginText() {
-                                    this.current.textMatrix = l.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
+                                    this.current.textMatrix = c.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
                                 }
                                 endText() {
                                     const i = this.pendingTextPaths,
                                         n = this.ctx;
                                     if (i === void 0) {
                                         n.beginPath();
                                         return;
@@ -5541,53 +5535,53 @@
                                 }
                                 setFont(i, n) {
                                     var Q;
                                     const s = this.commonObjs.get(i),
                                         o = this.current;
                                     if (!s)
                                         throw new Error(`Can't find font for ${i}`);
-                                    if (o.fontMatrix = s.fontMatrix || l.FONT_IDENTITY_MATRIX, (o.fontMatrix[0] === 0 || o.fontMatrix[3] === 0) && (0, l.warn)("Invalid font matrix for font " + i), n < 0 ? (n = -n, o.fontDirection = -1) : o.fontDirection = 1, this.current.font = s, this.current.fontSize = n, s.isType3Font)
+                                    if (o.fontMatrix = s.fontMatrix || c.FONT_IDENTITY_MATRIX, (o.fontMatrix[0] === 0 || o.fontMatrix[3] === 0) && (0, c.warn)("Invalid font matrix for font " + i), n < 0 ? (n = -n, o.fontDirection = -1) : o.fontDirection = 1, this.current.font = s, this.current.fontSize = n, s.isType3Font)
                                         return;
                                     const h = s.loadedName || "sans-serif",
-                                        b = ((Q = s.systemFontInfo) == null ? void 0 : Q.css) || `"${h}", ${s.fallbackName}`;
+                                        _ = ((Q = s.systemFontInfo) == null ? void 0 : Q.css) || `"${h}", ${s.fallbackName}`;
                                     let M = "normal";
                                     s.black ? M = "900" : s.bold && (M = "bold");
                                     const N = s.italic ? "italic" : "normal";
                                     let tt = n;
-                                    n < pt ? tt = pt : n > B && (tt = B), this.current.fontSizeScale = n / tt, this.ctx.font = `${N} ${M} ${tt}px ${b}`;
+                                    n < pt ? tt = pt : n > B && (tt = B), this.current.fontSizeScale = n / tt, this.ctx.font = `${N} ${M} ${tt}px ${_}`;
                                 }
                                 setTextRenderingMode(i) {
                                     this.current.textRenderingMode = i;
                                 }
                                 setTextRise(i) {
                                     this.current.textRise = i;
                                 }
                                 moveText(i, n) {
                                     this.current.x = this.current.lineX += i, this.current.y = this.current.lineY += n;
                                 }
                                 setLeadingMoveText(i, n) {
                                     this.setLeading(-n), this.moveText(i, n);
                                 }
-                                setTextMatrix(i, n, s, o, h, b) {
-                                    this.current.textMatrix = [i, n, s, o, h, b], this.current.textMatrixScale = Math.hypot(i, n), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
+                                setTextMatrix(i, n, s, o, h, _) {
+                                    this.current.textMatrix = [i, n, s, o, h, _], this.current.textMatrixScale = Math.hypot(i, n), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
                                 }
                                 nextLine() {
                                     this.moveText(0, this.current.leading);
                                 }
                                 paintChar(i, n, s, o) {
                                     const h = this.ctx,
-                                        b = this.current,
-                                        M = b.font,
-                                        N = b.textRenderingMode,
-                                        tt = b.fontSize / b.fontSizeScale,
-                                        Q = N & l.TextRenderingMode.FILL_STROKE_MASK,
-                                        nt = !!(N & l.TextRenderingMode.ADD_TO_PATH_FLAG),
-                                        ct = b.patternFill && !M.missingFile;
+                                        _ = this.current,
+                                        M = _.font,
+                                        N = _.textRenderingMode,
+                                        tt = _.fontSize / _.fontSizeScale,
+                                        Q = N & c.TextRenderingMode.FILL_STROKE_MASK,
+                                        nt = !!(N & c.TextRenderingMode.ADD_TO_PATH_FLAG),
+                                        ct = _.patternFill && !M.missingFile;
                                     let yt;
-                                    (M.disableFontFace || nt || ct) && (yt = M.getPathGenerator(this.commonObjs, i)), M.disableFontFace || ct ? (h.save(), h.translate(n, s), h.beginPath(), yt(h, tt), o && h.setTransform(...o), (Q === l.TextRenderingMode.FILL || Q === l.TextRenderingMode.FILL_STROKE) && h.fill(), (Q === l.TextRenderingMode.STROKE || Q === l.TextRenderingMode.FILL_STROKE) && h.stroke(), h.restore()) : ((Q === l.TextRenderingMode.FILL || Q === l.TextRenderingMode.FILL_STROKE) && h.fillText(i, n, s), (Q === l.TextRenderingMode.STROKE || Q === l.TextRenderingMode.FILL_STROKE) && h.strokeText(i, n, s)), nt && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
+                                    (M.disableFontFace || nt || ct) && (yt = M.getPathGenerator(this.commonObjs, i)), M.disableFontFace || ct ? (h.save(), h.translate(n, s), h.beginPath(), yt(h, tt), o && h.setTransform(...o), (Q === c.TextRenderingMode.FILL || Q === c.TextRenderingMode.FILL_STROKE) && h.fill(), (Q === c.TextRenderingMode.STROKE || Q === c.TextRenderingMode.FILL_STROKE) && h.stroke(), h.restore()) : ((Q === c.TextRenderingMode.FILL || Q === c.TextRenderingMode.FILL_STROKE) && h.fillText(i, n, s), (Q === c.TextRenderingMode.STROKE || Q === c.TextRenderingMode.FILL_STROKE) && h.strokeText(i, n, s)), nt && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
                                         transform: (0, P.getCurrentTransform)(h),
                                         x: n,
                                         y: s,
                                         fontSize: tt,
                                         addToPath: yt
                                     });
                                 }
@@ -5599,51 +5593,51 @@
                                     const n = i.getImageData(0, 0, 10, 10).data;
                                     let s = !1;
                                     for (let o = 3; o < n.length; o += 4)
                                         if (n[o] > 0 && n[o] < 255) {
                                             s = !0;
                                             break;
                                         }
-                                    return (0, l.shadow)(this, "isFontSubpixelAAEnabled", s);
+                                    return (0, c.shadow)(this, "isFontSubpixelAAEnabled", s);
                                 }
                                 showText(i) {
                                     const n = this.current,
                                         s = n.font;
                                     if (s.isType3Font)
                                         return this.showType3Text(i);
                                     const o = n.fontSize;
                                     if (o === 0)
                                         return;
                                     const h = this.ctx,
-                                        b = n.fontSizeScale,
+                                        _ = n.fontSizeScale,
                                         M = n.charSpacing,
                                         N = n.wordSpacing,
                                         tt = n.fontDirection,
                                         Q = n.textHScale * tt,
                                         nt = i.length,
                                         ct = s.vertical,
                                         yt = ct ? 1 : -1,
                                         ut = s.defaultVMetrics,
                                         Ft = o * n.fontMatrix[0],
-                                        Bt = n.textRenderingMode === l.TextRenderingMode.FILL && !s.disableFontFace && !n.patternFill;
+                                        Bt = n.textRenderingMode === c.TextRenderingMode.FILL && !s.disableFontFace && !n.patternFill;
                                     h.save(), h.transform(...n.textMatrix), h.translate(n.x, n.y + n.textRise), tt > 0 ? h.scale(Q, -1) : h.scale(Q, 1);
                                     let St;
                                     if (n.patternFill) {
                                         h.save();
                                         const ht = n.fillColor.getPattern(h, this, (0, P.getCurrentTransformInverse)(h), rt.PathType.FILL);
                                         St = (0, P.getCurrentTransform)(h), h.restore(), h.fillStyle = ht;
                                     }
                                     let Dt = n.lineWidth;
                                     const ft = n.textMatrixScale;
                                     if (ft === 0 || Dt === 0) {
-                                        const ht = n.textRenderingMode & l.TextRenderingMode.FILL_STROKE_MASK;
-                                        (ht === l.TextRenderingMode.STROKE || ht === l.TextRenderingMode.FILL_STROKE) && (Dt = this.getSinglePixelWidth());
+                                        const ht = n.textRenderingMode & c.TextRenderingMode.FILL_STROKE_MASK;
+                                        (ht === c.TextRenderingMode.STROKE || ht === c.TextRenderingMode.FILL_STROKE) && (Dt = this.getSinglePixelWidth());
                                     } else
                                         Dt /= ft;
-                                    if (b !== 1 && (h.scale(b, b), Dt /= b), h.lineWidth = Dt, s.isInvalidPDFjsFont) {
+                                    if (_ !== 1 && (h.scale(_, _), Dt /= _), h.lineWidth = Dt, s.isInvalidPDFjsFont) {
                                         const ht = [];
                                         let Et = 0;
                                         for (const Ct of i)
                                             ht.push(Ct.unicode), Et += Ct.width;
                                         h.fillText(ht.join(""), 0, 0), n.x += Et * Ft * Q, h.restore(), this.compose();
                                         return;
                                     }
@@ -5660,81 +5654,81 @@
                                             Ut = ht.fontChar,
                                             Gt = ht.accent;
                                         let Ht, Xt, Vt = ht.width;
                                         if (ct) {
                                             const $t = ht.vmetric || ut,
                                                 ot = -(ht.vmetric ? $t[1] : Vt * 0.5) * Ft,
                                                 Y = $t[2] * Ft;
-                                            Vt = $t ? -$t[0] : Vt, Ht = ot / b, Xt = (K + Y) / b;
+                                            Vt = $t ? -$t[0] : Vt, Ht = ot / _, Xt = (K + Y) / _;
                                         } else
-                                            Ht = K / b, Xt = 0;
+                                            Ht = K / _, Xt = 0;
                                         if (s.remeasure && Vt > 0) {
-                                            const $t = h.measureText(Ut).width * 1e3 / o * b;
+                                            const $t = h.measureText(Ut).width * 1e3 / o * _;
                                             if (Vt < $t && this.isFontSubpixelAAEnabled) {
                                                 const ot = Vt / $t;
                                                 Et = !0, h.save(), h.scale(ot, 1), Ht /= ot;
                                             } else
-                                                Vt !== $t && (Ht += (Vt - $t) / 2e3 * o / b);
+                                                Vt !== $t && (Ht += (Vt - $t) / 2e3 * o / _);
                                         }
                                         if (this.contentVisible && (ht.isInFont || s.missingFile)) {
                                             if (Bt && !Gt)
                                                 h.fillText(Ut, Ht, Xt);
                                             else if (this.paintChar(Ut, Ht, Xt, St), Gt) {
-                                                const $t = Ht + o * Gt.offset.x / b,
-                                                    ot = Xt - o * Gt.offset.y / b;
+                                                const $t = Ht + o * Gt.offset.x / _,
+                                                    ot = Xt - o * Gt.offset.y / _;
                                                 this.paintChar(Gt.fontChar, $t, ot, St);
                                             }
                                         }
                                         const Wt = ct ? Vt * Ft - Ct * tt : Vt * Ft + Ct * tt;
                                         K += Wt, Et && h.restore();
                                     }
                                     ct ? n.y -= K : n.x += K * Q, h.restore(), this.compose();
                                 }
                                 showType3Text(i) {
                                     const n = this.ctx,
                                         s = this.current,
                                         o = s.font,
                                         h = s.fontSize,
-                                        b = s.fontDirection,
+                                        _ = s.fontDirection,
                                         M = o.vertical ? 1 : -1,
                                         N = s.charSpacing,
                                         tt = s.wordSpacing,
-                                        Q = s.textHScale * b,
-                                        nt = s.fontMatrix || l.FONT_IDENTITY_MATRIX,
+                                        Q = s.textHScale * _,
+                                        nt = s.fontMatrix || c.FONT_IDENTITY_MATRIX,
                                         ct = i.length,
-                                        yt = s.textRenderingMode === l.TextRenderingMode.INVISIBLE;
+                                        yt = s.textRenderingMode === c.TextRenderingMode.INVISIBLE;
                                     let ut, Ft, Bt, St;
                                     if (!(yt || h === 0)) {
-                                        for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, n.save(), n.transform(...s.textMatrix), n.translate(s.x, s.y), n.scale(Q, b), ut = 0; ut < ct; ++ut) {
+                                        for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, n.save(), n.transform(...s.textMatrix), n.translate(s.x, s.y), n.scale(Q, _), ut = 0; ut < ct; ++ut) {
                                             if (Ft = i[ut], typeof Ft == "number") {
                                                 St = M * Ft * h / 1e3, this.ctx.translate(St, 0), s.x += St * Q;
                                                 continue;
                                             }
                                             const Dt = (Ft.isSpace ? tt : 0) + N,
                                                 ft = o.charProcOperatorList[Ft.operatorListId];
                                             if (!ft) {
-                                                (0, l.warn)(`Type3 character "${Ft.operatorListId}" is not available.`);
+                                                (0, c.warn)(`Type3 character "${Ft.operatorListId}" is not available.`);
                                                 continue;
                                             }
-                                            this.contentVisible && (this.processingType3 = Ft, this.save(), n.scale(h, h), n.transform(...nt), this.executeOperatorList(ft), this.restore()), Bt = l.Util.applyTransform([Ft.width, 0], nt)[0] * h + Dt, n.translate(Bt, 0), s.x += Bt * Q;
+                                            this.contentVisible && (this.processingType3 = Ft, this.save(), n.scale(h, h), n.transform(...nt), this.executeOperatorList(ft), this.restore()), Bt = c.Util.applyTransform([Ft.width, 0], nt)[0] * h + Dt, n.translate(Bt, 0), s.x += Bt * Q;
                                         }
                                         n.restore(), this.processingType3 = null;
                                     }
                                 }
                                 setCharWidth(i, n) {}
-                                setCharWidthAndBounds(i, n, s, o, h, b) {
-                                    this.ctx.rect(s, o, h - s, b - o), this.ctx.clip(), this.endPath();
+                                setCharWidthAndBounds(i, n, s, o, h, _) {
+                                    this.ctx.rect(s, o, h - s, _ - o), this.ctx.clip(), this.endPath();
                                 }
                                 getColorN_Pattern(i) {
                                     let n;
                                     if (i[0] === "TilingPattern") {
                                         const s = i[1],
                                             o = this.baseTransform || (0, P.getCurrentTransform)(this.ctx),
                                             h = {
-                                                createCanvasGraphics: (b) => new xt(b, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
+                                                createCanvasGraphics: (_) => new Pt(_, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                                                     optionalContentConfig: this.optionalContentConfig,
                                                     markedContentStack: this.markedContentStack
                                                 })
                                             };
                                         n = new rt.TilingPattern(i, s, this.ctx, h, o);
                                     } else
                                         n = this._getPattern(i[1], i[2]);
@@ -5743,19 +5737,19 @@
                                 setStrokeColorN() {
                                     this.current.strokeColor = this.getColorN_Pattern(arguments);
                                 }
                                 setFillColorN() {
                                     this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
                                 }
                                 setStrokeRGBColor(i, n, s) {
-                                    const o = l.Util.makeHexColor(i, n, s);
+                                    const o = c.Util.makeHexColor(i, n, s);
                                     this.ctx.strokeStyle = o, this.current.strokeColor = o;
                                 }
                                 setFillRGBColor(i, n, s) {
-                                    const o = l.Util.makeHexColor(i, n, s);
+                                    const o = c.Util.makeHexColor(i, n, s);
                                     this.ctx.fillStyle = o, this.current.fillColor = o, this.current.patternFill = !1;
                                 }
                                 _getPattern(i, n = null) {
                                     let s;
                                     return this.cachedPatterns.has(i) ? s = this.cachedPatterns.get(i) : (s = (0, rt.getShadingPattern)(this.getObject(i)), this.cachedPatterns.set(i, s)), n && (s.matrix = n), s;
                                 }
                                 shadingFill(i) {
@@ -5765,26 +5759,26 @@
                                     this.save();
                                     const s = this._getPattern(i);
                                     n.fillStyle = s.getPattern(n, this, (0, P.getCurrentTransformInverse)(n), rt.PathType.SHADING);
                                     const o = (0, P.getCurrentTransformInverse)(n);
                                     if (o) {
                                         const {
                                             width: h,
-                                            height: b
-                                        } = n.canvas, [M, N, tt, Q] = l.Util.getAxialAlignedBoundingBox([0, 0, h, b], o);
+                                            height: _
+                                        } = n.canvas, [M, N, tt, Q] = c.Util.getAxialAlignedBoundingBox([0, 0, h, _], o);
                                         this.ctx.fillRect(M, N, tt - M, Q - N);
                                     } else
                                         this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                                     this.compose(this.current.getClippedPathBoundingBox()), this.restore();
                                 }
                                 beginInlineImage() {
-                                    (0, l.unreachable)("Should not call beginInlineImage");
+                                    (0, c.unreachable)("Should not call beginInlineImage");
                                 }
                                 beginImageData() {
-                                    (0, l.unreachable)("Should not call beginImageData");
+                                    (0, c.unreachable)("Should not call beginImageData");
                                 }
                                 paintFormXObjectBegin(i, n) {
                                     if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(i) && i.length === 6 && this.transform(...i), this.baseTransform = (0, P.getCurrentTransform)(this.ctx), n)) {
                                         const s = n[2] - n[0],
                                             o = n[3] - n[1];
                                         this.ctx.rect(n[0], n[1], s, o), this.current.updateRectMinMax((0, P.getCurrentTransform)(this.ctx), n), this.clip(), this.endPath();
                                     }
@@ -5793,44 +5787,44 @@
                                     this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
                                 }
                                 beginGroup(i) {
                                     if (!this.contentVisible)
                                         return;
                                     this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
                                     const n = this.ctx;
-                                    i.isolated || (0, l.info)("TODO: Support non-isolated groups."), i.knockout && (0, l.warn)("Knockout groups not supported.");
+                                    i.isolated || (0, c.info)("TODO: Support non-isolated groups."), i.knockout && (0, c.warn)("Knockout groups not supported.");
                                     const s = (0, P.getCurrentTransform)(n);
                                     if (i.matrix && n.transform(...i.matrix), !i.bbox)
                                         throw new Error("Bounding box is required.");
-                                    let o = l.Util.getAxialAlignedBoundingBox(i.bbox, (0, P.getCurrentTransform)(n));
+                                    let o = c.Util.getAxialAlignedBoundingBox(i.bbox, (0, P.getCurrentTransform)(n));
                                     const h = [0, 0, n.canvas.width, n.canvas.height];
-                                    o = l.Util.intersect(o, h) || [0, 0, 0, 0];
-                                    const b = Math.floor(o[0]),
+                                    o = c.Util.intersect(o, h) || [0, 0, 0, 0];
+                                    const _ = Math.floor(o[0]),
                                         M = Math.floor(o[1]);
-                                    let N = Math.max(Math.ceil(o[2]) - b, 1),
+                                    let N = Math.max(Math.ceil(o[2]) - _, 1),
                                         tt = Math.max(Math.ceil(o[3]) - M, 1),
                                         Q = 1,
                                         nt = 1;
                                     N > F && (Q = N / F, N = F), tt > F && (nt = tt / F, tt = F), this.current.startNewPathAndClipBox([0, 0, N, tt]);
                                     let ct = "groupAt" + this.groupLevel;
                                     i.smask && (ct += "_smask_" + this.smaskCounter++ % 2);
                                     const yt = this.cachedCanvases.getCanvas(ct, N, tt),
                                         ut = yt.context;
-                                    ut.scale(1 / Q, 1 / nt), ut.translate(-b, -M), ut.transform(...s), i.smask ? this.smaskStack.push({
+                                    ut.scale(1 / Q, 1 / nt), ut.translate(-_, -M), ut.transform(...s), i.smask ? this.smaskStack.push({
                                         canvas: yt.canvas,
                                         context: ut,
-                                        offsetX: b,
+                                        offsetX: _,
                                         offsetY: M,
                                         scaleX: Q,
                                         scaleY: nt,
                                         subtype: i.smask.subtype,
                                         backdrop: i.smask.backdrop,
                                         transferMap: i.smask.transferMap || null,
                                         startTransformInverse: null
-                                    }) : (n.setTransform(1, 0, 0, 1, 0, 0), n.translate(b, M), n.scale(Q, nt), n.save()), a(n, ut), this.ctx = ut, this.setGState([
+                                    }) : (n.setTransform(1, 0, 0, 1, 0, 0), n.translate(_, M), n.scale(Q, nt), n.save()), a(n, ut), this.ctx = ut, this.setGState([
                                         ["BM", "source-over"],
                                         ["ca", 1],
                                         ["CA", 1]
                                     ]), this.groupStack.push(n), this.groupLevel++;
                                 }
                                 endGroup(i) {
                                     if (!this.contentVisible)
@@ -5840,173 +5834,173 @@
                                         s = this.groupStack.pop();
                                     if (this.ctx = s, this.ctx.imageSmoothingEnabled = !1, i.smask)
                                         this.tempSMask = this.smaskStack.pop(), this.restore();
                                     else {
                                         this.ctx.restore();
                                         const o = (0, P.getCurrentTransform)(this.ctx);
                                         this.restore(), this.ctx.save(), this.ctx.setTransform(...o);
-                                        const h = l.Util.getAxialAlignedBoundingBox([0, 0, n.canvas.width, n.canvas.height], o);
+                                        const h = c.Util.getAxialAlignedBoundingBox([0, 0, n.canvas.width, n.canvas.height], o);
                                         this.ctx.drawImage(n.canvas, 0, 0), this.ctx.restore(), this.compose(h);
                                     }
                                 }
                                 beginAnnotation(i, n, s, o, h) {
-                                    if (W(this, H, Qe).call(this), c(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(n) && n.length === 4) {
-                                        const b = n[2] - n[0],
+                                    if (W(this, H, Qe).call(this), l(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(n) && n.length === 4) {
+                                        const _ = n[2] - n[0],
                                             M = n[3] - n[1];
                                         if (h && this.annotationCanvasMap) {
-                                            s = s.slice(), s[4] -= n[0], s[5] -= n[1], n = n.slice(), n[0] = n[1] = 0, n[2] = b, n[3] = M;
-                                            const [N, tt] = l.Util.singularValueDecompose2dScale((0, P.getCurrentTransform)(this.ctx)), {
+                                            s = s.slice(), s[4] -= n[0], s[5] -= n[1], n = n.slice(), n[0] = n[1] = 0, n[2] = _, n[3] = M;
+                                            const [N, tt] = c.Util.singularValueDecompose2dScale((0, P.getCurrentTransform)(this.ctx)), {
                                                 viewportScale: Q
-                                            } = this, nt = Math.ceil(b * this.outputScaleX * Q), ct = Math.ceil(M * this.outputScaleY * Q);
+                                            } = this, nt = Math.ceil(_ * this.outputScaleX * Q), ct = Math.ceil(M * this.outputScaleY * Q);
                                             this.annotationCanvas = this.canvasFactory.create(nt, ct);
                                             const {
                                                 canvas: yt,
                                                 context: ut
                                             } = this.annotationCanvas;
-                                            this.annotationCanvasMap.set(i, yt), this.annotationCanvas.savedCtx = this.ctx, this.ctx = ut, this.ctx.save(), this.ctx.setTransform(N, 0, 0, -tt, 0, M * tt), c(this.ctx);
+                                            this.annotationCanvasMap.set(i, yt), this.annotationCanvas.savedCtx = this.ctx, this.ctx = ut, this.ctx.save(), this.ctx.setTransform(N, 0, 0, -tt, 0, M * tt), l(this.ctx);
                                         } else
-                                            c(this.ctx), this.ctx.rect(n[0], n[1], b, M), this.ctx.clip(), this.endPath();
+                                            l(this.ctx), this.ctx.rect(n[0], n[1], _, M), this.ctx.clip(), this.endPath();
                                     }
-                                    this.current = new w(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...s), this.transform(...o);
+                                    this.current = new E(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...s), this.transform(...o);
                                 }
                                 endAnnotation() {
                                     this.annotationCanvas && (this.ctx.restore(), W(this, gt, Ze).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
                                 }
                                 paintImageMaskXObject(i) {
                                     if (!this.contentVisible)
                                         return;
                                     const n = i.count;
                                     i = this.getObject(i.data, i), i.count = n;
                                     const s = this.ctx,
                                         o = this.processingType3;
-                                    if (o && (o.compiled === void 0 && (o.compiled = _(i)), o.compiled)) {
+                                    if (o && (o.compiled === void 0 && (o.compiled = b(i)), o.compiled)) {
                                         o.compiled(s);
                                         return;
                                     }
                                     const h = this._createMaskCanvas(i),
-                                        b = h.canvas;
-                                    s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.drawImage(b, h.offsetX, h.offsetY), s.restore(), this.compose();
+                                        _ = h.canvas;
+                                    s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.drawImage(_, h.offsetX, h.offsetY), s.restore(), this.compose();
                                 }
-                                paintImageMaskXObjectRepeat(i, n, s = 0, o = 0, h, b) {
+                                paintImageMaskXObjectRepeat(i, n, s = 0, o = 0, h, _) {
                                     if (!this.contentVisible)
                                         return;
                                     i = this.getObject(i.data, i);
                                     const M = this.ctx;
                                     M.save();
                                     const N = (0, P.getCurrentTransform)(M);
                                     M.transform(n, s, o, h, 0, 0);
                                     const tt = this._createMaskCanvas(i);
                                     M.setTransform(1, 0, 0, 1, tt.offsetX - N[4], tt.offsetY - N[5]);
-                                    for (let Q = 0, nt = b.length; Q < nt; Q += 2) {
-                                        const ct = l.Util.transform(N, [n, s, o, h, b[Q], b[Q + 1]]),
-                                            [yt, ut] = l.Util.applyTransform([0, 0], ct);
+                                    for (let Q = 0, nt = _.length; Q < nt; Q += 2) {
+                                        const ct = c.Util.transform(N, [n, s, o, h, _[Q], _[Q + 1]]),
+                                            [yt, ut] = c.Util.applyTransform([0, 0], ct);
                                         M.drawImage(tt.canvas, yt, ut);
                                     }
                                     M.restore(), this.compose();
                                 }
                                 paintImageMaskXObjectGroup(i) {
                                     if (!this.contentVisible)
                                         return;
                                     const n = this.ctx,
                                         s = this.current.fillColor,
                                         o = this.current.patternFill;
                                     for (const h of i) {
                                         const {
-                                            data: b,
+                                            data: _,
                                             width: M,
                                             height: N,
                                             transform: tt
                                         } = h, Q = this.cachedCanvases.getCanvas("maskCanvas", M, N), nt = Q.context;
                                         nt.save();
-                                        const ct = this.getObject(b, h);
+                                        const ct = this.getObject(_, h);
                                         y(nt, ct), nt.globalCompositeOperation = "source-in", nt.fillStyle = o ? s.getPattern(nt, this, (0, P.getCurrentTransformInverse)(n), rt.PathType.FILL) : s, nt.fillRect(0, 0, M, N), nt.restore(), n.save(), n.transform(...tt), n.scale(1, -1), u(n, Q.canvas, 0, 0, M, N, 0, -1, 1, 1), n.restore();
                                     }
                                     this.compose();
                                 }
                                 paintImageXObject(i) {
                                     if (!this.contentVisible)
                                         return;
                                     const n = this.getObject(i);
                                     if (!n) {
-                                        (0, l.warn)("Dependent image isn't ready yet");
+                                        (0, c.warn)("Dependent image isn't ready yet");
                                         return;
                                     }
                                     this.paintInlineImageXObject(n);
                                 }
                                 paintImageXObjectRepeat(i, n, s, o) {
                                     if (!this.contentVisible)
                                         return;
                                     const h = this.getObject(i);
                                     if (!h) {
-                                        (0, l.warn)("Dependent image isn't ready yet");
+                                        (0, c.warn)("Dependent image isn't ready yet");
                                         return;
                                     }
-                                    const b = h.width,
+                                    const _ = h.width,
                                         M = h.height,
                                         N = [];
                                     for (let tt = 0, Q = o.length; tt < Q; tt += 2)
                                         N.push({
                                             transform: [n, 0, 0, s, o[tt], o[tt + 1]],
                                             x: 0,
                                             y: 0,
-                                            w: b,
+                                            w: _,
                                             h: M
                                         });
                                     this.paintInlineImageXObjectGroup(h, N);
                                 }
                                 applyTransferMapsToCanvas(i) {
                                     return this.current.transferMaps !== "none" && (i.filter = this.current.transferMaps, i.drawImage(i.canvas, 0, 0), i.filter = "none"), i.canvas;
                                 }
                                 applyTransferMapsToBitmap(i) {
                                     if (this.current.transferMaps === "none")
                                         return i.bitmap;
                                     const {
                                         bitmap: n,
                                         width: s,
                                         height: o
-                                    } = i, h = this.cachedCanvases.getCanvas("inlineImage", s, o), b = h.context;
-                                    return b.filter = this.current.transferMaps, b.drawImage(n, 0, 0), b.filter = "none", h.canvas;
+                                    } = i, h = this.cachedCanvases.getCanvas("inlineImage", s, o), _ = h.context;
+                                    return _.filter = this.current.transferMaps, _.drawImage(n, 0, 0), _.filter = "none", h.canvas;
                                 }
                                 paintInlineImageXObject(i) {
                                     if (!this.contentVisible)
                                         return;
                                     const n = i.width,
                                         s = i.height,
                                         o = this.ctx;
-                                    if (this.save(), !l.isNodeJS) {
+                                    if (this.save(), !c.isNodeJS) {
                                         const {
                                             filter: M
                                         } = o;
                                         M !== "none" && M !== "" && (o.filter = "none");
                                     }
                                     o.scale(1 / n, -1 / s);
                                     let h;
                                     if (i.bitmap)
                                         h = this.applyTransferMapsToBitmap(i);
                                     else if (typeof HTMLElement == "function" && i instanceof HTMLElement || !i.data)
                                         h = i;
                                     else {
                                         const N = this.cachedCanvases.getCanvas("inlineImage", n, s).context;
-                                        C(N, i), h = this.applyTransferMapsToCanvas(N);
+                                        w(N, i), h = this.applyTransferMapsToCanvas(N);
                                     }
-                                    const b = this._scaleImage(h, (0, P.getCurrentTransformInverse)(o));
-                                    o.imageSmoothingEnabled = U((0, P.getCurrentTransform)(o), i.interpolate), u(o, b.img, 0, 0, b.paintWidth, b.paintHeight, 0, -s, n, s), this.compose(), this.restore();
+                                    const _ = this._scaleImage(h, (0, P.getCurrentTransformInverse)(o));
+                                    o.imageSmoothingEnabled = U((0, P.getCurrentTransform)(o), i.interpolate), u(o, _.img, 0, 0, _.paintWidth, _.paintHeight, 0, -s, n, s), this.compose(), this.restore();
                                 }
                                 paintInlineImageXObjectGroup(i, n) {
                                     if (!this.contentVisible)
                                         return;
                                     const s = this.ctx;
                                     let o;
                                     if (i.bitmap)
                                         o = i.bitmap;
                                     else {
                                         const h = i.width,
-                                            b = i.height,
-                                            N = this.cachedCanvases.getCanvas("inlineImage", h, b).context;
-                                        C(N, i), o = this.applyTransferMapsToCanvas(N);
+                                            _ = i.height,
+                                            N = this.cachedCanvases.getCanvas("inlineImage", h, _).context;
+                                        w(N, i), o = this.applyTransferMapsToCanvas(N);
                                     }
                                     for (const h of n)
                                         s.save(), s.transform(...h.transform), s.scale(1, -1), u(s, o, h.x, h.y, h.w, h.h, 0, -1, 1, 1), s.restore();
                                     this.compose();
                                 }
                                 paintSolidColorImageMask() {
                                     this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
@@ -6056,61 +6050,61 @@
                                             lineWidth: i
                                         } = this.current, {
                                             a: n,
                                             b: s,
                                             c: o,
                                             d: h
                                         } = this.ctx.getTransform();
-                                        let b, M;
+                                        let _, M;
                                         if (s === 0 && o === 0) {
                                             const N = Math.abs(n),
                                                 tt = Math.abs(h);
                                             if (N === tt)
                                                 if (i === 0)
-                                                    b = M = 1 / N;
+                                                    _ = M = 1 / N;
                                                 else {
                                                     const Q = N * i;
-                                                    b = M = Q < 1 ? 1 / Q : 1;
+                                                    _ = M = Q < 1 ? 1 / Q : 1;
                                                 }
                                             else if (i === 0)
-                                                b = 1 / N, M = 1 / tt;
+                                                _ = 1 / N, M = 1 / tt;
                                             else {
                                                 const Q = N * i,
                                                     nt = tt * i;
-                                                b = Q < 1 ? 1 / Q : 1, M = nt < 1 ? 1 / nt : 1;
+                                                _ = Q < 1 ? 1 / Q : 1, M = nt < 1 ? 1 / nt : 1;
                                             }
                                         } else {
                                             const N = Math.abs(n * h - s * o),
                                                 tt = Math.hypot(n, s),
                                                 Q = Math.hypot(o, h);
                                             if (i === 0)
-                                                b = Q / N, M = tt / N;
+                                                _ = Q / N, M = tt / N;
                                             else {
                                                 const nt = i * N;
-                                                b = Q > nt ? Q / nt : 1, M = tt > nt ? tt / nt : 1;
+                                                _ = Q > nt ? Q / nt : 1, M = tt > nt ? tt / nt : 1;
                                             }
                                         }
-                                        this._cachedScaleForStroking[0] = b, this._cachedScaleForStroking[1] = M;
+                                        this._cachedScaleForStroking[0] = _, this._cachedScaleForStroking[1] = M;
                                     }
                                     return this._cachedScaleForStroking;
                                 }
                                 rescaleAndStroke(i) {
                                     const {
                                         ctx: n
                                     } = this, {
                                         lineWidth: s
                                     } = this.current, [o, h] = this.getScaleForStroking();
                                     if (n.lineWidth = s || 1, o === 1 && h === 1) {
                                         n.stroke();
                                         return;
                                     }
-                                    const b = n.getLineDash();
-                                    if (i && n.save(), n.scale(o, h), b.length > 0) {
+                                    const _ = n.getLineDash();
+                                    if (i && n.save(), n.scale(o, h), _.length > 0) {
                                         const M = Math.max(o, h);
-                                        n.setLineDash(b.map((N) => N / M)), n.lineDashOffset /= M;
+                                        n.setLineDash(_.map((N) => N / M)), n.lineDashOffset /= M;
                                     }
                                     n.stroke(), i && n.restore();
                                 }
                                 isContentVisible() {
                                     for (let i = this.markedContentStack.length - 1; i >= 0; i--)
                                         if (!this.markedContentStack[i].visible)
                                             return !1;
@@ -6126,397 +6120,397 @@
                                 const i = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
                                 if (i !== "none") {
                                     const n = this.ctx.filter;
                                     this.ctx.filter = i, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = n;
                                 }
                             }
                         };
-                        let at = xt;
+                        let at = Pt;
                         d.CanvasGraphics = at;
-                        for (const S in l.OPS)
-                            at.prototype[S] !== void 0 && (at.prototype[l.OPS[S]] = at.prototype[S]);
+                        for (const S in c.OPS)
+                            at.prototype[S] !== void 0 && (at.prototype[c.OPS[S]] = at.prototype[S]);
                     },
                     /* 12 */
                     /***/
                     (dt, d, et) => {
                         Object.defineProperty(d, "__esModule", {
                             value: !0
-                        }), d.TilingPattern = d.PathType = void 0, d.getShadingPattern = x;
-                        var l = et(1),
+                        }), d.TilingPattern = d.PathType = void 0, d.getShadingPattern = T;
+                        var c = et(1),
                             P = et(6);
                         const rt = {
                             FILL: "Fill",
                             STROKE: "Stroke",
                             SHADING: "Shading"
                         };
                         d.PathType = rt;
 
-                        function X(_, w) {
-                            if (!w)
+                        function X(b, E) {
+                            if (!E)
                                 return;
-                            const C = w[2] - w[0],
-                                y = w[3] - w[1],
+                            const w = E[2] - E[0],
+                                y = E[3] - E[1],
                                 a = new Path2D();
-                            a.rect(w[0], w[1], C, y), _.clip(a);
+                            a.rect(E[0], E[1], w, y), b.clip(a);
                         }
                         class pt {
                             constructor() {
-                                this.constructor === pt && (0, l.unreachable)("Cannot initialize BaseShadingPattern.");
+                                this.constructor === pt && (0, c.unreachable)("Cannot initialize BaseShadingPattern.");
                             }
                             getPattern() {
-                                (0, l.unreachable)("Abstract method `getPattern` called.");
+                                (0, c.unreachable)("Abstract method `getPattern` called.");
                             }
                         }
                         class B extends pt {
-                            constructor(w) {
-                                super(), this._type = w[1], this._bbox = w[2], this._colorStops = w[3], this._p0 = w[4], this._p1 = w[5], this._r0 = w[6], this._r1 = w[7], this.matrix = null;
+                            constructor(E) {
+                                super(), this._type = E[1], this._bbox = E[2], this._colorStops = E[3], this._p0 = E[4], this._p1 = E[5], this._r0 = E[6], this._r1 = E[7], this.matrix = null;
                             }
-                            _createGradient(w) {
-                                let C;
-                                this._type === "axial" ? C = w.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (C = w.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
+                            _createGradient(E) {
+                                let w;
+                                this._type === "axial" ? w = E.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (w = E.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
                                 for (const y of this._colorStops)
-                                    C.addColorStop(y[0], y[1]);
-                                return C;
+                                    w.addColorStop(y[0], y[1]);
+                                return w;
                             }
-                            getPattern(w, C, y, a) {
-                                let c;
+                            getPattern(E, w, y, a) {
+                                let l;
                                 if (a === rt.STROKE || a === rt.FILL) {
-                                    const k = C.current.getClippedPathBoundingBox(a, (0, P.getCurrentTransform)(w)) || [0, 0, 0, 0],
+                                    const k = w.current.getClippedPathBoundingBox(a, (0, P.getCurrentTransform)(E)) || [0, 0, 0, 0],
                                         p = Math.ceil(k[2] - k[0]) || 1,
                                         r = Math.ceil(k[3] - k[1]) || 1,
-                                        T = C.cachedCanvases.getCanvas("pattern", p, r, !0),
-                                        m = T.context;
-                                    m.clearRect(0, 0, m.canvas.width, m.canvas.height), m.beginPath(), m.rect(0, 0, m.canvas.width, m.canvas.height), m.translate(-k[0], -k[1]), y = l.Util.transform(y, [1, 0, 0, 1, k[0], k[1]]), m.transform(...C.baseTransform), this.matrix && m.transform(...this.matrix), X(m, this._bbox), m.fillStyle = this._createGradient(m), m.fill(), c = w.createPattern(T.canvas, "no-repeat");
+                                        x = w.cachedCanvases.getCanvas("pattern", p, r, !0),
+                                        m = x.context;
+                                    m.clearRect(0, 0, m.canvas.width, m.canvas.height), m.beginPath(), m.rect(0, 0, m.canvas.width, m.canvas.height), m.translate(-k[0], -k[1]), y = c.Util.transform(y, [1, 0, 0, 1, k[0], k[1]]), m.transform(...w.baseTransform), this.matrix && m.transform(...this.matrix), X(m, this._bbox), m.fillStyle = this._createGradient(m), m.fill(), l = E.createPattern(x.canvas, "no-repeat");
                                     const U = new DOMMatrix(y);
-                                    c.setTransform(U);
+                                    l.setTransform(U);
                                 } else
-                                    X(w, this._bbox), c = this._createGradient(w);
-                                return c;
+                                    X(E, this._bbox), l = this._createGradient(E);
+                                return l;
                             }
                         }
 
-                        function F(_, w, C, y, a, c, k, p) {
-                            const r = w.coords,
-                                T = w.colors,
-                                m = _.data,
-                                U = _.width * 4;
+                        function F(b, E, w, y, a, l, k, p) {
+                            const r = E.coords,
+                                x = E.colors,
+                                m = b.data,
+                                U = b.width * 4;
                             let z;
-                            r[C + 1] > r[y + 1] && (z = C, C = y, y = z, z = c, c = k, k = z), r[y + 1] > r[a + 1] && (z = y, y = a, a = z, z = k, k = p, p = z), r[C + 1] > r[y + 1] && (z = C, C = y, y = z, z = c, c = k, k = z);
-                            const E = (r[C] + w.offsetX) * w.scaleX,
-                                V = (r[C + 1] + w.offsetY) * w.scaleY,
-                                st = (r[y] + w.offsetX) * w.scaleX,
-                                at = (r[y + 1] + w.offsetY) * w.scaleY,
-                                H = (r[a] + w.offsetX) * w.scaleX,
-                                lt = (r[a + 1] + w.offsetY) * w.scaleY;
+                            r[w + 1] > r[y + 1] && (z = w, w = y, y = z, z = l, l = k, k = z), r[y + 1] > r[a + 1] && (z = y, y = a, a = z, z = k, k = p, p = z), r[w + 1] > r[y + 1] && (z = w, w = y, y = z, z = l, l = k, k = z);
+                            const C = (r[w] + E.offsetX) * E.scaleX,
+                                V = (r[w + 1] + E.offsetY) * E.scaleY,
+                                st = (r[y] + E.offsetX) * E.scaleX,
+                                at = (r[y + 1] + E.offsetY) * E.scaleY,
+                                H = (r[a] + E.offsetX) * E.scaleX,
+                                lt = (r[a + 1] + E.offsetY) * E.scaleY;
                             if (V >= lt)
                                 return;
-                            const gt = T[c],
-                                wt = T[c + 1],
-                                xt = T[c + 2],
-                                S = T[k],
-                                i = T[k + 1],
-                                n = T[k + 2],
-                                s = T[p],
-                                o = T[p + 1],
-                                h = T[p + 2],
-                                b = Math.round(V),
+                            const gt = x[l],
+                                wt = x[l + 1],
+                                Pt = x[l + 2],
+                                S = x[k],
+                                i = x[k + 1],
+                                n = x[k + 2],
+                                s = x[p],
+                                o = x[p + 1],
+                                h = x[p + 2],
+                                _ = Math.round(V),
                                 M = Math.round(lt);
                             let N, tt, Q, nt, ct, yt, ut, Ft;
-                            for (let Bt = b; Bt <= M; Bt++) {
+                            for (let Bt = _; Bt <= M; Bt++) {
                                 if (Bt < at) {
                                     const J = Bt < V ? 0 : (V - Bt) / (V - at);
-                                    N = E - (E - st) * J, tt = gt - (gt - S) * J, Q = wt - (wt - i) * J, nt = xt - (xt - n) * J;
+                                    N = C - (C - st) * J, tt = gt - (gt - S) * J, Q = wt - (wt - i) * J, nt = Pt - (Pt - n) * J;
                                 } else {
                                     let J;
                                     Bt > lt ? J = 1 : at === lt ? J = 0 : J = (at - Bt) / (at - lt), N = st - (st - H) * J, tt = S - (S - s) * J, Q = i - (i - o) * J, nt = n - (n - h) * J;
                                 }
                                 let St;
-                                Bt < V ? St = 0 : Bt > lt ? St = 1 : St = (V - Bt) / (V - lt), ct = E - (E - H) * St, yt = gt - (gt - s) * St, ut = wt - (wt - o) * St, Ft = xt - (xt - h) * St;
+                                Bt < V ? St = 0 : Bt > lt ? St = 1 : St = (V - Bt) / (V - lt), ct = C - (C - H) * St, yt = gt - (gt - s) * St, ut = wt - (wt - o) * St, Ft = Pt - (Pt - h) * St;
                                 const Dt = Math.round(Math.min(N, ct)),
                                     ft = Math.round(Math.max(N, ct));
                                 let K = U * Bt + Dt * 4;
                                 for (let J = Dt; J <= ft; J++)
                                     St = (N - J) / (N - ct), St < 0 ? St = 0 : St > 1 && (St = 1), m[K++] = tt - (tt - yt) * St | 0, m[K++] = Q - (Q - ut) * St | 0, m[K++] = nt - (nt - Ft) * St | 0, m[K++] = 255;
                             }
                         }
 
-                        function g(_, w, C) {
-                            const y = w.coords,
-                                a = w.colors;
-                            let c, k;
-                            switch (w.type) {
+                        function g(b, E, w) {
+                            const y = E.coords,
+                                a = E.colors;
+                            let l, k;
+                            switch (E.type) {
                                 case "lattice":
-                                    const p = w.verticesPerRow,
+                                    const p = E.verticesPerRow,
                                         r = Math.floor(y.length / p) - 1,
-                                        T = p - 1;
-                                    for (c = 0; c < r; c++) {
-                                        let m = c * p;
-                                        for (let U = 0; U < T; U++, m++)
-                                            F(_, C, y[m], y[m + 1], y[m + p], a[m], a[m + 1], a[m + p]), F(_, C, y[m + p + 1], y[m + 1], y[m + p], a[m + p + 1], a[m + 1], a[m + p]);
+                                        x = p - 1;
+                                    for (l = 0; l < r; l++) {
+                                        let m = l * p;
+                                        for (let U = 0; U < x; U++, m++)
+                                            F(b, w, y[m], y[m + 1], y[m + p], a[m], a[m + 1], a[m + p]), F(b, w, y[m + p + 1], y[m + 1], y[m + p], a[m + p + 1], a[m + 1], a[m + p]);
                                     }
                                     break;
                                 case "triangles":
-                                    for (c = 0, k = y.length; c < k; c += 3)
-                                        F(_, C, y[c], y[c + 1], y[c + 2], a[c], a[c + 1], a[c + 2]);
+                                    for (l = 0, k = y.length; l < k; l += 3)
+                                        F(b, w, y[l], y[l + 1], y[l + 2], a[l], a[l + 1], a[l + 2]);
                                     break;
                                 default:
                                     throw new Error("illegal figure");
                             }
                         }
-                        class O extends pt {
-                            constructor(w) {
-                                super(), this._coords = w[2], this._colors = w[3], this._figures = w[4], this._bounds = w[5], this._bbox = w[7], this._background = w[8], this.matrix = null;
+                        class L extends pt {
+                            constructor(E) {
+                                super(), this._coords = E[2], this._colors = E[3], this._figures = E[4], this._bounds = E[5], this._bbox = E[7], this._background = E[8], this.matrix = null;
                             }
-                            _createMeshCanvas(w, C, y) {
+                            _createMeshCanvas(E, w, y) {
                                 const p = Math.floor(this._bounds[0]),
                                     r = Math.floor(this._bounds[1]),
-                                    T = Math.ceil(this._bounds[2]) - p,
+                                    x = Math.ceil(this._bounds[2]) - p,
                                     m = Math.ceil(this._bounds[3]) - r,
-                                    U = Math.min(Math.ceil(Math.abs(T * w[0] * 1.1)), 3e3),
-                                    z = Math.min(Math.ceil(Math.abs(m * w[1] * 1.1)), 3e3),
-                                    E = T / U,
+                                    U = Math.min(Math.ceil(Math.abs(x * E[0] * 1.1)), 3e3),
+                                    z = Math.min(Math.ceil(Math.abs(m * E[1] * 1.1)), 3e3),
+                                    C = x / U,
                                     V = m / z,
                                     st = {
                                         coords: this._coords,
                                         colors: this._colors,
                                         offsetX: -p,
                                         offsetY: -r,
-                                        scaleX: 1 / E,
+                                        scaleX: 1 / C,
                                         scaleY: 1 / V
                                     },
                                     at = U + 2 * 2,
                                     H = z + 2 * 2,
                                     lt = y.getCanvas("mesh", at, H, !1),
                                     gt = lt.context,
                                     wt = gt.createImageData(U, z);
-                                if (C) {
+                                if (w) {
                                     const S = wt.data;
                                     for (let i = 0, n = S.length; i < n; i += 4)
-                                        S[i] = C[0], S[i + 1] = C[1], S[i + 2] = C[2], S[i + 3] = 255;
+                                        S[i] = w[0], S[i + 1] = w[1], S[i + 2] = w[2], S[i + 3] = 255;
                                 }
                                 for (const S of this._figures)
                                     g(wt, S, st);
                                 return gt.putImageData(wt, 2, 2), {
                                     canvas: lt.canvas,
-                                    offsetX: p - 2 * E,
+                                    offsetX: p - 2 * C,
                                     offsetY: r - 2 * V,
-                                    scaleX: E,
+                                    scaleX: C,
                                     scaleY: V
                                 };
                             }
-                            getPattern(w, C, y, a) {
-                                X(w, this._bbox);
-                                let c;
+                            getPattern(E, w, y, a) {
+                                X(E, this._bbox);
+                                let l;
                                 if (a === rt.SHADING)
-                                    c = l.Util.singularValueDecompose2dScale((0, P.getCurrentTransform)(w));
-                                else if (c = l.Util.singularValueDecompose2dScale(C.baseTransform), this.matrix) {
-                                    const p = l.Util.singularValueDecompose2dScale(this.matrix);
-                                    c = [c[0] * p[0], c[1] * p[1]];
+                                    l = c.Util.singularValueDecompose2dScale((0, P.getCurrentTransform)(E));
+                                else if (l = c.Util.singularValueDecompose2dScale(w.baseTransform), this.matrix) {
+                                    const p = c.Util.singularValueDecompose2dScale(this.matrix);
+                                    l = [l[0] * p[0], l[1] * p[1]];
                                 }
-                                const k = this._createMeshCanvas(c, a === rt.SHADING ? null : this._background, C.cachedCanvases);
-                                return a !== rt.SHADING && (w.setTransform(...C.baseTransform), this.matrix && w.transform(...this.matrix)), w.translate(k.offsetX, k.offsetY), w.scale(k.scaleX, k.scaleY), w.createPattern(k.canvas, "no-repeat");
+                                const k = this._createMeshCanvas(l, a === rt.SHADING ? null : this._background, w.cachedCanvases);
+                                return a !== rt.SHADING && (E.setTransform(...w.baseTransform), this.matrix && E.transform(...this.matrix)), E.translate(k.offsetX, k.offsetY), E.scale(k.scaleX, k.scaleY), E.createPattern(k.canvas, "no-repeat");
                             }
                         }
-                        class I extends pt {
+                        class O extends pt {
                             getPattern() {
                                 return "hotpink";
                             }
                         }
 
-                        function x(_) {
-                            switch (_[0]) {
+                        function T(b) {
+                            switch (b[0]) {
                                 case "RadialAxial":
-                                    return new B(_);
+                                    return new B(b);
                                 case "Mesh":
-                                    return new O(_);
+                                    return new L(b);
                                 case "Dummy":
-                                    return new I();
+                                    return new O();
                             }
-                            throw new Error(`Unknown IR type: ${_[0]}`);
+                            throw new Error(`Unknown IR type: ${b[0]}`);
                         }
                         const v = {
                                 COLORED: 1,
                                 UNCOLORED: 2
                             },
                             u = class u {
-                                constructor(w, C, y, a, c) {
-                                    this.operatorList = w[2], this.matrix = w[3] || [1, 0, 0, 1, 0, 0], this.bbox = w[4], this.xstep = w[5], this.ystep = w[6], this.paintType = w[7], this.tilingType = w[8], this.color = C, this.ctx = y, this.canvasGraphicsFactory = a, this.baseTransform = c;
+                                constructor(E, w, y, a, l) {
+                                    this.operatorList = E[2], this.matrix = E[3] || [1, 0, 0, 1, 0, 0], this.bbox = E[4], this.xstep = E[5], this.ystep = E[6], this.paintType = E[7], this.tilingType = E[8], this.color = w, this.ctx = y, this.canvasGraphicsFactory = a, this.baseTransform = l;
                                 }
-                                createPatternCanvas(w) {
-                                    const C = this.operatorList,
+                                createPatternCanvas(E) {
+                                    const w = this.operatorList,
                                         y = this.bbox,
                                         a = this.xstep,
-                                        c = this.ystep,
+                                        l = this.ystep,
                                         k = this.paintType,
                                         p = this.tilingType,
                                         r = this.color,
-                                        T = this.canvasGraphicsFactory;
-                                    (0, l.info)("TilingType: " + p);
+                                        x = this.canvasGraphicsFactory;
+                                    (0, c.info)("TilingType: " + p);
                                     const m = y[0],
                                         U = y[1],
                                         z = y[2],
-                                        E = y[3],
-                                        V = l.Util.singularValueDecompose2dScale(this.matrix),
-                                        st = l.Util.singularValueDecompose2dScale(this.baseTransform),
+                                        C = y[3],
+                                        V = c.Util.singularValueDecompose2dScale(this.matrix),
+                                        st = c.Util.singularValueDecompose2dScale(this.baseTransform),
                                         at = [V[0] * st[0], V[1] * st[1]],
                                         H = this.getSizeAndScale(a, this.ctx.canvas.width, at[0]),
-                                        lt = this.getSizeAndScale(c, this.ctx.canvas.height, at[1]),
-                                        gt = w.cachedCanvases.getCanvas("pattern", H.size, lt.size, !0),
+                                        lt = this.getSizeAndScale(l, this.ctx.canvas.height, at[1]),
+                                        gt = E.cachedCanvases.getCanvas("pattern", H.size, lt.size, !0),
                                         wt = gt.context,
-                                        xt = T.createCanvasGraphics(wt);
-                                    xt.groupLevel = w.groupLevel, this.setFillAndStrokeStyleToContext(xt, k, r);
+                                        Pt = x.createCanvasGraphics(wt);
+                                    Pt.groupLevel = E.groupLevel, this.setFillAndStrokeStyleToContext(Pt, k, r);
                                     let S = m,
                                         i = U,
                                         n = z,
-                                        s = E;
-                                    return m < 0 && (S = 0, n += Math.abs(m)), U < 0 && (i = 0, s += Math.abs(U)), wt.translate(-(H.scale * S), -(lt.scale * i)), xt.transform(H.scale, 0, 0, lt.scale, 0, 0), wt.save(), this.clipBbox(xt, S, i, n, s), xt.baseTransform = (0, P.getCurrentTransform)(xt.ctx), xt.executeOperatorList(C), xt.endDrawing(), {
+                                        s = C;
+                                    return m < 0 && (S = 0, n += Math.abs(m)), U < 0 && (i = 0, s += Math.abs(U)), wt.translate(-(H.scale * S), -(lt.scale * i)), Pt.transform(H.scale, 0, 0, lt.scale, 0, 0), wt.save(), this.clipBbox(Pt, S, i, n, s), Pt.baseTransform = (0, P.getCurrentTransform)(Pt.ctx), Pt.executeOperatorList(w), Pt.endDrawing(), {
                                         canvas: gt.canvas,
                                         scaleX: H.scale,
                                         scaleY: lt.scale,
                                         offsetX: S,
                                         offsetY: i
                                     };
                                 }
-                                getSizeAndScale(w, C, y) {
-                                    w = Math.abs(w);
-                                    const a = Math.max(u.MAX_PATTERN_SIZE, C);
-                                    let c = Math.ceil(w * y);
-                                    return c >= a ? c = a : y = c / w, {
+                                getSizeAndScale(E, w, y) {
+                                    E = Math.abs(E);
+                                    const a = Math.max(u.MAX_PATTERN_SIZE, w);
+                                    let l = Math.ceil(E * y);
+                                    return l >= a ? l = a : y = l / E, {
                                         scale: y,
-                                        size: c
+                                        size: l
                                     };
                                 }
-                                clipBbox(w, C, y, a, c) {
-                                    const k = a - C,
-                                        p = c - y;
-                                    w.ctx.rect(C, y, k, p), w.current.updateRectMinMax((0, P.getCurrentTransform)(w.ctx), [C, y, a, c]), w.clip(), w.endPath();
-                                }
-                                setFillAndStrokeStyleToContext(w, C, y) {
-                                    const a = w.ctx,
-                                        c = w.current;
-                                    switch (C) {
+                                clipBbox(E, w, y, a, l) {
+                                    const k = a - w,
+                                        p = l - y;
+                                    E.ctx.rect(w, y, k, p), E.current.updateRectMinMax((0, P.getCurrentTransform)(E.ctx), [w, y, a, l]), E.clip(), E.endPath();
+                                }
+                                setFillAndStrokeStyleToContext(E, w, y) {
+                                    const a = E.ctx,
+                                        l = E.current;
+                                    switch (w) {
                                         case v.COLORED:
                                             const k = this.ctx;
-                                            a.fillStyle = k.fillStyle, a.strokeStyle = k.strokeStyle, c.fillColor = k.fillStyle, c.strokeColor = k.strokeStyle;
+                                            a.fillStyle = k.fillStyle, a.strokeStyle = k.strokeStyle, l.fillColor = k.fillStyle, l.strokeColor = k.strokeStyle;
                                             break;
                                         case v.UNCOLORED:
-                                            const p = l.Util.makeHexColor(y[0], y[1], y[2]);
-                                            a.fillStyle = p, a.strokeStyle = p, c.fillColor = p, c.strokeColor = p;
+                                            const p = c.Util.makeHexColor(y[0], y[1], y[2]);
+                                            a.fillStyle = p, a.strokeStyle = p, l.fillColor = p, l.strokeColor = p;
                                             break;
                                         default:
-                                            throw new l.FormatError(`Unsupported paint type: ${C}`);
+                                            throw new c.FormatError(`Unsupported paint type: ${w}`);
                                     }
                                 }
-                                getPattern(w, C, y, a) {
-                                    let c = y;
-                                    a !== rt.SHADING && (c = l.Util.transform(c, C.baseTransform), this.matrix && (c = l.Util.transform(c, this.matrix)));
-                                    const k = this.createPatternCanvas(C);
-                                    let p = new DOMMatrix(c);
+                                getPattern(E, w, y, a) {
+                                    let l = y;
+                                    a !== rt.SHADING && (l = c.Util.transform(l, w.baseTransform), this.matrix && (l = c.Util.transform(l, this.matrix)));
+                                    const k = this.createPatternCanvas(w);
+                                    let p = new DOMMatrix(l);
                                     p = p.translate(k.offsetX, k.offsetY), p = p.scale(1 / k.scaleX, 1 / k.scaleY);
-                                    const r = w.createPattern(k.canvas, "repeat");
+                                    const r = E.createPattern(k.canvas, "repeat");
                                     return r.setTransform(p), r;
                                 }
                             };
                         ee(u, "MAX_PATTERN_SIZE", 3e3);
                         let A = u;
                         d.TilingPattern = A;
                     },
                     /* 13 */
                     /***/
                     (dt, d, et) => {
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.convertBlackAndWhiteToRGBA = rt, d.convertToRGBA = P, d.grayToRGBA = pt;
-                        var l = et(1);
+                        var c = et(1);
 
                         function P(B) {
                             switch (B.kind) {
-                                case l.ImageKind.GRAYSCALE_1BPP:
+                                case c.ImageKind.GRAYSCALE_1BPP:
                                     return rt(B);
-                                case l.ImageKind.RGB_24BPP:
+                                case c.ImageKind.RGB_24BPP:
                                     return X(B);
                             }
                             return null;
                         }
 
                         function rt({
                             src: B,
                             srcPos: F = 0,
                             dest: g,
-                            width: O,
-                            height: I,
-                            nonBlackColor: x = 4294967295,
+                            width: L,
+                            height: O,
+                            nonBlackColor: T = 4294967295,
                             inverseDecode: v = !1
                         }) {
-                            const A = l.FeatureTest.isLittleEndian ? 4278190080 : 255,
-                                [u, _] = v ? [x, A] : [A, x],
-                                w = O >> 3,
-                                C = O & 7,
+                            const A = c.FeatureTest.isLittleEndian ? 4278190080 : 255,
+                                [u, b] = v ? [T, A] : [A, T],
+                                E = L >> 3,
+                                w = L & 7,
                                 y = B.length;
                             g = new Uint32Array(g.buffer);
                             let a = 0;
-                            for (let c = 0; c < I; c++) {
-                                for (const p = F + w; F < p; F++) {
+                            for (let l = 0; l < O; l++) {
+                                for (const p = F + E; F < p; F++) {
                                     const r = F < y ? B[F] : 255;
-                                    g[a++] = r & 128 ? _ : u, g[a++] = r & 64 ? _ : u, g[a++] = r & 32 ? _ : u, g[a++] = r & 16 ? _ : u, g[a++] = r & 8 ? _ : u, g[a++] = r & 4 ? _ : u, g[a++] = r & 2 ? _ : u, g[a++] = r & 1 ? _ : u;
+                                    g[a++] = r & 128 ? b : u, g[a++] = r & 64 ? b : u, g[a++] = r & 32 ? b : u, g[a++] = r & 16 ? b : u, g[a++] = r & 8 ? b : u, g[a++] = r & 4 ? b : u, g[a++] = r & 2 ? b : u, g[a++] = r & 1 ? b : u;
                                 }
-                                if (C === 0)
+                                if (w === 0)
                                     continue;
                                 const k = F < y ? B[F++] : 255;
-                                for (let p = 0; p < C; p++)
-                                    g[a++] = k & 1 << 7 - p ? _ : u;
+                                for (let p = 0; p < w; p++)
+                                    g[a++] = k & 1 << 7 - p ? b : u;
                             }
                             return {
                                 srcPos: F,
                                 destPos: a
                             };
                         }
 
                         function X({
                             src: B,
                             srcPos: F = 0,
                             dest: g,
-                            destPos: O = 0,
-                            width: I,
-                            height: x
+                            destPos: L = 0,
+                            width: O,
+                            height: T
                         }) {
                             let v = 0;
                             const A = B.length >> 2,
                                 u = new Uint32Array(B.buffer, F, A);
-                            if (l.FeatureTest.isLittleEndian) {
-                                for (; v < A - 2; v += 3, O += 4) {
-                                    const _ = u[v],
-                                        w = u[v + 1],
-                                        C = u[v + 2];
-                                    g[O] = _ | 4278190080, g[O + 1] = _ >>> 24 | w << 8 | 4278190080, g[O + 2] = w >>> 16 | C << 16 | 4278190080, g[O + 3] = C >>> 8 | 4278190080;
+                            if (c.FeatureTest.isLittleEndian) {
+                                for (; v < A - 2; v += 3, L += 4) {
+                                    const b = u[v],
+                                        E = u[v + 1],
+                                        w = u[v + 2];
+                                    g[L] = b | 4278190080, g[L + 1] = b >>> 24 | E << 8 | 4278190080, g[L + 2] = E >>> 16 | w << 16 | 4278190080, g[L + 3] = w >>> 8 | 4278190080;
                                 }
-                                for (let _ = v * 4, w = B.length; _ < w; _ += 3)
-                                    g[O++] = B[_] | B[_ + 1] << 8 | B[_ + 2] << 16 | 4278190080;
+                                for (let b = v * 4, E = B.length; b < E; b += 3)
+                                    g[L++] = B[b] | B[b + 1] << 8 | B[b + 2] << 16 | 4278190080;
                             } else {
-                                for (; v < A - 2; v += 3, O += 4) {
-                                    const _ = u[v],
-                                        w = u[v + 1],
-                                        C = u[v + 2];
-                                    g[O] = _ | 255, g[O + 1] = _ << 24 | w >>> 8 | 255, g[O + 2] = w << 16 | C >>> 16 | 255, g[O + 3] = C << 8 | 255;
+                                for (; v < A - 2; v += 3, L += 4) {
+                                    const b = u[v],
+                                        E = u[v + 1],
+                                        w = u[v + 2];
+                                    g[L] = b | 255, g[L + 1] = b << 24 | E >>> 8 | 255, g[L + 2] = E << 16 | w >>> 16 | 255, g[L + 3] = w << 8 | 255;
                                 }
-                                for (let _ = v * 4, w = B.length; _ < w; _ += 3)
-                                    g[O++] = B[_] << 24 | B[_ + 1] << 16 | B[_ + 2] << 8 | 255;
+                                for (let b = v * 4, E = B.length; b < E; b += 3)
+                                    g[L++] = B[b] << 24 | B[b + 1] << 16 | B[b + 2] << 8 | 255;
                             }
                             return {
                                 srcPos: F,
-                                destPos: O
+                                destPos: L
                             };
                         }
 
                         function pt(B, F) {
-                            if (l.FeatureTest.isLittleEndian)
-                                for (let g = 0, O = B.length; g < O; g++)
+                            if (c.FeatureTest.isLittleEndian)
+                                for (let g = 0, L = B.length; g < L; g++)
                                     F[g] = B[g] * 65793 | 4278190080;
                             else
-                                for (let g = 0, O = B.length; g < O; g++)
+                                for (let g = 0, L = B.length; g < L; g++)
                                     F[g] = B[g] * 16843008 | 255;
                         }
                     },
                     /* 14 */
                     /***/
                     (dt, d) => {
                         Object.defineProperty(d, "__esModule", {
@@ -6524,19 +6518,19 @@
                         }), d.GlobalWorkerOptions = void 0;
                         const et = /* @__PURE__ */ Object.create(null);
                         d.GlobalWorkerOptions = et, et.workerPort = null, et.workerSrc = "";
                     },
                     /* 15 */
                     /***/
                     (dt, d, et) => {
-                        var B, xi, g, ki, I, xe;
+                        var B, Pi, g, ki, O, Pe;
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.MessageHandler = void 0;
-                        var l = et(1);
+                        var c = et(1);
                         const P = {
                                 UNKNOWN: 0,
                                 DATA: 1,
                                 ERROR: 2
                             },
                             rt = {
                                 UNKNOWN: 0,
@@ -6547,609 +6541,609 @@
                                 ERROR: 5,
                                 PULL: 6,
                                 PULL_COMPLETE: 7,
                                 START_COMPLETE: 8
                             };
 
                         function X(v) {
-                            switch (v instanceof Error || typeof v == "object" && v !== null || (0, l.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), v.name) {
+                            switch (v instanceof Error || typeof v == "object" && v !== null || (0, c.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), v.name) {
                                 case "AbortException":
-                                    return new l.AbortException(v.message);
+                                    return new c.AbortException(v.message);
                                 case "MissingPDFException":
-                                    return new l.MissingPDFException(v.message);
+                                    return new c.MissingPDFException(v.message);
                                 case "PasswordException":
-                                    return new l.PasswordException(v.message, v.code);
+                                    return new c.PasswordException(v.message, v.code);
                                 case "UnexpectedResponseException":
-                                    return new l.UnexpectedResponseException(v.message, v.status);
+                                    return new c.UnexpectedResponseException(v.message, v.status);
                                 case "UnknownErrorException":
-                                    return new l.UnknownErrorException(v.message, v.details);
+                                    return new c.UnknownErrorException(v.message, v.details);
                                 default:
-                                    return new l.UnknownErrorException(v.message, v.toString());
+                                    return new c.UnknownErrorException(v.message, v.toString());
                             }
                         }
                         class pt {
-                            constructor(A, u, _) {
-                                L(this, B);
-                                L(this, g);
-                                L(this, I);
-                                this.sourceName = A, this.targetName = u, this.comObj = _, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (w) => {
-                                    const C = w.data;
-                                    if (C.targetName !== this.sourceName)
-                                        return;
-                                    if (C.stream) {
-                                        W(this, g, ki).call(this, C);
-                                        return;
-                                    }
-                                    if (C.callback) {
-                                        const a = C.callbackId,
-                                            c = this.callbackCapabilities[a];
-                                        if (!c)
+                            constructor(A, u, b) {
+                                I(this, B);
+                                I(this, g);
+                                I(this, O);
+                                this.sourceName = A, this.targetName = u, this.comObj = b, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (E) => {
+                                    const w = E.data;
+                                    if (w.targetName !== this.sourceName)
+                                        return;
+                                    if (w.stream) {
+                                        W(this, g, ki).call(this, w);
+                                        return;
+                                    }
+                                    if (w.callback) {
+                                        const a = w.callbackId,
+                                            l = this.callbackCapabilities[a];
+                                        if (!l)
                                             throw new Error(`Cannot resolve callback ${a}`);
-                                        if (delete this.callbackCapabilities[a], C.callback === P.DATA)
-                                            c.resolve(C.data);
-                                        else if (C.callback === P.ERROR)
-                                            c.reject(X(C.reason));
+                                        if (delete this.callbackCapabilities[a], w.callback === P.DATA)
+                                            l.resolve(w.data);
+                                        else if (w.callback === P.ERROR)
+                                            l.reject(X(w.reason));
                                         else
                                             throw new Error("Unexpected callback case");
                                         return;
                                     }
-                                    const y = this.actionHandler[C.action];
+                                    const y = this.actionHandler[w.action];
                                     if (!y)
-                                        throw new Error(`Unknown action from worker: ${C.action}`);
-                                    if (C.callbackId) {
+                                        throw new Error(`Unknown action from worker: ${w.action}`);
+                                    if (w.callbackId) {
                                         const a = this.sourceName,
-                                            c = C.sourceName;
+                                            l = w.sourceName;
                                         new Promise(function(k) {
-                                            k(y(C.data));
+                                            k(y(w.data));
                                         }).then(function(k) {
-                                            _.postMessage({
+                                            b.postMessage({
                                                 sourceName: a,
-                                                targetName: c,
+                                                targetName: l,
                                                 callback: P.DATA,
-                                                callbackId: C.callbackId,
+                                                callbackId: w.callbackId,
                                                 data: k
                                             });
                                         }, function(k) {
-                                            _.postMessage({
+                                            b.postMessage({
                                                 sourceName: a,
-                                                targetName: c,
+                                                targetName: l,
                                                 callback: P.ERROR,
-                                                callbackId: C.callbackId,
+                                                callbackId: w.callbackId,
                                                 reason: X(k)
                                             });
                                         });
                                         return;
                                     }
-                                    if (C.streamId) {
-                                        W(this, B, xi).call(this, C);
+                                    if (w.streamId) {
+                                        W(this, B, Pi).call(this, w);
                                         return;
                                     }
-                                    y(C.data);
-                                }, _.addEventListener("message", this._onComObjOnMessage);
+                                    y(w.data);
+                                }, b.addEventListener("message", this._onComObjOnMessage);
                             }
                             on(A, u) {
-                                const _ = this.actionHandler;
-                                if (_[A])
+                                const b = this.actionHandler;
+                                if (b[A])
                                     throw new Error(`There is already an actionName called "${A}"`);
-                                _[A] = u;
+                                b[A] = u;
                             }
-                            send(A, u, _) {
+                            send(A, u, b) {
                                 this.comObj.postMessage({
                                     sourceName: this.sourceName,
                                     targetName: this.targetName,
                                     action: A,
                                     data: u
-                                }, _);
+                                }, b);
                             }
-                            sendWithPromise(A, u, _) {
-                                const w = this.callbackId++,
-                                    C = new l.PromiseCapability();
-                                this.callbackCapabilities[w] = C;
+                            sendWithPromise(A, u, b) {
+                                const E = this.callbackId++,
+                                    w = new c.PromiseCapability();
+                                this.callbackCapabilities[E] = w;
                                 try {
                                     this.comObj.postMessage({
                                         sourceName: this.sourceName,
                                         targetName: this.targetName,
                                         action: A,
-                                        callbackId: w,
+                                        callbackId: E,
                                         data: u
-                                    }, _);
+                                    }, b);
                                 } catch (y) {
-                                    C.reject(y);
+                                    w.reject(y);
                                 }
-                                return C.promise;
+                                return w.promise;
                             }
-                            sendWithStream(A, u, _, w) {
-                                const C = this.streamId++,
+                            sendWithStream(A, u, b, E) {
+                                const w = this.streamId++,
                                     y = this.sourceName,
                                     a = this.targetName,
-                                    c = this.comObj;
+                                    l = this.comObj;
                                 return new ReadableStream({
                                     start: (k) => {
-                                        const p = new l.PromiseCapability();
-                                        return this.streamControllers[C] = {
+                                        const p = new c.PromiseCapability();
+                                        return this.streamControllers[w] = {
                                             controller: k,
                                             startCall: p,
                                             pullCall: null,
                                             cancelCall: null,
                                             isClosed: !1
-                                        }, c.postMessage({
+                                        }, l.postMessage({
                                             sourceName: y,
                                             targetName: a,
                                             action: A,
-                                            streamId: C,
+                                            streamId: w,
                                             data: u,
                                             desiredSize: k.desiredSize
-                                        }, w), p.promise;
+                                        }, E), p.promise;
                                     },
                                     pull: (k) => {
-                                        const p = new l.PromiseCapability();
-                                        return this.streamControllers[C].pullCall = p, c.postMessage({
+                                        const p = new c.PromiseCapability();
+                                        return this.streamControllers[w].pullCall = p, l.postMessage({
                                             sourceName: y,
                                             targetName: a,
                                             stream: rt.PULL,
-                                            streamId: C,
+                                            streamId: w,
                                             desiredSize: k.desiredSize
                                         }), p.promise;
                                     },
                                     cancel: (k) => {
-                                        (0, l.assert)(k instanceof Error, "cancel must have a valid reason");
-                                        const p = new l.PromiseCapability();
-                                        return this.streamControllers[C].cancelCall = p, this.streamControllers[C].isClosed = !0, c.postMessage({
+                                        (0, c.assert)(k instanceof Error, "cancel must have a valid reason");
+                                        const p = new c.PromiseCapability();
+                                        return this.streamControllers[w].cancelCall = p, this.streamControllers[w].isClosed = !0, l.postMessage({
                                             sourceName: y,
                                             targetName: a,
                                             stream: rt.CANCEL,
-                                            streamId: C,
+                                            streamId: w,
                                             reason: X(k)
                                         }), p.promise;
                                     }
-                                }, _);
+                                }, b);
                             }
                             destroy() {
                                 this.comObj.removeEventListener("message", this._onComObjOnMessage);
                             }
                         }
-                        B = new WeakSet(), xi = function(A) {
+                        B = new WeakSet(), Pi = function(A) {
                             const u = A.streamId,
-                                _ = this.sourceName,
-                                w = A.sourceName,
-                                C = this.comObj,
+                                b = this.sourceName,
+                                E = A.sourceName,
+                                w = this.comObj,
                                 y = this,
                                 a = this.actionHandler[A.action],
-                                c = {
+                                l = {
                                     enqueue(k, p = 1, r) {
                                         if (this.isCancelled)
                                             return;
-                                        const T = this.desiredSize;
-                                        this.desiredSize -= p, T > 0 && this.desiredSize <= 0 && (this.sinkCapability = new l.PromiseCapability(), this.ready = this.sinkCapability.promise), C.postMessage({
-                                            sourceName: _,
-                                            targetName: w,
+                                        const x = this.desiredSize;
+                                        this.desiredSize -= p, x > 0 && this.desiredSize <= 0 && (this.sinkCapability = new c.PromiseCapability(), this.ready = this.sinkCapability.promise), w.postMessage({
+                                            sourceName: b,
+                                            targetName: E,
                                             stream: rt.ENQUEUE,
                                             streamId: u,
                                             chunk: k
                                         }, r);
                                     },
                                     close() {
-                                        this.isCancelled || (this.isCancelled = !0, C.postMessage({
-                                            sourceName: _,
-                                            targetName: w,
+                                        this.isCancelled || (this.isCancelled = !0, w.postMessage({
+                                            sourceName: b,
+                                            targetName: E,
                                             stream: rt.CLOSE,
                                             streamId: u
                                         }), delete y.streamSinks[u]);
                                     },
                                     error(k) {
-                                        (0, l.assert)(k instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, C.postMessage({
-                                            sourceName: _,
-                                            targetName: w,
+                                        (0, c.assert)(k instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, w.postMessage({
+                                            sourceName: b,
+                                            targetName: E,
                                             stream: rt.ERROR,
                                             streamId: u,
                                             reason: X(k)
                                         }));
                                     },
-                                    sinkCapability: new l.PromiseCapability(),
+                                    sinkCapability: new c.PromiseCapability(),
                                     onPull: null,
                                     onCancel: null,
                                     isCancelled: !1,
                                     desiredSize: A.desiredSize,
                                     ready: null
                                 };
-                            c.sinkCapability.resolve(), c.ready = c.sinkCapability.promise, this.streamSinks[u] = c, new Promise(function(k) {
-                                k(a(A.data, c));
+                            l.sinkCapability.resolve(), l.ready = l.sinkCapability.promise, this.streamSinks[u] = l, new Promise(function(k) {
+                                k(a(A.data, l));
                             }).then(function() {
-                                C.postMessage({
-                                    sourceName: _,
-                                    targetName: w,
+                                w.postMessage({
+                                    sourceName: b,
+                                    targetName: E,
                                     stream: rt.START_COMPLETE,
                                     streamId: u,
                                     success: !0
                                 });
                             }, function(k) {
-                                C.postMessage({
-                                    sourceName: _,
-                                    targetName: w,
+                                w.postMessage({
+                                    sourceName: b,
+                                    targetName: E,
                                     stream: rt.START_COMPLETE,
                                     streamId: u,
                                     reason: X(k)
                                 });
                             });
                         }, g = new WeakSet(), ki = function(A) {
                             const u = A.streamId,
-                                _ = this.sourceName,
-                                w = A.sourceName,
-                                C = this.comObj,
+                                b = this.sourceName,
+                                E = A.sourceName,
+                                w = this.comObj,
                                 y = this.streamControllers[u],
                                 a = this.streamSinks[u];
                             switch (A.stream) {
                                 case rt.START_COMPLETE:
                                     A.success ? y.startCall.resolve() : y.startCall.reject(X(A.reason));
                                     break;
                                 case rt.PULL_COMPLETE:
                                     A.success ? y.pullCall.resolve() : y.pullCall.reject(X(A.reason));
                                     break;
                                 case rt.PULL:
                                     if (!a) {
-                                        C.postMessage({
-                                            sourceName: _,
-                                            targetName: w,
+                                        w.postMessage({
+                                            sourceName: b,
+                                            targetName: E,
                                             stream: rt.PULL_COMPLETE,
                                             streamId: u,
                                             success: !0
                                         });
                                         break;
                                     }
-                                    a.desiredSize <= 0 && A.desiredSize > 0 && a.sinkCapability.resolve(), a.desiredSize = A.desiredSize, new Promise(function(c) {
+                                    a.desiredSize <= 0 && A.desiredSize > 0 && a.sinkCapability.resolve(), a.desiredSize = A.desiredSize, new Promise(function(l) {
                                         var k;
-                                        c((k = a.onPull) == null ? void 0 : k.call(a));
+                                        l((k = a.onPull) == null ? void 0 : k.call(a));
                                     }).then(function() {
-                                        C.postMessage({
-                                            sourceName: _,
-                                            targetName: w,
+                                        w.postMessage({
+                                            sourceName: b,
+                                            targetName: E,
                                             stream: rt.PULL_COMPLETE,
                                             streamId: u,
                                             success: !0
                                         });
-                                    }, function(c) {
-                                        C.postMessage({
-                                            sourceName: _,
-                                            targetName: w,
+                                    }, function(l) {
+                                        w.postMessage({
+                                            sourceName: b,
+                                            targetName: E,
                                             stream: rt.PULL_COMPLETE,
                                             streamId: u,
-                                            reason: X(c)
+                                            reason: X(l)
                                         });
                                     });
                                     break;
                                 case rt.ENQUEUE:
-                                    if ((0, l.assert)(y, "enqueue should have stream controller"), y.isClosed)
+                                    if ((0, c.assert)(y, "enqueue should have stream controller"), y.isClosed)
                                         break;
                                     y.controller.enqueue(A.chunk);
                                     break;
                                 case rt.CLOSE:
-                                    if ((0, l.assert)(y, "close should have stream controller"), y.isClosed)
+                                    if ((0, c.assert)(y, "close should have stream controller"), y.isClosed)
                                         break;
-                                    y.isClosed = !0, y.controller.close(), W(this, I, xe).call(this, y, u);
+                                    y.isClosed = !0, y.controller.close(), W(this, O, Pe).call(this, y, u);
                                     break;
                                 case rt.ERROR:
-                                    (0, l.assert)(y, "error should have stream controller"), y.controller.error(X(A.reason)), W(this, I, xe).call(this, y, u);
+                                    (0, c.assert)(y, "error should have stream controller"), y.controller.error(X(A.reason)), W(this, O, Pe).call(this, y, u);
                                     break;
                                 case rt.CANCEL_COMPLETE:
-                                    A.success ? y.cancelCall.resolve() : y.cancelCall.reject(X(A.reason)), W(this, I, xe).call(this, y, u);
+                                    A.success ? y.cancelCall.resolve() : y.cancelCall.reject(X(A.reason)), W(this, O, Pe).call(this, y, u);
                                     break;
                                 case rt.CANCEL:
                                     if (!a)
                                         break;
-                                    new Promise(function(c) {
+                                    new Promise(function(l) {
                                         var k;
-                                        c((k = a.onCancel) == null ? void 0 : k.call(a, X(A.reason)));
+                                        l((k = a.onCancel) == null ? void 0 : k.call(a, X(A.reason)));
                                     }).then(function() {
-                                        C.postMessage({
-                                            sourceName: _,
-                                            targetName: w,
+                                        w.postMessage({
+                                            sourceName: b,
+                                            targetName: E,
                                             stream: rt.CANCEL_COMPLETE,
                                             streamId: u,
                                             success: !0
                                         });
-                                    }, function(c) {
-                                        C.postMessage({
-                                            sourceName: _,
-                                            targetName: w,
+                                    }, function(l) {
+                                        w.postMessage({
+                                            sourceName: b,
+                                            targetName: E,
                                             stream: rt.CANCEL_COMPLETE,
                                             streamId: u,
-                                            reason: X(c)
+                                            reason: X(l)
                                         });
                                     }), a.sinkCapability.reject(X(A.reason)), a.isCancelled = !0, delete this.streamSinks[u];
                                     break;
                                 default:
                                     throw new Error("Unexpected stream case");
                             }
-                        }, I = new WeakSet(), xe = async function(A, u) {
-                            var _, w, C;
-                            await Promise.allSettled([(_ = A.startCall) == null ? void 0 : _.promise, (w = A.pullCall) == null ? void 0 : w.promise, (C = A.cancelCall) == null ? void 0 : C.promise]), delete this.streamControllers[u];
+                        }, O = new WeakSet(), Pe = async function(A, u) {
+                            var b, E, w;
+                            await Promise.allSettled([(b = A.startCall) == null ? void 0 : b.promise, (E = A.pullCall) == null ? void 0 : E.promise, (w = A.cancelCall) == null ? void 0 : w.promise]), delete this.streamControllers[u];
                         }, d.MessageHandler = pt;
                     },
                     /* 16 */
                     /***/
                     (dt, d, et) => {
                         var rt, X;
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.Metadata = void 0;
-                        var l = et(1);
+                        var c = et(1);
                         class P {
                             constructor({
                                 parsedData: B,
                                 rawData: F
                             }) {
-                                L(this, rt, void 0);
-                                L(this, X, void 0);
+                                I(this, rt, void 0);
+                                I(this, X, void 0);
                                 Z(this, rt, B), Z(this, X, F);
                             }
                             getRaw() {
                                 return t(this, X);
                             }
                             get(B) {
                                 return t(this, rt).get(B) ?? null;
                             }
                             getAll() {
-                                return (0, l.objectFromMap)(t(this, rt));
+                                return (0, c.objectFromMap)(t(this, rt));
                             }
                             has(B) {
                                 return t(this, rt).has(B);
                             }
                         }
                         rt = new WeakMap(), X = new WeakMap(), d.Metadata = P;
                     },
                     /* 17 */
                     /***/
                     (dt, d, et) => {
-                        var B, F, g, O, I, x, ti;
+                        var B, F, g, L, O, T, ti;
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.OptionalContentConfig = void 0;
-                        var l = et(1),
+                        var c = et(1),
                             P = et(8);
                         const rt = Symbol("INTERNAL");
                         class X {
-                            constructor(u, _) {
-                                L(this, B, !0);
-                                this.name = u, this.intent = _;
+                            constructor(u, b) {
+                                I(this, B, !0);
+                                this.name = u, this.intent = b;
                             }
                             get visible() {
                                 return t(this, B);
                             }
-                            _setVisible(u, _) {
-                                u !== rt && (0, l.unreachable)("Internal method `_setVisible` called."), Z(this, B, _);
+                            _setVisible(u, b) {
+                                u !== rt && (0, c.unreachable)("Internal method `_setVisible` called."), Z(this, B, b);
                             }
                         }
                         B = new WeakMap();
                         class pt {
                             constructor(u) {
-                                L(this, x);
-                                L(this, F, null);
-                                L(this, g, /* @__PURE__ */ new Map());
-                                L(this, O, null);
-                                L(this, I, null);
+                                I(this, T);
+                                I(this, F, null);
+                                I(this, g, /* @__PURE__ */ new Map());
+                                I(this, L, null);
+                                I(this, O, null);
                                 if (this.name = null, this.creator = null, u !== null) {
-                                    this.name = u.name, this.creator = u.creator, Z(this, I, u.order);
-                                    for (const _ of u.groups)
-                                        t(this, g).set(_.id, new X(_.name, _.intent));
+                                    this.name = u.name, this.creator = u.creator, Z(this, O, u.order);
+                                    for (const b of u.groups)
+                                        t(this, g).set(b.id, new X(b.name, b.intent));
                                     if (u.baseState === "OFF")
-                                        for (const _ of t(this, g).values())
-                                            _._setVisible(rt, !1);
-                                    for (const _ of u.on)
-                                        t(this, g).get(_)._setVisible(rt, !0);
-                                    for (const _ of u.off)
-                                        t(this, g).get(_)._setVisible(rt, !1);
-                                    Z(this, O, this.getHash());
+                                        for (const b of t(this, g).values())
+                                            b._setVisible(rt, !1);
+                                    for (const b of u.on)
+                                        t(this, g).get(b)._setVisible(rt, !0);
+                                    for (const b of u.off)
+                                        t(this, g).get(b)._setVisible(rt, !1);
+                                    Z(this, L, this.getHash());
                                 }
                             }
                             isVisible(u) {
                                 if (t(this, g).size === 0)
                                     return !0;
                                 if (!u)
-                                    return (0, l.warn)("Optional content group not defined."), !0;
+                                    return (0, c.warn)("Optional content group not defined."), !0;
                                 if (u.type === "OCG")
-                                    return t(this, g).has(u.id) ? t(this, g).get(u.id).visible : ((0, l.warn)(`Optional content group not found: ${u.id}`), !0);
+                                    return t(this, g).has(u.id) ? t(this, g).get(u.id).visible : ((0, c.warn)(`Optional content group not found: ${u.id}`), !0);
                                 if (u.type === "OCMD") {
                                     if (u.expression)
-                                        return W(this, x, ti).call(this, u.expression);
+                                        return W(this, T, ti).call(this, u.expression);
                                     if (!u.policy || u.policy === "AnyOn") {
-                                        for (const _ of u.ids) {
-                                            if (!t(this, g).has(_))
-                                                return (0, l.warn)(`Optional content group not found: ${_}`), !0;
-                                            if (t(this, g).get(_).visible)
+                                        for (const b of u.ids) {
+                                            if (!t(this, g).has(b))
+                                                return (0, c.warn)(`Optional content group not found: ${b}`), !0;
+                                            if (t(this, g).get(b).visible)
                                                 return !0;
                                         }
                                         return !1;
                                     } else if (u.policy === "AllOn") {
-                                        for (const _ of u.ids) {
-                                            if (!t(this, g).has(_))
-                                                return (0, l.warn)(`Optional content group not found: ${_}`), !0;
-                                            if (!t(this, g).get(_).visible)
+                                        for (const b of u.ids) {
+                                            if (!t(this, g).has(b))
+                                                return (0, c.warn)(`Optional content group not found: ${b}`), !0;
+                                            if (!t(this, g).get(b).visible)
                                                 return !1;
                                         }
                                         return !0;
                                     } else if (u.policy === "AnyOff") {
-                                        for (const _ of u.ids) {
-                                            if (!t(this, g).has(_))
-                                                return (0, l.warn)(`Optional content group not found: ${_}`), !0;
-                                            if (!t(this, g).get(_).visible)
+                                        for (const b of u.ids) {
+                                            if (!t(this, g).has(b))
+                                                return (0, c.warn)(`Optional content group not found: ${b}`), !0;
+                                            if (!t(this, g).get(b).visible)
                                                 return !0;
                                         }
                                         return !1;
                                     } else if (u.policy === "AllOff") {
-                                        for (const _ of u.ids) {
-                                            if (!t(this, g).has(_))
-                                                return (0, l.warn)(`Optional content group not found: ${_}`), !0;
-                                            if (t(this, g).get(_).visible)
+                                        for (const b of u.ids) {
+                                            if (!t(this, g).has(b))
+                                                return (0, c.warn)(`Optional content group not found: ${b}`), !0;
+                                            if (t(this, g).get(b).visible)
                                                 return !1;
                                         }
                                         return !0;
                                     }
-                                    return (0, l.warn)(`Unknown optional content policy ${u.policy}.`), !0;
+                                    return (0, c.warn)(`Unknown optional content policy ${u.policy}.`), !0;
                                 }
-                                return (0, l.warn)(`Unknown group type ${u.type}.`), !0;
+                                return (0, c.warn)(`Unknown group type ${u.type}.`), !0;
                             }
-                            setVisibility(u, _ = !0) {
+                            setVisibility(u, b = !0) {
                                 if (!t(this, g).has(u)) {
-                                    (0, l.warn)(`Optional content group not found: ${u}`);
+                                    (0, c.warn)(`Optional content group not found: ${u}`);
                                     return;
                                 }
-                                t(this, g).get(u)._setVisible(rt, !!_), Z(this, F, null);
+                                t(this, g).get(u)._setVisible(rt, !!b), Z(this, F, null);
                             }
                             get hasInitialVisibility() {
-                                return t(this, O) === null || this.getHash() === t(this, O);
+                                return t(this, L) === null || this.getHash() === t(this, L);
                             }
                             getOrder() {
-                                return t(this, g).size ? t(this, I) ? t(this, I).slice() : [...t(this, g).keys()] : null;
+                                return t(this, g).size ? t(this, O) ? t(this, O).slice() : [...t(this, g).keys()] : null;
                             }
                             getGroups() {
-                                return t(this, g).size > 0 ? (0, l.objectFromMap)(t(this, g)) : null;
+                                return t(this, g).size > 0 ? (0, c.objectFromMap)(t(this, g)) : null;
                             }
                             getGroup(u) {
                                 return t(this, g).get(u) || null;
                             }
                             getHash() {
                                 if (t(this, F) !== null)
                                     return t(this, F);
                                 const u = new P.MurmurHash3_64();
-                                for (const [_, w] of t(this, g))
-                                    u.update(`${_}:${w.visible}`);
+                                for (const [b, E] of t(this, g))
+                                    u.update(`${b}:${E.visible}`);
                                 return Z(this, F, u.hexdigest());
                             }
                         }
-                        F = new WeakMap(), g = new WeakMap(), O = new WeakMap(), I = new WeakMap(), x = new WeakSet(), ti = function(u) {
-                            const _ = u.length;
-                            if (_ < 2)
+                        F = new WeakMap(), g = new WeakMap(), L = new WeakMap(), O = new WeakMap(), T = new WeakSet(), ti = function(u) {
+                            const b = u.length;
+                            if (b < 2)
                                 return !0;
-                            const w = u[0];
-                            for (let C = 1; C < _; C++) {
-                                const y = u[C];
+                            const E = u[0];
+                            for (let w = 1; w < b; w++) {
+                                const y = u[w];
                                 let a;
                                 if (Array.isArray(y))
-                                    a = W(this, x, ti).call(this, y);
+                                    a = W(this, T, ti).call(this, y);
                                 else if (t(this, g).has(y))
                                     a = t(this, g).get(y).visible;
                                 else
-                                    return (0, l.warn)(`Optional content group not found: ${y}`), !0;
-                                switch (w) {
+                                    return (0, c.warn)(`Optional content group not found: ${y}`), !0;
+                                switch (E) {
                                     case "And":
                                         if (!a)
                                             return !1;
                                         break;
                                     case "Or":
                                         if (a)
                                             return !0;
                                         break;
                                     case "Not":
                                         return !a;
                                     default:
                                         return !0;
                                 }
                             }
-                            return w === "And";
+                            return E === "And";
                         }, d.OptionalContentConfig = pt;
                     },
                     /* 18 */
                     /***/
                     (dt, d, et) => {
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.PDFDataTransportStream = void 0;
-                        var l = et(1),
+                        var c = et(1),
                             P = et(6);
                         class rt {
                             constructor({
                                 length: F,
                                 initialData: g,
-                                progressiveDone: O = !1,
-                                contentDispositionFilename: I = null,
-                                disableRange: x = !1,
+                                progressiveDone: L = !1,
+                                contentDispositionFilename: O = null,
+                                disableRange: T = !1,
                                 disableStream: v = !1
                             }, A) {
-                                if ((0, l.assert)(A, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = O, this._contentDispositionFilename = I, (g == null ? void 0 : g.length) > 0) {
+                                if ((0, c.assert)(A, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = L, this._contentDispositionFilename = O, (g == null ? void 0 : g.length) > 0) {
                                     const u = g instanceof Uint8Array && g.byteLength === g.buffer.byteLength ? g.buffer : new Uint8Array(g).buffer;
                                     this._queuedChunks.push(u);
                                 }
-                                this._pdfDataRangeTransport = A, this._isStreamingSupported = !v, this._isRangeSupported = !x, this._contentLength = F, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((u, _) => {
+                                this._pdfDataRangeTransport = A, this._isStreamingSupported = !v, this._isRangeSupported = !T, this._contentLength = F, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((u, b) => {
                                     this._onReceiveData({
                                         begin: u,
-                                        chunk: _
+                                        chunk: b
                                     });
-                                }), this._pdfDataRangeTransport.addProgressListener((u, _) => {
+                                }), this._pdfDataRangeTransport.addProgressListener((u, b) => {
                                     this._onProgress({
                                         loaded: u,
-                                        total: _
+                                        total: b
                                     });
                                 }), this._pdfDataRangeTransport.addProgressiveReadListener((u) => {
                                     this._onReceiveData({
                                         chunk: u
                                     });
                                 }), this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                                     this._onProgressiveDone();
                                 }), this._pdfDataRangeTransport.transportReady();
                             }
                             _onReceiveData({
                                 begin: F,
                                 chunk: g
                             }) {
-                                const O = g instanceof Uint8Array && g.byteLength === g.buffer.byteLength ? g.buffer : new Uint8Array(g).buffer;
+                                const L = g instanceof Uint8Array && g.byteLength === g.buffer.byteLength ? g.buffer : new Uint8Array(g).buffer;
                                 if (F === void 0)
-                                    this._fullRequestReader ? this._fullRequestReader._enqueue(O) : this._queuedChunks.push(O);
+                                    this._fullRequestReader ? this._fullRequestReader._enqueue(L) : this._queuedChunks.push(L);
                                 else {
-                                    const I = this._rangeReaders.some(function(x) {
-                                        return x._begin !== F ? !1 : (x._enqueue(O), !0);
+                                    const O = this._rangeReaders.some(function(T) {
+                                        return T._begin !== F ? !1 : (T._enqueue(L), !0);
                                     });
-                                    (0, l.assert)(I, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
+                                    (0, c.assert)(O, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
                                 }
                             }
                             get _progressiveDataLength() {
                                 var F;
                                 return ((F = this._fullRequestReader) == null ? void 0 : F._loaded) ?? 0;
                             }
                             _onProgress(F) {
-                                var g, O, I, x;
-                                F.total === void 0 ? (O = (g = this._rangeReaders[0]) == null ? void 0 : g.onProgress) == null || O.call(g, {
+                                var g, L, O, T;
+                                F.total === void 0 ? (L = (g = this._rangeReaders[0]) == null ? void 0 : g.onProgress) == null || L.call(g, {
                                     loaded: F.loaded
-                                }) : (x = (I = this._fullRequestReader) == null ? void 0 : I.onProgress) == null || x.call(I, {
+                                }) : (T = (O = this._fullRequestReader) == null ? void 0 : O.onProgress) == null || T.call(O, {
                                     loaded: F.loaded,
                                     total: F.total
                                 });
                             }
                             _onProgressiveDone() {
                                 var F;
                                 (F = this._fullRequestReader) == null || F.progressiveDone(), this._progressiveDone = !0;
                             }
                             _removeRangeReader(F) {
                                 const g = this._rangeReaders.indexOf(F);
                                 g >= 0 && this._rangeReaders.splice(g, 1);
                             }
                             getFullReader() {
-                                (0, l.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
+                                (0, c.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
                                 const F = this._queuedChunks;
                                 return this._queuedChunks = null, new X(this, F, this._progressiveDone, this._contentDispositionFilename);
                             }
                             getRangeReader(F, g) {
                                 if (g <= this._progressiveDataLength)
                                     return null;
-                                const O = new pt(this, F, g);
-                                return this._pdfDataRangeTransport.requestDataRange(F, g), this._rangeReaders.push(O), O;
+                                const L = new pt(this, F, g);
+                                return this._pdfDataRangeTransport.requestDataRange(F, g), this._rangeReaders.push(L), L;
                             }
                             cancelAllRequests(F) {
                                 var g;
                                 (g = this._fullRequestReader) == null || g.cancel(F);
-                                for (const O of this._rangeReaders.slice(0))
-                                    O.cancel(F);
+                                for (const L of this._rangeReaders.slice(0))
+                                    L.cancel(F);
                                 this._pdfDataRangeTransport.abort();
                             }
                         }
                         d.PDFDataTransportStream = rt;
                         class X {
-                            constructor(F, g, O = !1, I = null) {
-                                this._stream = F, this._done = O || !1, this._filename = (0, P.isPdfFile)(I) ? I : null, this._queuedChunks = g || [], this._loaded = 0;
-                                for (const x of this._queuedChunks)
-                                    this._loaded += x.byteLength;
+                            constructor(F, g, L = !1, O = null) {
+                                this._stream = F, this._done = L || !1, this._filename = (0, P.isPdfFile)(O) ? O : null, this._queuedChunks = g || [], this._loaded = 0;
+                                for (const T of this._queuedChunks)
+                                    this._loaded += T.byteLength;
                                 this._requests = [], this._headersReady = Promise.resolve(), F._fullRequestReader = this, this.onProgress = null;
                             }
                             _enqueue(F) {
                                 this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
                                     value: F,
                                     done: !1
                                 }) : this._queuedChunks.push(F), this._loaded += F.byteLength);
@@ -7176,15 +7170,15 @@
                                         done: !1
                                     };
                                 if (this._done)
                                     return {
                                         value: void 0,
                                         done: !0
                                     };
-                                const F = new l.PromiseCapability();
+                                const F = new c.PromiseCapability();
                                 return this._requests.push(F), F.promise;
                             }
                             cancel(F) {
                                 this._done = !0;
                                 for (const g of this._requests)
                                     g.resolve({
                                         value: void 0,
@@ -7193,28 +7187,28 @@
                                 this._requests.length = 0;
                             }
                             progressiveDone() {
                                 this._done || (this._done = !0);
                             }
                         }
                         class pt {
-                            constructor(F, g, O) {
-                                this._stream = F, this._begin = g, this._end = O, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
+                            constructor(F, g, L) {
+                                this._stream = F, this._begin = g, this._end = L, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
                             }
                             _enqueue(F) {
                                 if (!this._done) {
                                     if (this._requests.length === 0)
                                         this._queuedChunk = F;
                                     else {
                                         this._requests.shift().resolve({
                                             value: F,
                                             done: !1
                                         });
-                                        for (const O of this._requests)
-                                            O.resolve({
+                                        for (const L of this._requests)
+                                            L.resolve({
                                                 value: void 0,
                                                 done: !0
                                             });
                                         this._requests.length = 0;
                                     }
                                     this._done = !0, this._stream._removeRangeReader(this);
                                 }
@@ -7231,15 +7225,15 @@
                                     };
                                 }
                                 if (this._done)
                                     return {
                                         value: void 0,
                                         done: !0
                                     };
-                                const F = new l.PromiseCapability();
+                                const F = new c.PromiseCapability();
                                 return this._requests.push(F), F.promise;
                             }
                             cancel(F) {
                                 this._done = !0;
                                 for (const g of this._requests)
                                     g.resolve({
                                         value: void 0,
@@ -7251,86 +7245,86 @@
                     },
                     /* 19 */
                     /***/
                     (dt, d, et) => {
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.PDFFetchStream = void 0;
-                        var l = et(1),
+                        var c = et(1),
                             P = et(20);
 
-                        function rt(O, I, x) {
+                        function rt(L, O, T) {
                             return {
                                 method: "GET",
-                                headers: O,
-                                signal: x.signal,
+                                headers: L,
+                                signal: T.signal,
                                 mode: "cors",
-                                credentials: I ? "include" : "same-origin",
+                                credentials: O ? "include" : "same-origin",
                                 redirect: "follow"
                             };
                         }
 
-                        function X(O) {
-                            const I = new Headers();
-                            for (const x in O) {
-                                const v = O[x];
-                                v !== void 0 && I.append(x, v);
+                        function X(L) {
+                            const O = new Headers();
+                            for (const T in L) {
+                                const v = L[T];
+                                v !== void 0 && O.append(T, v);
                             }
-                            return I;
+                            return O;
                         }
 
-                        function pt(O) {
-                            return O instanceof Uint8Array ? O.buffer : O instanceof ArrayBuffer ? O : ((0, l.warn)(`getArrayBuffer - unexpected data format: ${O}`), new Uint8Array(O).buffer);
+                        function pt(L) {
+                            return L instanceof Uint8Array ? L.buffer : L instanceof ArrayBuffer ? L : ((0, c.warn)(`getArrayBuffer - unexpected data format: ${L}`), new Uint8Array(L).buffer);
                         }
                         class B {
-                            constructor(I) {
-                                this.source = I, this.isHttp = /^https?:/i.test(I.url), this.httpHeaders = this.isHttp && I.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
+                            constructor(O) {
+                                this.source = O, this.isHttp = /^https?:/i.test(O.url), this.httpHeaders = this.isHttp && O.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
                             }
                             get _progressiveDataLength() {
-                                var I;
-                                return ((I = this._fullRequestReader) == null ? void 0 : I._loaded) ?? 0;
+                                var O;
+                                return ((O = this._fullRequestReader) == null ? void 0 : O._loaded) ?? 0;
                             }
                             getFullReader() {
-                                return (0, l.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new F(this), this._fullRequestReader;
+                                return (0, c.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new F(this), this._fullRequestReader;
                             }
-                            getRangeReader(I, x) {
-                                if (x <= this._progressiveDataLength)
+                            getRangeReader(O, T) {
+                                if (T <= this._progressiveDataLength)
                                     return null;
-                                const v = new g(this, I, x);
+                                const v = new g(this, O, T);
                                 return this._rangeRequestReaders.push(v), v;
                             }
-                            cancelAllRequests(I) {
-                                var x;
-                                (x = this._fullRequestReader) == null || x.cancel(I);
+                            cancelAllRequests(O) {
+                                var T;
+                                (T = this._fullRequestReader) == null || T.cancel(O);
                                 for (const v of this._rangeRequestReaders.slice(0))
-                                    v.cancel(I);
+                                    v.cancel(O);
                             }
                         }
                         d.PDFFetchStream = B;
                         class F {
-                            constructor(I) {
-                                this._stream = I, this._reader = null, this._loaded = 0, this._filename = null;
-                                const x = I.source;
-                                this._withCredentials = x.withCredentials || !1, this._contentLength = x.length, this._headersCapability = new l.PromiseCapability(), this._disableRange = x.disableRange || !1, this._rangeChunkSize = x.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !x.disableStream, this._isRangeSupported = !x.disableRange, this._headers = X(this._stream.httpHeaders);
-                                const v = x.url;
+                            constructor(O) {
+                                this._stream = O, this._reader = null, this._loaded = 0, this._filename = null;
+                                const T = O.source;
+                                this._withCredentials = T.withCredentials || !1, this._contentLength = T.length, this._headersCapability = new c.PromiseCapability(), this._disableRange = T.disableRange || !1, this._rangeChunkSize = T.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !T.disableStream, this._isRangeSupported = !T.disableRange, this._headers = X(this._stream.httpHeaders);
+                                const v = T.url;
                                 fetch(v, rt(this._headers, this._withCredentials, this._abortController)).then((A) => {
                                     if (!(0, P.validateResponseStatus)(A.status))
                                         throw (0, P.createResponseStatusError)(A.status, v);
                                     this._reader = A.body.getReader(), this._headersCapability.resolve();
-                                    const u = (C) => A.headers.get(C),
+                                    const u = (w) => A.headers.get(w),
                                         {
-                                            allowRangeRequests: _,
-                                            suggestedLength: w
+                                            allowRangeRequests: b,
+                                            suggestedLength: E
                                         } = (0, P.validateRangeRequestCapabilities)({
                                             getResponseHeader: u,
                                             isHttp: this._stream.isHttp,
                                             rangeChunkSize: this._rangeChunkSize,
                                             disableRange: this._disableRange
                                         });
-                                    this._isRangeSupported = _, this._contentLength = w || this._contentLength, this._filename = (0, P.extractFilenameFromHeader)(u), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new l.AbortException("Streaming is disabled."));
+                                    this._isRangeSupported = b, this._contentLength = E || this._contentLength, this._filename = (0, P.extractFilenameFromHeader)(u), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new c.AbortException("Streaming is disabled."));
                                 }).catch(this._headersCapability.reject), this.onProgress = null;
                             }
                             get headersReady() {
                                 return this._headersCapability.promise;
                             }
                             get filename() {
                                 return this._filename;
@@ -7344,393 +7338,393 @@
                             get isStreamingSupported() {
                                 return this._isStreamingSupported;
                             }
                             async read() {
                                 var v;
                                 await this._headersCapability.promise;
                                 const {
-                                    value: I,
-                                    done: x
+                                    value: O,
+                                    done: T
                                 } = await this._reader.read();
-                                return x ? {
-                                    value: I,
-                                    done: x
-                                } : (this._loaded += I.byteLength, (v = this.onProgress) == null || v.call(this, {
+                                return T ? {
+                                    value: O,
+                                    done: T
+                                } : (this._loaded += O.byteLength, (v = this.onProgress) == null || v.call(this, {
                                     loaded: this._loaded,
                                     total: this._contentLength
                                 }), {
-                                    value: pt(I),
+                                    value: pt(O),
                                     done: !1
                                 });
                             }
-                            cancel(I) {
-                                var x;
-                                (x = this._reader) == null || x.cancel(I), this._abortController.abort();
+                            cancel(O) {
+                                var T;
+                                (T = this._reader) == null || T.cancel(O), this._abortController.abort();
                             }
                         }
                         class g {
-                            constructor(I, x, v) {
-                                this._stream = I, this._reader = null, this._loaded = 0;
-                                const A = I.source;
-                                this._withCredentials = A.withCredentials || !1, this._readCapability = new l.PromiseCapability(), this._isStreamingSupported = !A.disableStream, this._abortController = new AbortController(), this._headers = X(this._stream.httpHeaders), this._headers.append("Range", `bytes=${x}-${v - 1}`);
+                            constructor(O, T, v) {
+                                this._stream = O, this._reader = null, this._loaded = 0;
+                                const A = O.source;
+                                this._withCredentials = A.withCredentials || !1, this._readCapability = new c.PromiseCapability(), this._isStreamingSupported = !A.disableStream, this._abortController = new AbortController(), this._headers = X(this._stream.httpHeaders), this._headers.append("Range", `bytes=${T}-${v - 1}`);
                                 const u = A.url;
-                                fetch(u, rt(this._headers, this._withCredentials, this._abortController)).then((_) => {
-                                    if (!(0, P.validateResponseStatus)(_.status))
-                                        throw (0, P.createResponseStatusError)(_.status, u);
-                                    this._readCapability.resolve(), this._reader = _.body.getReader();
+                                fetch(u, rt(this._headers, this._withCredentials, this._abortController)).then((b) => {
+                                    if (!(0, P.validateResponseStatus)(b.status))
+                                        throw (0, P.createResponseStatusError)(b.status, u);
+                                    this._readCapability.resolve(), this._reader = b.body.getReader();
                                 }).catch(this._readCapability.reject), this.onProgress = null;
                             }
                             get isStreamingSupported() {
                                 return this._isStreamingSupported;
                             }
                             async read() {
                                 var v;
                                 await this._readCapability.promise;
                                 const {
-                                    value: I,
-                                    done: x
+                                    value: O,
+                                    done: T
                                 } = await this._reader.read();
-                                return x ? {
-                                    value: I,
-                                    done: x
-                                } : (this._loaded += I.byteLength, (v = this.onProgress) == null || v.call(this, {
+                                return T ? {
+                                    value: O,
+                                    done: T
+                                } : (this._loaded += O.byteLength, (v = this.onProgress) == null || v.call(this, {
                                     loaded: this._loaded
                                 }), {
-                                    value: pt(I),
+                                    value: pt(O),
                                     done: !1
                                 });
                             }
-                            cancel(I) {
-                                var x;
-                                (x = this._reader) == null || x.cancel(I), this._abortController.abort();
+                            cancel(O) {
+                                var T;
+                                (T = this._reader) == null || T.cancel(O), this._abortController.abort();
                             }
                         }
                     },
                     /* 20 */
                     /***/
                     (dt, d, et) => {
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.createResponseStatusError = B, d.extractFilenameFromHeader = pt, d.validateRangeRequestCapabilities = X, d.validateResponseStatus = F;
-                        var l = et(1),
+                        var c = et(1),
                             P = et(21),
                             rt = et(6);
 
                         function X({
                             getResponseHeader: g,
-                            isHttp: O,
-                            rangeChunkSize: I,
-                            disableRange: x
+                            isHttp: L,
+                            rangeChunkSize: O,
+                            disableRange: T
                         }) {
                             const v = {
                                     allowRangeRequests: !1,
                                     suggestedLength: void 0
                                 },
                                 A = parseInt(g("Content-Length"), 10);
-                            return !Number.isInteger(A) || (v.suggestedLength = A, A <= 2 * I) || x || !O || g("Accept-Ranges") !== "bytes" || (g("Content-Encoding") || "identity") !== "identity" || (v.allowRangeRequests = !0), v;
+                            return !Number.isInteger(A) || (v.suggestedLength = A, A <= 2 * O) || T || !L || g("Accept-Ranges") !== "bytes" || (g("Content-Encoding") || "identity") !== "identity" || (v.allowRangeRequests = !0), v;
                         }
 
                         function pt(g) {
-                            const O = g("Content-Disposition");
-                            if (O) {
-                                let I = (0, P.getFilenameFromContentDispositionHeader)(O);
-                                if (I.includes("%"))
+                            const L = g("Content-Disposition");
+                            if (L) {
+                                let O = (0, P.getFilenameFromContentDispositionHeader)(L);
+                                if (O.includes("%"))
                                     try {
-                                        I = decodeURIComponent(I);
+                                        O = decodeURIComponent(O);
                                     } catch {}
-                                if ((0, rt.isPdfFile)(I))
-                                    return I;
+                                if ((0, rt.isPdfFile)(O))
+                                    return O;
                             }
                             return null;
                         }
 
-                        function B(g, O) {
-                            return g === 404 || g === 0 && O.startsWith("file:") ? new l.MissingPDFException('Missing PDF "' + O + '".') : new l.UnexpectedResponseException(`Unexpected server response (${g}) while retrieving PDF "${O}".`, g);
+                        function B(g, L) {
+                            return g === 404 || g === 0 && L.startsWith("file:") ? new c.MissingPDFException('Missing PDF "' + L + '".') : new c.UnexpectedResponseException(`Unexpected server response (${g}) while retrieving PDF "${L}".`, g);
                         }
 
                         function F(g) {
                             return g === 200 || g === 206;
                         }
                     },
                     /* 21 */
                     /***/
                     (dt, d, et) => {
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.getFilenameFromContentDispositionHeader = P;
-                        var l = et(1);
+                        var c = et(1);
 
                         function P(rt) {
                             let X = !0,
                                 pt = B("filename\\*", "i").exec(rt);
                             if (pt) {
                                 pt = pt[1];
-                                let A = I(pt);
-                                return A = unescape(A), A = x(A), A = v(A), g(A);
+                                let A = O(pt);
+                                return A = unescape(A), A = T(A), A = v(A), g(A);
                             }
-                            if (pt = O(rt), pt) {
+                            if (pt = L(rt), pt) {
                                 const A = v(pt);
                                 return g(A);
                             }
                             if (pt = B("filename", "i").exec(rt), pt) {
                                 pt = pt[1];
-                                let A = I(pt);
+                                let A = O(pt);
                                 return A = v(A), g(A);
                             }
 
                             function B(A, u) {
                                 return new RegExp("(?:^|;)\\s*" + A + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', u);
                             }
 
                             function F(A, u) {
                                 if (A) {
                                     if (!/^[\x00-\xFF]+$/.test(u))
                                         return u;
                                     try {
-                                        const _ = new TextDecoder(A, {
+                                        const b = new TextDecoder(A, {
                                                 fatal: !0
                                             }),
-                                            w = (0, l.stringToBytes)(u);
-                                        u = _.decode(w), X = !1;
+                                            E = (0, c.stringToBytes)(u);
+                                        u = b.decode(E), X = !1;
                                     } catch {}
                                 }
                                 return u;
                             }
 
                             function g(A) {
                                 return X && /[\x80-\xff]/.test(A) && (A = F("utf-8", A), X && (A = F("iso-8859-1", A))), A;
                             }
 
-                            function O(A) {
+                            function L(A) {
                                 const u = [];
-                                let _;
-                                const w = B("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
+                                let b;
+                                const E = B("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                                 for (;
-                                    (_ = w.exec(A)) !== null;) {
-                                    let [, y, a, c] = _;
+                                    (b = E.exec(A)) !== null;) {
+                                    let [, y, a, l] = b;
                                     if (y = parseInt(y, 10), y in u) {
                                         if (y === 0)
                                             break;
                                         continue;
                                     }
-                                    u[y] = [a, c];
+                                    u[y] = [a, l];
                                 }
-                                const C = [];
+                                const w = [];
                                 for (let y = 0; y < u.length && y in u; ++y) {
-                                    let [a, c] = u[y];
-                                    c = I(c), a && (c = unescape(c), y === 0 && (c = x(c))), C.push(c);
+                                    let [a, l] = u[y];
+                                    l = O(l), a && (l = unescape(l), y === 0 && (l = T(l))), w.push(l);
                                 }
-                                return C.join("");
+                                return w.join("");
                             }
 
-                            function I(A) {
+                            function O(A) {
                                 if (A.startsWith('"')) {
                                     const u = A.slice(1).split('\\"');
-                                    for (let _ = 0; _ < u.length; ++_) {
-                                        const w = u[_].indexOf('"');
-                                        w !== -1 && (u[_] = u[_].slice(0, w), u.length = _ + 1), u[_] = u[_].replaceAll(/\\(.)/g, "$1");
+                                    for (let b = 0; b < u.length; ++b) {
+                                        const E = u[b].indexOf('"');
+                                        E !== -1 && (u[b] = u[b].slice(0, E), u.length = b + 1), u[b] = u[b].replaceAll(/\\(.)/g, "$1");
                                     }
                                     A = u.join('"');
                                 }
                                 return A;
                             }
 
-                            function x(A) {
+                            function T(A) {
                                 const u = A.indexOf("'");
                                 if (u === -1)
                                     return A;
-                                const _ = A.slice(0, u),
-                                    C = A.slice(u + 1).replace(/^[^']*'/, "");
-                                return F(_, C);
+                                const b = A.slice(0, u),
+                                    w = A.slice(u + 1).replace(/^[^']*'/, "");
+                                return F(b, w);
                             }
 
                             function v(A) {
-                                return !A.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(A) ? A : A.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(u, _, w, C) {
-                                    if (w === "q" || w === "Q")
-                                        return C = C.replaceAll("_", " "), C = C.replaceAll(/=([0-9a-fA-F]{2})/g, function(y, a) {
+                                return !A.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(A) ? A : A.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(u, b, E, w) {
+                                    if (E === "q" || E === "Q")
+                                        return w = w.replaceAll("_", " "), w = w.replaceAll(/=([0-9a-fA-F]{2})/g, function(y, a) {
                                             return String.fromCharCode(parseInt(a, 16));
-                                        }), F(_, C);
+                                        }), F(b, w);
                                     try {
-                                        C = atob(C);
+                                        w = atob(w);
                                     } catch {}
-                                    return F(_, C);
+                                    return F(b, w);
                                 });
                             }
                             return "";
                         }
                     },
                     /* 22 */
                     /***/
                     (dt, d, et) => {
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.PDFNetworkStream = void 0;
-                        var l = et(1),
+                        var c = et(1),
                             P = et(20);
                         const rt = 200,
                             X = 206;
 
-                        function pt(I) {
-                            const x = I.response;
-                            return typeof x != "string" ? x : (0, l.stringToBytes)(x).buffer;
+                        function pt(O) {
+                            const T = O.response;
+                            return typeof T != "string" ? T : (0, c.stringToBytes)(T).buffer;
                         }
                         class B {
-                            constructor(x, v = {}) {
-                                this.url = x, this.isHttp = /^https?:/i.test(x), this.httpHeaders = this.isHttp && v.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = v.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
+                            constructor(T, v = {}) {
+                                this.url = T, this.isHttp = /^https?:/i.test(T), this.httpHeaders = this.isHttp && v.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = v.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
                             }
-                            requestRange(x, v, A) {
+                            requestRange(T, v, A) {
                                 const u = {
-                                    begin: x,
+                                    begin: T,
                                     end: v
                                 };
-                                for (const _ in A)
-                                    u[_] = A[_];
+                                for (const b in A)
+                                    u[b] = A[b];
                                 return this.request(u);
                             }
-                            requestFull(x) {
-                                return this.request(x);
+                            requestFull(T) {
+                                return this.request(T);
                             }
-                            request(x) {
+                            request(T) {
                                 const v = new XMLHttpRequest(),
                                     A = this.currXhrId++,
                                     u = this.pendingRequests[A] = {
                                         xhr: v
                                     };
                                 v.open("GET", this.url), v.withCredentials = this.withCredentials;
-                                for (const _ in this.httpHeaders) {
-                                    const w = this.httpHeaders[_];
-                                    w !== void 0 && v.setRequestHeader(_, w);
-                                }
-                                return this.isHttp && "begin" in x && "end" in x ? (v.setRequestHeader("Range", `bytes=${x.begin}-${x.end - 1}`), u.expectedStatus = X) : u.expectedStatus = rt, v.responseType = "arraybuffer", x.onError && (v.onerror = function(_) {
-                                    x.onError(v.status);
-                                }), v.onreadystatechange = this.onStateChange.bind(this, A), v.onprogress = this.onProgress.bind(this, A), u.onHeadersReceived = x.onHeadersReceived, u.onDone = x.onDone, u.onError = x.onError, u.onProgress = x.onProgress, v.send(null), A;
+                                for (const b in this.httpHeaders) {
+                                    const E = this.httpHeaders[b];
+                                    E !== void 0 && v.setRequestHeader(b, E);
+                                }
+                                return this.isHttp && "begin" in T && "end" in T ? (v.setRequestHeader("Range", `bytes=${T.begin}-${T.end - 1}`), u.expectedStatus = X) : u.expectedStatus = rt, v.responseType = "arraybuffer", T.onError && (v.onerror = function(b) {
+                                    T.onError(v.status);
+                                }), v.onreadystatechange = this.onStateChange.bind(this, A), v.onprogress = this.onProgress.bind(this, A), u.onHeadersReceived = T.onHeadersReceived, u.onDone = T.onDone, u.onError = T.onError, u.onProgress = T.onProgress, v.send(null), A;
                             }
-                            onProgress(x, v) {
+                            onProgress(T, v) {
                                 var u;
-                                const A = this.pendingRequests[x];
+                                const A = this.pendingRequests[T];
                                 A && ((u = A.onProgress) == null || u.call(A, v));
                             }
-                            onStateChange(x, v) {
-                                var y, a, c;
-                                const A = this.pendingRequests[x];
+                            onStateChange(T, v) {
+                                var y, a, l;
+                                const A = this.pendingRequests[T];
                                 if (!A)
                                     return;
                                 const u = A.xhr;
-                                if (u.readyState >= 2 && A.onHeadersReceived && (A.onHeadersReceived(), delete A.onHeadersReceived), u.readyState !== 4 || !(x in this.pendingRequests))
+                                if (u.readyState >= 2 && A.onHeadersReceived && (A.onHeadersReceived(), delete A.onHeadersReceived), u.readyState !== 4 || !(T in this.pendingRequests))
                                     return;
-                                if (delete this.pendingRequests[x], u.status === 0 && this.isHttp) {
+                                if (delete this.pendingRequests[T], u.status === 0 && this.isHttp) {
                                     (y = A.onError) == null || y.call(A, u.status);
                                     return;
                                 }
-                                const _ = u.status || rt;
-                                if (!(_ === rt && A.expectedStatus === X) && _ !== A.expectedStatus) {
+                                const b = u.status || rt;
+                                if (!(b === rt && A.expectedStatus === X) && b !== A.expectedStatus) {
                                     (a = A.onError) == null || a.call(A, u.status);
                                     return;
                                 }
-                                const C = pt(u);
-                                if (_ === X) {
+                                const w = pt(u);
+                                if (b === X) {
                                     const k = u.getResponseHeader("Content-Range"),
                                         p = /bytes (\d+)-(\d+)\/(\d+)/.exec(k);
                                     A.onDone({
                                         begin: parseInt(p[1], 10),
-                                        chunk: C
+                                        chunk: w
                                     });
                                 } else
-                                    C ? A.onDone({
+                                    w ? A.onDone({
                                         begin: 0,
-                                        chunk: C
-                                    }) : (c = A.onError) == null || c.call(A, u.status);
+                                        chunk: w
+                                    }) : (l = A.onError) == null || l.call(A, u.status);
                             }
-                            getRequestXhr(x) {
-                                return this.pendingRequests[x].xhr;
+                            getRequestXhr(T) {
+                                return this.pendingRequests[T].xhr;
                             }
-                            isPendingRequest(x) {
-                                return x in this.pendingRequests;
+                            isPendingRequest(T) {
+                                return T in this.pendingRequests;
                             }
-                            abortRequest(x) {
-                                const v = this.pendingRequests[x].xhr;
-                                delete this.pendingRequests[x], v.abort();
+                            abortRequest(T) {
+                                const v = this.pendingRequests[T].xhr;
+                                delete this.pendingRequests[T], v.abort();
                             }
                         }
                         class F {
-                            constructor(x) {
-                                this._source = x, this._manager = new B(x.url, {
-                                    httpHeaders: x.httpHeaders,
-                                    withCredentials: x.withCredentials
-                                }), this._rangeChunkSize = x.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
+                            constructor(T) {
+                                this._source = T, this._manager = new B(T.url, {
+                                    httpHeaders: T.httpHeaders,
+                                    withCredentials: T.withCredentials
+                                }), this._rangeChunkSize = T.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
                             }
-                            _onRangeRequestReaderClosed(x) {
-                                const v = this._rangeRequestReaders.indexOf(x);
+                            _onRangeRequestReaderClosed(T) {
+                                const v = this._rangeRequestReaders.indexOf(T);
                                 v >= 0 && this._rangeRequestReaders.splice(v, 1);
                             }
                             getFullReader() {
-                                return (0, l.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new g(this._manager, this._source), this._fullRequestReader;
+                                return (0, c.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new g(this._manager, this._source), this._fullRequestReader;
                             }
-                            getRangeReader(x, v) {
-                                const A = new O(this._manager, x, v);
+                            getRangeReader(T, v) {
+                                const A = new L(this._manager, T, v);
                                 return A.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(A), A;
                             }
-                            cancelAllRequests(x) {
+                            cancelAllRequests(T) {
                                 var v;
-                                (v = this._fullRequestReader) == null || v.cancel(x);
+                                (v = this._fullRequestReader) == null || v.cancel(T);
                                 for (const A of this._rangeRequestReaders.slice(0))
-                                    A.cancel(x);
+                                    A.cancel(T);
                             }
                         }
                         d.PDFNetworkStream = F;
                         class g {
-                            constructor(x, v) {
-                                this._manager = x;
+                            constructor(T, v) {
+                                this._manager = T;
                                 const A = {
                                     onHeadersReceived: this._onHeadersReceived.bind(this),
                                     onDone: this._onDone.bind(this),
                                     onError: this._onError.bind(this),
                                     onProgress: this._onProgress.bind(this)
                                 };
-                                this._url = v.url, this._fullRequestId = x.requestFull(A), this._headersReceivedCapability = new l.PromiseCapability(), this._disableRange = v.disableRange || !1, this._contentLength = v.length, this._rangeChunkSize = v.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
+                                this._url = v.url, this._fullRequestId = T.requestFull(A), this._headersReceivedCapability = new c.PromiseCapability(), this._disableRange = v.disableRange || !1, this._contentLength = v.length, this._rangeChunkSize = v.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
                             }
                             _onHeadersReceived() {
-                                const x = this._fullRequestId,
-                                    v = this._manager.getRequestXhr(x),
-                                    A = (w) => v.getResponseHeader(w),
+                                const T = this._fullRequestId,
+                                    v = this._manager.getRequestXhr(T),
+                                    A = (E) => v.getResponseHeader(E),
                                     {
                                         allowRangeRequests: u,
-                                        suggestedLength: _
+                                        suggestedLength: b
                                     } = (0, P.validateRangeRequestCapabilities)({
                                         getResponseHeader: A,
                                         isHttp: this._manager.isHttp,
                                         rangeChunkSize: this._rangeChunkSize,
                                         disableRange: this._disableRange
                                     });
-                                u && (this._isRangeSupported = !0), this._contentLength = _ || this._contentLength, this._filename = (0, P.extractFilenameFromHeader)(A), this._isRangeSupported && this._manager.abortRequest(x), this._headersReceivedCapability.resolve();
+                                u && (this._isRangeSupported = !0), this._contentLength = b || this._contentLength, this._filename = (0, P.extractFilenameFromHeader)(A), this._isRangeSupported && this._manager.abortRequest(T), this._headersReceivedCapability.resolve();
                             }
-                            _onDone(x) {
-                                if (x && (this._requests.length > 0 ? this._requests.shift().resolve({
-                                        value: x.chunk,
+                            _onDone(T) {
+                                if (T && (this._requests.length > 0 ? this._requests.shift().resolve({
+                                        value: T.chunk,
                                         done: !1
-                                    }) : this._cachedChunks.push(x.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
+                                    }) : this._cachedChunks.push(T.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
                                     for (const v of this._requests)
                                         v.resolve({
                                             value: void 0,
                                             done: !0
                                         });
                                     this._requests.length = 0;
                                 }
                             }
-                            _onError(x) {
-                                this._storedError = (0, P.createResponseStatusError)(x, this._url), this._headersReceivedCapability.reject(this._storedError);
+                            _onError(T) {
+                                this._storedError = (0, P.createResponseStatusError)(T, this._url), this._headersReceivedCapability.reject(this._storedError);
                                 for (const v of this._requests)
                                     v.reject(this._storedError);
                                 this._requests.length = 0, this._cachedChunks.length = 0;
                             }
-                            _onProgress(x) {
+                            _onProgress(T) {
                                 var v;
                                 (v = this.onProgress) == null || v.call(this, {
-                                    loaded: x.loaded,
-                                    total: x.lengthComputable ? x.total : this._contentLength
+                                    loaded: T.loaded,
+                                    total: T.lengthComputable ? T.total : this._contentLength
                                 });
                             }
                             get filename() {
                                 return this._filename;
                             }
                             get isRangeSupported() {
                                 return this._isRangeSupported;
@@ -7753,64 +7747,64 @@
                                         done: !1
                                     };
                                 if (this._done)
                                     return {
                                         value: void 0,
                                         done: !0
                                     };
-                                const x = new l.PromiseCapability();
-                                return this._requests.push(x), x.promise;
+                                const T = new c.PromiseCapability();
+                                return this._requests.push(T), T.promise;
                             }
-                            cancel(x) {
-                                this._done = !0, this._headersReceivedCapability.reject(x);
+                            cancel(T) {
+                                this._done = !0, this._headersReceivedCapability.reject(T);
                                 for (const v of this._requests)
                                     v.resolve({
                                         value: void 0,
                                         done: !0
                                     });
                                 this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
                             }
                         }
-                        class O {
-                            constructor(x, v, A) {
-                                this._manager = x;
+                        class L {
+                            constructor(T, v, A) {
+                                this._manager = T;
                                 const u = {
                                     onDone: this._onDone.bind(this),
                                     onError: this._onError.bind(this),
                                     onProgress: this._onProgress.bind(this)
                                 };
-                                this._url = x.url, this._requestId = x.requestRange(v, A, u), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
+                                this._url = T.url, this._requestId = T.requestRange(v, A, u), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
                             }
                             _close() {
-                                var x;
-                                (x = this.onClosed) == null || x.call(this, this);
+                                var T;
+                                (T = this.onClosed) == null || T.call(this, this);
                             }
-                            _onDone(x) {
-                                const v = x.chunk;
+                            _onDone(T) {
+                                const v = T.chunk;
                                 this._requests.length > 0 ? this._requests.shift().resolve({
                                     value: v,
                                     done: !1
                                 }) : this._queuedChunk = v, this._done = !0;
                                 for (const A of this._requests)
                                     A.resolve({
                                         value: void 0,
                                         done: !0
                                     });
                                 this._requests.length = 0, this._close();
                             }
-                            _onError(x) {
-                                this._storedError = (0, P.createResponseStatusError)(x, this._url);
+                            _onError(T) {
+                                this._storedError = (0, P.createResponseStatusError)(T, this._url);
                                 for (const v of this._requests)
                                     v.reject(this._storedError);
                                 this._requests.length = 0, this._queuedChunk = null;
                             }
-                            _onProgress(x) {
+                            _onProgress(T) {
                                 var v;
                                 this.isStreamingSupported || (v = this.onProgress) == null || v.call(this, {
-                                    loaded: x.loaded
+                                    loaded: T.loaded
                                 });
                             }
                             get isStreamingSupported() {
                                 return !1;
                             }
                             async read() {
                                 if (this._storedError)
@@ -7823,18 +7817,18 @@
                                     };
                                 }
                                 if (this._done)
                                     return {
                                         value: void 0,
                                         done: !0
                                     };
-                                const x = new l.PromiseCapability();
-                                return this._requests.push(x), x.promise;
+                                const T = new c.PromiseCapability();
+                                return this._requests.push(T), T.promise;
                             }
-                            cancel(x) {
+                            cancel(T) {
                                 this._done = !0;
                                 for (const v of this._requests)
                                     v.resolve({
                                         value: void 0,
                                         done: !0
                                     });
                                 this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
@@ -7843,53 +7837,53 @@
                     },
                     /* 23 */
                     /***/
                     (dt, d, et) => {
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.PDFNodeStream = void 0;
-                        var l = et(1),
+                        var c = et(1),
                             P = et(20);
                         const rt = /^file:\/\/\/[a-zA-Z]:\//;
 
                         function X(A) {
                             const u = require$$5,
-                                _ = u.parse(A);
-                            return _.protocol === "file:" || _.host ? _ : /^[a-z]:[/\\]/i.test(A) ? u.parse(`file:///${A}`) : (_.host || (_.protocol = "file:"), _);
+                                b = u.parse(A);
+                            return b.protocol === "file:" || b.host ? b : /^[a-z]:[/\\]/i.test(A) ? u.parse(`file:///${A}`) : (b.host || (b.protocol = "file:"), b);
                         }
                         class pt {
                             constructor(u) {
                                 this.source = u, this.url = X(u.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && u.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
                             }
                             get _progressiveDataLength() {
                                 var u;
                                 return ((u = this._fullRequestReader) == null ? void 0 : u._loaded) ?? 0;
                             }
                             getFullReader() {
-                                return (0, l.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new x(this) : new O(this), this._fullRequestReader;
+                                return (0, c.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new T(this) : new L(this), this._fullRequestReader;
                             }
-                            getRangeReader(u, _) {
-                                if (_ <= this._progressiveDataLength)
+                            getRangeReader(u, b) {
+                                if (b <= this._progressiveDataLength)
                                     return null;
-                                const w = this.isFsUrl ? new v(this, u, _) : new I(this, u, _);
-                                return this._rangeRequestReaders.push(w), w;
+                                const E = this.isFsUrl ? new v(this, u, b) : new O(this, u, b);
+                                return this._rangeRequestReaders.push(E), E;
                             }
                             cancelAllRequests(u) {
-                                var _;
-                                (_ = this._fullRequestReader) == null || _.cancel(u);
-                                for (const w of this._rangeRequestReaders.slice(0))
-                                    w.cancel(u);
+                                var b;
+                                (b = this._fullRequestReader) == null || b.cancel(u);
+                                for (const E of this._rangeRequestReaders.slice(0))
+                                    E.cancel(u);
                             }
                         }
                         d.PDFNodeStream = pt;
                         class B {
                             constructor(u) {
                                 this._url = u.url, this._done = !1, this._storedError = null, this.onProgress = null;
-                                const _ = u.source;
-                                this._contentLength = _.length, this._loaded = 0, this._filename = null, this._disableRange = _.disableRange || !1, this._rangeChunkSize = _.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !_.disableStream, this._isRangeSupported = !_.disableRange, this._readableStream = null, this._readCapability = new l.PromiseCapability(), this._headersCapability = new l.PromiseCapability();
+                                const b = u.source;
+                                this._contentLength = b.length, this._loaded = 0, this._filename = null, this._disableRange = b.disableRange || !1, this._rangeChunkSize = b.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !b.disableStream, this._isRangeSupported = !b.disableRange, this._readableStream = null, this._readCapability = new c.PromiseCapability(), this._headersCapability = new c.PromiseCapability();
                             }
                             get headersReady() {
                                 return this._headersCapability.promise;
                             }
                             get filename() {
                                 return this._filename;
                             }
@@ -7899,24 +7893,24 @@
                             get isRangeSupported() {
                                 return this._isRangeSupported;
                             }
                             get isStreamingSupported() {
                                 return this._isStreamingSupported;
                             }
                             async read() {
-                                var w;
+                                var E;
                                 if (await this._readCapability.promise, this._done)
                                     return {
                                         value: void 0,
                                         done: !0
                                     };
                                 if (this._storedError)
                                     throw this._storedError;
                                 const u = this._readableStream.read();
-                                return u === null ? (this._readCapability = new l.PromiseCapability(), this.read()) : (this._loaded += u.length, (w = this.onProgress) == null || w.call(this, {
+                                return u === null ? (this._readCapability = new c.PromiseCapability(), this.read()) : (this._loaded += u.length, (E = this.onProgress) == null || E.call(this, {
                                     loaded: this._loaded,
                                     total: this._contentLength
                                 }), {
                                     value: new Uint8Array(u).buffer,
                                     done: !1
                                 });
                             }
@@ -7931,39 +7925,39 @@
                                 this._storedError = u, this._readCapability.resolve();
                             }
                             _setReadableStream(u) {
                                 this._readableStream = u, u.on("readable", () => {
                                     this._readCapability.resolve();
                                 }), u.on("end", () => {
                                     u.destroy(), this._done = !0, this._readCapability.resolve();
-                                }), u.on("error", (_) => {
-                                    this._error(_);
-                                }), !this._isStreamingSupported && this._isRangeSupported && this._error(new l.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
+                                }), u.on("error", (b) => {
+                                    this._error(b);
+                                }), !this._isStreamingSupported && this._isRangeSupported && this._error(new c.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
                             }
                         }
                         class F {
                             constructor(u) {
-                                this._url = u.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = new l.PromiseCapability();
-                                const _ = u.source;
-                                this._isStreamingSupported = !_.disableStream;
+                                this._url = u.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = new c.PromiseCapability();
+                                const b = u.source;
+                                this._isStreamingSupported = !b.disableStream;
                             }
                             get isStreamingSupported() {
                                 return this._isStreamingSupported;
                             }
                             async read() {
-                                var w;
+                                var E;
                                 if (await this._readCapability.promise, this._done)
                                     return {
                                         value: void 0,
                                         done: !0
                                     };
                                 if (this._storedError)
                                     throw this._storedError;
                                 const u = this._readableStream.read();
-                                return u === null ? (this._readCapability = new l.PromiseCapability(), this.read()) : (this._loaded += u.length, (w = this.onProgress) == null || w.call(this, {
+                                return u === null ? (this._readCapability = new c.PromiseCapability(), this.read()) : (this._loaded += u.length, (E = this.onProgress) == null || E.call(this, {
                                     loaded: this._loaded
                                 }), {
                                     value: new Uint8Array(u).buffer,
                                     done: !1
                                 });
                             }
                             cancel(u) {
@@ -7977,16 +7971,16 @@
                                 this._storedError = u, this._readCapability.resolve();
                             }
                             _setReadableStream(u) {
                                 this._readableStream = u, u.on("readable", () => {
                                     this._readCapability.resolve();
                                 }), u.on("end", () => {
                                     u.destroy(), this._done = !0, this._readCapability.resolve();
-                                }), u.on("error", (_) => {
-                                    this._error(_);
+                                }), u.on("error", (b) => {
+                                    this._error(b);
                                 }), this._storedError && this._readableStream.destroy(this._storedError);
                             }
                         }
 
                         function g(A, u) {
                             return {
                                 protocol: A.protocol,
@@ -7994,213 +7988,213 @@
                                 host: A.hostname,
                                 port: A.port,
                                 path: A.path,
                                 method: "GET",
                                 headers: u
                             };
                         }
-                        class O extends B {
+                        class L extends B {
                             constructor(u) {
                                 super(u);
-                                const _ = (w) => {
-                                    if (w.statusCode === 404) {
-                                        const c = new l.MissingPDFException(`Missing PDF "${this._url}".`);
-                                        this._storedError = c, this._headersCapability.reject(c);
+                                const b = (E) => {
+                                    if (E.statusCode === 404) {
+                                        const l = new c.MissingPDFException(`Missing PDF "${this._url}".`);
+                                        this._storedError = l, this._headersCapability.reject(l);
                                         return;
                                     }
-                                    this._headersCapability.resolve(), this._setReadableStream(w);
-                                    const C = (c) => this._readableStream.headers[c.toLowerCase()],
+                                    this._headersCapability.resolve(), this._setReadableStream(E);
+                                    const w = (l) => this._readableStream.headers[l.toLowerCase()],
                                         {
                                             allowRangeRequests: y,
                                             suggestedLength: a
                                         } = (0, P.validateRangeRequestCapabilities)({
-                                            getResponseHeader: C,
+                                            getResponseHeader: w,
                                             isHttp: u.isHttp,
                                             rangeChunkSize: this._rangeChunkSize,
                                             disableRange: this._disableRange
                                         });
-                                    this._isRangeSupported = y, this._contentLength = a || this._contentLength, this._filename = (0, P.extractFilenameFromHeader)(C);
+                                    this._isRangeSupported = y, this._contentLength = a || this._contentLength, this._filename = (0, P.extractFilenameFromHeader)(w);
                                 };
                                 if (this._request = null, this._url.protocol === "http:") {
-                                    const w = require$$5;
-                                    this._request = w.request(g(this._url, u.httpHeaders), _);
+                                    const E = require$$5;
+                                    this._request = E.request(g(this._url, u.httpHeaders), b);
                                 } else {
-                                    const w = require$$5;
-                                    this._request = w.request(g(this._url, u.httpHeaders), _);
+                                    const E = require$$5;
+                                    this._request = E.request(g(this._url, u.httpHeaders), b);
                                 }
-                                this._request.on("error", (w) => {
-                                    this._storedError = w, this._headersCapability.reject(w);
+                                this._request.on("error", (E) => {
+                                    this._storedError = E, this._headersCapability.reject(E);
                                 }), this._request.end();
                             }
                         }
-                        class I extends F {
-                            constructor(u, _, w) {
+                        class O extends F {
+                            constructor(u, b, E) {
                                 super(u), this._httpHeaders = {};
                                 for (const y in u.httpHeaders) {
                                     const a = u.httpHeaders[y];
                                     a !== void 0 && (this._httpHeaders[y] = a);
                                 }
-                                this._httpHeaders.Range = `bytes=${_}-${w - 1}`;
-                                const C = (y) => {
+                                this._httpHeaders.Range = `bytes=${b}-${E - 1}`;
+                                const w = (y) => {
                                     if (y.statusCode === 404) {
-                                        const a = new l.MissingPDFException(`Missing PDF "${this._url}".`);
+                                        const a = new c.MissingPDFException(`Missing PDF "${this._url}".`);
                                         this._storedError = a;
                                         return;
                                     }
                                     this._setReadableStream(y);
                                 };
                                 if (this._request = null, this._url.protocol === "http:") {
                                     const y = require$$5;
-                                    this._request = y.request(g(this._url, this._httpHeaders), C);
+                                    this._request = y.request(g(this._url, this._httpHeaders), w);
                                 } else {
                                     const y = require$$5;
-                                    this._request = y.request(g(this._url, this._httpHeaders), C);
+                                    this._request = y.request(g(this._url, this._httpHeaders), w);
                                 }
                                 this._request.on("error", (y) => {
                                     this._storedError = y;
                                 }), this._request.end();
                             }
                         }
-                        class x extends B {
+                        class T extends B {
                             constructor(u) {
                                 super(u);
-                                let _ = decodeURIComponent(this._url.path);
-                                rt.test(this._url.href) && (_ = _.replace(/^\//, ""));
-                                const w = require$$5;
-                                w.lstat(_, (C, y) => {
-                                    if (C) {
-                                        C.code === "ENOENT" && (C = new l.MissingPDFException(`Missing PDF "${_}".`)), this._storedError = C, this._headersCapability.reject(C);
+                                let b = decodeURIComponent(this._url.path);
+                                rt.test(this._url.href) && (b = b.replace(/^\//, ""));
+                                const E = require$$5;
+                                E.lstat(b, (w, y) => {
+                                    if (w) {
+                                        w.code === "ENOENT" && (w = new c.MissingPDFException(`Missing PDF "${b}".`)), this._storedError = w, this._headersCapability.reject(w);
                                         return;
                                     }
-                                    this._contentLength = y.size, this._setReadableStream(w.createReadStream(_)), this._headersCapability.resolve();
+                                    this._contentLength = y.size, this._setReadableStream(E.createReadStream(b)), this._headersCapability.resolve();
                                 });
                             }
                         }
                         class v extends F {
-                            constructor(u, _, w) {
+                            constructor(u, b, E) {
                                 super(u);
-                                let C = decodeURIComponent(this._url.path);
-                                rt.test(this._url.href) && (C = C.replace(/^\//, ""));
+                                let w = decodeURIComponent(this._url.path);
+                                rt.test(this._url.href) && (w = w.replace(/^\//, ""));
                                 const y = require$$5;
-                                this._setReadableStream(y.createReadStream(C, {
-                                    start: _,
-                                    end: w - 1
+                                this._setReadableStream(y.createReadStream(w, {
+                                    start: b,
+                                    end: E - 1
                                 }));
                             }
                         }
                     },
                     /* 24 */
                     /***/
                     (dt, d, et) => {
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.SVGGraphics = void 0;
-                        var l = et(6),
+                        var c = et(6),
                             P = et(1);
                         const rt = {
                                 fontStyle: "normal",
                                 fontWeight: "normal",
                                 fillColor: "#000000"
                             },
                             X = "http://www.w3.org/XML/1998/namespace",
                             pt = "http://www.w3.org/1999/xlink",
                             B = ["butt", "round", "square"],
                             F = ["miter", "round", "bevel"],
-                            g = function(y, a = "", c = !1) {
-                                if (URL.createObjectURL && typeof Blob < "u" && !c)
+                            g = function(y, a = "", l = !1) {
+                                if (URL.createObjectURL && typeof Blob < "u" && !l)
                                     return URL.createObjectURL(new Blob([y], {
                                         type: a
                                     }));
                                 const k = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                                 let p = `data:${a};base64,`;
-                                for (let r = 0, T = y.length; r < T; r += 3) {
+                                for (let r = 0, x = y.length; r < x; r += 3) {
                                     const m = y[r] & 255,
                                         U = y[r + 1] & 255,
                                         z = y[r + 2] & 255,
-                                        E = m >> 2,
+                                        C = m >> 2,
                                         V = (m & 3) << 4 | U >> 4,
-                                        st = r + 1 < T ? (U & 15) << 2 | z >> 6 : 64,
-                                        at = r + 2 < T ? z & 63 : 64;
-                                    p += k[E] + k[V] + k[st] + k[at];
+                                        st = r + 1 < x ? (U & 15) << 2 | z >> 6 : 64,
+                                        at = r + 2 < x ? z & 63 : 64;
+                                    p += k[C] + k[V] + k[st] + k[at];
                                 }
                                 return p;
                             },
-                            O = function() {
+                            L = function() {
                                 const y = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]),
                                     a = 12,
-                                    c = new Int32Array(256);
+                                    l = new Int32Array(256);
                                 for (let z = 0; z < 256; z++) {
-                                    let E = z;
+                                    let C = z;
                                     for (let V = 0; V < 8; V++)
-                                        E = E & 1 ? 3988292384 ^ E >> 1 & 2147483647 : E >> 1 & 2147483647;
-                                    c[z] = E;
+                                        C = C & 1 ? 3988292384 ^ C >> 1 & 2147483647 : C >> 1 & 2147483647;
+                                    l[z] = C;
                                 }
 
-                                function k(z, E, V) {
+                                function k(z, C, V) {
                                     let st = -1;
-                                    for (let at = E; at < V; at++) {
+                                    for (let at = C; at < V; at++) {
                                         const H = (st ^ z[at]) & 255,
-                                            lt = c[H];
+                                            lt = l[H];
                                         st = st >>> 8 ^ lt;
                                     }
                                     return st ^ -1;
                                 }
 
-                                function p(z, E, V, st) {
+                                function p(z, C, V, st) {
                                     let at = st;
-                                    const H = E.length;
-                                    V[at] = H >> 24 & 255, V[at + 1] = H >> 16 & 255, V[at + 2] = H >> 8 & 255, V[at + 3] = H & 255, at += 4, V[at] = z.charCodeAt(0) & 255, V[at + 1] = z.charCodeAt(1) & 255, V[at + 2] = z.charCodeAt(2) & 255, V[at + 3] = z.charCodeAt(3) & 255, at += 4, V.set(E, at), at += E.length;
+                                    const H = C.length;
+                                    V[at] = H >> 24 & 255, V[at + 1] = H >> 16 & 255, V[at + 2] = H >> 8 & 255, V[at + 3] = H & 255, at += 4, V[at] = z.charCodeAt(0) & 255, V[at + 1] = z.charCodeAt(1) & 255, V[at + 2] = z.charCodeAt(2) & 255, V[at + 3] = z.charCodeAt(3) & 255, at += 4, V.set(C, at), at += C.length;
                                     const lt = k(V, st + 4, at);
                                     V[at] = lt >> 24 & 255, V[at + 1] = lt >> 16 & 255, V[at + 2] = lt >> 8 & 255, V[at + 3] = lt & 255;
                                 }
 
-                                function r(z, E, V) {
+                                function r(z, C, V) {
                                     let st = 1,
                                         at = 0;
-                                    for (let H = E; H < V; ++H)
+                                    for (let H = C; H < V; ++H)
                                         st = (st + (z[H] & 255)) % 65521, at = (at + st) % 65521;
                                     return at << 16 | st;
                                 }
 
-                                function T(z) {
+                                function x(z) {
                                     if (!P.isNodeJS)
                                         return m(z);
                                     try {
-                                        const E = parseInt(process.versions.node) >= 8 ? z : Buffer.from(z),
-                                            V = require$$5.deflateSync(E, {
+                                        const C = parseInt(process.versions.node) >= 8 ? z : Buffer.from(z),
+                                            V = require$$5.deflateSync(C, {
                                                 level: 9
                                             });
                                         return V instanceof Uint8Array ? V : new Uint8Array(V);
-                                    } catch (E) {
-                                        (0, P.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + E);
+                                    } catch (C) {
+                                        (0, P.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + C);
                                     }
                                     return m(z);
                                 }
 
                                 function m(z) {
-                                    let E = z.length;
+                                    let C = z.length;
                                     const V = 65535,
-                                        st = Math.ceil(E / V),
-                                        at = new Uint8Array(2 + E + st * 5 + 4);
+                                        st = Math.ceil(C / V),
+                                        at = new Uint8Array(2 + C + st * 5 + 4);
                                     let H = 0;
                                     at[H++] = 120, at[H++] = 156;
                                     let lt = 0;
-                                    for (; E > V;)
-                                        at[H++] = 0, at[H++] = 255, at[H++] = 255, at[H++] = 0, at[H++] = 0, at.set(z.subarray(lt, lt + V), H), H += V, lt += V, E -= V;
-                                    at[H++] = 1, at[H++] = E & 255, at[H++] = E >> 8 & 255, at[H++] = ~E & 65535 & 255, at[H++] = (~E & 65535) >> 8 & 255, at.set(z.subarray(lt), H), H += z.length - lt;
+                                    for (; C > V;)
+                                        at[H++] = 0, at[H++] = 255, at[H++] = 255, at[H++] = 0, at[H++] = 0, at.set(z.subarray(lt, lt + V), H), H += V, lt += V, C -= V;
+                                    at[H++] = 1, at[H++] = C & 255, at[H++] = C >> 8 & 255, at[H++] = ~C & 65535 & 255, at[H++] = (~C & 65535) >> 8 & 255, at.set(z.subarray(lt), H), H += z.length - lt;
                                     const gt = r(z, 0, z.length);
                                     return at[H++] = gt >> 24 & 255, at[H++] = gt >> 16 & 255, at[H++] = gt >> 8 & 255, at[H++] = gt & 255, at;
                                 }
 
-                                function U(z, E, V, st) {
+                                function U(z, C, V, st) {
                                     const at = z.width,
                                         H = z.height;
                                     let lt, gt, wt;
-                                    const xt = z.data;
-                                    switch (E) {
+                                    const Pt = z.data;
+                                    switch (C) {
                                         case P.ImageKind.GRAYSCALE_1BPP:
                                             gt = 0, lt = 1, wt = at + 7 >> 3;
                                             break;
                                         case P.ImageKind.RGB_24BPP:
                                             gt = 2, lt = 8, wt = at * 3;
                                             break;
                                         case P.ImageKind.RGBA_32BPP:
@@ -8209,75 +8203,75 @@
                                         default:
                                             throw new Error("invalid format");
                                     }
                                     const S = new Uint8Array((1 + wt) * H);
                                     let i = 0,
                                         n = 0;
                                     for (let N = 0; N < H; ++N)
-                                        S[i++] = 0, S.set(xt.subarray(n, n + wt), i), n += wt, i += wt;
-                                    if (E === P.ImageKind.GRAYSCALE_1BPP && st) {
+                                        S[i++] = 0, S.set(Pt.subarray(n, n + wt), i), n += wt, i += wt;
+                                    if (C === P.ImageKind.GRAYSCALE_1BPP && st) {
                                         i = 0;
                                         for (let N = 0; N < H; N++) {
                                             i++;
                                             for (let tt = 0; tt < wt; tt++)
                                                 S[i++] ^= 255;
                                         }
                                     }
                                     const s = new Uint8Array([at >> 24 & 255, at >> 16 & 255, at >> 8 & 255, at & 255, H >> 24 & 255, H >> 16 & 255, H >> 8 & 255, H & 255, lt, gt, 0, 0, 0]),
-                                        o = T(S),
+                                        o = x(S),
                                         h = y.length + a * 3 + s.length + o.length,
-                                        b = new Uint8Array(h);
+                                        _ = new Uint8Array(h);
                                     let M = 0;
-                                    return b.set(y, M), M += y.length, p("IHDR", s, b, M), M += a + s.length, p("IDATA", o, b, M), M += a + o.length, p("IEND", new Uint8Array(0), b, M), g(b, "image/png", V);
+                                    return _.set(y, M), M += y.length, p("IHDR", s, _, M), M += a + s.length, p("IDATA", o, _, M), M += a + o.length, p("IEND", new Uint8Array(0), _, M), g(_, "image/png", V);
                                 }
-                                return function(E, V, st) {
-                                    const at = E.kind === void 0 ? P.ImageKind.GRAYSCALE_1BPP : E.kind;
-                                    return U(E, at, V, st);
+                                return function(C, V, st) {
+                                    const at = C.kind === void 0 ? P.ImageKind.GRAYSCALE_1BPP : C.kind;
+                                    return U(C, at, V, st);
                                 };
                             }();
-                        class I {
+                        class O {
                             constructor() {
                                 this.fontSizeScale = 1, this.fontWeight = rt.fontWeight, this.fontSize = 0, this.textMatrix = P.IDENTITY_MATRIX, this.fontMatrix = P.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = P.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = rt.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = "";
                             }
                             clone() {
                                 return Object.create(this);
                             }
-                            setCurrentPoint(a, c) {
-                                this.x = a, this.y = c;
+                            setCurrentPoint(a, l) {
+                                this.x = a, this.y = l;
                             }
                         }
 
-                        function x(y) {
+                        function T(y) {
                             let a = [];
-                            const c = [];
+                            const l = [];
                             for (const k of y) {
                                 if (k.fn === "save") {
                                     a.push({
                                         fnId: 92,
                                         fn: "group",
                                         items: []
-                                    }), c.push(a), a = a.at(-1).items;
+                                    }), l.push(a), a = a.at(-1).items;
                                     continue;
                                 }
-                                k.fn === "restore" ? a = c.pop() : a.push(k);
+                                k.fn === "restore" ? a = l.pop() : a.push(k);
                             }
                             return a;
                         }
 
                         function v(y) {
                             if (Number.isInteger(y))
                                 return y.toString();
                             const a = y.toFixed(10);
-                            let c = a.length - 1;
-                            if (a[c] !== "0")
+                            let l = a.length - 1;
+                            if (a[l] !== "0")
                                 return a;
                             do
-                                c--;
-                            while (a[c] === "0");
-                            return a.substring(0, a[c] === "." ? c : c + 1);
+                                l--;
+                            while (a[l] === "0");
+                            return a.substring(0, a[l] === "." ? l : l + 1);
                         }
 
                         function A(y) {
                             if (y[4] === 0 && y[5] === 0) {
                                 if (y[1] === 0 && y[2] === 0)
                                     return y[0] === 1 && y[3] === 1 ? "" : `scale(${v(y[0])} ${v(y[3])})`;
                                 if (y[0] === y[3] && y[1] === -y[2]) {
@@ -8285,79 +8279,79 @@
                                     return `rotate(${v(a)})`;
                                 }
                             } else if (y[0] === 1 && y[1] === 0 && y[2] === 0 && y[3] === 1)
                                 return `translate(${v(y[4])} ${v(y[5])})`;
                             return `matrix(${v(y[0])} ${v(y[1])} ${v(y[2])} ${v(y[3])} ${v(y[4])} ${v(y[5])})`;
                         }
                         let u = 0,
-                            _ = 0,
-                            w = 0;
-                        class C {
-                            constructor(a, c, k = !1) {
-                                (0, l.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future."), this.svgFactory = new l.DOMSVGFactory(), this.current = new I(), this.transformMatrix = P.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = a, this.objs = c, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = /* @__PURE__ */ Object.create(null), this.cssStyle = null, this.forceDataSchema = !!k, this._operatorIdMapping = [];
+                            b = 0,
+                            E = 0;
+                        class w {
+                            constructor(a, l, k = !1) {
+                                (0, c.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future."), this.svgFactory = new c.DOMSVGFactory(), this.current = new O(), this.transformMatrix = P.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = a, this.objs = l, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = /* @__PURE__ */ Object.create(null), this.cssStyle = null, this.forceDataSchema = !!k, this._operatorIdMapping = [];
                                 for (const p in P.OPS)
                                     this._operatorIdMapping[P.OPS[p]] = p;
                             }
-                            getObject(a, c = null) {
-                                return typeof a == "string" ? a.startsWith("g_") ? this.commonObjs.get(a) : this.objs.get(a) : c;
+                            getObject(a, l = null) {
+                                return typeof a == "string" ? a.startsWith("g_") ? this.commonObjs.get(a) : this.objs.get(a) : l;
                             }
                             save() {
                                 this.transformStack.push(this.transformMatrix);
                                 const a = this.current;
                                 this.extraStack.push(a), this.current = a.clone();
                             }
                             restore() {
                                 this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.pendingClip = null, this.tgrp = null;
                             }
                             group(a) {
                                 this.save(), this.executeOpTree(a), this.restore();
                             }
                             loadDependencies(a) {
-                                const c = a.fnArray,
+                                const l = a.fnArray,
                                     k = a.argsArray;
-                                for (let p = 0, r = c.length; p < r; p++)
-                                    if (c[p] === P.OPS.dependency)
-                                        for (const T of k[p]) {
-                                            const m = T.startsWith("g_") ? this.commonObjs : this.objs,
+                                for (let p = 0, r = l.length; p < r; p++)
+                                    if (l[p] === P.OPS.dependency)
+                                        for (const x of k[p]) {
+                                            const m = x.startsWith("g_") ? this.commonObjs : this.objs,
                                                 U = new Promise((z) => {
-                                                    m.get(T, z);
+                                                    m.get(x, z);
                                                 });
                                             this.current.dependencies.push(U);
                                         }
                                 return Promise.all(this.current.dependencies);
                             }
-                            transform(a, c, k, p, r, T) {
-                                const m = [a, c, k, p, r, T];
+                            transform(a, l, k, p, r, x) {
+                                const m = [a, l, k, p, r, x];
                                 this.transformMatrix = P.Util.transform(this.transformMatrix, m), this.tgrp = null;
                             }
-                            getSVG(a, c) {
-                                this.viewport = c;
-                                const k = this._initialize(c);
+                            getSVG(a, l) {
+                                this.viewport = l;
+                                const k = this._initialize(l);
                                 return this.loadDependencies(a).then(() => (this.transformMatrix = P.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(a)), k));
                             }
                             convertOpList(a) {
-                                const c = this._operatorIdMapping,
+                                const l = this._operatorIdMapping,
                                     k = a.argsArray,
                                     p = a.fnArray,
                                     r = [];
-                                for (let T = 0, m = p.length; T < m; T++) {
-                                    const U = p[T];
+                                for (let x = 0, m = p.length; x < m; x++) {
+                                    const U = p[x];
                                     r.push({
                                         fnId: U,
-                                        fn: c[U],
-                                        args: k[T]
+                                        fn: l[U],
+                                        args: k[x]
                                     });
                                 }
-                                return x(r);
+                                return T(r);
                             }
                             executeOpTree(a) {
-                                for (const c of a) {
-                                    const k = c.fn,
-                                        p = c.fnId,
-                                        r = c.args;
+                                for (const l of a) {
+                                    const k = l.fn,
+                                        p = l.fnId,
+                                        r = l.args;
                                     switch (p | 0) {
                                         case P.OPS.beginText:
                                             this.beginText();
                                             break;
                                         case P.OPS.dependency:
                                             break;
                                         case P.OPS.setLeading:
@@ -8498,15 +8492,15 @@
                                         case P.OPS.constructPath:
                                             this.constructPath(r[0], r[1]);
                                             break;
                                         case P.OPS.endPath:
                                             this.endPath();
                                             break;
                                         case 92:
-                                            this.group(c.items);
+                                            this.group(l.items);
                                             break;
                                         default:
                                             (0, P.warn)(`Unimplemented operator ${k}`);
                                             break;
                                     }
                                 }
                             }
@@ -8515,99 +8509,99 @@
                             }
                             setCharSpacing(a) {
                                 this.current.charSpacing = a;
                             }
                             nextLine() {
                                 this.moveText(0, this.current.leading);
                             }
-                            setTextMatrix(a, c, k, p, r, T) {
+                            setTextMatrix(a, l, k, p, r, x) {
                                 const m = this.current;
-                                m.textMatrix = m.lineMatrix = [a, c, k, p, r, T], m.textMatrixScale = Math.hypot(a, c), m.x = m.lineX = 0, m.y = m.lineY = 0, m.xcoords = [], m.ycoords = [], m.tspan = this.svgFactory.createElement("svg:tspan"), m.tspan.setAttributeNS(null, "font-family", m.fontFamily), m.tspan.setAttributeNS(null, "font-size", `${v(m.fontSize)}px`), m.tspan.setAttributeNS(null, "y", v(-m.y)), m.txtElement = this.svgFactory.createElement("svg:text"), m.txtElement.append(m.tspan);
+                                m.textMatrix = m.lineMatrix = [a, l, k, p, r, x], m.textMatrixScale = Math.hypot(a, l), m.x = m.lineX = 0, m.y = m.lineY = 0, m.xcoords = [], m.ycoords = [], m.tspan = this.svgFactory.createElement("svg:tspan"), m.tspan.setAttributeNS(null, "font-family", m.fontFamily), m.tspan.setAttributeNS(null, "font-size", `${v(m.fontSize)}px`), m.tspan.setAttributeNS(null, "y", v(-m.y)), m.txtElement = this.svgFactory.createElement("svg:text"), m.txtElement.append(m.tspan);
                             }
                             beginText() {
                                 const a = this.current;
                                 a.x = a.lineX = 0, a.y = a.lineY = 0, a.textMatrix = P.IDENTITY_MATRIX, a.lineMatrix = P.IDENTITY_MATRIX, a.textMatrixScale = 1, a.tspan = this.svgFactory.createElement("svg:tspan"), a.txtElement = this.svgFactory.createElement("svg:text"), a.txtgrp = this.svgFactory.createElement("svg:g"), a.xcoords = [], a.ycoords = [];
                             }
-                            moveText(a, c) {
+                            moveText(a, l) {
                                 const k = this.current;
-                                k.x = k.lineX += a, k.y = k.lineY += c, k.xcoords = [], k.ycoords = [], k.tspan = this.svgFactory.createElement("svg:tspan"), k.tspan.setAttributeNS(null, "font-family", k.fontFamily), k.tspan.setAttributeNS(null, "font-size", `${v(k.fontSize)}px`), k.tspan.setAttributeNS(null, "y", v(-k.y));
+                                k.x = k.lineX += a, k.y = k.lineY += l, k.xcoords = [], k.ycoords = [], k.tspan = this.svgFactory.createElement("svg:tspan"), k.tspan.setAttributeNS(null, "font-family", k.fontFamily), k.tspan.setAttributeNS(null, "font-size", `${v(k.fontSize)}px`), k.tspan.setAttributeNS(null, "y", v(-k.y));
                             }
                             showText(a) {
-                                const c = this.current,
-                                    k = c.font,
-                                    p = c.fontSize;
+                                const l = this.current,
+                                    k = l.font,
+                                    p = l.fontSize;
                                 if (p === 0)
                                     return;
-                                const r = c.fontSizeScale,
-                                    T = c.charSpacing,
-                                    m = c.wordSpacing,
-                                    U = c.fontDirection,
-                                    z = c.textHScale * U,
-                                    E = k.vertical,
-                                    V = E ? 1 : -1,
+                                const r = l.fontSizeScale,
+                                    x = l.charSpacing,
+                                    m = l.wordSpacing,
+                                    U = l.fontDirection,
+                                    z = l.textHScale * U,
+                                    C = k.vertical,
+                                    V = C ? 1 : -1,
                                     st = k.defaultVMetrics,
-                                    at = p * c.fontMatrix[0];
+                                    at = p * l.fontMatrix[0];
                                 let H = 0;
                                 for (const wt of a) {
                                     if (wt === null) {
                                         H += U * m;
                                         continue;
                                     } else if (typeof wt == "number") {
                                         H += V * wt * p / 1e3;
                                         continue;
                                     }
-                                    const xt = (wt.isSpace ? m : 0) + T,
+                                    const Pt = (wt.isSpace ? m : 0) + x,
                                         S = wt.fontChar;
                                     let i, n, s = wt.width;
-                                    if (E) {
+                                    if (C) {
                                         let h;
-                                        const b = wt.vmetric || st;
-                                        h = wt.vmetric ? b[1] : s * 0.5, h = -h * at;
-                                        const M = b[2] * at;
-                                        s = b ? -b[0] : s, i = h / r, n = (H + M) / r;
+                                        const _ = wt.vmetric || st;
+                                        h = wt.vmetric ? _[1] : s * 0.5, h = -h * at;
+                                        const M = _[2] * at;
+                                        s = _ ? -_[0] : s, i = h / r, n = (H + M) / r;
                                     } else
                                         i = H / r, n = 0;
-                                    (wt.isInFont || k.missingFile) && (c.xcoords.push(c.x + i), E && c.ycoords.push(-c.y + n), c.tspan.textContent += S);
-                                    const o = E ? s * at - xt * U : s * at + xt * U;
+                                    (wt.isInFont || k.missingFile) && (l.xcoords.push(l.x + i), C && l.ycoords.push(-l.y + n), l.tspan.textContent += S);
+                                    const o = C ? s * at - Pt * U : s * at + Pt * U;
                                     H += o;
                                 }
-                                c.tspan.setAttributeNS(null, "x", c.xcoords.map(v).join(" ")), E ? c.tspan.setAttributeNS(null, "y", c.ycoords.map(v).join(" ")) : c.tspan.setAttributeNS(null, "y", v(-c.y)), E ? c.y -= H : c.x += H * z, c.tspan.setAttributeNS(null, "font-family", c.fontFamily), c.tspan.setAttributeNS(null, "font-size", `${v(c.fontSize)}px`), c.fontStyle !== rt.fontStyle && c.tspan.setAttributeNS(null, "font-style", c.fontStyle), c.fontWeight !== rt.fontWeight && c.tspan.setAttributeNS(null, "font-weight", c.fontWeight);
-                                const lt = c.textRenderingMode & P.TextRenderingMode.FILL_STROKE_MASK;
-                                if (lt === P.TextRenderingMode.FILL || lt === P.TextRenderingMode.FILL_STROKE ? (c.fillColor !== rt.fillColor && c.tspan.setAttributeNS(null, "fill", c.fillColor), c.fillAlpha < 1 && c.tspan.setAttributeNS(null, "fill-opacity", c.fillAlpha)) : c.textRenderingMode === P.TextRenderingMode.ADD_TO_PATH ? c.tspan.setAttributeNS(null, "fill", "transparent") : c.tspan.setAttributeNS(null, "fill", "none"), lt === P.TextRenderingMode.STROKE || lt === P.TextRenderingMode.FILL_STROKE) {
-                                    const wt = 1 / (c.textMatrixScale || 1);
-                                    this._setStrokeAttributes(c.tspan, wt);
+                                l.tspan.setAttributeNS(null, "x", l.xcoords.map(v).join(" ")), C ? l.tspan.setAttributeNS(null, "y", l.ycoords.map(v).join(" ")) : l.tspan.setAttributeNS(null, "y", v(-l.y)), C ? l.y -= H : l.x += H * z, l.tspan.setAttributeNS(null, "font-family", l.fontFamily), l.tspan.setAttributeNS(null, "font-size", `${v(l.fontSize)}px`), l.fontStyle !== rt.fontStyle && l.tspan.setAttributeNS(null, "font-style", l.fontStyle), l.fontWeight !== rt.fontWeight && l.tspan.setAttributeNS(null, "font-weight", l.fontWeight);
+                                const lt = l.textRenderingMode & P.TextRenderingMode.FILL_STROKE_MASK;
+                                if (lt === P.TextRenderingMode.FILL || lt === P.TextRenderingMode.FILL_STROKE ? (l.fillColor !== rt.fillColor && l.tspan.setAttributeNS(null, "fill", l.fillColor), l.fillAlpha < 1 && l.tspan.setAttributeNS(null, "fill-opacity", l.fillAlpha)) : l.textRenderingMode === P.TextRenderingMode.ADD_TO_PATH ? l.tspan.setAttributeNS(null, "fill", "transparent") : l.tspan.setAttributeNS(null, "fill", "none"), lt === P.TextRenderingMode.STROKE || lt === P.TextRenderingMode.FILL_STROKE) {
+                                    const wt = 1 / (l.textMatrixScale || 1);
+                                    this._setStrokeAttributes(l.tspan, wt);
                                 }
-                                let gt = c.textMatrix;
-                                c.textRise !== 0 && (gt = gt.slice(), gt[5] += c.textRise), c.txtElement.setAttributeNS(null, "transform", `${A(gt)} scale(${v(z)}, -1)`), c.txtElement.setAttributeNS(X, "xml:space", "preserve"), c.txtElement.append(c.tspan), c.txtgrp.append(c.txtElement), this._ensureTransformGroup().append(c.txtElement);
+                                let gt = l.textMatrix;
+                                l.textRise !== 0 && (gt = gt.slice(), gt[5] += l.textRise), l.txtElement.setAttributeNS(null, "transform", `${A(gt)} scale(${v(z)}, -1)`), l.txtElement.setAttributeNS(X, "xml:space", "preserve"), l.txtElement.append(l.tspan), l.txtgrp.append(l.txtElement), this._ensureTransformGroup().append(l.txtElement);
                             }
-                            setLeadingMoveText(a, c) {
-                                this.setLeading(-c), this.moveText(a, c);
+                            setLeadingMoveText(a, l) {
+                                this.setLeading(-l), this.moveText(a, l);
                             }
                             addFontStyle(a) {
                                 if (!a.data)
                                     throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                                 this.cssStyle || (this.cssStyle = this.svgFactory.createElement("svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.append(this.cssStyle));
-                                const c = g(a.data, a.mimetype, this.forceDataSchema);
-                                this.cssStyle.textContent += `@font-face { font-family: "${a.loadedName}"; src: url(${c}); }
+                                const l = g(a.data, a.mimetype, this.forceDataSchema);
+                                this.cssStyle.textContent += `@font-face { font-family: "${a.loadedName}"; src: url(${l}); }
 `;
                             }
                             setFont(a) {
-                                const c = this.current,
+                                const l = this.current,
                                     k = this.commonObjs.get(a[0]);
                                 let p = a[1];
-                                c.font = k, this.embedFonts && !k.missingFile && !this.embeddedFonts[k.loadedName] && (this.addFontStyle(k), this.embeddedFonts[k.loadedName] = k), c.fontMatrix = k.fontMatrix || P.FONT_IDENTITY_MATRIX;
+                                l.font = k, this.embedFonts && !k.missingFile && !this.embeddedFonts[k.loadedName] && (this.addFontStyle(k), this.embeddedFonts[k.loadedName] = k), l.fontMatrix = k.fontMatrix || P.FONT_IDENTITY_MATRIX;
                                 let r = "normal";
                                 k.black ? r = "900" : k.bold && (r = "bold");
-                                const T = k.italic ? "italic" : "normal";
-                                p < 0 ? (p = -p, c.fontDirection = -1) : c.fontDirection = 1, c.fontSize = p, c.fontFamily = k.loadedName, c.fontWeight = r, c.fontStyle = T, c.tspan = this.svgFactory.createElement("svg:tspan"), c.tspan.setAttributeNS(null, "y", v(-c.y)), c.xcoords = [], c.ycoords = [];
+                                const x = k.italic ? "italic" : "normal";
+                                p < 0 ? (p = -p, l.fontDirection = -1) : l.fontDirection = 1, l.fontSize = p, l.fontFamily = k.loadedName, l.fontWeight = r, l.fontStyle = x, l.tspan = this.svgFactory.createElement("svg:tspan"), l.tspan.setAttributeNS(null, "y", v(-l.y)), l.xcoords = [], l.ycoords = [];
                             }
                             endText() {
-                                var c;
+                                var l;
                                 const a = this.current;
-                                a.textRenderingMode & P.TextRenderingMode.ADD_TO_PATH_FLAG && ((c = a.txtElement) != null && c.hasChildNodes()) && (a.element = a.txtElement, this.clip("nonzero"), this.endPath());
+                                a.textRenderingMode & P.TextRenderingMode.ADD_TO_PATH_FLAG && ((l = a.txtElement) != null && l.hasChildNodes()) && (a.element = a.txtElement, this.clip("nonzero"), this.endPath());
                             }
                             setLineWidth(a) {
                                 a > 0 && (this.current.lineWidth = a);
                             }
                             setLineCap(a) {
                                 this.current.lineCap = B[a];
                             }
@@ -8616,168 +8610,168 @@
                             }
                             setMiterLimit(a) {
                                 this.current.miterLimit = a;
                             }
                             setStrokeAlpha(a) {
                                 this.current.strokeAlpha = a;
                             }
-                            setStrokeRGBColor(a, c, k) {
-                                this.current.strokeColor = P.Util.makeHexColor(a, c, k);
+                            setStrokeRGBColor(a, l, k) {
+                                this.current.strokeColor = P.Util.makeHexColor(a, l, k);
                             }
                             setFillAlpha(a) {
                                 this.current.fillAlpha = a;
                             }
-                            setFillRGBColor(a, c, k) {
-                                this.current.fillColor = P.Util.makeHexColor(a, c, k), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = [];
+                            setFillRGBColor(a, l, k) {
+                                this.current.fillColor = P.Util.makeHexColor(a, l, k), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = [];
                             }
                             setStrokeColorN(a) {
                                 this.current.strokeColor = this._makeColorN_Pattern(a);
                             }
                             setFillColorN(a) {
                                 this.current.fillColor = this._makeColorN_Pattern(a);
                             }
                             shadingFill(a) {
                                 const {
-                                    width: c,
+                                    width: l,
                                     height: k
-                                } = this.viewport, p = P.Util.inverseTransform(this.transformMatrix), [r, T, m, U] = P.Util.getAxialAlignedBoundingBox([0, 0, c, k], p), z = this.svgFactory.createElement("svg:rect");
-                                z.setAttributeNS(null, "x", r), z.setAttributeNS(null, "y", T), z.setAttributeNS(null, "width", m - r), z.setAttributeNS(null, "height", U - T), z.setAttributeNS(null, "fill", this._makeShadingPattern(a)), this.current.fillAlpha < 1 && z.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().append(z);
+                                } = this.viewport, p = P.Util.inverseTransform(this.transformMatrix), [r, x, m, U] = P.Util.getAxialAlignedBoundingBox([0, 0, l, k], p), z = this.svgFactory.createElement("svg:rect");
+                                z.setAttributeNS(null, "x", r), z.setAttributeNS(null, "y", x), z.setAttributeNS(null, "width", m - r), z.setAttributeNS(null, "height", U - x), z.setAttributeNS(null, "fill", this._makeShadingPattern(a)), this.current.fillAlpha < 1 && z.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().append(z);
                             }
                             _makeColorN_Pattern(a) {
                                 return a[0] === "TilingPattern" ? this._makeTilingPattern(a) : this._makeShadingPattern(a);
                             }
                             _makeTilingPattern(a) {
-                                const c = a[1],
+                                const l = a[1],
                                     k = a[2],
                                     p = a[3] || P.IDENTITY_MATRIX,
-                                    [r, T, m, U] = a[4],
+                                    [r, x, m, U] = a[4],
                                     z = a[5],
-                                    E = a[6],
+                                    C = a[6],
                                     V = a[7],
-                                    st = `shading${w++}`,
-                                    [at, H, lt, gt] = P.Util.normalizeRect([...P.Util.applyTransform([r, T], p), ...P.Util.applyTransform([m, U], p)]),
-                                    [wt, xt] = P.Util.singularValueDecompose2dScale(p),
+                                    st = `shading${E++}`,
+                                    [at, H, lt, gt] = P.Util.normalizeRect([...P.Util.applyTransform([r, x], p), ...P.Util.applyTransform([m, U], p)]),
+                                    [wt, Pt] = P.Util.singularValueDecompose2dScale(p),
                                     S = z * wt,
-                                    i = E * xt,
+                                    i = C * Pt,
                                     n = this.svgFactory.createElement("svg:pattern");
                                 n.setAttributeNS(null, "id", st), n.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), n.setAttributeNS(null, "width", S), n.setAttributeNS(null, "height", i), n.setAttributeNS(null, "x", `${at}`), n.setAttributeNS(null, "y", `${H}`);
                                 const s = this.svg,
                                     o = this.transformMatrix,
                                     h = this.current.fillColor,
-                                    b = this.current.strokeColor,
+                                    _ = this.current.strokeColor,
                                     M = this.svgFactory.create(lt - at, gt - H);
                                 if (this.svg = M, this.transformMatrix = p, V === 2) {
-                                    const N = P.Util.makeHexColor(...c);
+                                    const N = P.Util.makeHexColor(...l);
                                     this.current.fillColor = N, this.current.strokeColor = N;
                                 }
-                                return this.executeOpTree(this.convertOpList(k)), this.svg = s, this.transformMatrix = o, this.current.fillColor = h, this.current.strokeColor = b, n.append(M.childNodes[0]), this.defs.append(n), `url(#${st})`;
+                                return this.executeOpTree(this.convertOpList(k)), this.svg = s, this.transformMatrix = o, this.current.fillColor = h, this.current.strokeColor = _, n.append(M.childNodes[0]), this.defs.append(n), `url(#${st})`;
                             }
                             _makeShadingPattern(a) {
                                 switch (typeof a == "string" && (a = this.objs.get(a)), a[0]) {
                                     case "RadialAxial":
-                                        const c = `shading${w++}`,
+                                        const l = `shading${E++}`,
                                             k = a[3];
                                         let p;
                                         switch (a[1]) {
                                             case "axial":
                                                 const r = a[4],
-                                                    T = a[5];
-                                                p = this.svgFactory.createElement("svg:linearGradient"), p.setAttributeNS(null, "id", c), p.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), p.setAttributeNS(null, "x1", r[0]), p.setAttributeNS(null, "y1", r[1]), p.setAttributeNS(null, "x2", T[0]), p.setAttributeNS(null, "y2", T[1]);
+                                                    x = a[5];
+                                                p = this.svgFactory.createElement("svg:linearGradient"), p.setAttributeNS(null, "id", l), p.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), p.setAttributeNS(null, "x1", r[0]), p.setAttributeNS(null, "y1", r[1]), p.setAttributeNS(null, "x2", x[0]), p.setAttributeNS(null, "y2", x[1]);
                                                 break;
                                             case "radial":
                                                 const m = a[4],
                                                     U = a[5],
                                                     z = a[6],
-                                                    E = a[7];
-                                                p = this.svgFactory.createElement("svg:radialGradient"), p.setAttributeNS(null, "id", c), p.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), p.setAttributeNS(null, "cx", U[0]), p.setAttributeNS(null, "cy", U[1]), p.setAttributeNS(null, "r", E), p.setAttributeNS(null, "fx", m[0]), p.setAttributeNS(null, "fy", m[1]), p.setAttributeNS(null, "fr", z);
+                                                    C = a[7];
+                                                p = this.svgFactory.createElement("svg:radialGradient"), p.setAttributeNS(null, "id", l), p.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), p.setAttributeNS(null, "cx", U[0]), p.setAttributeNS(null, "cy", U[1]), p.setAttributeNS(null, "r", C), p.setAttributeNS(null, "fx", m[0]), p.setAttributeNS(null, "fy", m[1]), p.setAttributeNS(null, "fr", z);
                                                 break;
                                             default:
                                                 throw new Error(`Unknown RadialAxial type: ${a[1]}`);
                                         }
                                         for (const r of k) {
-                                            const T = this.svgFactory.createElement("svg:stop");
-                                            T.setAttributeNS(null, "offset", r[0]), T.setAttributeNS(null, "stop-color", r[1]), p.append(T);
+                                            const x = this.svgFactory.createElement("svg:stop");
+                                            x.setAttributeNS(null, "offset", r[0]), x.setAttributeNS(null, "stop-color", r[1]), p.append(x);
                                         }
-                                        return this.defs.append(p), `url(#${c})`;
+                                        return this.defs.append(p), `url(#${l})`;
                                     case "Mesh":
                                         return (0, P.warn)("Unimplemented pattern Mesh"), null;
                                     case "Dummy":
                                         return "hotpink";
                                     default:
                                         throw new Error(`Unknown IR type: ${a[0]}`);
                                 }
                             }
-                            setDash(a, c) {
-                                this.current.dashArray = a, this.current.dashPhase = c;
+                            setDash(a, l) {
+                                this.current.dashArray = a, this.current.dashPhase = l;
                             }
-                            constructPath(a, c) {
+                            constructPath(a, l) {
                                 const k = this.current;
                                 let p = k.x,
                                     r = k.y,
-                                    T = [],
+                                    x = [],
                                     m = 0;
                                 for (const U of a)
                                     switch (U | 0) {
                                         case P.OPS.rectangle:
-                                            p = c[m++], r = c[m++];
-                                            const z = c[m++],
-                                                E = c[m++],
+                                            p = l[m++], r = l[m++];
+                                            const z = l[m++],
+                                                C = l[m++],
                                                 V = p + z,
-                                                st = r + E;
-                                            T.push("M", v(p), v(r), "L", v(V), v(r), "L", v(V), v(st), "L", v(p), v(st), "Z");
+                                                st = r + C;
+                                            x.push("M", v(p), v(r), "L", v(V), v(r), "L", v(V), v(st), "L", v(p), v(st), "Z");
                                             break;
                                         case P.OPS.moveTo:
-                                            p = c[m++], r = c[m++], T.push("M", v(p), v(r));
+                                            p = l[m++], r = l[m++], x.push("M", v(p), v(r));
                                             break;
                                         case P.OPS.lineTo:
-                                            p = c[m++], r = c[m++], T.push("L", v(p), v(r));
+                                            p = l[m++], r = l[m++], x.push("L", v(p), v(r));
                                             break;
                                         case P.OPS.curveTo:
-                                            p = c[m + 4], r = c[m + 5], T.push("C", v(c[m]), v(c[m + 1]), v(c[m + 2]), v(c[m + 3]), v(p), v(r)), m += 6;
+                                            p = l[m + 4], r = l[m + 5], x.push("C", v(l[m]), v(l[m + 1]), v(l[m + 2]), v(l[m + 3]), v(p), v(r)), m += 6;
                                             break;
                                         case P.OPS.curveTo2:
-                                            T.push("C", v(p), v(r), v(c[m]), v(c[m + 1]), v(c[m + 2]), v(c[m + 3])), p = c[m + 2], r = c[m + 3], m += 4;
+                                            x.push("C", v(p), v(r), v(l[m]), v(l[m + 1]), v(l[m + 2]), v(l[m + 3])), p = l[m + 2], r = l[m + 3], m += 4;
                                             break;
                                         case P.OPS.curveTo3:
-                                            p = c[m + 2], r = c[m + 3], T.push("C", v(c[m]), v(c[m + 1]), v(p), v(r), v(p), v(r)), m += 4;
+                                            p = l[m + 2], r = l[m + 3], x.push("C", v(l[m]), v(l[m + 1]), v(p), v(r), v(p), v(r)), m += 4;
                                             break;
                                         case P.OPS.closePath:
-                                            T.push("Z");
+                                            x.push("Z");
                                             break;
                                     }
-                                T = T.join(" "), k.path && a.length > 0 && a[0] !== P.OPS.rectangle && a[0] !== P.OPS.moveTo ? T = k.path.getAttributeNS(null, "d") + T : (k.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().append(k.path)), k.path.setAttributeNS(null, "d", T), k.path.setAttributeNS(null, "fill", "none"), k.element = k.path, k.setCurrentPoint(p, r);
+                                x = x.join(" "), k.path && a.length > 0 && a[0] !== P.OPS.rectangle && a[0] !== P.OPS.moveTo ? x = k.path.getAttributeNS(null, "d") + x : (k.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().append(k.path)), k.path.setAttributeNS(null, "d", x), k.path.setAttributeNS(null, "fill", "none"), k.element = k.path, k.setCurrentPoint(p, r);
                             }
                             endPath() {
                                 const a = this.current;
                                 if (a.path = null, !this.pendingClip)
                                     return;
                                 if (!a.element) {
                                     this.pendingClip = null;
                                     return;
                                 }
-                                const c = `clippath${u++}`,
+                                const l = `clippath${u++}`,
                                     k = this.svgFactory.createElement("svg:clipPath");
-                                k.setAttributeNS(null, "id", c), k.setAttributeNS(null, "transform", A(this.transformMatrix));
+                                k.setAttributeNS(null, "id", l), k.setAttributeNS(null, "transform", A(this.transformMatrix));
                                 const p = a.element.cloneNode(!0);
                                 if (this.pendingClip === "evenodd" ? p.setAttributeNS(null, "clip-rule", "evenodd") : p.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, k.append(p), this.defs.append(k), a.activeClipUrl) {
                                     a.clipGroup = null;
                                     for (const r of this.extraStack)
                                         r.clipGroup = null;
                                     k.setAttributeNS(null, "clip-path", a.activeClipUrl);
                                 }
-                                a.activeClipUrl = `url(#${c})`, this.tgrp = null;
+                                a.activeClipUrl = `url(#${l})`, this.tgrp = null;
                             }
                             clip(a) {
                                 this.pendingClip = a;
                             }
                             closePath() {
                                 const a = this.current;
                                 if (a.path) {
-                                    const c = `${a.path.getAttributeNS(null, "d")}Z`;
-                                    a.path.setAttributeNS(null, "d", c);
+                                    const l = `${a.path.getAttributeNS(null, "d")}Z`;
+                                    a.path.setAttributeNS(null, "d", l);
                                 }
                             }
                             setLeading(a) {
                                 this.current.leading = -a;
                             }
                             setTextRise(a) {
                                 this.current.textRise = a;
@@ -8787,16 +8781,16 @@
                             }
                             setHScale(a) {
                                 this.current.textHScale = a / 100;
                             }
                             setRenderingIntent(a) {}
                             setFlatness(a) {}
                             setGState(a) {
-                                for (const [c, k] of a)
-                                    switch (c) {
+                                for (const [l, k] of a)
+                                    switch (l) {
                                         case "LW":
                                             this.setLineWidth(k);
                                             break;
                                         case "LC":
                                             this.setLineCap(k);
                                             break;
                                         case "LJ":
@@ -8820,32 +8814,32 @@
                                         case "CA":
                                             this.setStrokeAlpha(k);
                                             break;
                                         case "ca":
                                             this.setFillAlpha(k);
                                             break;
                                         default:
-                                            (0, P.warn)(`Unimplemented graphic state operator ${c}`);
+                                            (0, P.warn)(`Unimplemented graphic state operator ${l}`);
                                             break;
                                     }
                             }
                             fill() {
                                 const a = this.current;
                                 a.element && (a.element.setAttributeNS(null, "fill", a.fillColor), a.element.setAttributeNS(null, "fill-opacity", a.fillAlpha), this.endPath());
                             }
                             stroke() {
                                 const a = this.current;
                                 a.element && (this._setStrokeAttributes(a.element), a.element.setAttributeNS(null, "fill", "none"), this.endPath());
                             }
-                            _setStrokeAttributes(a, c = 1) {
+                            _setStrokeAttributes(a, l = 1) {
                                 const k = this.current;
                                 let p = k.dashArray;
-                                c !== 1 && p.length > 0 && (p = p.map(function(r) {
-                                    return c * r;
-                                })), a.setAttributeNS(null, "stroke", k.strokeColor), a.setAttributeNS(null, "stroke-opacity", k.strokeAlpha), a.setAttributeNS(null, "stroke-miterlimit", v(k.miterLimit)), a.setAttributeNS(null, "stroke-linecap", k.lineCap), a.setAttributeNS(null, "stroke-linejoin", k.lineJoin), a.setAttributeNS(null, "stroke-width", v(c * k.lineWidth) + "px"), a.setAttributeNS(null, "stroke-dasharray", p.map(v).join(" ")), a.setAttributeNS(null, "stroke-dashoffset", v(c * k.dashPhase) + "px");
+                                l !== 1 && p.length > 0 && (p = p.map(function(r) {
+                                    return l * r;
+                                })), a.setAttributeNS(null, "stroke", k.strokeColor), a.setAttributeNS(null, "stroke-opacity", k.strokeAlpha), a.setAttributeNS(null, "stroke-miterlimit", v(k.miterLimit)), a.setAttributeNS(null, "stroke-linecap", k.lineCap), a.setAttributeNS(null, "stroke-linejoin", k.lineJoin), a.setAttributeNS(null, "stroke-width", v(l * k.lineWidth) + "px"), a.setAttributeNS(null, "stroke-dasharray", p.map(v).join(" ")), a.setAttributeNS(null, "stroke-dashoffset", v(l * k.dashPhase) + "px");
                             }
                             eoFill() {
                                 var a;
                                 (a = this.current.element) == null || a.setAttributeNS(null, "fill-rule", "evenodd"), this.fill();
                             }
                             fillStroke() {
                                 this.stroke(), this.fill();
@@ -8864,74 +8858,74 @@
                                 this.closePath(), this.eoFillStroke();
                             }
                             paintSolidColorImageMask() {
                                 const a = this.svgFactory.createElement("svg:rect");
                                 a.setAttributeNS(null, "x", "0"), a.setAttributeNS(null, "y", "0"), a.setAttributeNS(null, "width", "1px"), a.setAttributeNS(null, "height", "1px"), a.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().append(a);
                             }
                             paintImageXObject(a) {
-                                const c = this.getObject(a);
-                                if (!c) {
+                                const l = this.getObject(a);
+                                if (!l) {
                                     (0, P.warn)(`Dependent image with object ID ${a} is not ready yet`);
                                     return;
                                 }
-                                this.paintInlineImageXObject(c);
+                                this.paintInlineImageXObject(l);
                             }
-                            paintInlineImageXObject(a, c) {
+                            paintInlineImageXObject(a, l) {
                                 const k = a.width,
                                     p = a.height,
-                                    r = O(a, this.forceDataSchema, !!c),
-                                    T = this.svgFactory.createElement("svg:rect");
-                                T.setAttributeNS(null, "x", "0"), T.setAttributeNS(null, "y", "0"), T.setAttributeNS(null, "width", v(k)), T.setAttributeNS(null, "height", v(p)), this.current.element = T, this.clip("nonzero");
+                                    r = L(a, this.forceDataSchema, !!l),
+                                    x = this.svgFactory.createElement("svg:rect");
+                                x.setAttributeNS(null, "x", "0"), x.setAttributeNS(null, "y", "0"), x.setAttributeNS(null, "width", v(k)), x.setAttributeNS(null, "height", v(p)), this.current.element = x, this.clip("nonzero");
                                 const m = this.svgFactory.createElement("svg:image");
-                                m.setAttributeNS(pt, "xlink:href", r), m.setAttributeNS(null, "x", "0"), m.setAttributeNS(null, "y", v(-p)), m.setAttributeNS(null, "width", v(k) + "px"), m.setAttributeNS(null, "height", v(p) + "px"), m.setAttributeNS(null, "transform", `scale(${v(1 / k)} ${v(-1 / p)})`), c ? c.append(m) : this._ensureTransformGroup().append(m);
+                                m.setAttributeNS(pt, "xlink:href", r), m.setAttributeNS(null, "x", "0"), m.setAttributeNS(null, "y", v(-p)), m.setAttributeNS(null, "width", v(k) + "px"), m.setAttributeNS(null, "height", v(p) + "px"), m.setAttributeNS(null, "transform", `scale(${v(1 / k)} ${v(-1 / p)})`), l ? l.append(m) : this._ensureTransformGroup().append(m);
                             }
                             paintImageMaskXObject(a) {
-                                const c = this.getObject(a.data, a);
-                                if (c.bitmap) {
+                                const l = this.getObject(a.data, a);
+                                if (l.bitmap) {
                                     (0, P.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled.");
                                     return;
                                 }
                                 const k = this.current,
-                                    p = c.width,
-                                    r = c.height,
-                                    T = k.fillColor;
-                                k.maskId = `mask${_++}`;
+                                    p = l.width,
+                                    r = l.height,
+                                    x = k.fillColor;
+                                k.maskId = `mask${b++}`;
                                 const m = this.svgFactory.createElement("svg:mask");
                                 m.setAttributeNS(null, "id", k.maskId);
                                 const U = this.svgFactory.createElement("svg:rect");
-                                U.setAttributeNS(null, "x", "0"), U.setAttributeNS(null, "y", "0"), U.setAttributeNS(null, "width", v(p)), U.setAttributeNS(null, "height", v(r)), U.setAttributeNS(null, "fill", T), U.setAttributeNS(null, "mask", `url(#${k.maskId})`), this.defs.append(m), this._ensureTransformGroup().append(U), this.paintInlineImageXObject(c, m);
+                                U.setAttributeNS(null, "x", "0"), U.setAttributeNS(null, "y", "0"), U.setAttributeNS(null, "width", v(p)), U.setAttributeNS(null, "height", v(r)), U.setAttributeNS(null, "fill", x), U.setAttributeNS(null, "mask", `url(#${k.maskId})`), this.defs.append(m), this._ensureTransformGroup().append(U), this.paintInlineImageXObject(l, m);
                             }
-                            paintFormXObjectBegin(a, c) {
-                                if (Array.isArray(a) && a.length === 6 && this.transform(a[0], a[1], a[2], a[3], a[4], a[5]), c) {
-                                    const k = c[2] - c[0],
-                                        p = c[3] - c[1],
+                            paintFormXObjectBegin(a, l) {
+                                if (Array.isArray(a) && a.length === 6 && this.transform(a[0], a[1], a[2], a[3], a[4], a[5]), l) {
+                                    const k = l[2] - l[0],
+                                        p = l[3] - l[1],
                                         r = this.svgFactory.createElement("svg:rect");
-                                    r.setAttributeNS(null, "x", c[0]), r.setAttributeNS(null, "y", c[1]), r.setAttributeNS(null, "width", v(k)), r.setAttributeNS(null, "height", v(p)), this.current.element = r, this.clip("nonzero"), this.endPath();
+                                    r.setAttributeNS(null, "x", l[0]), r.setAttributeNS(null, "y", l[1]), r.setAttributeNS(null, "width", v(k)), r.setAttributeNS(null, "height", v(p)), this.current.element = r, this.clip("nonzero"), this.endPath();
                                 }
                             }
                             paintFormXObjectEnd() {}
                             _initialize(a) {
-                                const c = this.svgFactory.create(a.width, a.height),
+                                const l = this.svgFactory.create(a.width, a.height),
                                     k = this.svgFactory.createElement("svg:defs");
-                                c.append(k), this.defs = k;
+                                l.append(k), this.defs = k;
                                 const p = this.svgFactory.createElement("svg:g");
-                                return p.setAttributeNS(null, "transform", A(a.transform)), c.append(p), this.svg = p, c;
+                                return p.setAttributeNS(null, "transform", A(a.transform)), l.append(p), this.svg = p, l;
                             }
                             _ensureClipGroup() {
                                 if (!this.current.clipGroup) {
                                     const a = this.svgFactory.createElement("svg:g");
                                     a.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.append(a), this.current.clipGroup = a;
                                 }
                                 return this.current.clipGroup;
                             }
                             _ensureTransformGroup() {
                                 return this.tgrp || (this.tgrp = this.svgFactory.createElement("svg:g"), this.tgrp.setAttributeNS(null, "transform", A(this.transformMatrix)), this.current.activeClipUrl ? this._ensureClipGroup().append(this.tgrp) : this.svg.append(this.tgrp)), this.tgrp;
                             }
                         }
-                        d.SVGGraphics = C;
+                        d.SVGGraphics = w;
                     },
                     /* 25 */
                     /***/
                     (dt, d) => {
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.XfaText = void 0;
@@ -8940,30 +8934,30 @@
                                 const rt = [],
                                     X = {
                                         items: rt,
                                         styles: /* @__PURE__ */ Object.create(null)
                                     };
 
                                 function pt(B) {
-                                    var O;
+                                    var L;
                                     if (!B)
                                         return;
                                     let F = null;
                                     const g = B.name;
                                     if (g === "#text")
                                         F = B.value;
                                     else if (et.shouldBuildText(g))
-                                        (O = B == null ? void 0 : B.attributes) != null && O.textContent ? F = B.attributes.textContent : B.value && (F = B.value);
+                                        (L = B == null ? void 0 : B.attributes) != null && L.textContent ? F = B.attributes.textContent : B.value && (F = B.value);
                                     else
                                         return;
                                     if (F !== null && rt.push({
                                             str: F
                                         }), !!B.children)
-                                        for (const I of B.children)
-                                            pt(I);
+                                        for (const O of B.children)
+                                            pt(O);
                                 }
                                 return pt(P), X;
                             }
                             static shouldBuildText(P) {
                                 return !(P === "textarea" || P === "input" || P === "option" || P === "select");
                             }
                         }
@@ -8971,640 +8965,640 @@
                     },
                     /* 26 */
                     /***/
                     (dt, d, et) => {
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.TextLayerRenderTask = void 0, d.renderTextLayer = A, d.updateTextLayer = u;
-                        var l = et(1),
+                        var c = et(1),
                             P = et(6);
                         const rt = 1e5,
                             X = 30,
                             pt = 0.8,
                             B = /* @__PURE__ */ new Map();
 
-                        function F(_, w) {
-                            let C;
-                            if (w && l.FeatureTest.isOffscreenCanvasSupported)
-                                C = new OffscreenCanvas(_, _).getContext("2d", {
+                        function F(b, E) {
+                            let w;
+                            if (E && c.FeatureTest.isOffscreenCanvasSupported)
+                                w = new OffscreenCanvas(b, b).getContext("2d", {
                                     alpha: !1
                                 });
                             else {
                                 const y = document.createElement("canvas");
-                                y.width = y.height = _, C = y.getContext("2d", {
+                                y.width = y.height = b, w = y.getContext("2d", {
                                     alpha: !1
                                 });
                             }
-                            return C;
+                            return w;
                         }
 
-                        function g(_, w) {
-                            const C = B.get(_);
-                            if (C)
-                                return C;
-                            const y = F(X, w);
-                            y.font = `${X}px ${_}`;
+                        function g(b, E) {
+                            const w = B.get(b);
+                            if (w)
+                                return w;
+                            const y = F(X, E);
+                            y.font = `${X}px ${b}`;
                             const a = y.measureText("");
-                            let c = a.fontBoundingBoxAscent,
+                            let l = a.fontBoundingBoxAscent,
                                 k = Math.abs(a.fontBoundingBoxDescent);
-                            if (c) {
-                                const r = c / (c + k);
-                                return B.set(_, r), y.canvas.width = y.canvas.height = 0, r;
+                            if (l) {
+                                const r = l / (l + k);
+                                return B.set(b, r), y.canvas.width = y.canvas.height = 0, r;
                             }
                             y.strokeStyle = "red", y.clearRect(0, 0, X, X), y.strokeText("g", 0, 0);
                             let p = y.getImageData(0, 0, X, X).data;
                             k = 0;
                             for (let r = p.length - 1 - 3; r >= 0; r -= 4)
                                 if (p[r] > 0) {
                                     k = Math.ceil(r / 4 / X);
                                     break;
                                 }
-                            y.clearRect(0, 0, X, X), y.strokeText("A", 0, X), p = y.getImageData(0, 0, X, X).data, c = 0;
-                            for (let r = 0, T = p.length; r < T; r += 4)
+                            y.clearRect(0, 0, X, X), y.strokeText("A", 0, X), p = y.getImageData(0, 0, X, X).data, l = 0;
+                            for (let r = 0, x = p.length; r < x; r += 4)
                                 if (p[r] > 0) {
-                                    c = X - Math.floor(r / 4 / X);
+                                    l = X - Math.floor(r / 4 / X);
                                     break;
                                 }
-                            if (y.canvas.width = y.canvas.height = 0, c) {
-                                const r = c / (c + k);
-                                return B.set(_, r), r;
+                            if (y.canvas.width = y.canvas.height = 0, l) {
+                                const r = l / (l + k);
+                                return B.set(b, r), r;
                             }
-                            return B.set(_, pt), pt;
+                            return B.set(b, pt), pt;
                         }
 
-                        function O(_, w, C) {
+                        function L(b, E, w) {
                             const y = document.createElement("span"),
                                 a = {
                                     angle: 0,
                                     canvasWidth: 0,
-                                    hasText: w.str !== "",
-                                    hasEOL: w.hasEOL,
+                                    hasText: E.str !== "",
+                                    hasEOL: E.hasEOL,
                                     fontSize: 0
                                 };
-                            _._textDivs.push(y);
-                            const c = l.Util.transform(_._transform, w.transform);
-                            let k = Math.atan2(c[1], c[0]);
-                            const p = C[w.fontName];
+                            b._textDivs.push(y);
+                            const l = c.Util.transform(b._transform, E.transform);
+                            let k = Math.atan2(l[1], l[0]);
+                            const p = w[E.fontName];
                             p.vertical && (k += Math.PI / 2);
-                            const r = Math.hypot(c[2], c[3]),
-                                T = r * g(p.fontFamily, _._isOffscreenCanvasSupported);
+                            const r = Math.hypot(l[2], l[3]),
+                                x = r * g(p.fontFamily, b._isOffscreenCanvasSupported);
                             let m, U;
-                            k === 0 ? (m = c[4], U = c[5] - T) : (m = c[4] + T * Math.sin(k), U = c[5] - T * Math.cos(k));
+                            k === 0 ? (m = l[4], U = l[5] - x) : (m = l[4] + x * Math.sin(k), U = l[5] - x * Math.cos(k));
                             const z = "calc(var(--scale-factor)*",
-                                E = y.style;
-                            _._container === _._rootContainer ? (E.left = `${(100 * m / _._pageWidth).toFixed(2)}%`, E.top = `${(100 * U / _._pageHeight).toFixed(2)}%`) : (E.left = `${z}${m.toFixed(2)}px)`, E.top = `${z}${U.toFixed(2)}px)`), E.fontSize = `${z}${r.toFixed(2)}px)`, E.fontFamily = p.fontFamily, a.fontSize = r, y.setAttribute("role", "presentation"), y.textContent = w.str, y.dir = w.dir, _._fontInspectorEnabled && (y.dataset.fontName = w.fontName), k !== 0 && (a.angle = k * (180 / Math.PI));
+                                C = y.style;
+                            b._container === b._rootContainer ? (C.left = `${(100 * m / b._pageWidth).toFixed(2)}%`, C.top = `${(100 * U / b._pageHeight).toFixed(2)}%`) : (C.left = `${z}${m.toFixed(2)}px)`, C.top = `${z}${U.toFixed(2)}px)`), C.fontSize = `${z}${r.toFixed(2)}px)`, C.fontFamily = p.fontFamily, a.fontSize = r, y.setAttribute("role", "presentation"), y.textContent = E.str, y.dir = E.dir, b._fontInspectorEnabled && (y.dataset.fontName = E.fontName), k !== 0 && (a.angle = k * (180 / Math.PI));
                             let V = !1;
-                            if (w.str.length > 1)
+                            if (E.str.length > 1)
                                 V = !0;
-                            else if (w.str !== " " && w.transform[0] !== w.transform[3]) {
-                                const st = Math.abs(w.transform[0]),
-                                    at = Math.abs(w.transform[3]);
+                            else if (E.str !== " " && E.transform[0] !== E.transform[3]) {
+                                const st = Math.abs(E.transform[0]),
+                                    at = Math.abs(E.transform[3]);
                                 st !== at && Math.max(st, at) / Math.min(st, at) > 1.5 && (V = !0);
                             }
-                            V && (a.canvasWidth = p.vertical ? w.height : w.width), _._textDivProperties.set(y, a), _._isReadableStream && _._layoutText(y);
+                            V && (a.canvasWidth = p.vertical ? E.height : E.width), b._textDivProperties.set(y, a), b._isReadableStream && b._layoutText(y);
                         }
 
-                        function I(_) {
+                        function O(b) {
                             const {
-                                div: w,
-                                scale: C,
+                                div: E,
+                                scale: w,
                                 properties: y,
                                 ctx: a,
-                                prevFontSize: c,
+                                prevFontSize: l,
                                 prevFontFamily: k
-                            } = _, {
+                            } = b, {
                                 style: p
-                            } = w;
+                            } = E;
                             let r = "";
                             if (y.canvasWidth !== 0 && y.hasText) {
                                 const {
-                                    fontFamily: T
+                                    fontFamily: x
                                 } = p, {
                                     canvasWidth: m,
                                     fontSize: U
                                 } = y;
-                                (c !== U || k !== T) && (a.font = `${U * C}px ${T}`, _.prevFontSize = U, _.prevFontFamily = T);
+                                (l !== U || k !== x) && (a.font = `${U * w}px ${x}`, b.prevFontSize = U, b.prevFontFamily = x);
                                 const {
                                     width: z
-                                } = a.measureText(w.textContent);
-                                z > 0 && (r = `scaleX(${m * C / z})`);
+                                } = a.measureText(E.textContent);
+                                z > 0 && (r = `scaleX(${m * w / z})`);
                             }
                             y.angle !== 0 && (r = `rotate(${y.angle}deg) ${r}`), r.length > 0 && (p.transform = r);
                         }
 
-                        function x(_) {
-                            if (_._canceled)
+                        function T(b) {
+                            if (b._canceled)
                                 return;
-                            const w = _._textDivs,
-                                C = _._capability;
-                            if (w.length > rt) {
-                                C.resolve();
+                            const E = b._textDivs,
+                                w = b._capability;
+                            if (E.length > rt) {
+                                w.resolve();
                                 return;
                             }
-                            if (!_._isReadableStream)
-                                for (const a of w)
-                                    _._layoutText(a);
-                            C.resolve();
+                            if (!b._isReadableStream)
+                                for (const a of E)
+                                    b._layoutText(a);
+                            w.resolve();
                         }
                         class v {
                             constructor({
-                                textContentSource: w,
-                                container: C,
+                                textContentSource: E,
+                                container: w,
                                 viewport: y,
                                 textDivs: a,
-                                textDivProperties: c,
+                                textDivProperties: l,
                                 textContentItemsStr: k,
                                 isOffscreenCanvasSupported: p
                             }) {
                                 var z;
-                                this._textContentSource = w, this._isReadableStream = w instanceof ReadableStream, this._container = this._rootContainer = C, this._textDivs = a || [], this._textContentItemsStr = k || [], this._isOffscreenCanvasSupported = p, this._fontInspectorEnabled = !!((z = globalThis.FontInspector) != null && z.enabled), this._reader = null, this._textDivProperties = c || /* @__PURE__ */ new WeakMap(), this._canceled = !1, this._capability = new l.PromiseCapability(), this._layoutTextParams = {
+                                this._textContentSource = E, this._isReadableStream = E instanceof ReadableStream, this._container = this._rootContainer = w, this._textDivs = a || [], this._textContentItemsStr = k || [], this._isOffscreenCanvasSupported = p, this._fontInspectorEnabled = !!((z = globalThis.FontInspector) != null && z.enabled), this._reader = null, this._textDivProperties = l || /* @__PURE__ */ new WeakMap(), this._canceled = !1, this._capability = new c.PromiseCapability(), this._layoutTextParams = {
                                     prevFontSize: null,
                                     prevFontFamily: null,
                                     div: null,
                                     scale: y.scale * (globalThis.devicePixelRatio || 1),
                                     properties: null,
                                     ctx: F(0, p)
                                 };
                                 const {
                                     pageWidth: r,
-                                    pageHeight: T,
+                                    pageHeight: x,
                                     pageX: m,
                                     pageY: U
                                 } = y.rawDims;
-                                this._transform = [1, 0, 0, -1, -m, U + T], this._pageWidth = r, this._pageHeight = T, (0, P.setLayerDimensions)(C, y), this._capability.promise.finally(() => {
+                                this._transform = [1, 0, 0, -1, -m, U + x], this._pageWidth = r, this._pageHeight = x, (0, P.setLayerDimensions)(w, y), this._capability.promise.finally(() => {
                                     this._layoutTextParams = null;
                                 }).catch(() => {});
                             }
                             get promise() {
                                 return this._capability.promise;
                             }
                             cancel() {
-                                this._canceled = !0, this._reader && (this._reader.cancel(new l.AbortException("TextLayer task cancelled.")).catch(() => {}), this._reader = null), this._capability.reject(new l.AbortException("TextLayer task cancelled."));
+                                this._canceled = !0, this._reader && (this._reader.cancel(new c.AbortException("TextLayer task cancelled.")).catch(() => {}), this._reader = null), this._capability.reject(new c.AbortException("TextLayer task cancelled."));
                             }
-                            _processItems(w, C) {
-                                for (const y of w) {
+                            _processItems(E, w) {
+                                for (const y of E) {
                                     if (y.str === void 0) {
                                         if (y.type === "beginMarkedContentProps" || y.type === "beginMarkedContent") {
                                             const a = this._container;
                                             this._container = document.createElement("span"), this._container.classList.add("markedContent"), y.id !== null && this._container.setAttribute("id", `${y.id}`), a.append(this._container);
                                         } else
                                             y.type === "endMarkedContent" && (this._container = this._container.parentNode);
                                         continue;
                                     }
-                                    this._textContentItemsStr.push(y.str), O(this, y, C);
+                                    this._textContentItemsStr.push(y.str), L(this, y, w);
                                 }
                             }
-                            _layoutText(w) {
-                                const C = this._layoutTextParams.properties = this._textDivProperties.get(w);
-                                if (this._layoutTextParams.div = w, I(this._layoutTextParams), C.hasText && this._container.append(w), C.hasEOL) {
+                            _layoutText(E) {
+                                const w = this._layoutTextParams.properties = this._textDivProperties.get(E);
+                                if (this._layoutTextParams.div = E, O(this._layoutTextParams), w.hasText && this._container.append(E), w.hasEOL) {
                                     const y = document.createElement("br");
                                     y.setAttribute("role", "presentation"), this._container.append(y);
                                 }
                             }
                             _render() {
-                                const w = new l.PromiseCapability();
-                                let C = /* @__PURE__ */ Object.create(null);
+                                const E = new c.PromiseCapability();
+                                let w = /* @__PURE__ */ Object.create(null);
                                 if (this._isReadableStream) {
                                     const y = () => {
                                         this._reader.read().then(({
                                             value: a,
-                                            done: c
+                                            done: l
                                         }) => {
-                                            if (c) {
-                                                w.resolve();
+                                            if (l) {
+                                                E.resolve();
                                                 return;
                                             }
-                                            Object.assign(C, a.styles), this._processItems(a.items, C), y();
-                                        }, w.reject);
+                                            Object.assign(w, a.styles), this._processItems(a.items, w), y();
+                                        }, E.reject);
                                     };
                                     this._reader = this._textContentSource.getReader(), y();
                                 } else if (this._textContentSource) {
                                     const {
                                         items: y,
                                         styles: a
                                     } = this._textContentSource;
-                                    this._processItems(y, a), w.resolve();
+                                    this._processItems(y, a), E.resolve();
                                 } else
                                     throw new Error('No "textContentSource" parameter specified.');
-                                w.promise.then(() => {
-                                    C = null, x(this);
+                                E.promise.then(() => {
+                                    w = null, T(this);
                                 }, this._capability.reject);
                             }
                         }
                         d.TextLayerRenderTask = v;
 
-                        function A(_) {
-                            !_.textContentSource && (_.textContent || _.textContentStream) && ((0, P.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead."), _.textContentSource = _.textContent || _.textContentStream);
+                        function A(b) {
+                            !b.textContentSource && (b.textContent || b.textContentStream) && ((0, P.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead."), b.textContentSource = b.textContent || b.textContentStream);
                             const {
-                                container: w,
-                                viewport: C
-                            } = _, y = getComputedStyle(w), a = y.getPropertyValue("visibility"), c = parseFloat(y.getPropertyValue("--scale-factor"));
-                            a === "visible" && (!c || Math.abs(c - C.scale) > 1e-5) && console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.");
-                            const k = new v(_);
+                                container: E,
+                                viewport: w
+                            } = b, y = getComputedStyle(E), a = y.getPropertyValue("visibility"), l = parseFloat(y.getPropertyValue("--scale-factor"));
+                            a === "visible" && (!l || Math.abs(l - w.scale) > 1e-5) && console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.");
+                            const k = new v(b);
                             return k._render(), k;
                         }
 
                         function u({
-                            container: _,
-                            viewport: w,
-                            textDivs: C,
+                            container: b,
+                            viewport: E,
+                            textDivs: w,
                             textDivProperties: y,
                             isOffscreenCanvasSupported: a,
-                            mustRotate: c = !0,
+                            mustRotate: l = !0,
                             mustRescale: k = !0
                         }) {
-                            if (c && (0, P.setLayerDimensions)(_, {
-                                    rotation: w.rotation
+                            if (l && (0, P.setLayerDimensions)(b, {
+                                    rotation: E.rotation
                                 }), k) {
                                 const p = F(0, a),
-                                    T = {
+                                    x = {
                                         prevFontSize: null,
                                         prevFontFamily: null,
                                         div: null,
-                                        scale: w.scale * (globalThis.devicePixelRatio || 1),
+                                        scale: E.scale * (globalThis.devicePixelRatio || 1),
                                         properties: null,
                                         ctx: p
                                     };
-                                for (const m of C)
-                                    T.properties = y.get(m), T.div = m, I(T);
+                                for (const m of w)
+                                    x.properties = y.get(m), x.div = m, O(x);
                             }
                         }
                     },
                     /* 27 */
                     /***/
                     (dt, d, et) => {
-                        var g, O, I, x, v, A, u, _, w, C, y, ei, c, ke, p, ii, T, si;
+                        var g, L, O, T, v, A, u, b, E, w, y, ei, l, ke, p, ii, x, si;
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.AnnotationEditorLayer = void 0;
-                        var l = et(1),
+                        var c = et(1),
                             P = et(4),
                             rt = et(28),
                             X = et(33),
                             pt = et(6),
                             B = et(34);
                         const U = class U {
                             constructor({
-                                uiManager: E,
+                                uiManager: C,
                                 pageIndex: V,
                                 div: st,
                                 accessibilityManager: at,
                                 annotationLayer: H,
                                 viewport: lt,
                                 l10n: gt
                             }) {
-                                L(this, y);
-                                L(this, c);
-                                L(this, p);
-                                L(this, T);
-                                L(this, g, void 0);
-                                L(this, O, !1);
-                                L(this, I, null);
-                                L(this, x, this.pointerup.bind(this));
-                                L(this, v, this.pointerdown.bind(this));
-                                L(this, A, /* @__PURE__ */ new Map());
-                                L(this, u, !1);
-                                L(this, _, !1);
-                                L(this, w, !1);
-                                L(this, C, void 0);
+                                I(this, y);
+                                I(this, l);
+                                I(this, p);
+                                I(this, x);
+                                I(this, g, void 0);
+                                I(this, L, !1);
+                                I(this, O, null);
+                                I(this, T, this.pointerup.bind(this));
+                                I(this, v, this.pointerdown.bind(this));
+                                I(this, A, /* @__PURE__ */ new Map());
+                                I(this, u, !1);
+                                I(this, b, !1);
+                                I(this, E, !1);
+                                I(this, w, void 0);
                                 const wt = [rt.FreeTextEditor, X.InkEditor, B.StampEditor];
                                 if (!U._initialized) {
                                     U._initialized = !0;
-                                    for (const xt of wt)
-                                        xt.initialize(gt);
+                                    for (const Pt of wt)
+                                        Pt.initialize(gt);
                                 }
-                                E.registerEditorTypes(wt), Z(this, C, E), this.pageIndex = V, this.div = st, Z(this, g, at), Z(this, I, H), this.viewport = lt, t(this, C).addLayer(this);
+                                C.registerEditorTypes(wt), Z(this, w, C), this.pageIndex = V, this.div = st, Z(this, g, at), Z(this, O, H), this.viewport = lt, t(this, w).addLayer(this);
                             }
                             get isEmpty() {
                                 return t(this, A).size === 0;
                             }
-                            updateToolbar(E) {
-                                t(this, C).updateToolbar(E);
+                            updateToolbar(C) {
+                                t(this, w).updateToolbar(C);
                             }
-                            updateMode(E = t(this, C).getMode()) {
-                                W(this, T, si).call(this), E === l.AnnotationEditorType.INK ? (this.addInkEditorIfNeeded(!1), this.disableClick()) : this.enableClick(), E !== l.AnnotationEditorType.NONE && (this.div.classList.toggle("freeTextEditing", E === l.AnnotationEditorType.FREETEXT), this.div.classList.toggle("inkEditing", E === l.AnnotationEditorType.INK), this.div.classList.toggle("stampEditing", E === l.AnnotationEditorType.STAMP), this.div.hidden = !1);
+                            updateMode(C = t(this, w).getMode()) {
+                                W(this, x, si).call(this), C === c.AnnotationEditorType.INK ? (this.addInkEditorIfNeeded(!1), this.disableClick()) : this.enableClick(), C !== c.AnnotationEditorType.NONE && (this.div.classList.toggle("freeTextEditing", C === c.AnnotationEditorType.FREETEXT), this.div.classList.toggle("inkEditing", C === c.AnnotationEditorType.INK), this.div.classList.toggle("stampEditing", C === c.AnnotationEditorType.STAMP), this.div.hidden = !1);
                             }
-                            addInkEditorIfNeeded(E) {
-                                if (!E && t(this, C).getMode() !== l.AnnotationEditorType.INK)
+                            addInkEditorIfNeeded(C) {
+                                if (!C && t(this, w).getMode() !== c.AnnotationEditorType.INK)
                                     return;
-                                if (!E) {
+                                if (!C) {
                                     for (const st of t(this, A).values())
                                         if (st.isEmpty()) {
                                             st.setInBackground();
                                             return;
                                         }
                                 }
-                                W(this, c, ke).call(this, {
+                                W(this, l, ke).call(this, {
                                     offsetX: 0,
                                     offsetY: 0
                                 }, !1).setInBackground();
                             }
-                            setEditingState(E) {
-                                t(this, C).setEditingState(E);
+                            setEditingState(C) {
+                                t(this, w).setEditingState(C);
                             }
-                            addCommands(E) {
-                                t(this, C).addCommands(E);
+                            addCommands(C) {
+                                t(this, w).addCommands(C);
                             }
                             enable() {
                                 this.div.style.pointerEvents = "auto";
-                                const E = /* @__PURE__ */ new Set();
+                                const C = /* @__PURE__ */ new Set();
                                 for (const st of t(this, A).values())
-                                    st.enableEditing(), st.annotationElementId && E.add(st.annotationElementId);
-                                if (!t(this, I))
+                                    st.enableEditing(), st.annotationElementId && C.add(st.annotationElementId);
+                                if (!t(this, O))
                                     return;
-                                const V = t(this, I).getEditableAnnotations();
+                                const V = t(this, O).getEditableAnnotations();
                                 for (const st of V) {
-                                    if (st.hide(), t(this, C).isDeletedAnnotationElement(st.data.id) || E.has(st.data.id))
+                                    if (st.hide(), t(this, w).isDeletedAnnotationElement(st.data.id) || C.has(st.data.id))
                                         continue;
                                     const at = this.deserialize(st);
                                     at && (this.addOrRebuild(at), at.enableEditing());
                                 }
                             }
                             disable() {
                                 var V;
-                                Z(this, w, !0), this.div.style.pointerEvents = "none";
-                                const E = /* @__PURE__ */ new Set();
+                                Z(this, E, !0), this.div.style.pointerEvents = "none";
+                                const C = /* @__PURE__ */ new Set();
                                 for (const st of t(this, A).values()) {
                                     if (st.disableEditing(), !st.annotationElementId || st.serialize() !== null) {
-                                        E.add(st.annotationElementId);
+                                        C.add(st.annotationElementId);
                                         continue;
                                     }
                                     (V = this.getEditableAnnotation(st.annotationElementId)) == null || V.show(), st.remove();
                                 }
-                                if (t(this, I)) {
-                                    const st = t(this, I).getEditableAnnotations();
+                                if (t(this, O)) {
+                                    const st = t(this, O).getEditableAnnotations();
                                     for (const at of st) {
                                         const {
                                             id: H
                                         } = at.data;
-                                        E.has(H) || t(this, C).isDeletedAnnotationElement(H) || at.show();
+                                        C.has(H) || t(this, w).isDeletedAnnotationElement(H) || at.show();
                                     }
                                 }
-                                W(this, T, si).call(this), this.isEmpty && (this.div.hidden = !0), Z(this, w, !1);
+                                W(this, x, si).call(this), this.isEmpty && (this.div.hidden = !0), Z(this, E, !1);
                             }
-                            getEditableAnnotation(E) {
+                            getEditableAnnotation(C) {
                                 var V;
-                                return ((V = t(this, I)) == null ? void 0 : V.getEditableAnnotation(E)) || null;
+                                return ((V = t(this, O)) == null ? void 0 : V.getEditableAnnotation(C)) || null;
                             }
-                            setActiveEditor(E) {
-                                t(this, C).getActive() !== E && t(this, C).setActiveEditor(E);
+                            setActiveEditor(C) {
+                                t(this, w).getActive() !== C && t(this, w).setActiveEditor(C);
                             }
                             enableClick() {
-                                this.div.addEventListener("pointerdown", t(this, v)), this.div.addEventListener("pointerup", t(this, x));
+                                this.div.addEventListener("pointerdown", t(this, v)), this.div.addEventListener("pointerup", t(this, T));
                             }
                             disableClick() {
-                                this.div.removeEventListener("pointerdown", t(this, v)), this.div.removeEventListener("pointerup", t(this, x));
+                                this.div.removeEventListener("pointerdown", t(this, v)), this.div.removeEventListener("pointerup", t(this, T));
                             }
-                            attach(E) {
-                                t(this, A).set(E.id, E);
+                            attach(C) {
+                                t(this, A).set(C.id, C);
                                 const {
                                     annotationElementId: V
-                                } = E;
-                                V && t(this, C).isDeletedAnnotationElement(V) && t(this, C).removeDeletedAnnotationElement(E);
+                                } = C;
+                                V && t(this, w).isDeletedAnnotationElement(V) && t(this, w).removeDeletedAnnotationElement(C);
                             }
-                            detach(E) {
+                            detach(C) {
                                 var V;
-                                t(this, A).delete(E.id), (V = t(this, g)) == null || V.removePointerInTextLayer(E.contentDiv), !t(this, w) && E.annotationElementId && t(this, C).addDeletedAnnotationElement(E);
+                                t(this, A).delete(C.id), (V = t(this, g)) == null || V.removePointerInTextLayer(C.contentDiv), !t(this, E) && C.annotationElementId && t(this, w).addDeletedAnnotationElement(C);
                             }
-                            remove(E) {
-                                this.detach(E), t(this, C).removeEditor(E), E.div.contains(document.activeElement) && setTimeout(() => {
-                                    t(this, C).focusMainContainer();
-                                }, 0), E.div.remove(), E.isAttachedToDOM = !1, t(this, _) || this.addInkEditorIfNeeded(!1);
+                            remove(C) {
+                                this.detach(C), t(this, w).removeEditor(C), C.div.contains(document.activeElement) && setTimeout(() => {
+                                    t(this, w).focusMainContainer();
+                                }, 0), C.div.remove(), C.isAttachedToDOM = !1, t(this, b) || this.addInkEditorIfNeeded(!1);
                             }
-                            changeParent(E) {
+                            changeParent(C) {
                                 var V;
-                                E.parent !== this && (E.annotationElementId && (t(this, C).addDeletedAnnotationElement(E.annotationElementId), P.AnnotationEditor.deleteAnnotationElement(E), E.annotationElementId = null), this.attach(E), (V = E.parent) == null || V.detach(E), E.setParent(this), E.div && E.isAttachedToDOM && (E.div.remove(), this.div.append(E.div)));
+                                C.parent !== this && (C.annotationElementId && (t(this, w).addDeletedAnnotationElement(C.annotationElementId), P.AnnotationEditor.deleteAnnotationElement(C), C.annotationElementId = null), this.attach(C), (V = C.parent) == null || V.detach(C), C.setParent(this), C.div && C.isAttachedToDOM && (C.div.remove(), this.div.append(C.div)));
                             }
-                            add(E) {
-                                if (this.changeParent(E), t(this, C).addEditor(E), this.attach(E), !E.isAttachedToDOM) {
-                                    const V = E.render();
-                                    this.div.append(V), E.isAttachedToDOM = !0;
+                            add(C) {
+                                if (this.changeParent(C), t(this, w).addEditor(C), this.attach(C), !C.isAttachedToDOM) {
+                                    const V = C.render();
+                                    this.div.append(V), C.isAttachedToDOM = !0;
                                 }
-                                E.fixAndSetPosition(), E.onceAdded(), t(this, C).addToAnnotationStorage(E);
+                                C.fixAndSetPosition(), C.onceAdded(), t(this, w).addToAnnotationStorage(C);
                             }
-                            moveEditorInDOM(E) {
+                            moveEditorInDOM(C) {
                                 var st;
-                                if (!E.isAttachedToDOM)
+                                if (!C.isAttachedToDOM)
                                     return;
                                 const {
                                     activeElement: V
                                 } = document;
-                                E.div.contains(V) && (E._focusEventsAllowed = !1, setTimeout(() => {
-                                    E.div.contains(document.activeElement) ? E._focusEventsAllowed = !0 : (E.div.addEventListener("focusin", () => {
-                                        E._focusEventsAllowed = !0;
+                                C.div.contains(V) && (C._focusEventsAllowed = !1, setTimeout(() => {
+                                    C.div.contains(document.activeElement) ? C._focusEventsAllowed = !0 : (C.div.addEventListener("focusin", () => {
+                                        C._focusEventsAllowed = !0;
                                     }, {
                                         once: !0
                                     }), V.focus());
-                                }, 0)), E._structTreeParentId = (st = t(this, g)) == null ? void 0 : st.moveElementInDOM(this.div, E.div, E.contentDiv, !0);
+                                }, 0)), C._structTreeParentId = (st = t(this, g)) == null ? void 0 : st.moveElementInDOM(this.div, C.div, C.contentDiv, !0);
                             }
-                            addOrRebuild(E) {
-                                E.needsToBeRebuilt() ? E.rebuild() : this.add(E);
+                            addOrRebuild(C) {
+                                C.needsToBeRebuilt() ? C.rebuild() : this.add(C);
                             }
-                            addUndoableEditor(E) {
-                                const V = () => E._uiManager.rebuild(E),
+                            addUndoableEditor(C) {
+                                const V = () => C._uiManager.rebuild(C),
                                     st = () => {
-                                        E.remove();
+                                        C.remove();
                                     };
                                 this.addCommands({
                                     cmd: V,
                                     undo: st,
                                     mustExec: !1
                                 });
                             }
                             getNextId() {
-                                return t(this, C).getId();
+                                return t(this, w).getId();
                             }
-                            pasteEditor(E, V) {
-                                t(this, C).updateToolbar(E), t(this, C).updateMode(E);
+                            pasteEditor(C, V) {
+                                t(this, w).updateToolbar(C), t(this, w).updateMode(C);
                                 const {
                                     offsetX: st,
                                     offsetY: at
                                 } = W(this, p, ii).call(this), H = this.getNextId(), lt = W(this, y, ei).call(this, {
                                     parent: this,
                                     id: H,
                                     x: st,
                                     y: at,
-                                    uiManager: t(this, C),
+                                    uiManager: t(this, w),
                                     isCentered: !0,
                                     ...V
                                 });
                                 lt && this.add(lt);
                             }
-                            deserialize(E) {
-                                switch (E.annotationType ?? E.annotationEditorType) {
-                                    case l.AnnotationEditorType.FREETEXT:
-                                        return rt.FreeTextEditor.deserialize(E, this, t(this, C));
-                                    case l.AnnotationEditorType.INK:
-                                        return X.InkEditor.deserialize(E, this, t(this, C));
-                                    case l.AnnotationEditorType.STAMP:
-                                        return B.StampEditor.deserialize(E, this, t(this, C));
+                            deserialize(C) {
+                                switch (C.annotationType ?? C.annotationEditorType) {
+                                    case c.AnnotationEditorType.FREETEXT:
+                                        return rt.FreeTextEditor.deserialize(C, this, t(this, w));
+                                    case c.AnnotationEditorType.INK:
+                                        return X.InkEditor.deserialize(C, this, t(this, w));
+                                    case c.AnnotationEditorType.STAMP:
+                                        return B.StampEditor.deserialize(C, this, t(this, w));
                                 }
                                 return null;
                             }
                             addNewEditor() {
-                                W(this, c, ke).call(this, W(this, p, ii).call(this), !0);
+                                W(this, l, ke).call(this, W(this, p, ii).call(this), !0);
                             }
-                            setSelected(E) {
-                                t(this, C).setSelected(E);
+                            setSelected(C) {
+                                t(this, w).setSelected(C);
                             }
-                            toggleSelected(E) {
-                                t(this, C).toggleSelected(E);
+                            toggleSelected(C) {
+                                t(this, w).toggleSelected(C);
                             }
-                            isSelected(E) {
-                                return t(this, C).isSelected(E);
+                            isSelected(C) {
+                                return t(this, w).isSelected(C);
                             }
-                            unselect(E) {
-                                t(this, C).unselect(E);
+                            unselect(C) {
+                                t(this, w).unselect(C);
                             }
-                            pointerup(E) {
+                            pointerup(C) {
                                 const {
                                     isMac: V
-                                } = l.FeatureTest.platform;
-                                if (!(E.button !== 0 || E.ctrlKey && V) && E.target === this.div && t(this, u)) {
-                                    if (Z(this, u, !1), !t(this, O)) {
-                                        Z(this, O, !0);
+                                } = c.FeatureTest.platform;
+                                if (!(C.button !== 0 || C.ctrlKey && V) && C.target === this.div && t(this, u)) {
+                                    if (Z(this, u, !1), !t(this, L)) {
+                                        Z(this, L, !0);
                                         return;
                                     }
-                                    if (t(this, C).getMode() === l.AnnotationEditorType.STAMP) {
-                                        t(this, C).unselectAll();
+                                    if (t(this, w).getMode() === c.AnnotationEditorType.STAMP) {
+                                        t(this, w).unselectAll();
                                         return;
                                     }
-                                    W(this, c, ke).call(this, E, !1);
+                                    W(this, l, ke).call(this, C, !1);
                                 }
                             }
-                            pointerdown(E) {
+                            pointerdown(C) {
                                 if (t(this, u)) {
                                     Z(this, u, !1);
                                     return;
                                 }
                                 const {
                                     isMac: V
-                                } = l.FeatureTest.platform;
-                                if (E.button !== 0 || E.ctrlKey && V || E.target !== this.div)
+                                } = c.FeatureTest.platform;
+                                if (C.button !== 0 || C.ctrlKey && V || C.target !== this.div)
                                     return;
                                 Z(this, u, !0);
-                                const st = t(this, C).getActive();
-                                Z(this, O, !st || st.isEmpty());
+                                const st = t(this, w).getActive();
+                                Z(this, L, !st || st.isEmpty());
                             }
-                            findNewParent(E, V, st) {
-                                const at = t(this, C).findParent(V, st);
-                                return at === null || at === this ? !1 : (at.changeParent(E), !0);
+                            findNewParent(C, V, st) {
+                                const at = t(this, w).findParent(V, st);
+                                return at === null || at === this ? !1 : (at.changeParent(C), !0);
                             }
                             destroy() {
-                                var E, V;
-                                ((E = t(this, C).getActive()) == null ? void 0 : E.parent) === this && (t(this, C).commitOrRemove(), t(this, C).setActiveEditor(null));
+                                var C, V;
+                                ((C = t(this, w).getActive()) == null ? void 0 : C.parent) === this && (t(this, w).commitOrRemove(), t(this, w).setActiveEditor(null));
                                 for (const st of t(this, A).values())
                                     (V = t(this, g)) == null || V.removePointerInTextLayer(st.contentDiv), st.setParent(null), st.isAttachedToDOM = !1, st.div.remove();
-                                this.div = null, t(this, A).clear(), t(this, C).removeLayer(this);
+                                this.div = null, t(this, A).clear(), t(this, w).removeLayer(this);
                             }
                             render({
-                                viewport: E
+                                viewport: C
                             }) {
-                                this.viewport = E, (0, pt.setLayerDimensions)(this.div, E);
-                                for (const V of t(this, C).getEditors(this.pageIndex))
+                                this.viewport = C, (0, pt.setLayerDimensions)(this.div, C);
+                                for (const V of t(this, w).getEditors(this.pageIndex))
                                     this.add(V);
                                 this.updateMode();
                             }
                             update({
-                                viewport: E
+                                viewport: C
                             }) {
-                                t(this, C).commitOrRemove(), this.viewport = E, (0, pt.setLayerDimensions)(this.div, {
-                                    rotation: E.rotation
+                                t(this, w).commitOrRemove(), this.viewport = C, (0, pt.setLayerDimensions)(this.div, {
+                                    rotation: C.rotation
                                 }), this.updateMode();
                             }
                             get pageDimensions() {
                                 const {
-                                    pageWidth: E,
+                                    pageWidth: C,
                                     pageHeight: V
                                 } = this.viewport.rawDims;
-                                return [E, V];
+                                return [C, V];
                             }
                         };
-                        g = new WeakMap(), O = new WeakMap(), I = new WeakMap(), x = new WeakMap(), v = new WeakMap(), A = new WeakMap(), u = new WeakMap(), _ = new WeakMap(), w = new WeakMap(), C = new WeakMap(), y = new WeakSet(), ei = function(E) {
-                            switch (t(this, C).getMode()) {
-                                case l.AnnotationEditorType.FREETEXT:
-                                    return new rt.FreeTextEditor(E);
-                                case l.AnnotationEditorType.INK:
-                                    return new X.InkEditor(E);
-                                case l.AnnotationEditorType.STAMP:
-                                    return new B.StampEditor(E);
+                        g = new WeakMap(), L = new WeakMap(), O = new WeakMap(), T = new WeakMap(), v = new WeakMap(), A = new WeakMap(), u = new WeakMap(), b = new WeakMap(), E = new WeakMap(), w = new WeakMap(), y = new WeakSet(), ei = function(C) {
+                            switch (t(this, w).getMode()) {
+                                case c.AnnotationEditorType.FREETEXT:
+                                    return new rt.FreeTextEditor(C);
+                                case c.AnnotationEditorType.INK:
+                                    return new X.InkEditor(C);
+                                case c.AnnotationEditorType.STAMP:
+                                    return new B.StampEditor(C);
                             }
                             return null;
-                        }, c = new WeakSet(), ke = function(E, V) {
+                        }, l = new WeakSet(), ke = function(C, V) {
                             const st = this.getNextId(),
                                 at = W(this, y, ei).call(this, {
                                     parent: this,
                                     id: st,
-                                    x: E.offsetX,
-                                    y: E.offsetY,
-                                    uiManager: t(this, C),
+                                    x: C.offsetX,
+                                    y: C.offsetY,
+                                    uiManager: t(this, w),
                                     isCentered: V
                                 });
                             return at && this.add(at), at;
                         }, p = new WeakSet(), ii = function() {
                             const {
-                                x: E,
+                                x: C,
                                 y: V,
                                 width: st,
                                 height: at
-                            } = this.div.getBoundingClientRect(), H = Math.max(0, E), lt = Math.max(0, V), gt = Math.min(window.innerWidth, E + st), wt = Math.min(window.innerHeight, V + at), xt = (H + gt) / 2 - E, S = (lt + wt) / 2 - V, [i, n] = this.viewport.rotation % 180 === 0 ? [xt, S] : [S, xt];
+                            } = this.div.getBoundingClientRect(), H = Math.max(0, C), lt = Math.max(0, V), gt = Math.min(window.innerWidth, C + st), wt = Math.min(window.innerHeight, V + at), Pt = (H + gt) / 2 - C, S = (lt + wt) / 2 - V, [i, n] = this.viewport.rotation % 180 === 0 ? [Pt, S] : [S, Pt];
                             return {
                                 offsetX: i,
                                 offsetY: n
                             };
-                        }, T = new WeakSet(), si = function() {
-                            Z(this, _, !0);
-                            for (const E of t(this, A).values())
-                                E.isEmpty() && E.remove();
-                            Z(this, _, !1);
+                        }, x = new WeakSet(), si = function() {
+                            Z(this, b, !0);
+                            for (const C of t(this, A).values())
+                                C.isEmpty() && C.remove();
+                            Z(this, b, !1);
                         }, ee(U, "_initialized", !1);
                         let F = U;
                         d.AnnotationEditorLayer = F;
                     },
                     /* 28 */
                     /***/
                     (dt, d, et) => {
-                        var B, F, g, O, I, x, v, A, u, _, Fi, C, Mi, a, Ri, k, ye, r, ni, m, Di, z, ri;
+                        var B, F, g, L, O, T, v, A, u, b, Fi, w, Mi, a, Ri, k, ye, r, ni, m, Di, z, ri;
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.FreeTextEditor = void 0;
-                        var l = et(1),
+                        var c = et(1),
                             P = et(5),
                             rt = et(4),
                             X = et(29);
                         const V = class V extends rt.AnnotationEditor {
                             constructor(H) {
                                 super({
                                     ...H,
                                     name: "freeTextEditor"
                                 });
-                                L(this, _);
-                                L(this, C);
-                                L(this, a);
-                                L(this, k);
-                                L(this, r);
-                                L(this, m);
-                                L(this, z);
-                                L(this, B, this.editorDivBlur.bind(this));
-                                L(this, F, this.editorDivFocus.bind(this));
-                                L(this, g, this.editorDivInput.bind(this));
-                                L(this, O, this.editorDivKeydown.bind(this));
-                                L(this, I, void 0);
-                                L(this, x, "");
-                                L(this, v, `${this.id}-editor`);
-                                L(this, A, void 0);
-                                L(this, u, null);
-                                Z(this, I, H.color || V._defaultColor || rt.AnnotationEditor._defaultLineColor), Z(this, A, H.fontSize || V._defaultFontSize);
+                                I(this, b);
+                                I(this, w);
+                                I(this, a);
+                                I(this, k);
+                                I(this, r);
+                                I(this, m);
+                                I(this, z);
+                                I(this, B, this.editorDivBlur.bind(this));
+                                I(this, F, this.editorDivFocus.bind(this));
+                                I(this, g, this.editorDivInput.bind(this));
+                                I(this, L, this.editorDivKeydown.bind(this));
+                                I(this, O, void 0);
+                                I(this, T, "");
+                                I(this, v, `${this.id}-editor`);
+                                I(this, A, void 0);
+                                I(this, u, null);
+                                Z(this, O, H.color || V._defaultColor || rt.AnnotationEditor._defaultLineColor), Z(this, A, H.fontSize || V._defaultFontSize);
                             }
                             static get _keyboardManager() {
                                 const H = V.prototype,
-                                    lt = (xt) => xt.isEmpty(),
+                                    lt = (Pt) => Pt.isEmpty(),
                                     gt = P.AnnotationEditorUIManager.TRANSLATE_SMALL,
                                     wt = P.AnnotationEditorUIManager.TRANSLATE_BIG;
-                                return (0, l.shadow)(this, "_keyboardManager", new P.KeyboardManager([
+                                return (0, c.shadow)(this, "_keyboardManager", new P.KeyboardManager([
                                     [
                                         ["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], H.commitOrRemove, {
                                             bubbles: !0
                                         }
                                     ],
                                     [
                                         ["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], H.commitOrRemove
@@ -9664,59 +9658,59 @@
                                     strings: ["free_text2_default_content", "editor_free_text2_aria_label"]
                                 });
                                 const lt = getComputedStyle(document.documentElement);
                                 this._internalPadding = parseFloat(lt.getPropertyValue("--freetext-padding"));
                             }
                             static updateDefaultParams(H, lt) {
                                 switch (H) {
-                                    case l.AnnotationEditorParamsType.FREETEXT_SIZE:
+                                    case c.AnnotationEditorParamsType.FREETEXT_SIZE:
                                         V._defaultFontSize = lt;
                                         break;
-                                    case l.AnnotationEditorParamsType.FREETEXT_COLOR:
+                                    case c.AnnotationEditorParamsType.FREETEXT_COLOR:
                                         V._defaultColor = lt;
                                         break;
                                 }
                             }
                             updateParams(H, lt) {
                                 switch (H) {
-                                    case l.AnnotationEditorParamsType.FREETEXT_SIZE:
-                                        W(this, _, Fi).call(this, lt);
+                                    case c.AnnotationEditorParamsType.FREETEXT_SIZE:
+                                        W(this, b, Fi).call(this, lt);
                                         break;
-                                    case l.AnnotationEditorParamsType.FREETEXT_COLOR:
-                                        W(this, C, Mi).call(this, lt);
+                                    case c.AnnotationEditorParamsType.FREETEXT_COLOR:
+                                        W(this, w, Mi).call(this, lt);
                                         break;
                                 }
                             }
                             static get defaultPropertiesToUpdate() {
                                 return [
-                                    [l.AnnotationEditorParamsType.FREETEXT_SIZE, V._defaultFontSize],
-                                    [l.AnnotationEditorParamsType.FREETEXT_COLOR, V._defaultColor || rt.AnnotationEditor._defaultLineColor]
+                                    [c.AnnotationEditorParamsType.FREETEXT_SIZE, V._defaultFontSize],
+                                    [c.AnnotationEditorParamsType.FREETEXT_COLOR, V._defaultColor || rt.AnnotationEditor._defaultLineColor]
                                 ];
                             }
                             get propertiesToUpdate() {
                                 return [
-                                    [l.AnnotationEditorParamsType.FREETEXT_SIZE, t(this, A)],
-                                    [l.AnnotationEditorParamsType.FREETEXT_COLOR, t(this, I)]
+                                    [c.AnnotationEditorParamsType.FREETEXT_SIZE, t(this, A)],
+                                    [c.AnnotationEditorParamsType.FREETEXT_COLOR, t(this, O)]
                                 ];
                             }
                             _translateEmpty(H, lt) {
                                 this._uiManager.translateSelectedEditors(H, lt, !0);
                             }
                             getInitialTranslation() {
                                 const H = this.parentScale;
                                 return [-V._internalPadding * H, -(V._internalPadding + t(this, A)) * H];
                             }
                             rebuild() {
                                 this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
                             }
                             enableEditMode() {
-                                this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(l.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), this.editorDiv.addEventListener("keydown", t(this, O)), this.editorDiv.addEventListener("focus", t(this, F)), this.editorDiv.addEventListener("blur", t(this, B)), this.editorDiv.addEventListener("input", t(this, g)));
+                                this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(c.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), this.editorDiv.addEventListener("keydown", t(this, L)), this.editorDiv.addEventListener("focus", t(this, F)), this.editorDiv.addEventListener("blur", t(this, B)), this.editorDiv.addEventListener("input", t(this, g)));
                             }
                             disableEditMode() {
-                                this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", t(this, v)), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", t(this, O)), this.editorDiv.removeEventListener("focus", t(this, F)), this.editorDiv.removeEventListener("blur", t(this, B)), this.editorDiv.removeEventListener("input", t(this, g)), this.div.focus({
+                                this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", t(this, v)), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", t(this, L)), this.editorDiv.removeEventListener("focus", t(this, F)), this.editorDiv.removeEventListener("blur", t(this, B)), this.editorDiv.removeEventListener("input", t(this, g)), this.div.focus({
                                     preventScroll: !0
                                 }), this.isEditing = !1, this.parent.div.classList.add("freeTextEditing"));
                             }
                             focusin(H) {
                                 this._focusEventsAllowed && (super.focusin(H), H.target !== this.editorDiv && this.editorDiv.focus());
                             }
                             onceAdded() {
@@ -9733,20 +9727,20 @@
                             remove() {
                                 this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freeTextEditing")), super.remove();
                             }
                             commit() {
                                 if (!this.isInEditMode())
                                     return;
                                 super.commit(), this.disableEditMode();
-                                const H = t(this, x),
-                                    lt = Z(this, x, W(this, a, Ri).call(this).trimEnd());
+                                const H = t(this, T),
+                                    lt = Z(this, T, W(this, a, Ri).call(this).trimEnd());
                                 if (H === lt)
                                     return;
                                 const gt = (wt) => {
-                                    if (Z(this, x, wt), !wt) {
+                                    if (Z(this, T, wt), !wt) {
                                         this.remove();
                                         return;
                                     }
                                     W(this, r, ni).call(this), this._uiManager.rebuild(this), W(this, k, ye).call(this);
                                 };
                                 this.addCommands({
                                     cmd: () => {
@@ -9789,50 +9783,50 @@
                                 this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
                             }
                             render() {
                                 if (this.div)
                                     return this.div;
                                 let H, lt;
                                 this.width && (H = this.x, lt = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", t(this, v)), this.enableEditing(), rt.AnnotationEditor._l10nPromise.get("editor_free_text2_aria_label").then((wt) => {
-                                    var xt;
-                                    return (xt = this.editorDiv) == null ? void 0 : xt.setAttribute("aria-label", wt);
+                                    var Pt;
+                                    return (Pt = this.editorDiv) == null ? void 0 : Pt.setAttribute("aria-label", wt);
                                 }), rt.AnnotationEditor._l10nPromise.get("free_text2_default_content").then((wt) => {
-                                    var xt;
-                                    return (xt = this.editorDiv) == null ? void 0 : xt.setAttribute("default-content", wt);
+                                    var Pt;
+                                    return (Pt = this.editorDiv) == null ? void 0 : Pt.setAttribute("default-content", wt);
                                 }), this.editorDiv.contentEditable = !0;
                                 const {
                                     style: gt
                                 } = this.editorDiv;
-                                if (gt.fontSize = `calc(${t(this, A)}px * var(--scale-factor))`, gt.color = t(this, I), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, P.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) {
-                                    const [wt, xt] = this.parentDimensions;
+                                if (gt.fontSize = `calc(${t(this, A)}px * var(--scale-factor))`, gt.color = t(this, O), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, P.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) {
+                                    const [wt, Pt] = this.parentDimensions;
                                     if (this.annotationElementId) {
                                         const {
                                             position: S
                                         } = t(this, u);
                                         let [i, n] = this.getInitialTranslation();
                                         [i, n] = this.pageTranslationToScreen(i, n);
-                                        const [s, o] = this.pageDimensions, [h, b] = this.pageTranslation;
+                                        const [s, o] = this.pageDimensions, [h, _] = this.pageTranslation;
                                         let M, N;
                                         switch (this.rotation) {
                                             case 0:
-                                                M = H + (S[0] - h) / s, N = lt + this.height - (S[1] - b) / o;
+                                                M = H + (S[0] - h) / s, N = lt + this.height - (S[1] - _) / o;
                                                 break;
                                             case 90:
-                                                M = H + (S[0] - h) / s, N = lt - (S[1] - b) / o, [i, n] = [n, -i];
+                                                M = H + (S[0] - h) / s, N = lt - (S[1] - _) / o, [i, n] = [n, -i];
                                                 break;
                                             case 180:
-                                                M = H - this.width + (S[0] - h) / s, N = lt - (S[1] - b) / o, [i, n] = [-i, -n];
+                                                M = H - this.width + (S[0] - h) / s, N = lt - (S[1] - _) / o, [i, n] = [-i, -n];
                                                 break;
                                             case 270:
-                                                M = H + (S[0] - h - this.height * o) / s, N = lt + (S[1] - b - this.width * s) / o, [i, n] = [-n, i];
+                                                M = H + (S[0] - h - this.height * o) / s, N = lt + (S[1] - _ - this.width * s) / o, [i, n] = [-n, i];
                                                 break;
                                         }
-                                        this.setAt(M * wt, N * xt, i, n);
+                                        this.setAt(M * wt, N * Pt, i, n);
                                     } else
-                                        this.setAt(H * wt, lt * xt, this.width * wt, this.height * xt);
+                                        this.setAt(H * wt, lt * Pt, this.width * wt, this.height * Pt);
                                     W(this, r, ni).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
                                 } else
                                     this._isDraggable = !1, this.editorDiv.contentEditable = !0;
                                 return this.div;
                             }
                             get contentDiv() {
                                 return this.editorDiv;
@@ -9847,93 +9841,93 @@
                                                 fontColor: i
                                             },
                                             rect: n,
                                             rotation: s,
                                             id: o
                                         },
                                         textContent: h,
-                                        textPosition: b,
+                                        textPosition: _,
                                         parent: {
                                             page: {
                                                 pageNumber: M
                                             }
                                         }
                                     } = H;
                                     if (!h || h.length === 0)
                                         return null;
                                     wt = H = {
-                                        annotationType: l.AnnotationEditorType.FREETEXT,
+                                        annotationType: c.AnnotationEditorType.FREETEXT,
                                         color: Array.from(i),
                                         fontSize: S,
                                         value: h.join(`
 `),
-                                        position: b,
+                                        position: _,
                                         pageIndex: M - 1,
                                         rect: n,
                                         rotation: s,
                                         id: o,
                                         deleted: !1
                                     };
                                 }
-                                const xt = super.deserialize(H, lt, gt);
-                                return Z(xt, A, H.fontSize), Z(xt, I, l.Util.makeHexColor(...H.color)), Z(xt, x, H.value), xt.annotationElementId = H.id || null, Z(xt, u, wt), xt;
+                                const Pt = super.deserialize(H, lt, gt);
+                                return Z(Pt, A, H.fontSize), Z(Pt, O, c.Util.makeHexColor(...H.color)), Z(Pt, T, H.value), Pt.annotationElementId = H.id || null, Z(Pt, u, wt), Pt;
                             }
                             serialize(H = !1) {
                                 if (this.isEmpty())
                                     return null;
                                 if (this.deleted)
                                     return {
                                         pageIndex: this.pageIndex,
                                         id: this.annotationElementId,
                                         deleted: !0
                                     };
                                 const lt = V._internalPadding * this.parentScale,
                                     gt = this.getRect(lt, lt),
-                                    wt = rt.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : t(this, I)),
-                                    xt = {
-                                        annotationType: l.AnnotationEditorType.FREETEXT,
+                                    wt = rt.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : t(this, O)),
+                                    Pt = {
+                                        annotationType: c.AnnotationEditorType.FREETEXT,
                                         color: wt,
                                         fontSize: t(this, A),
-                                        value: t(this, x),
+                                        value: t(this, T),
                                         pageIndex: this.pageIndex,
                                         rect: gt,
                                         rotation: this.rotation,
                                         structTreeParentId: this._structTreeParentId
                                     };
-                                return H ? xt : this.annotationElementId && !W(this, m, Di).call(this, xt) ? null : (xt.id = this.annotationElementId, xt);
+                                return H ? Pt : this.annotationElementId && !W(this, m, Di).call(this, Pt) ? null : (Pt.id = this.annotationElementId, Pt);
                             }
                         };
-                        B = new WeakMap(), F = new WeakMap(), g = new WeakMap(), O = new WeakMap(), I = new WeakMap(), x = new WeakMap(), v = new WeakMap(), A = new WeakMap(), u = new WeakMap(), _ = new WeakSet(), Fi = function(H) {
+                        B = new WeakMap(), F = new WeakMap(), g = new WeakMap(), L = new WeakMap(), O = new WeakMap(), T = new WeakMap(), v = new WeakMap(), A = new WeakMap(), u = new WeakMap(), b = new WeakSet(), Fi = function(H) {
                             const lt = (wt) => {
                                     this.editorDiv.style.fontSize = `calc(${wt}px * var(--scale-factor))`, this.translate(0, -(wt - t(this, A)) * this.parentScale), Z(this, A, wt), W(this, k, ye).call(this);
                                 },
                                 gt = t(this, A);
                             this.addCommands({
                                 cmd: () => {
                                     lt(H);
                                 },
                                 undo: () => {
                                     lt(gt);
                                 },
                                 mustExec: !0,
-                                type: l.AnnotationEditorParamsType.FREETEXT_SIZE,
+                                type: c.AnnotationEditorParamsType.FREETEXT_SIZE,
                                 overwriteIfSameType: !0,
                                 keepUndo: !0
                             });
-                        }, C = new WeakSet(), Mi = function(H) {
-                            const lt = t(this, I);
+                        }, w = new WeakSet(), Mi = function(H) {
+                            const lt = t(this, O);
                             this.addCommands({
                                 cmd: () => {
-                                    Z(this, I, this.editorDiv.style.color = H);
+                                    Z(this, O, this.editorDiv.style.color = H);
                                 },
                                 undo: () => {
-                                    Z(this, I, this.editorDiv.style.color = lt);
+                                    Z(this, O, this.editorDiv.style.color = lt);
                                 },
                                 mustExec: !0,
-                                type: l.AnnotationEditorParamsType.FREETEXT_COLOR,
+                                type: c.AnnotationEditorParamsType.FREETEXT_COLOR,
                                 overwriteIfSameType: !0,
                                 keepUndo: !0
                             });
                         }, a = new WeakSet(), Ri = function() {
                             const H = this.editorDiv.getElementsByTagName("div");
                             if (H.length === 0)
                                 return this.editorDiv.innerText;
@@ -9946,35 +9940,35 @@
                             const [H, lt] = this.parentDimensions;
                             let gt;
                             if (this.isAttachedToDOM)
                                 gt = this.div.getBoundingClientRect();
                             else {
                                 const {
                                     currentLayer: wt,
-                                    div: xt
-                                } = this, S = xt.style.display;
-                                xt.style.display = "hidden", wt.div.append(this.div), gt = xt.getBoundingClientRect(), xt.remove(), xt.style.display = S;
+                                    div: Pt
+                                } = this, S = Pt.style.display;
+                                Pt.style.display = "hidden", wt.div.append(this.div), gt = Pt.getBoundingClientRect(), Pt.remove(), Pt.style.display = S;
                             }
                             this.rotation % 180 === this.parentRotation % 180 ? (this.width = gt.width / H, this.height = gt.height / lt) : (this.width = gt.height / H, this.height = gt.width / lt), this.fixAndSetPosition();
                         }, r = new WeakSet(), ni = function() {
-                            if (this.editorDiv.replaceChildren(), !!t(this, x))
-                                for (const H of t(this, x).split(`
+                            if (this.editorDiv.replaceChildren(), !!t(this, T))
+                                for (const H of t(this, T).split(`
 `)) {
                                     const lt = document.createElement("div");
                                     lt.append(H ? document.createTextNode(H) : document.createElement("br")), this.editorDiv.append(lt);
                                 }
                         }, m = new WeakSet(), Di = function(H) {
                             const {
                                 value: lt,
                                 fontSize: gt,
                                 color: wt,
-                                rect: xt,
+                                rect: Pt,
                                 pageIndex: S
                             } = t(this, u);
-                            return H.value !== lt || H.fontSize !== gt || H.rect.some((i, n) => Math.abs(i - xt[n]) >= 1) || H.color.some((i, n) => i !== wt[n]) || H.pageIndex !== S;
+                            return H.value !== lt || H.fontSize !== gt || H.rect.some((i, n) => Math.abs(i - Pt[n]) >= 1) || H.color.some((i, n) => i !== wt[n]) || H.pageIndex !== S;
                         }, z = new WeakSet(), ri = function(H = !1) {
                             if (!this.annotationElementId)
                                 return;
                             if (W(this, k, ye).call(this), !H && (this.width === 0 || this.height === 0)) {
                                 setTimeout(() => W(this, z, ri).call(this, !0), 0);
                                 return;
                             }
@@ -9983,95 +9977,95 @@
                         }, ee(V, "_freeTextDefaultContent", ""), ee(V, "_internalPadding", 0), ee(V, "_defaultColor", null), ee(V, "_defaultFontSize", 10), ee(V, "_type", "freetext");
                         let pt = V;
                         d.FreeTextEditor = pt;
                     },
                     /* 29 */
                     /***/
                     (dt, d, et) => {
-                        var n, o, ce, b, Ii, N, tt, Q, nt, ct, yt, ut, Ft, Bt, St, Dt, ft, K, J, ht, Et, Ct, Ut, Li, Ht, Fe, Vt, ai, $t, oi, Y, G, bt, At, te, Zt, $, li, Lt, Tt, Ot, Nt, Oi, _t, ci;
+                        var n, o, ce, _, Ii, N, tt, Q, nt, ct, yt, ut, Ft, Bt, St, Dt, ft, K, J, ht, Et, Ct, Ut, Li, Ht, Fe, Vt, ai, $t, oi, Y, G, bt, At, te, Zt, $, li, Lt, Tt, Ot, Nt, Oi, _t, ci;
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.StampAnnotationElement = d.InkAnnotationElement = d.FreeTextAnnotationElement = d.AnnotationLayer = void 0;
-                        var l = et(1),
+                        var c = et(1),
                             P = et(6),
                             rt = et(3),
                             X = et(30),
                             pt = et(31),
                             B = et(32);
                         const F = 1e3,
                             g = 9,
-                            O = /* @__PURE__ */ new WeakSet();
+                            L = /* @__PURE__ */ new WeakSet();
 
-                        function I(It) {
+                        function O(It) {
                             return {
                                 width: It[2] - It[0],
                                 height: It[3] - It[1]
                             };
                         }
-                        class x {
+                        class T {
                             static create(R) {
                                 switch (R.data.annotationType) {
-                                    case l.AnnotationType.LINK:
+                                    case c.AnnotationType.LINK:
                                         return new A(R);
-                                    case l.AnnotationType.TEXT:
+                                    case c.AnnotationType.TEXT:
                                         return new u(R);
-                                    case l.AnnotationType.WIDGET:
+                                    case c.AnnotationType.WIDGET:
                                         switch (R.data.fieldType) {
                                             case "Tx":
-                                                return new w(R);
+                                                return new E(R);
                                             case "Btn":
-                                                return R.data.radioButton ? new a(R) : R.data.checkBox ? new y(R) : new c(R);
+                                                return R.data.radioButton ? new a(R) : R.data.checkBox ? new y(R) : new l(R);
                                             case "Ch":
                                                 return new k(R);
                                             case "Sig":
-                                                return new C(R);
+                                                return new w(R);
                                         }
-                                        return new _(R);
-                                    case l.AnnotationType.POPUP:
+                                        return new b(R);
+                                    case c.AnnotationType.POPUP:
                                         return new p(R);
-                                    case l.AnnotationType.FREETEXT:
-                                        return new T(R);
-                                    case l.AnnotationType.LINE:
+                                    case c.AnnotationType.FREETEXT:
+                                        return new x(R);
+                                    case c.AnnotationType.LINE:
                                         return new m(R);
-                                    case l.AnnotationType.SQUARE:
+                                    case c.AnnotationType.SQUARE:
                                         return new U(R);
-                                    case l.AnnotationType.CIRCLE:
+                                    case c.AnnotationType.CIRCLE:
                                         return new z(R);
-                                    case l.AnnotationType.POLYLINE:
-                                        return new E(R);
-                                    case l.AnnotationType.CARET:
+                                    case c.AnnotationType.POLYLINE:
+                                        return new C(R);
+                                    case c.AnnotationType.CARET:
                                         return new st(R);
-                                    case l.AnnotationType.INK:
+                                    case c.AnnotationType.INK:
                                         return new at(R);
-                                    case l.AnnotationType.POLYGON:
+                                    case c.AnnotationType.POLYGON:
                                         return new V(R);
-                                    case l.AnnotationType.HIGHLIGHT:
+                                    case c.AnnotationType.HIGHLIGHT:
                                         return new H(R);
-                                    case l.AnnotationType.UNDERLINE:
+                                    case c.AnnotationType.UNDERLINE:
                                         return new lt(R);
-                                    case l.AnnotationType.SQUIGGLY:
+                                    case c.AnnotationType.SQUIGGLY:
                                         return new gt(R);
-                                    case l.AnnotationType.STRIKEOUT:
+                                    case c.AnnotationType.STRIKEOUT:
                                         return new wt(R);
-                                    case l.AnnotationType.STAMP:
-                                        return new xt(R);
-                                    case l.AnnotationType.FILEATTACHMENT:
+                                    case c.AnnotationType.STAMP:
+                                        return new Pt(R);
+                                    case c.AnnotationType.FILEATTACHMENT:
                                         return new S(R);
                                     default:
                                         return new v(R);
                                 }
                             }
                         }
                         const s = class s {
                             constructor(R, {
                                 isRenderable: e = !1,
                                 ignoreBorder: f = !1,
                                 createQuadrilaterals: D = !1
                             } = {}) {
-                                L(this, n, !1);
+                                I(this, n, !1);
                                 this.isRenderable = e, this.data = R.data, this.layer = R.layer, this.linkService = R.linkService, this.downloadManager = R.downloadManager, this.imageResourcesPath = R.imageResourcesPath, this.renderForms = R.renderForms, this.svgFactory = R.svgFactory, this.annotationStorage = R.annotationStorage, this.enableScripting = R.enableScripting, this.hasJSActions = R.hasJSActions, this._fieldObjects = R.fieldObjects, this.parent = R.parent, e && (this.container = this._createContainer(f)), D && this._createQuadrilaterals();
                             }
                             static _hasPopupData({
                                 titleObj: R,
                                 contentsObj: e,
                                 richText: f
                             }) {
@@ -10084,91 +10078,91 @@
                                 const {
                                     data: e,
                                     parent: {
                                         page: f,
                                         viewport: D
                                     }
                                 } = this, j = document.createElement("section");
-                                j.setAttribute("data-annotation-id", e.id), this instanceof _ || (j.tabIndex = F), j.style.zIndex = this.parent.zIndex++, this.data.popupRef && j.setAttribute("aria-haspopup", "dialog"), e.noRotate && j.classList.add("norotate");
+                                j.setAttribute("data-annotation-id", e.id), this instanceof b || (j.tabIndex = F), j.style.zIndex = this.parent.zIndex++, this.data.popupRef && j.setAttribute("aria-haspopup", "dialog"), e.noRotate && j.classList.add("norotate");
                                 const {
                                     pageWidth: q,
                                     pageHeight: it,
                                     pageX: mt,
                                     pageY: kt
                                 } = D.rawDims;
                                 if (!e.rect || this instanceof p) {
                                     const {
                                         rotation: jt
                                     } = e;
                                     return !e.hasOwnCanvas && jt !== 0 && this.setRotation(jt, j), j;
                                 }
                                 const {
-                                    width: Pt,
+                                    width: xt,
                                     height: zt
-                                } = I(e.rect), Mt = l.Util.normalizeRect([e.rect[0], f.view[3] - e.rect[1] + f.view[1], e.rect[2], f.view[3] - e.rect[3] + f.view[1]]);
+                                } = O(e.rect), Mt = c.Util.normalizeRect([e.rect[0], f.view[3] - e.rect[1] + f.view[1], e.rect[2], f.view[3] - e.rect[3] + f.view[1]]);
                                 if (!R && e.borderStyle.width > 0) {
                                     j.style.borderWidth = `${e.borderStyle.width}px`;
                                     const jt = e.borderStyle.horizontalCornerRadius,
                                         qt = e.borderStyle.verticalCornerRadius;
                                     if (jt > 0 || qt > 0) {
                                         const Qt = `calc(${jt}px * var(--scale-factor)) / calc(${qt}px * var(--scale-factor))`;
                                         j.style.borderRadius = Qt;
                                     } else if (this instanceof a) {
-                                        const Qt = `calc(${Pt}px * var(--scale-factor)) / calc(${zt}px * var(--scale-factor))`;
+                                        const Qt = `calc(${xt}px * var(--scale-factor)) / calc(${zt}px * var(--scale-factor))`;
                                         j.style.borderRadius = Qt;
                                     }
                                     switch (e.borderStyle.style) {
-                                        case l.AnnotationBorderStyleType.SOLID:
+                                        case c.AnnotationBorderStyleType.SOLID:
                                             j.style.borderStyle = "solid";
                                             break;
-                                        case l.AnnotationBorderStyleType.DASHED:
+                                        case c.AnnotationBorderStyleType.DASHED:
                                             j.style.borderStyle = "dashed";
                                             break;
-                                        case l.AnnotationBorderStyleType.BEVELED:
-                                            (0, l.warn)("Unimplemented border style: beveled");
+                                        case c.AnnotationBorderStyleType.BEVELED:
+                                            (0, c.warn)("Unimplemented border style: beveled");
                                             break;
-                                        case l.AnnotationBorderStyleType.INSET:
-                                            (0, l.warn)("Unimplemented border style: inset");
+                                        case c.AnnotationBorderStyleType.INSET:
+                                            (0, c.warn)("Unimplemented border style: inset");
                                             break;
-                                        case l.AnnotationBorderStyleType.UNDERLINE:
+                                        case c.AnnotationBorderStyleType.UNDERLINE:
                                             j.style.borderBottomStyle = "solid";
                                             break;
                                     }
                                     const Kt = e.borderColor || null;
-                                    Kt ? (Z(this, n, !0), j.style.borderColor = l.Util.makeHexColor(Kt[0] | 0, Kt[1] | 0, Kt[2] | 0)) : j.style.borderWidth = 0;
+                                    Kt ? (Z(this, n, !0), j.style.borderColor = c.Util.makeHexColor(Kt[0] | 0, Kt[1] | 0, Kt[2] | 0)) : j.style.borderWidth = 0;
                                 }
                                 j.style.left = `${100 * (Mt[0] - mt) / q}%`, j.style.top = `${100 * (Mt[1] - kt) / it}%`;
                                 const {
                                     rotation: Rt
                                 } = e;
-                                return e.hasOwnCanvas || Rt === 0 ? (j.style.width = `${100 * Pt / q}%`, j.style.height = `${100 * zt / it}%`) : this.setRotation(Rt, j), j;
+                                return e.hasOwnCanvas || Rt === 0 ? (j.style.width = `${100 * xt / q}%`, j.style.height = `${100 * zt / it}%`) : this.setRotation(Rt, j), j;
                             }
                             setRotation(R, e = this.container) {
                                 if (!this.data.rect)
                                     return;
                                 const {
                                     pageWidth: f,
                                     pageHeight: D
                                 } = this.parent.viewport.rawDims, {
                                     width: j,
                                     height: q
-                                } = I(this.data.rect);
+                                } = O(this.data.rect);
                                 let it, mt;
                                 R % 180 === 0 ? (it = 100 * j / f, mt = 100 * q / D) : (it = 100 * q / f, mt = 100 * j / D), e.style.width = `${it}%`, e.style.height = `${mt}%`, e.setAttribute("data-main-rotation", (360 - R) % 360);
                             }
                             get _commonActions() {
                                 const R = (e, f, D) => {
                                     const j = D.detail[e],
                                         q = j[0],
                                         it = j.slice(1);
                                     D.target.style[f] = X.ColorConverters[`${q}_HTML`](it), this.annotationStorage.setValue(this.data.id, {
                                         [f]: X.ColorConverters[`${q}_rgb`](it)
                                     });
                                 };
-                                return (0, l.shadow)(this, "_commonActions", {
+                                return (0, c.shadow)(this, "_commonActions", {
                                     display: (e) => {
                                         const {
                                             display: f
                                         } = e.detail, D = f % 2 === 1;
                                         this.container.style.visibility = D ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                                             noView: D,
                                             noPrint: f === 1 || f === 2
@@ -10285,31 +10279,31 @@
                                         borderWidth: Kt
                                     } = q;
                                     q.borderWidth = 0, it = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${qt}" stroke-width="${Kt}">`], this.container.classList.add("hasBorder");
                                 }
                                 const mt = D - e,
                                     kt = j - f,
                                     {
-                                        svgFactory: Pt
+                                        svgFactory: xt
                                     } = this,
-                                    zt = Pt.createElement("svg");
+                                    zt = xt.createElement("svg");
                                 zt.classList.add("quadrilateralsContainer"), zt.setAttribute("width", 0), zt.setAttribute("height", 0);
-                                const Mt = Pt.createElement("defs");
+                                const Mt = xt.createElement("defs");
                                 zt.append(Mt);
-                                const Rt = Pt.createElement("clipPath"),
+                                const Rt = xt.createElement("clipPath"),
                                     jt = `clippath_${this.data.id}`;
                                 Rt.setAttribute("id", jt), Rt.setAttribute("clipPathUnits", "objectBoundingBox"), Mt.append(Rt);
                                 for (const [, {
                                         x: qt,
                                         y: Kt
                                     }, {
                                         x: Qt,
                                         y: se
                                     }] of R) {
-                                    const ie = Pt.createElement("rect"),
+                                    const ie = xt.createElement("rect"),
                                         ne = (Qt - e) / mt,
                                         oe = (j - Kt) / kt,
                                         le = (qt - Qt) / mt,
                                         _i = (Kt - se) / kt;
                                     ie.setAttribute("x", ne), ie.setAttribute("y", oe), ie.setAttribute("width", le), ie.setAttribute("height", _i), Rt.append(ie), it == null || it.push(`<rect vector-effect="non-scaling-stroke" x="${ne}" y="${oe}" width="${le}" height="${_i}"/>`);
                                 }
                                 t(this, n) && (it.push("</g></svg>')"), q.backgroundImage = it.join("")), this.container.append(zt), this.container.style.clipPath = `url(#${jt})`;
@@ -10334,15 +10328,15 @@
                                     },
                                     parent: this.parent,
                                     elements: [this]
                                 });
                                 this.parent.div.append(f.render());
                             }
                             render() {
-                                (0, l.unreachable)("Abstract method `AnnotationElement.render` called");
+                                (0, c.unreachable)("Abstract method `AnnotationElement.render` called");
                             }
                             _getElementsByName(R, e = null) {
                                 const f = [];
                                 if (this._fieldObjects) {
                                     const D = this._fieldObjects[R];
                                     if (D)
                                         for (const {
@@ -10351,31 +10345,31 @@
                                                 exportValues: it
                                             }
                                             of D) {
                                             if (j === -1 || q === e)
                                                 continue;
                                             const mt = typeof it == "string" ? it : null,
                                                 kt = document.querySelector(`[data-element-id="${q}"]`);
-                                            if (kt && !O.has(kt)) {
-                                                (0, l.warn)(`_getElementsByName - element not allowed: ${q}`);
+                                            if (kt && !L.has(kt)) {
+                                                (0, c.warn)(`_getElementsByName - element not allowed: ${q}`);
                                                 continue;
                                             }
                                             f.push({
                                                 id: q,
                                                 exportValue: mt,
                                                 domElement: kt
                                             });
                                         }
                                     return f;
                                 }
                                 for (const D of document.getElementsByName(R)) {
                                     const {
                                         exportValue: j
                                     } = D, q = D.getAttribute("data-element-id");
-                                    q !== e && O.has(D) && f.push({
+                                    q !== e && L.has(D) && f.push({
                                         id: q,
                                         exportValue: j,
                                         domElement: D
                                     });
                                 }
                                 return f;
                             }
@@ -10420,26 +10414,26 @@
                         class A extends v {
                             constructor(e, f = null) {
                                 super(e, {
                                     isRenderable: !0,
                                     ignoreBorder: !!(f != null && f.ignoreBorder),
                                     createQuadrilaterals: !0
                                 });
-                                L(this, o);
-                                L(this, b);
+                                I(this, o);
+                                I(this, _);
                                 this.isTooltipOnly = e.data.isTooltipOnly;
                             }
                             render() {
                                 const {
                                     data: e,
                                     linkService: f
                                 } = this, D = document.createElement("a");
                                 D.setAttribute("data-element-id", e.id);
                                 let j = !1;
-                                return e.url ? (f.addLinkAttributes(D, e.url, e.newWindow), j = !0) : e.action ? (this._bindNamedAction(D, e.action), j = !0) : e.attachment ? (this._bindAttachment(D, e.attachment), j = !0) : e.setOCGState ? (W(this, b, Ii).call(this, D, e.setOCGState), j = !0) : e.dest ? (this._bindLink(D, e.dest), j = !0) : (e.actions && (e.actions.Action || e.actions["Mouse Up"] || e.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(D, e), j = !0), e.resetForm ? (this._bindResetFormAction(D, e.resetForm), j = !0) : this.isTooltipOnly && !j && (this._bindLink(D, ""), j = !0)), this.container.classList.add("linkAnnotation"), j && this.container.append(D), this.container;
+                                return e.url ? (f.addLinkAttributes(D, e.url, e.newWindow), j = !0) : e.action ? (this._bindNamedAction(D, e.action), j = !0) : e.attachment ? (this._bindAttachment(D, e.attachment), j = !0) : e.setOCGState ? (W(this, _, Ii).call(this, D, e.setOCGState), j = !0) : e.dest ? (this._bindLink(D, e.dest), j = !0) : (e.actions && (e.actions.Action || e.actions["Mouse Up"] || e.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(D, e), j = !0), e.resetForm ? (this._bindResetFormAction(D, e.resetForm), j = !0) : this.isTooltipOnly && !j && (this._bindLink(D, ""), j = !0)), this.container.classList.add("linkAnnotation"), j && this.container.append(D), this.container;
                             }
                             _bindLink(e, f) {
                                 e.href = this.linkService.getDestinationHash(f), e.onclick = () => (f && this.linkService.goToDestination(f), !1), (f || f === "") && W(this, o, ce).call(this);
                             }
                             _bindNamedAction(e, f) {
                                 e.href = this.linkService.getAnchorUrl(""), e.onclick = () => (this.linkService.executeNamedAction(f), !1), W(this, o, ce).call(this);
                             }
@@ -10470,15 +10464,15 @@
                                     });
                                 }
                                 e.onclick || (e.onclick = () => !1), W(this, o, ce).call(this);
                             }
                             _bindResetFormAction(e, f) {
                                 const D = e.onclick;
                                 if (D || (e.href = this.linkService.getAnchorUrl("")), W(this, o, ce).call(this), !this._fieldObjects) {
-                                    (0, l.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), D || (e.onclick = () => !1);
+                                    (0, c.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), D || (e.onclick = () => !1);
                                     return;
                                 }
                                 e.onclick = () => {
                                     var zt;
                                     D == null || D();
                                     const {
                                         fields: j,
@@ -10498,20 +10492,20 @@
                                         for (const Rt of Object.values(this._fieldObjects))
                                             for (const jt of Rt)
                                                 Mt.has(jt.id) === it && mt.push(jt);
                                     } else
                                         for (const Mt of Object.values(this._fieldObjects))
                                             mt.push(...Mt);
                                     const kt = this.annotationStorage,
-                                        Pt = [];
+                                        xt = [];
                                     for (const Mt of mt) {
                                         const {
                                             id: Rt
                                         } = Mt;
-                                        switch (Pt.push(Rt), Mt.type) {
+                                        switch (xt.push(Rt), Mt.type) {
                                             case "text": {
                                                 const qt = Mt.defaultValue || "";
                                                 kt.setValue(Rt, {
                                                     value: qt
                                                 });
                                                 break;
                                             }
@@ -10532,36 +10526,36 @@
                                                 break;
                                             }
                                             default:
                                                 continue;
                                         }
                                         const jt = document.querySelector(`[data-element-id="${Rt}"]`);
                                         if (jt) {
-                                            if (!O.has(jt)) {
-                                                (0, l.warn)(`_bindResetFormAction - element not allowed: ${Rt}`);
+                                            if (!L.has(jt)) {
+                                                (0, c.warn)(`_bindResetFormAction - element not allowed: ${Rt}`);
                                                 continue;
                                             }
                                         } else
                                             continue;
                                         jt.dispatchEvent(new Event("resetform"));
                                     }
                                     return this.enableScripting && ((zt = this.linkService.eventBus) == null || zt.dispatch("dispatcheventinsandbox", {
                                         source: this,
                                         detail: {
                                             id: "app",
-                                            ids: Pt,
+                                            ids: xt,
                                             name: "ResetForm"
                                         }
                                     })), !1;
                                 };
                             }
                         }
                         o = new WeakSet(), ce = function() {
                             this.container.setAttribute("data-internal-link", "");
-                        }, b = new WeakSet(), Ii = function(e, f) {
+                        }, _ = new WeakSet(), Ii = function(e, f) {
                             e.href = this.linkService.getAnchorUrl(""), e.onclick = () => (this.linkService.executeSetOCGState(f), !1), W(this, o, ce).call(this);
                         };
                         class u extends v {
                             constructor(R) {
                                 super(R, {
                                     isRenderable: !0
                                 });
@@ -10570,27 +10564,27 @@
                                 this.container.classList.add("textAnnotation");
                                 const R = document.createElement("img");
                                 return R.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", R.alt = "[{{type}} Annotation]", R.dataset.l10nId = "text_annotation_type", R.dataset.l10nArgs = JSON.stringify({
                                     type: this.data.name
                                 }), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(R), this.container;
                             }
                         }
-                        class _ extends v {
+                        class b extends v {
                             render() {
                                 return this.data.alternativeText && (this.container.title = this.data.alternativeText), this.container;
                             }
                             showElementAndHideCanvas(R) {
                                 var e;
                                 this.data.hasOwnCanvas && (((e = R.previousSibling) == null ? void 0 : e.nodeName) === "CANVAS" && (R.previousSibling.hidden = !0), R.hidden = !1);
                             }
                             _getKeyModifier(R) {
                                 const {
                                     isWin: e,
                                     isMac: f
-                                } = l.FeatureTest.platform;
+                                } = c.FeatureTest.platform;
                                 return e && R.ctrlKey || f && R.metaKey;
                             }
                             _setEventListener(R, e, f, D, j) {
                                 f.includes("mouse") ? R.addEventListener(f, (q) => {
                                     var it;
                                     (it = this.linkService.eventBus) == null || it.dispatch("dispatcheventinsandbox", {
                                         source: this,
@@ -10628,42 +10622,42 @@
                                 for (const [mt, kt] of f)
                                     (kt === "Action" || (j = this.data.actions) != null && j[kt]) && ((kt === "Focus" || kt === "Blur") && (e || (e = {
                                         focused: !1
                                     })), this._setEventListener(R, e, mt, kt, D), kt === "Focus" && !((q = this.data.actions) != null && q.Blur) ? this._setEventListener(R, e, "blur", "Blur", null) : kt === "Blur" && !((it = this.data.actions) != null && it.Focus) && this._setEventListener(R, e, "focus", "Focus", null));
                             }
                             _setBackgroundColor(R) {
                                 const e = this.data.backgroundColor || null;
-                                R.style.backgroundColor = e === null ? "transparent" : l.Util.makeHexColor(e[0], e[1], e[2]);
+                                R.style.backgroundColor = e === null ? "transparent" : c.Util.makeHexColor(e[0], e[1], e[2]);
                             }
                             _setTextStyle(R) {
                                 const e = ["left", "center", "right"],
                                     {
                                         fontColor: f
                                     } = this.data.defaultAppearanceData,
                                     D = this.data.defaultAppearanceData.fontSize || g,
                                     j = R.style;
                                 let q;
                                 const it = 2,
                                     mt = (kt) => Math.round(10 * kt) / 10;
                                 if (this.data.multiLine) {
                                     const kt = Math.abs(this.data.rect[3] - this.data.rect[1] - it),
-                                        Pt = Math.round(kt / (l.LINE_FACTOR * D)) || 1,
-                                        zt = kt / Pt;
-                                    q = Math.min(D, mt(zt / l.LINE_FACTOR));
+                                        xt = Math.round(kt / (c.LINE_FACTOR * D)) || 1,
+                                        zt = kt / xt;
+                                    q = Math.min(D, mt(zt / c.LINE_FACTOR));
                                 } else {
                                     const kt = Math.abs(this.data.rect[3] - this.data.rect[1] - it);
-                                    q = Math.min(D, mt(kt / l.LINE_FACTOR));
+                                    q = Math.min(D, mt(kt / c.LINE_FACTOR));
                                 }
-                                j.fontSize = `calc(${q}px * var(--scale-factor))`, j.color = l.Util.makeHexColor(f[0], f[1], f[2]), this.data.textAlignment !== null && (j.textAlign = e[this.data.textAlignment]);
+                                j.fontSize = `calc(${q}px * var(--scale-factor))`, j.color = c.Util.makeHexColor(f[0], f[1], f[2]), this.data.textAlignment !== null && (j.textAlign = e[this.data.textAlignment]);
                             }
                             _setRequired(R, e) {
                                 e ? R.setAttribute("required", !0) : R.removeAttribute("required"), R.setAttribute("aria-required", e);
                             }
                         }
-                        class w extends _ {
+                        class E extends b {
                             constructor(R) {
                                 const e = R.renderForms || !R.data.hasAppearance && !!R.data.fieldValue;
                                 super(R, {
                                     isRenderable: e
                                 });
                             }
                             setPropertyOnSiblings(R, e, f, D) {
@@ -10687,56 +10681,56 @@
                                     const mt = R.getValue(e, {
                                         charLimit: this.data.maxLen
                                     }).charLimit;
                                     mt && it.length > mt && (it = it.slice(0, mt));
                                     let kt = q.formattedValue || ((D = this.data.textContent) == null ? void 0 : D.join(`
 `)) || null;
                                     kt && this.data.comb && (kt = kt.replaceAll(/\s+/g, ""));
-                                    const Pt = {
+                                    const xt = {
                                         userValue: it,
                                         formattedValue: kt,
                                         lastCommittedValue: null,
                                         commitKey: 1,
                                         focused: !1
                                     };
-                                    this.data.multiLine ? (f = document.createElement("textarea"), f.textContent = kt ?? it, this.data.doNotScroll && (f.style.overflowY = "hidden")) : (f = document.createElement("input"), f.type = "text", f.setAttribute("value", kt ?? it), this.data.doNotScroll && (f.style.overflowX = "hidden")), this.data.hasOwnCanvas && (f.hidden = !0), O.add(f), f.setAttribute("data-element-id", e), f.disabled = this.data.readOnly, f.name = this.data.fieldName, f.tabIndex = F, this._setRequired(f, this.data.required), mt && (f.maxLength = mt), f.addEventListener("input", (Mt) => {
+                                    this.data.multiLine ? (f = document.createElement("textarea"), f.textContent = kt ?? it, this.data.doNotScroll && (f.style.overflowY = "hidden")) : (f = document.createElement("input"), f.type = "text", f.setAttribute("value", kt ?? it), this.data.doNotScroll && (f.style.overflowX = "hidden")), this.data.hasOwnCanvas && (f.hidden = !0), L.add(f), f.setAttribute("data-element-id", e), f.disabled = this.data.readOnly, f.name = this.data.fieldName, f.tabIndex = F, this._setRequired(f, this.data.required), mt && (f.maxLength = mt), f.addEventListener("input", (Mt) => {
                                         R.setValue(e, {
                                             value: Mt.target.value
-                                        }), this.setPropertyOnSiblings(f, "value", Mt.target.value, "value"), Pt.formattedValue = null;
+                                        }), this.setPropertyOnSiblings(f, "value", Mt.target.value, "value"), xt.formattedValue = null;
                                     }), f.addEventListener("resetform", (Mt) => {
                                         const Rt = this.data.defaultFieldValue ?? "";
-                                        f.value = Pt.userValue = Rt, Pt.formattedValue = null;
+                                        f.value = xt.userValue = Rt, xt.formattedValue = null;
                                     });
                                     let zt = (Mt) => {
                                         const {
                                             formattedValue: Rt
-                                        } = Pt;
+                                        } = xt;
                                         Rt != null && (Mt.target.value = Rt), Mt.target.scrollLeft = 0;
                                     };
                                     if (this.enableScripting && this.hasJSActions) {
                                         f.addEventListener("focus", (Rt) => {
-                                            if (Pt.focused)
+                                            if (xt.focused)
                                                 return;
                                             const {
                                                 target: jt
                                             } = Rt;
-                                            Pt.userValue && (jt.value = Pt.userValue), Pt.lastCommittedValue = jt.value, Pt.commitKey = 1, Pt.focused = !0;
+                                            xt.userValue && (jt.value = xt.userValue), xt.lastCommittedValue = jt.value, xt.commitKey = 1, xt.focused = !0;
                                         }), f.addEventListener("updatefromsandbox", (Rt) => {
                                             this.showElementAndHideCanvas(Rt.target);
                                             const jt = {
                                                 value(qt) {
-                                                    Pt.userValue = qt.detail.value ?? "", R.setValue(e, {
-                                                        value: Pt.userValue.toString()
-                                                    }), qt.target.value = Pt.userValue;
+                                                    xt.userValue = qt.detail.value ?? "", R.setValue(e, {
+                                                        value: xt.userValue.toString()
+                                                    }), qt.target.value = xt.userValue;
                                                 },
                                                 formattedValue(qt) {
                                                     const {
                                                         formattedValue: Kt
                                                     } = qt.detail;
-                                                    Pt.formattedValue = Kt, Kt != null && qt.target !== document.activeElement && (qt.target.value = Kt), R.setValue(e, {
+                                                    xt.formattedValue = Kt, Kt != null && qt.target !== document.activeElement && (qt.target.value = Kt), R.setValue(e, {
                                                         formattedValue: Kt
                                                     });
                                                 },
                                                 selRange(qt) {
                                                     qt.target.setSelectionRange(...qt.detail.selRange);
                                                 },
                                                 charLimit: (qt) => {
@@ -10747,16 +10741,16 @@
                                                         target: Qt
                                                     } = qt;
                                                     if (Kt === 0) {
                                                         Qt.removeAttribute("maxLength");
                                                         return;
                                                     }
                                                     Qt.setAttribute("maxLength", Kt);
-                                                    let se = Pt.userValue;
-                                                    !se || se.length <= Kt || (se = se.slice(0, Kt), Qt.value = Pt.userValue = se, R.setValue(e, {
+                                                    let se = xt.userValue;
+                                                    !se || se.length <= Kt || (se = se.slice(0, Kt), Qt.value = xt.userValue = se, R.setValue(e, {
                                                         value: se
                                                     }), (ie = this.linkService.eventBus) == null || ie.dispatch("dispatcheventinsandbox", {
                                                         source: this,
                                                         detail: {
                                                             id: e,
                                                             name: "Keystroke",
                                                             value: se,
@@ -10767,22 +10761,22 @@
                                                         }
                                                     }));
                                                 }
                                             };
                                             this._dispatchEventFromSandbox(jt, Rt);
                                         }), f.addEventListener("keydown", (Rt) => {
                                             var Kt;
-                                            Pt.commitKey = 1;
+                                            xt.commitKey = 1;
                                             let jt = -1;
-                                            if (Rt.key === "Escape" ? jt = 0 : Rt.key === "Enter" && !this.data.multiLine ? jt = 2 : Rt.key === "Tab" && (Pt.commitKey = 3), jt === -1)
+                                            if (Rt.key === "Escape" ? jt = 0 : Rt.key === "Enter" && !this.data.multiLine ? jt = 2 : Rt.key === "Tab" && (xt.commitKey = 3), jt === -1)
                                                 return;
                                             const {
                                                 value: qt
                                             } = Rt.target;
-                                            Pt.lastCommittedValue !== qt && (Pt.lastCommittedValue = qt, Pt.userValue = qt, (Kt = this.linkService.eventBus) == null || Kt.dispatch("dispatcheventinsandbox", {
+                                            xt.lastCommittedValue !== qt && (xt.lastCommittedValue = qt, xt.userValue = qt, (Kt = this.linkService.eventBus) == null || Kt.dispatch("dispatcheventinsandbox", {
                                                 source: this,
                                                 detail: {
                                                     id: e,
                                                     name: "Keystroke",
                                                     value: qt,
                                                     willCommit: !0,
                                                     commitKey: jt,
@@ -10790,35 +10784,35 @@
                                                     selEnd: Rt.target.selectionEnd
                                                 }
                                             }));
                                         });
                                         const Mt = zt;
                                         zt = null, f.addEventListener("blur", (Rt) => {
                                             var qt;
-                                            if (!Pt.focused || !Rt.relatedTarget)
+                                            if (!xt.focused || !Rt.relatedTarget)
                                                 return;
-                                            Pt.focused = !1;
+                                            xt.focused = !1;
                                             const {
                                                 value: jt
                                             } = Rt.target;
-                                            Pt.userValue = jt, Pt.lastCommittedValue !== jt && ((qt = this.linkService.eventBus) == null || qt.dispatch("dispatcheventinsandbox", {
+                                            xt.userValue = jt, xt.lastCommittedValue !== jt && ((qt = this.linkService.eventBus) == null || qt.dispatch("dispatcheventinsandbox", {
                                                 source: this,
                                                 detail: {
                                                     id: e,
                                                     name: "Keystroke",
                                                     value: jt,
                                                     willCommit: !0,
-                                                    commitKey: Pt.commitKey,
+                                                    commitKey: xt.commitKey,
                                                     selStart: Rt.target.selectionStart,
                                                     selEnd: Rt.target.selectionEnd
                                                 }
                                             })), Mt(Rt);
                                         }), (j = this.data.actions) != null && j.Keystroke && f.addEventListener("beforeinput", (Rt) => {
                                             var oe;
-                                            Pt.lastCommittedValue = null;
+                                            xt.lastCommittedValue = null;
                                             const {
                                                 data: jt,
                                                 target: qt
                                             } = Rt, {
                                                 value: Kt,
                                                 selectionStart: Qt,
                                                 selectionEnd: se
@@ -10851,15 +10845,15 @@
                                                     value: Kt,
                                                     change: jt || "",
                                                     willCommit: !1,
                                                     selStart: ie,
                                                     selEnd: ne
                                                 }
                                             });
-                                        }), this._setEventListeners(f, Pt, [
+                                        }), this._setEventListeners(f, xt, [
                                             ["focus", "Focus"],
                                             ["blur", "Blur"],
                                             ["mousedown", "Mouse Down"],
                                             ["mouseenter", "Mouse Enter"],
                                             ["mouseleave", "Mouse Exit"],
                                             ["mouseup", "Mouse Up"]
                                         ], (Rt) => Rt.target.value);
@@ -10869,22 +10863,22 @@
                                         f.classList.add("comb"), f.style.letterSpacing = `calc(${Rt}px * var(--scale-factor) - 1ch)`;
                                     }
                                 } else
                                     f = document.createElement("div"), f.textContent = this.data.fieldValue, f.style.verticalAlign = "middle", f.style.display = "table-cell";
                                 return this._setTextStyle(f), this._setBackgroundColor(f), this._setDefaultPropertiesFromJS(f), this.container.append(f), this.container;
                             }
                         }
-                        class C extends _ {
+                        class w extends b {
                             constructor(R) {
                                 super(R, {
                                     isRenderable: !!R.data.hasOwnCanvas
                                 });
                             }
                         }
-                        class y extends _ {
+                        class y extends b {
                             constructor(R) {
                                 super(R, {
                                     isRenderable: R.renderForms
                                 });
                             }
                             render() {
                                 const R = this.annotationStorage,
@@ -10893,23 +10887,23 @@
                                 let D = R.getValue(f, {
                                     value: e.exportValue === e.fieldValue
                                 }).value;
                                 typeof D == "string" && (D = D !== "Off", R.setValue(f, {
                                     value: D
                                 })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
                                 const j = document.createElement("input");
-                                return O.add(j), j.setAttribute("data-element-id", f), j.disabled = e.readOnly, this._setRequired(j, this.data.required), j.type = "checkbox", j.name = e.fieldName, D && j.setAttribute("checked", !0), j.setAttribute("exportValue", e.exportValue), j.tabIndex = F, j.addEventListener("change", (q) => {
+                                return L.add(j), j.setAttribute("data-element-id", f), j.disabled = e.readOnly, this._setRequired(j, this.data.required), j.type = "checkbox", j.name = e.fieldName, D && j.setAttribute("checked", !0), j.setAttribute("exportValue", e.exportValue), j.tabIndex = F, j.addEventListener("change", (q) => {
                                     const {
                                         name: it,
                                         checked: mt
                                     } = q.target;
                                     for (const kt of this._getElementsByName(it, f)) {
-                                        const Pt = mt && kt.exportValue === e.exportValue;
-                                        kt.domElement && (kt.domElement.checked = Pt), R.setValue(kt.id, {
-                                            value: Pt
+                                        const xt = mt && kt.exportValue === e.exportValue;
+                                        kt.domElement && (kt.domElement.checked = xt), R.setValue(kt.id, {
+                                            value: xt
                                         });
                                     }
                                     R.setValue(f, {
                                         value: mt
                                     });
                                 }), j.addEventListener("resetform", (q) => {
                                     const it = e.defaultFieldValue || "Off";
@@ -10931,15 +10925,15 @@
                                     ["mousedown", "Mouse Down"],
                                     ["mouseenter", "Mouse Enter"],
                                     ["mouseleave", "Mouse Exit"],
                                     ["mouseup", "Mouse Up"]
                                 ], (q) => q.target.checked)), this._setBackgroundColor(j), this._setDefaultPropertiesFromJS(j), this.container.append(j), this.container;
                             }
                         }
-                        class a extends _ {
+                        class a extends b {
                             constructor(R) {
                                 super(R, {
                                     isRenderable: R.renderForms
                                 });
                             }
                             render() {
                                 this.container.classList.add("buttonWidgetAnnotation", "radioButton");
@@ -10949,15 +10943,15 @@
                                 let D = R.getValue(f, {
                                     value: e.fieldValue === e.buttonValue
                                 }).value;
                                 typeof D == "string" && (D = D !== e.buttonValue, R.setValue(f, {
                                     value: D
                                 }));
                                 const j = document.createElement("input");
-                                if (O.add(j), j.setAttribute("data-element-id", f), j.disabled = e.readOnly, this._setRequired(j, this.data.required), j.type = "radio", j.name = e.fieldName, D && j.setAttribute("checked", !0), j.tabIndex = F, j.addEventListener("change", (q) => {
+                                if (L.add(j), j.setAttribute("data-element-id", f), j.disabled = e.readOnly, this._setRequired(j, this.data.required), j.type = "radio", j.name = e.fieldName, D && j.setAttribute("checked", !0), j.tabIndex = F, j.addEventListener("change", (q) => {
                                         const {
                                             name: it,
                                             checked: mt
                                         } = q.target;
                                         for (const kt of this._getElementsByName(it, f))
                                             R.setValue(kt.id, {
                                                 value: !1
@@ -10969,17 +10963,17 @@
                                         const it = e.defaultFieldValue;
                                         q.target.checked = it != null && it === e.buttonValue;
                                     }), this.enableScripting && this.hasJSActions) {
                                     const q = e.buttonValue;
                                     j.addEventListener("updatefromsandbox", (it) => {
                                         const mt = {
                                             value: (kt) => {
-                                                const Pt = q === kt.detail.value;
+                                                const xt = q === kt.detail.value;
                                                 for (const zt of this._getElementsByName(kt.target.name)) {
-                                                    const Mt = Pt && zt.id === f;
+                                                    const Mt = xt && zt.id === f;
                                                     zt.domElement && (zt.domElement.checked = Mt), R.setValue(zt.id, {
                                                         value: Mt
                                                     });
                                                 }
                                             }
                                         };
                                         this._dispatchEventFromSandbox(mt, it);
@@ -10993,78 +10987,78 @@
                                         ["mouseleave", "Mouse Exit"],
                                         ["mouseup", "Mouse Up"]
                                     ], (it) => it.target.checked);
                                 }
                                 return this._setBackgroundColor(j), this._setDefaultPropertiesFromJS(j), this.container.append(j), this.container;
                             }
                         }
-                        class c extends A {
+                        class l extends A {
                             constructor(R) {
                                 super(R, {
                                     ignoreBorder: R.data.hasAppearance
                                 });
                             }
                             render() {
                                 const R = super.render();
                                 R.classList.add("buttonWidgetAnnotation", "pushButton"), this.data.alternativeText && (R.title = this.data.alternativeText);
                                 const e = R.lastChild;
                                 return this.enableScripting && this.hasJSActions && e && (this._setDefaultPropertiesFromJS(e), e.addEventListener("updatefromsandbox", (f) => {
                                     this._dispatchEventFromSandbox({}, f);
                                 })), R;
                             }
                         }
-                        class k extends _ {
+                        class k extends b {
                             constructor(R) {
                                 super(R, {
                                     isRenderable: R.renderForms
                                 });
                             }
                             render() {
                                 this.container.classList.add("choiceWidgetAnnotation");
                                 const R = this.annotationStorage,
                                     e = this.data.id,
                                     f = R.getValue(e, {
                                         value: this.data.fieldValue
                                     }),
                                     D = document.createElement("select");
-                                O.add(D), D.setAttribute("data-element-id", e), D.disabled = this.data.readOnly, this._setRequired(D, this.data.required), D.name = this.data.fieldName, D.tabIndex = F;
+                                L.add(D), D.setAttribute("data-element-id", e), D.disabled = this.data.readOnly, this._setRequired(D, this.data.required), D.name = this.data.fieldName, D.tabIndex = F;
                                 let j = this.data.combo && this.data.options.length > 0;
-                                this.data.combo || (D.size = this.data.options.length, this.data.multiSelect && (D.multiple = !0)), D.addEventListener("resetform", (Pt) => {
+                                this.data.combo || (D.size = this.data.options.length, this.data.multiSelect && (D.multiple = !0)), D.addEventListener("resetform", (xt) => {
                                     const zt = this.data.defaultFieldValue;
                                     for (const Mt of D.options)
                                         Mt.selected = Mt.value === zt;
                                 });
-                                for (const Pt of this.data.options) {
+                                for (const xt of this.data.options) {
                                     const zt = document.createElement("option");
-                                    zt.textContent = Pt.displayValue, zt.value = Pt.exportValue, f.value.includes(Pt.exportValue) && (zt.setAttribute("selected", !0), j = !1), D.append(zt);
+                                    zt.textContent = xt.displayValue, zt.value = xt.exportValue, f.value.includes(xt.exportValue) && (zt.setAttribute("selected", !0), j = !1), D.append(zt);
                                 }
                                 let q = null;
                                 if (j) {
-                                    const Pt = document.createElement("option");
-                                    Pt.value = " ", Pt.setAttribute("hidden", !0), Pt.setAttribute("selected", !0), D.prepend(Pt), q = () => {
-                                        Pt.remove(), D.removeEventListener("input", q), q = null;
+                                    const xt = document.createElement("option");
+                                    xt.value = " ", xt.setAttribute("hidden", !0), xt.setAttribute("selected", !0), D.prepend(xt), q = () => {
+                                        xt.remove(), D.removeEventListener("input", q), q = null;
                                     }, D.addEventListener("input", q);
                                 }
-                                const it = (Pt) => {
-                                    const zt = Pt ? "value" : "textContent",
+                                const it = (xt) => {
+                                    const zt = xt ? "value" : "textContent",
                                         {
                                             options: Mt,
                                             multiple: Rt
                                         } = D;
                                     return Rt ? Array.prototype.filter.call(Mt, (jt) => jt.selected).map((jt) => jt[zt]) : Mt.selectedIndex === -1 ? null : Mt[Mt.selectedIndex][zt];
                                 };
                                 let mt = it(!1);
-                                const kt = (Pt) => {
-                                    const zt = Pt.target.options;
+                                const kt = (xt) => {
+                                    const zt = xt.target.options;
                                     return Array.prototype.map.call(zt, (Mt) => ({
                                         displayValue: Mt.textContent,
                                         exportValue: Mt.value
                                     }));
                                 };
-                                return this.enableScripting && this.hasJSActions ? (D.addEventListener("updatefromsandbox", (Pt) => {
+                                return this.enableScripting && this.hasJSActions ? (D.addEventListener("updatefromsandbox", (xt) => {
                                     const zt = {
                                         value(Mt) {
                                             q == null || q();
                                             const Rt = Mt.detail.value,
                                                 jt = new Set(Array.isArray(Rt) ? Rt : [Rt]);
                                             for (const qt of D.options)
                                                 qt.selected = jt.has(qt.value);
@@ -11128,21 +11122,21 @@
                                                 value: it(!0)
                                             }), mt = it(!1);
                                         },
                                         editable(Mt) {
                                             Mt.target.disabled = !Mt.detail.editable;
                                         }
                                     };
-                                    this._dispatchEventFromSandbox(zt, Pt);
-                                }), D.addEventListener("input", (Pt) => {
+                                    this._dispatchEventFromSandbox(zt, xt);
+                                }), D.addEventListener("input", (xt) => {
                                     var Mt;
                                     const zt = it(!0);
                                     R.setValue(e, {
                                         value: zt
-                                    }), Pt.preventDefault(), (Mt = this.linkService.eventBus) == null || Mt.dispatch("dispatcheventinsandbox", {
+                                    }), xt.preventDefault(), (Mt = this.linkService.eventBus) == null || Mt.dispatch("dispatcheventinsandbox", {
                                         source: this,
                                         detail: {
                                             id: e,
                                             name: "Keystroke",
                                             value: mt,
                                             changeEx: zt,
                                             willCommit: !1,
@@ -11155,15 +11149,15 @@
                                     ["blur", "Blur"],
                                     ["mousedown", "Mouse Down"],
                                     ["mouseenter", "Mouse Enter"],
                                     ["mouseleave", "Mouse Exit"],
                                     ["mouseup", "Mouse Up"],
                                     ["input", "Action"],
                                     ["input", "Validate"]
-                                ], (Pt) => Pt.target.value)) : D.addEventListener("input", function(Pt) {
+                                ], (xt) => xt.target.value)) : D.addEventListener("input", function(xt) {
                                     R.setValue(e, {
                                         value: it(!0)
                                     });
                                 }), this.data.combo && this._setTextStyle(D), this._setBackgroundColor(D), this._setDefaultPropertiesFromJS(D), this.container.append(D), this.container;
                             }
                         }
                         class p extends v {
@@ -11190,54 +11184,54 @@
                                         parent: this.parent,
                                         elements: this.elements,
                                         open: this.data.open
                                     }),
                                     e = [];
                                 for (const f of this.elements)
                                     f.popup = R, e.push(f.data.id), f.addHighlightArea();
-                                return this.container.setAttribute("aria-controls", e.map((f) => `${l.AnnotationPrefix}${f}`).join(",")), this.container;
+                                return this.container.setAttribute("aria-controls", e.map((f) => `${c.AnnotationPrefix}${f}`).join(",")), this.container;
                             }
                         }
                         class r {
                             constructor({
                                 container: R,
                                 color: e,
                                 elements: f,
                                 titleObj: D,
                                 modificationDate: j,
                                 contentsObj: q,
                                 richText: it,
                                 parent: mt,
                                 rect: kt,
-                                parentRect: Pt,
+                                parentRect: xt,
                                 open: zt
                             }) {
-                                L(this, Ut);
-                                L(this, Ht);
-                                L(this, Vt);
-                                L(this, $t);
-                                L(this, N, null);
-                                L(this, tt, W(this, Ut, Li).bind(this));
-                                L(this, Q, W(this, $t, oi).bind(this));
-                                L(this, nt, W(this, Vt, ai).bind(this));
-                                L(this, ct, W(this, Ht, Fe).bind(this));
-                                L(this, yt, null);
-                                L(this, ut, null);
-                                L(this, Ft, null);
-                                L(this, Bt, null);
-                                L(this, St, null);
-                                L(this, Dt, null);
-                                L(this, ft, !1);
-                                L(this, K, null);
-                                L(this, J, null);
-                                L(this, ht, null);
-                                L(this, Et, null);
-                                L(this, Ct, !1);
+                                I(this, Ut);
+                                I(this, Ht);
+                                I(this, Vt);
+                                I(this, $t);
+                                I(this, N, null);
+                                I(this, tt, W(this, Ut, Li).bind(this));
+                                I(this, Q, W(this, $t, oi).bind(this));
+                                I(this, nt, W(this, Vt, ai).bind(this));
+                                I(this, ct, W(this, Ht, Fe).bind(this));
+                                I(this, yt, null);
+                                I(this, ut, null);
+                                I(this, Ft, null);
+                                I(this, Bt, null);
+                                I(this, St, null);
+                                I(this, Dt, null);
+                                I(this, ft, !1);
+                                I(this, K, null);
+                                I(this, J, null);
+                                I(this, ht, null);
+                                I(this, Et, null);
+                                I(this, Ct, !1);
                                 var Rt;
-                                Z(this, ut, R), Z(this, Et, D), Z(this, Ft, q), Z(this, ht, it), Z(this, St, mt), Z(this, yt, e), Z(this, J, kt), Z(this, Dt, Pt), Z(this, Bt, f);
+                                Z(this, ut, R), Z(this, Et, D), Z(this, Ft, q), Z(this, ht, it), Z(this, St, mt), Z(this, yt, e), Z(this, J, kt), Z(this, Dt, xt), Z(this, Bt, f);
                                 const Mt = P.PDFDateString.toDateObject(j);
                                 Mt && Z(this, N, mt.l10n.get("annotation_date_string", {
                                     date: Mt.toLocaleDateString(),
                                     time: Mt.toLocaleTimeString()
                                 })), this.trigger = f.flatMap((jt) => jt.getElementsToTriggerPopup());
                                 for (const jt of this.trigger)
                                     jt.addEventListener("click", t(this, ct)), jt.addEventListener("mouseenter", t(this, nt)), jt.addEventListener("mouseleave", t(this, Q)), jt.classList.add("popupTriggerArea");
@@ -11258,49 +11252,49 @@
                                             pageHeight: f,
                                             pageX: D,
                                             pageY: j
                                         }
                                     }
                                 } = t(this, St), q = Z(this, K, document.createElement("div"));
                                 if (q.className = "popup", t(this, yt)) {
-                                    const ie = q.style.outlineColor = l.Util.makeHexColor(...t(this, yt));
-                                    CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? q.style.backgroundColor = `color-mix(in srgb, ${ie} 30%, white)` : q.style.backgroundColor = l.Util.makeHexColor(...t(this, yt).map((oe) => Math.floor(0.7 * (255 - oe) + oe)));
+                                    const ie = q.style.outlineColor = c.Util.makeHexColor(...t(this, yt));
+                                    CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? q.style.backgroundColor = `color-mix(in srgb, ${ie} 30%, white)` : q.style.backgroundColor = c.Util.makeHexColor(...t(this, yt).map((oe) => Math.floor(0.7 * (255 - oe) + oe)));
                                 }
                                 const it = document.createElement("span");
                                 it.className = "header";
                                 const mt = document.createElement("h1");
                                 if (it.append(mt), {
                                         dir: mt.dir,
                                         str: mt.textContent
                                     } = t(this, Et), q.append(it), t(this, N)) {
                                     const ie = document.createElement("span");
                                     ie.classList.add("popupDate"), t(this, N).then((ne) => {
                                         ie.textContent = ne;
                                     }), it.append(ie);
                                 }
                                 const kt = t(this, Ft),
-                                    Pt = t(this, ht);
-                                if (Pt != null && Pt.str && (!(kt != null && kt.str) || kt.str === Pt.str))
+                                    xt = t(this, ht);
+                                if (xt != null && xt.str && (!(kt != null && kt.str) || kt.str === xt.str))
                                     B.XfaLayer.render({
-                                        xfaHtml: Pt.html,
+                                        xfaHtml: xt.html,
                                         intent: "richText",
                                         div: q
                                     }), q.lastChild.classList.add("richText", "popupContent");
                                 else {
                                     const ie = this._formatContents(kt);
                                     q.append(ie);
                                 }
                                 let zt = !!t(this, Dt),
                                     Mt = zt ? t(this, Dt) : t(this, J);
                                 for (const ie of t(this, Bt))
-                                    if (!Mt || l.Util.intersect(ie.data.rect, Mt) !== null) {
+                                    if (!Mt || c.Util.intersect(ie.data.rect, Mt) !== null) {
                                         Mt = ie.data.rect, zt = !0;
                                         break;
                                     }
-                                const Rt = l.Util.normalizeRect([Mt[0], R[3] - Mt[1] + R[1], Mt[2], R[3] - Mt[3] + R[1]]),
+                                const Rt = c.Util.normalizeRect([Mt[0], R[3] - Mt[1] + R[1], Mt[2], R[3] - Mt[3] + R[1]]),
                                     qt = zt ? Mt[2] - Mt[0] + 5 : 0,
                                     Kt = Rt[0] + qt,
                                     Qt = Rt[1],
                                     {
                                         style: se
                                     } = t(this, ut);
                                 se.left = `${100 * (Kt - D) / e}%`, se.top = `${100 * (Qt - j) / f}%`, t(this, ut).append(q);
@@ -11333,50 +11327,50 @@
                         }, Ht = new WeakSet(), Fe = function() {
                             Z(this, ft, !t(this, ft)), t(this, ft) ? (W(this, Vt, ai).call(this), t(this, ut).addEventListener("click", t(this, ct)), t(this, ut).addEventListener("keydown", t(this, tt))) : (W(this, $t, oi).call(this), t(this, ut).removeEventListener("click", t(this, ct)), t(this, ut).removeEventListener("keydown", t(this, tt)));
                         }, Vt = new WeakSet(), ai = function() {
                             t(this, K) || this.render(), this.isVisible ? t(this, ft) && t(this, ut).classList.add("focused") : (t(this, ut).hidden = !1, t(this, ut).style.zIndex = parseInt(t(this, ut).style.zIndex) + 1e3);
                         }, $t = new WeakSet(), oi = function() {
                             t(this, ut).classList.remove("focused"), !(t(this, ft) || !this.isVisible) && (t(this, ut).hidden = !0, t(this, ut).style.zIndex = parseInt(t(this, ut).style.zIndex) - 1e3);
                         };
-                        class T extends v {
+                        class x extends v {
                             constructor(R) {
                                 super(R, {
                                     isRenderable: !0,
                                     ignoreBorder: !0
-                                }), this.textContent = R.data.textContent, this.textPosition = R.data.textPosition, this.annotationEditorType = l.AnnotationEditorType.FREETEXT;
+                                }), this.textContent = R.data.textContent, this.textPosition = R.data.textPosition, this.annotationEditorType = c.AnnotationEditorType.FREETEXT;
                             }
                             render() {
                                 if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
                                     const R = document.createElement("div");
                                     R.classList.add("annotationTextContent"), R.setAttribute("role", "comment");
                                     for (const e of this.textContent) {
                                         const f = document.createElement("span");
                                         f.textContent = e, R.append(f);
                                     }
                                     this.container.append(R);
                                 }
                                 return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
                             }
                         }
-                        d.FreeTextAnnotationElement = T;
+                        d.FreeTextAnnotationElement = x;
                         class m extends v {
                             constructor(e) {
                                 super(e, {
                                     isRenderable: !0,
                                     ignoreBorder: !0
                                 });
-                                L(this, Y, null);
+                                I(this, Y, null);
                             }
                             render() {
                                 this.container.classList.add("lineAnnotation");
                                 const e = this.data,
                                     {
                                         width: f,
                                         height: D
-                                    } = I(e.rect),
+                                    } = O(e.rect),
                                     j = this.svgFactory.create(f, D, !0),
                                     q = Z(this, Y, this.svgFactory.createElement("svg:line"));
                                 return q.setAttribute("x1", e.rect[2] - e.lineCoordinates[0]), q.setAttribute("y1", e.rect[3] - e.lineCoordinates[1]), q.setAttribute("x2", e.rect[2] - e.lineCoordinates[2]), q.setAttribute("y2", e.rect[3] - e.lineCoordinates[3]), q.setAttribute("stroke-width", e.borderStyle.width || 1), q.setAttribute("stroke", "transparent"), q.setAttribute("fill", "transparent"), j.append(q), this.container.append(j), !e.popupRef && this.hasPopupData && this._createPopup(), this.container;
                             }
                             getElementsToTriggerPopup() {
                                 return t(this, Y);
                             }
@@ -11387,23 +11381,23 @@
                         Y = new WeakMap();
                         class U extends v {
                             constructor(e) {
                                 super(e, {
                                     isRenderable: !0,
                                     ignoreBorder: !0
                                 });
-                                L(this, G, null);
+                                I(this, G, null);
                             }
                             render() {
                                 this.container.classList.add("squareAnnotation");
                                 const e = this.data,
                                     {
                                         width: f,
                                         height: D
-                                    } = I(e.rect),
+                                    } = O(e.rect),
                                     j = this.svgFactory.create(f, D, !0),
                                     q = e.borderStyle.width,
                                     it = Z(this, G, this.svgFactory.createElement("svg:rect"));
                                 return it.setAttribute("x", q / 2), it.setAttribute("y", q / 2), it.setAttribute("width", f - q), it.setAttribute("height", D - q), it.setAttribute("stroke-width", q || 1), it.setAttribute("stroke", "transparent"), it.setAttribute("fill", "transparent"), j.append(it), this.container.append(j), !e.popupRef && this.hasPopupData && this._createPopup(), this.container;
                             }
                             getElementsToTriggerPopup() {
                                 return t(this, G);
@@ -11415,72 +11409,72 @@
                         G = new WeakMap();
                         class z extends v {
                             constructor(e) {
                                 super(e, {
                                     isRenderable: !0,
                                     ignoreBorder: !0
                                 });
-                                L(this, bt, null);
+                                I(this, bt, null);
                             }
                             render() {
                                 this.container.classList.add("circleAnnotation");
                                 const e = this.data,
                                     {
                                         width: f,
                                         height: D
-                                    } = I(e.rect),
+                                    } = O(e.rect),
                                     j = this.svgFactory.create(f, D, !0),
                                     q = e.borderStyle.width,
                                     it = Z(this, bt, this.svgFactory.createElement("svg:ellipse"));
                                 return it.setAttribute("cx", f / 2), it.setAttribute("cy", D / 2), it.setAttribute("rx", f / 2 - q / 2), it.setAttribute("ry", D / 2 - q / 2), it.setAttribute("stroke-width", q || 1), it.setAttribute("stroke", "transparent"), it.setAttribute("fill", "transparent"), j.append(it), this.container.append(j), !e.popupRef && this.hasPopupData && this._createPopup(), this.container;
                             }
                             getElementsToTriggerPopup() {
                                 return t(this, bt);
                             }
                             addHighlightArea() {
                                 this.container.classList.add("highlightArea");
                             }
                         }
                         bt = new WeakMap();
-                        class E extends v {
+                        class C extends v {
                             constructor(e) {
                                 super(e, {
                                     isRenderable: !0,
                                     ignoreBorder: !0
                                 });
-                                L(this, At, null);
+                                I(this, At, null);
                                 this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
                             }
                             render() {
                                 this.container.classList.add(this.containerClassName);
                                 const e = this.data,
                                     {
                                         width: f,
                                         height: D
-                                    } = I(e.rect),
+                                    } = O(e.rect),
                                     j = this.svgFactory.create(f, D, !0);
                                 let q = [];
                                 for (const mt of e.vertices) {
                                     const kt = mt.x - e.rect[0],
-                                        Pt = e.rect[3] - mt.y;
-                                    q.push(kt + "," + Pt);
+                                        xt = e.rect[3] - mt.y;
+                                    q.push(kt + "," + xt);
                                 }
                                 q = q.join(" ");
                                 const it = Z(this, At, this.svgFactory.createElement(this.svgElementName));
                                 return it.setAttribute("points", q), it.setAttribute("stroke-width", e.borderStyle.width || 1), it.setAttribute("stroke", "transparent"), it.setAttribute("fill", "transparent"), j.append(it), this.container.append(j), !e.popupRef && this.hasPopupData && this._createPopup(), this.container;
                             }
                             getElementsToTriggerPopup() {
                                 return t(this, At);
                             }
                             addHighlightArea() {
                                 this.container.classList.add("highlightArea");
                             }
                         }
                         At = new WeakMap();
-                        class V extends E {
+                        class V extends C {
                             constructor(R) {
                                 super(R), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
                             }
                         }
                         class st extends v {
                             constructor(R) {
                                 super(R, {
@@ -11494,31 +11488,31 @@
                         }
                         class at extends v {
                             constructor(e) {
                                 super(e, {
                                     isRenderable: !0,
                                     ignoreBorder: !0
                                 });
-                                L(this, te, []);
-                                this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = l.AnnotationEditorType.INK;
+                                I(this, te, []);
+                                this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = c.AnnotationEditorType.INK;
                             }
                             render() {
                                 this.container.classList.add(this.containerClassName);
                                 const e = this.data,
                                     {
                                         width: f,
                                         height: D
-                                    } = I(e.rect),
+                                    } = O(e.rect),
                                     j = this.svgFactory.create(f, D, !0);
                                 for (const q of e.inkLists) {
                                     let it = [];
                                     for (const kt of q) {
-                                        const Pt = kt.x - e.rect[0],
+                                        const xt = kt.x - e.rect[0],
                                             zt = e.rect[3] - kt.y;
-                                        it.push(`${Pt},${zt}`);
+                                        it.push(`${xt},${zt}`);
                                     }
                                     it = it.join(" ");
                                     const mt = this.svgFactory.createElement(this.svgElementName);
                                     t(this, te).push(mt), mt.setAttribute("points", it), mt.setAttribute("stroke-width", e.borderStyle.width || 1), mt.setAttribute("stroke", "transparent"), mt.setAttribute("fill", "transparent"), !e.popupRef && this.hasPopupData && this._createPopup(), j.append(mt);
                                 }
                                 return this.container.append(j), this.container;
                             }
@@ -11574,34 +11568,34 @@
                                     createQuadrilaterals: !0
                                 });
                             }
                             render() {
                                 return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
                             }
                         }
-                        class xt extends v {
+                        class Pt extends v {
                             constructor(R) {
                                 super(R, {
                                     isRenderable: !0,
                                     ignoreBorder: !0
                                 });
                             }
                             render() {
                                 return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
                             }
                         }
-                        d.StampAnnotationElement = xt;
+                        d.StampAnnotationElement = Pt;
                         class S extends v {
                             constructor(e) {
                                 var j;
                                 super(e, {
                                     isRenderable: !0
                                 });
-                                L(this, $);
-                                L(this, Zt, null);
+                                I(this, $);
+                                I(this, Zt, null);
                                 const {
                                     filename: f,
                                     content: D
                                 } = this.data.file;
                                 this.filename = (0, P.getFilenameFromUrl)(f, !0), this.content = D, (j = this.linkService.eventBus) == null || j.dispatch("fileattachmentannotation", {
                                     source: this,
                                     filename: f,
@@ -11614,15 +11608,15 @@
                                     container: e,
                                     data: f
                                 } = this;
                                 let D;
                                 f.hasAppearance || f.fillAlpha === 0 ? D = document.createElement("div") : (D = document.createElement("img"), D.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(f.name) ? "paperclip" : "pushpin"}.svg`, f.fillAlpha && f.fillAlpha < 1 && (D.style = `filter: opacity(${Math.round(f.fillAlpha * 100)}%);`)), D.addEventListener("dblclick", W(this, $, li).bind(this)), Z(this, Zt, D);
                                 const {
                                     isMac: j
-                                } = l.FeatureTest.platform;
+                                } = c.FeatureTest.platform;
                                 return e.addEventListener("keydown", (q) => {
                                     q.key === "Enter" && (j ? q.metaKey : q.ctrlKey) && W(this, $, li).call(this);
                                 }), !f.popupRef && this.hasPopupData ? this._createPopup() : D.classList.add("popupTriggerArea"), e.append(D), e;
                             }
                             getElementsToTriggerPopup() {
                                 return t(this, Zt);
                             }
@@ -11639,19 +11633,19 @@
                                 div: R,
                                 accessibilityManager: e,
                                 annotationCanvasMap: f,
                                 l10n: D,
                                 page: j,
                                 viewport: q
                             }) {
-                                L(this, Nt);
-                                L(this, _t);
-                                L(this, Lt, null);
-                                L(this, Tt, null);
-                                L(this, Ot, /* @__PURE__ */ new Map());
+                                I(this, Nt);
+                                I(this, _t);
+                                I(this, Lt, null);
+                                I(this, Tt, null);
+                                I(this, Ot, /* @__PURE__ */ new Map());
                                 this.div = R, Z(this, Lt, e), Z(this, Tt, f), this.l10n = D, this.page = j, this.viewport = q, this.zIndex = 0, this.l10n || (this.l10n = pt.NullL10n);
                             }
                             async render(R) {
                                 const {
                                     annotations: e
                                 } = R, f = this.div;
                                 (0, P.setLayerDimensions)(f, this.viewport);
@@ -11670,35 +11664,35 @@
                                         fieldObjects: R.fieldObjects,
                                         parent: this,
                                         elements: null
                                     };
                                 for (const q of e) {
                                     if (q.noHTML)
                                         continue;
-                                    const it = q.annotationType === l.AnnotationType.POPUP;
+                                    const it = q.annotationType === c.AnnotationType.POPUP;
                                     if (it) {
-                                        const Pt = D.get(q.id);
-                                        if (!Pt)
+                                        const xt = D.get(q.id);
+                                        if (!xt)
                                             continue;
-                                        j.elements = Pt;
+                                        j.elements = xt;
                                     } else {
                                         const {
-                                            width: Pt,
+                                            width: xt,
                                             height: zt
-                                        } = I(q.rect);
-                                        if (Pt <= 0 || zt <= 0)
+                                        } = O(q.rect);
+                                        if (xt <= 0 || zt <= 0)
                                             continue;
                                     }
                                     j.data = q;
-                                    const mt = x.create(j);
+                                    const mt = T.create(j);
                                     if (!mt.isRenderable)
                                         continue;
                                     if (!it && q.popupRef) {
-                                        const Pt = D.get(q.popupRef);
-                                        Pt ? Pt.push(mt) : D.set(q.popupRef, [mt]);
+                                        const xt = D.get(q.popupRef);
+                                        xt ? xt.push(mt) : D.set(q.popupRef, [mt]);
                                     }
                                     mt.annotationEditorType > 0 && t(this, Ot).set(mt.data.id, mt);
                                     const kt = mt.render();
                                     q.hidden && (kt.style.visibility = "hidden"), W(this, Nt, Oi).call(this, kt, q.id);
                                 }
                                 W(this, _t, ci).call(this), await this.l10n.translate(f);
                             }
@@ -11716,15 +11710,15 @@
                             getEditableAnnotation(R) {
                                 return t(this, Ot).get(R);
                             }
                         }
                         Lt = new WeakMap(), Tt = new WeakMap(), Ot = new WeakMap(), Nt = new WeakSet(), Oi = function(R, e) {
                             var D;
                             const f = R.firstChild || R;
-                            f.id = `${l.AnnotationPrefix}${e}`, this.div.append(R), (D = t(this, Lt)) == null || D.moveElementInDOM(this.div, R, f, !1);
+                            f.id = `${c.AnnotationPrefix}${e}`, this.div.append(R), (D = t(this, Lt)) == null || D.moveElementInDOM(this.div, R, f, !1);
                         }, _t = new WeakSet(), ci = function() {
                             if (!t(this, Tt))
                                 return;
                             const R = this.div;
                             for (const [e, f] of t(this, Tt)) {
                                 const D = R.querySelector(`[data-annotation-id="${e}"]`);
                                 if (!D)
@@ -11744,75 +11738,75 @@
                             value: !0
                         }), d.ColorConverters = void 0;
 
                         function et(rt) {
                             return Math.floor(Math.max(0, Math.min(1, rt)) * 255).toString(16).padStart(2, "0");
                         }
 
-                        function l(rt) {
+                        function c(rt) {
                             return Math.max(0, Math.min(255, 255 * rt));
                         }
                         class P {
                             static CMYK_G([X, pt, B, F]) {
                                 return ["G", 1 - Math.min(1, 0.3 * X + 0.59 * B + 0.11 * pt + F)];
                             }
                             static G_CMYK([X]) {
                                 return ["CMYK", 0, 0, 0, 1 - X];
                             }
                             static G_RGB([X]) {
                                 return ["RGB", X, X, X];
                             }
                             static G_rgb([X]) {
-                                return X = l(X), [X, X, X];
+                                return X = c(X), [X, X, X];
                             }
                             static G_HTML([X]) {
                                 const pt = et(X);
                                 return `#${pt}${pt}${pt}`;
                             }
                             static RGB_G([X, pt, B]) {
                                 return ["G", 0.3 * X + 0.59 * pt + 0.11 * B];
                             }
                             static RGB_rgb(X) {
-                                return X.map(l);
+                                return X.map(c);
                             }
                             static RGB_HTML(X) {
                                 return `#${X.map(et).join("")}`;
                             }
                             static T_HTML() {
                                 return "#00000000";
                             }
                             static T_rgb() {
                                 return [null];
                             }
                             static CMYK_RGB([X, pt, B, F]) {
                                 return ["RGB", 1 - Math.min(1, X + F), 1 - Math.min(1, B + F), 1 - Math.min(1, pt + F)];
                             }
                             static CMYK_rgb([X, pt, B, F]) {
-                                return [l(1 - Math.min(1, X + F)), l(1 - Math.min(1, B + F)), l(1 - Math.min(1, pt + F))];
+                                return [c(1 - Math.min(1, X + F)), c(1 - Math.min(1, B + F)), c(1 - Math.min(1, pt + F))];
                             }
                             static CMYK_HTML(X) {
                                 const pt = this.CMYK_RGB(X).slice(1);
                                 return this.RGB_HTML(pt);
                             }
                             static RGB_CMYK([X, pt, B]) {
                                 const F = 1 - X,
                                     g = 1 - pt,
-                                    O = 1 - B,
-                                    I = Math.min(F, g, O);
-                                return ["CMYK", F, g, O, I];
+                                    L = 1 - B,
+                                    O = Math.min(F, g, L);
+                                return ["CMYK", F, g, L, O];
                             }
                         }
                         d.ColorConverters = P;
                     },
                     /* 31 */
                     /***/
                     (dt, d) => {
                         Object.defineProperty(d, "__esModule", {
                             value: !0
-                        }), d.NullL10n = void 0, d.getL10nFallback = l;
+                        }), d.NullL10n = void 0, d.getL10nFallback = c;
                         const et = {
                             of_pages: "of {{pagesCount}}",
                             page_of_pages: "({{pageNumber}} of {{pagesCount}})",
                             document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
                             document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
                             document_properties_date_string: "{{date}}, {{time}}",
                             document_properties_page_size_unit_inches: "in",
@@ -11858,15 +11852,15 @@
                             editor_ink_canvas_aria_label: "User-created image",
                             editor_alt_text_button_label: "Alt text",
                             editor_alt_text_edit_button_label: "Edit alt text",
                             editor_alt_text_decorative_tooltip: "Marked as decorative"
                         };
                         et.print_progress_percent = "{{progress}}%";
 
-                        function l(X, pt) {
+                        function c(X, pt) {
                             switch (X) {
                                 case "find_match_count":
                                     X = `find_match_count[${pt.total === 1 ? "one" : "other"}]`;
                                     break;
                                 case "find_match_count_limit":
                                     X = `find_match_count_limit[${pt.limit === 1 ? "one" : "other"}]`;
                                     break;
@@ -11880,71 +11874,71 @@
                         const rt = {
                             async getLanguage() {
                                 return "en-us";
                             },
                             async getDirection() {
                                 return "ltr";
                             },
-                            async get(X, pt = null, B = l(X, pt)) {
+                            async get(X, pt = null, B = c(X, pt)) {
                                 return P(B, pt);
                             },
                             async translate(X) {}
                         };
                         d.NullL10n = rt;
                     },
                     /* 32 */
                     /***/
                     (dt, d, et) => {
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.XfaLayer = void 0;
-                        var l = et(25);
+                        var c = et(25);
                         class P {
                             static setupStorage(X, pt, B, F, g) {
-                                const O = F.getValue(pt, {
+                                const L = F.getValue(pt, {
                                     value: null
                                 });
                                 switch (B.name) {
                                     case "textarea":
-                                        if (O.value !== null && (X.textContent = O.value), g === "print")
+                                        if (L.value !== null && (X.textContent = L.value), g === "print")
                                             break;
-                                        X.addEventListener("input", (I) => {
+                                        X.addEventListener("input", (O) => {
                                             F.setValue(pt, {
-                                                value: I.target.value
+                                                value: O.target.value
                                             });
                                         });
                                         break;
                                     case "input":
                                         if (B.attributes.type === "radio" || B.attributes.type === "checkbox") {
-                                            if (O.value === B.attributes.xfaOn ? X.setAttribute("checked", !0) : O.value === B.attributes.xfaOff && X.removeAttribute("checked"), g === "print")
+                                            if (L.value === B.attributes.xfaOn ? X.setAttribute("checked", !0) : L.value === B.attributes.xfaOff && X.removeAttribute("checked"), g === "print")
                                                 break;
-                                            X.addEventListener("change", (I) => {
+                                            X.addEventListener("change", (O) => {
                                                 F.setValue(pt, {
-                                                    value: I.target.checked ? I.target.getAttribute("xfaOn") : I.target.getAttribute("xfaOff")
+                                                    value: O.target.checked ? O.target.getAttribute("xfaOn") : O.target.getAttribute("xfaOff")
                                                 });
                                             });
                                         } else {
-                                            if (O.value !== null && X.setAttribute("value", O.value), g === "print")
+                                            if (L.value !== null && X.setAttribute("value", L.value), g === "print")
                                                 break;
-                                            X.addEventListener("input", (I) => {
+                                            X.addEventListener("input", (O) => {
                                                 F.setValue(pt, {
-                                                    value: I.target.value
+                                                    value: O.target.value
                                                 });
                                             });
                                         }
                                         break;
                                     case "select":
-                                        if (O.value !== null) {
-                                            X.setAttribute("value", O.value);
-                                            for (const I of B.children)
-                                                I.attributes.value === O.value ? I.attributes.selected = !0 : I.attributes.hasOwnProperty("selected") && delete I.attributes.selected;
-                                        }
-                                        X.addEventListener("input", (I) => {
-                                            const x = I.target.options,
-                                                v = x.selectedIndex === -1 ? "" : x[x.selectedIndex].value;
+                                        if (L.value !== null) {
+                                            X.setAttribute("value", L.value);
+                                            for (const O of B.children)
+                                                O.attributes.value === L.value ? O.attributes.selected = !0 : O.attributes.hasOwnProperty("selected") && delete O.attributes.selected;
+                                        }
+                                        X.addEventListener("input", (O) => {
+                                            const T = O.target.options,
+                                                v = T.selectedIndex === -1 ? "" : T[T.selectedIndex].value;
                                             F.setValue(pt, {
                                                 value: v
                                             });
                                         });
                                         break;
                                 }
                             }
@@ -11952,94 +11946,94 @@
                                 html: X,
                                 element: pt,
                                 storage: B = null,
                                 intent: F,
                                 linkService: g
                             }) {
                                 const {
-                                    attributes: O
-                                } = pt, I = X instanceof HTMLAnchorElement;
-                                O.type === "radio" && (O.name = `${O.name}-${F}`);
-                                for (const [x, v] of Object.entries(O))
+                                    attributes: L
+                                } = pt, O = X instanceof HTMLAnchorElement;
+                                L.type === "radio" && (L.name = `${L.name}-${F}`);
+                                for (const [T, v] of Object.entries(L))
                                     if (v != null)
-                                        switch (x) {
+                                        switch (T) {
                                             case "class":
-                                                v.length && X.setAttribute(x, v.join(" "));
+                                                v.length && X.setAttribute(T, v.join(" "));
                                                 break;
                                             case "dataId":
                                                 break;
                                             case "id":
                                                 X.setAttribute("data-element-id", v);
                                                 break;
                                             case "style":
                                                 Object.assign(X.style, v);
                                                 break;
                                             case "textContent":
                                                 X.textContent = v;
                                                 break;
                                             default:
-                                                (!I || x !== "href" && x !== "newWindow") && X.setAttribute(x, v);
+                                                (!O || T !== "href" && T !== "newWindow") && X.setAttribute(T, v);
                                         }
-                                I && g.addLinkAttributes(X, O.href, O.newWindow), B && O.dataId && this.setupStorage(X, O.dataId, pt, B);
+                                O && g.addLinkAttributes(X, L.href, L.newWindow), B && L.dataId && this.setupStorage(X, L.dataId, pt, B);
                             }
                             static render(X) {
                                 var A;
                                 const pt = X.annotationStorage,
                                     B = X.linkService,
                                     F = X.xfaHtml,
                                     g = X.intent || "display",
-                                    O = document.createElement(F.name);
+                                    L = document.createElement(F.name);
                                 F.attributes && this.setAttributes({
-                                    html: O,
+                                    html: L,
                                     element: F,
                                     intent: g,
                                     linkService: B
                                 });
-                                const I = [
-                                        [F, -1, O]
+                                const O = [
+                                        [F, -1, L]
                                     ],
-                                    x = X.div;
-                                if (x.append(O), X.viewport) {
+                                    T = X.div;
+                                if (T.append(L), X.viewport) {
                                     const u = `matrix(${X.viewport.transform.join(",")})`;
-                                    x.style.transform = u;
+                                    T.style.transform = u;
                                 }
-                                g !== "richText" && x.setAttribute("class", "xfaLayer xfaFont");
+                                g !== "richText" && T.setAttribute("class", "xfaLayer xfaFont");
                                 const v = [];
-                                for (; I.length > 0;) {
-                                    const [u, _, w] = I.at(-1);
-                                    if (_ + 1 === u.children.length) {
-                                        I.pop();
+                                for (; O.length > 0;) {
+                                    const [u, b, E] = O.at(-1);
+                                    if (b + 1 === u.children.length) {
+                                        O.pop();
                                         continue;
                                     }
-                                    const C = u.children[++I.at(-1)[1]];
-                                    if (C === null)
+                                    const w = u.children[++O.at(-1)[1]];
+                                    if (w === null)
                                         continue;
                                     const {
                                         name: y
-                                    } = C;
+                                    } = w;
                                     if (y === "#text") {
-                                        const c = document.createTextNode(C.value);
-                                        v.push(c), w.append(c);
+                                        const l = document.createTextNode(w.value);
+                                        v.push(l), E.append(l);
                                         continue;
                                     }
-                                    const a = (A = C == null ? void 0 : C.attributes) != null && A.xmlns ? document.createElementNS(C.attributes.xmlns, y) : document.createElement(y);
-                                    if (w.append(a), C.attributes && this.setAttributes({
+                                    const a = (A = w == null ? void 0 : w.attributes) != null && A.xmlns ? document.createElementNS(w.attributes.xmlns, y) : document.createElement(y);
+                                    if (E.append(a), w.attributes && this.setAttributes({
                                             html: a,
-                                            element: C,
+                                            element: w,
                                             storage: pt,
                                             intent: g,
                                             linkService: B
-                                        }), C.children && C.children.length > 0)
-                                        I.push([C, -1, a]);
-                                    else if (C.value) {
-                                        const c = document.createTextNode(C.value);
-                                        l.XfaText.shouldBuildText(y) && v.push(c), a.append(c);
+                                        }), w.children && w.children.length > 0)
+                                        O.push([w, -1, a]);
+                                    else if (w.value) {
+                                        const l = document.createTextNode(w.value);
+                                        c.XfaText.shouldBuildText(y) && v.push(l), a.append(l);
                                     }
                                 }
-                                for (const u of x.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
+                                for (const u of T.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
                                     u.setAttribute("readOnly", !0);
                                 return {
                                     textDivs: v
                                 };
                             }
                             static update(X) {
                                 const pt = `matrix(${X.viewport.transform.join(",")})`;
@@ -12047,118 +12041,118 @@
                             }
                         }
                         d.XfaLayer = P;
                     },
                     /* 33 */
                     /***/
                     (dt, d, et) => {
-                        var F, g, O, I, x, v, A, u, _, w, C, y, a, c, k, Ni, r, Bi, m, Ui, z, ji, V, hi, at, Hi, lt, di, wt, Wi, S, Gi, n, zi, o, Xi, b, Vi, N, ae, Q, ui, ct, Me, ut, Re, Bt, fe, Dt, fi, K, De, ht, qi, Ct, pi, Gt, $i, Xt, Yi, Wt, gi, ot, Ie, G, pe;
+                        var F, g, L, O, T, v, A, u, b, E, w, y, a, l, k, Ni, r, Bi, m, Ui, z, ji, V, hi, at, Hi, lt, di, wt, Wi, S, Gi, n, zi, o, Xi, _, Vi, N, ae, Q, ui, ct, Me, ut, Re, Bt, fe, Dt, fi, K, De, ht, qi, Ct, pi, Gt, $i, Xt, Yi, Wt, gi, ot, Ie, G, pe;
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.InkEditor = void 0;
-                        var l = et(1),
+                        var c = et(1),
                             P = et(4),
                             rt = et(29),
                             X = et(6),
                             pt = et(5);
                         const At = class At extends P.AnnotationEditor {
                             constructor($) {
                                 super({
                                     ...$,
                                     name: "inkEditor"
                                 });
-                                L(this, k);
-                                L(this, r);
-                                L(this, m);
-                                L(this, z);
-                                L(this, V);
-                                L(this, at);
-                                L(this, lt);
-                                L(this, wt);
-                                L(this, S);
-                                L(this, n);
-                                L(this, o);
-                                L(this, b);
-                                L(this, N);
-                                L(this, Q);
-                                L(this, ct);
-                                L(this, ut);
-                                L(this, Bt);
-                                L(this, Dt);
-                                L(this, K);
-                                L(this, Xt);
-                                L(this, Wt);
-                                L(this, ot);
-                                L(this, G);
-                                L(this, F, 0);
-                                L(this, g, 0);
-                                L(this, O, this.canvasPointermove.bind(this));
-                                L(this, I, this.canvasPointerleave.bind(this));
-                                L(this, x, this.canvasPointerup.bind(this));
-                                L(this, v, this.canvasPointerdown.bind(this));
-                                L(this, A, new Path2D());
-                                L(this, u, !1);
-                                L(this, _, !1);
-                                L(this, w, !1);
-                                L(this, C, null);
-                                L(this, y, 0);
-                                L(this, a, 0);
-                                L(this, c, null);
+                                I(this, k);
+                                I(this, r);
+                                I(this, m);
+                                I(this, z);
+                                I(this, V);
+                                I(this, at);
+                                I(this, lt);
+                                I(this, wt);
+                                I(this, S);
+                                I(this, n);
+                                I(this, o);
+                                I(this, _);
+                                I(this, N);
+                                I(this, Q);
+                                I(this, ct);
+                                I(this, ut);
+                                I(this, Bt);
+                                I(this, Dt);
+                                I(this, K);
+                                I(this, Xt);
+                                I(this, Wt);
+                                I(this, ot);
+                                I(this, G);
+                                I(this, F, 0);
+                                I(this, g, 0);
+                                I(this, L, this.canvasPointermove.bind(this));
+                                I(this, O, this.canvasPointerleave.bind(this));
+                                I(this, T, this.canvasPointerup.bind(this));
+                                I(this, v, this.canvasPointerdown.bind(this));
+                                I(this, A, new Path2D());
+                                I(this, u, !1);
+                                I(this, b, !1);
+                                I(this, E, !1);
+                                I(this, w, null);
+                                I(this, y, 0);
+                                I(this, a, 0);
+                                I(this, l, null);
                                 this.color = $.color || null, this.thickness = $.thickness || null, this.opacity = $.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
                             }
                             static initialize($) {
                                 P.AnnotationEditor.initialize($, {
                                     strings: ["editor_ink_canvas_aria_label", "editor_ink2_aria_label"]
                                 });
                             }
                             static updateDefaultParams($, vt) {
                                 switch ($) {
-                                    case l.AnnotationEditorParamsType.INK_THICKNESS:
+                                    case c.AnnotationEditorParamsType.INK_THICKNESS:
                                         At._defaultThickness = vt;
                                         break;
-                                    case l.AnnotationEditorParamsType.INK_COLOR:
+                                    case c.AnnotationEditorParamsType.INK_COLOR:
                                         At._defaultColor = vt;
                                         break;
-                                    case l.AnnotationEditorParamsType.INK_OPACITY:
+                                    case c.AnnotationEditorParamsType.INK_OPACITY:
                                         At._defaultOpacity = vt / 100;
                                         break;
                                 }
                             }
                             updateParams($, vt) {
                                 switch ($) {
-                                    case l.AnnotationEditorParamsType.INK_THICKNESS:
+                                    case c.AnnotationEditorParamsType.INK_THICKNESS:
                                         W(this, k, Ni).call(this, vt);
                                         break;
-                                    case l.AnnotationEditorParamsType.INK_COLOR:
+                                    case c.AnnotationEditorParamsType.INK_COLOR:
                                         W(this, r, Bi).call(this, vt);
                                         break;
-                                    case l.AnnotationEditorParamsType.INK_OPACITY:
+                                    case c.AnnotationEditorParamsType.INK_OPACITY:
                                         W(this, m, Ui).call(this, vt);
                                         break;
                                 }
                             }
                             static get defaultPropertiesToUpdate() {
                                 return [
-                                    [l.AnnotationEditorParamsType.INK_THICKNESS, At._defaultThickness],
-                                    [l.AnnotationEditorParamsType.INK_COLOR, At._defaultColor || P.AnnotationEditor._defaultLineColor],
-                                    [l.AnnotationEditorParamsType.INK_OPACITY, Math.round(At._defaultOpacity * 100)]
+                                    [c.AnnotationEditorParamsType.INK_THICKNESS, At._defaultThickness],
+                                    [c.AnnotationEditorParamsType.INK_COLOR, At._defaultColor || P.AnnotationEditor._defaultLineColor],
+                                    [c.AnnotationEditorParamsType.INK_OPACITY, Math.round(At._defaultOpacity * 100)]
                                 ];
                             }
                             get propertiesToUpdate() {
                                 return [
-                                    [l.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || At._defaultThickness],
-                                    [l.AnnotationEditorParamsType.INK_COLOR, this.color || At._defaultColor || P.AnnotationEditor._defaultLineColor],
-                                    [l.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? At._defaultOpacity))]
+                                    [c.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || At._defaultThickness],
+                                    [c.AnnotationEditorParamsType.INK_COLOR, this.color || At._defaultColor || P.AnnotationEditor._defaultLineColor],
+                                    [c.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? At._defaultOpacity))]
                                 ];
                             }
                             rebuild() {
                                 this.parent && (super.rebuild(), this.div !== null && (this.canvas || (W(this, ct, Me).call(this), W(this, ut, Re).call(this)), this.isAttachedToDOM || (this.parent.add(this), W(this, Bt, fe).call(this)), W(this, G, pe).call(this)));
                             }
                             remove() {
-                                this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, t(this, C).disconnect(), Z(this, C, null), super.remove());
+                                this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, t(this, w).disconnect(), Z(this, w, null), super.remove());
                             }
                             setParent($) {
                                 !this.parent && $ ? this._uiManager.removeShouldRescale(this) : this.parent && $ === null && this._uiManager.addShouldRescale(this), super.setParent($);
                             }
                             onScaleChanging() {
                                 const [$, vt] = this.parentDimensions, Lt = this.width * $, Tt = this.height * vt;
                                 this.setDimensions(Lt, Tt);
@@ -12205,15 +12199,15 @@
                                 this.width && ($ = this.x, vt = this.y), super.render(), P.AnnotationEditor._l10nPromise.get("editor_ink2_aria_label").then((Jt) => {
                                     var _t;
                                     return (_t = this.div) == null ? void 0 : _t.setAttribute("aria-label", Jt);
                                 });
                                 const [Lt, Tt, Ot, Nt] = W(this, z, ji).call(this);
                                 if (this.setAt(Lt, Tt, 0, 0), this.setDims(Ot, Nt), W(this, ct, Me).call(this), this.width) {
                                     const [Jt, _t] = this.parentDimensions;
-                                    this.setAspectRatio(this.width * Jt, this.height * _t), this.setAt($ * Jt, vt * _t, this.width * Jt, this.height * _t), Z(this, w, !0), W(this, Bt, fe).call(this), this.setDims(this.width * Jt, this.height * _t), W(this, N, ae).call(this), this.div.classList.add("disabled");
+                                    this.setAspectRatio(this.width * Jt, this.height * _t), this.setAt($ * Jt, vt * _t, this.width * Jt, this.height * _t), Z(this, E, !0), W(this, Bt, fe).call(this), this.setDims(this.width * Jt, this.height * _t), W(this, N, ae).call(this), this.div.classList.add("disabled");
                                 } else
                                     this.div.classList.add("editing"), this.enableEditMode();
                                 return W(this, ut, Re).call(this), this.div;
                             }
                             setDimensions($, vt) {
                                 const Lt = Math.round($),
                                     Tt = Math.round(vt);
@@ -12224,109 +12218,109 @@
                                 this.width = $ / Ot, this.height = vt / Nt, this.fixAndSetPosition(), t(this, u) && W(this, Dt, fi).call(this, $, vt), W(this, Bt, fe).call(this), W(this, N, ae).call(this), this.canvas.style.visibility = "visible", this.fixDims();
                             }
                             static deserialize($, vt, Lt) {
                                 var j, q, it;
                                 if ($ instanceof rt.InkAnnotationElement)
                                     return null;
                                 const Tt = super.deserialize($, vt, Lt);
-                                Tt.thickness = $.thickness, Tt.color = l.Util.makeHexColor(...$.color), Tt.opacity = $.opacity;
+                                Tt.thickness = $.thickness, Tt.color = c.Util.makeHexColor(...$.color), Tt.opacity = $.opacity;
                                 const [Ot, Nt] = Tt.pageDimensions, Jt = Tt.width * Ot, _t = Tt.height * Nt, Yt = Tt.parentScale, It = $.thickness / 2;
                                 Z(Tt, u, !0), Z(Tt, y, Math.round(Jt)), Z(Tt, a, Math.round(_t));
                                 const {
                                     paths: R,
                                     rect: e,
                                     rotation: f
                                 } = $;
                                 for (let {
                                         bezier: mt
                                     }
                                     of R) {
                                     mt = W(j = At, Gt, $i).call(j, mt, e, f);
                                     const kt = [];
                                     Tt.paths.push(kt);
-                                    let Pt = Yt * (mt[0] - It),
+                                    let xt = Yt * (mt[0] - It),
                                         zt = Yt * (mt[1] - It);
                                     for (let Rt = 2, jt = mt.length; Rt < jt; Rt += 6) {
                                         const qt = Yt * (mt[Rt] - It),
                                             Kt = Yt * (mt[Rt + 1] - It),
                                             Qt = Yt * (mt[Rt + 2] - It),
                                             se = Yt * (mt[Rt + 3] - It),
                                             ie = Yt * (mt[Rt + 4] - It),
                                             ne = Yt * (mt[Rt + 5] - It);
                                         kt.push([
-                                            [Pt, zt],
+                                            [xt, zt],
                                             [qt, Kt],
                                             [Qt, se],
                                             [ie, ne]
-                                        ]), Pt = ie, zt = ne;
+                                        ]), xt = ie, zt = ne;
                                     }
                                     const Mt = W(this, ht, qi).call(this, kt);
                                     Tt.bezierPath2D.push(Mt);
                                 }
                                 const D = W(q = Tt, Wt, gi).call(q);
                                 return Z(Tt, g, Math.max(P.AnnotationEditor.MIN_SIZE, D[2] - D[0])), Z(Tt, F, Math.max(P.AnnotationEditor.MIN_SIZE, D[3] - D[1])), W(it = Tt, Dt, fi).call(it, Jt, _t), Tt;
                             }
                             serialize() {
                                 if (this.isEmpty())
                                     return null;
                                 const $ = this.getRect(0, 0),
                                     vt = P.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
                                 return {
-                                    annotationType: l.AnnotationEditorType.INK,
+                                    annotationType: c.AnnotationEditorType.INK,
                                     color: vt,
                                     thickness: this.thickness,
                                     opacity: this.opacity,
                                     paths: W(this, Xt, Yi).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, $),
                                     pageIndex: this.pageIndex,
                                     rect: $,
                                     rotation: this.rotation,
                                     structTreeParentId: this._structTreeParentId
                                 };
                             }
                         };
-                        F = new WeakMap(), g = new WeakMap(), O = new WeakMap(), I = new WeakMap(), x = new WeakMap(), v = new WeakMap(), A = new WeakMap(), u = new WeakMap(), _ = new WeakMap(), w = new WeakMap(), C = new WeakMap(), y = new WeakMap(), a = new WeakMap(), c = new WeakMap(), k = new WeakSet(), Ni = function($) {
+                        F = new WeakMap(), g = new WeakMap(), L = new WeakMap(), O = new WeakMap(), T = new WeakMap(), v = new WeakMap(), A = new WeakMap(), u = new WeakMap(), b = new WeakMap(), E = new WeakMap(), w = new WeakMap(), y = new WeakMap(), a = new WeakMap(), l = new WeakMap(), k = new WeakSet(), Ni = function($) {
                             const vt = this.thickness;
                             this.addCommands({
                                 cmd: () => {
                                     this.thickness = $, W(this, G, pe).call(this);
                                 },
                                 undo: () => {
                                     this.thickness = vt, W(this, G, pe).call(this);
                                 },
                                 mustExec: !0,
-                                type: l.AnnotationEditorParamsType.INK_THICKNESS,
+                                type: c.AnnotationEditorParamsType.INK_THICKNESS,
                                 overwriteIfSameType: !0,
                                 keepUndo: !0
                             });
                         }, r = new WeakSet(), Bi = function($) {
                             const vt = this.color;
                             this.addCommands({
                                 cmd: () => {
                                     this.color = $, W(this, N, ae).call(this);
                                 },
                                 undo: () => {
                                     this.color = vt, W(this, N, ae).call(this);
                                 },
                                 mustExec: !0,
-                                type: l.AnnotationEditorParamsType.INK_COLOR,
+                                type: c.AnnotationEditorParamsType.INK_COLOR,
                                 overwriteIfSameType: !0,
                                 keepUndo: !0
                             });
                         }, m = new WeakSet(), Ui = function($) {
                             $ /= 100;
                             const vt = this.opacity;
                             this.addCommands({
                                 cmd: () => {
                                     this.opacity = $, W(this, N, ae).call(this);
                                 },
                                 undo: () => {
                                     this.opacity = vt, W(this, N, ae).call(this);
                                 },
                                 mustExec: !0,
-                                type: l.AnnotationEditorParamsType.INK_OPACITY,
+                                type: c.AnnotationEditorParamsType.INK_OPACITY,
                                 overwriteIfSameType: !0,
                                 keepUndo: !0
                             });
                         }, z = new WeakSet(), ji = function() {
                             const {
                                 parentRotation: $,
                                 parentDimensions: [vt, Lt]
@@ -12348,38 +12342,38 @@
                                 opacity: Lt,
                                 thickness: Tt,
                                 parentScale: Ot,
                                 scaleFactor: Nt
                             } = this;
                             $.lineWidth = Tt * Ot / Nt, $.lineCap = "round", $.lineJoin = "round", $.miterLimit = 10, $.strokeStyle = `${vt}${(0, pt.opacityToHex)(Lt)}`;
                         }, at = new WeakSet(), Hi = function($, vt) {
-                            this.canvas.addEventListener("contextmenu", X.noContextMenu), this.canvas.addEventListener("pointerleave", t(this, I)), this.canvas.addEventListener("pointermove", t(this, O)), this.canvas.addEventListener("pointerup", t(this, x)), this.canvas.removeEventListener("pointerdown", t(this, v)), this.isEditing = !0, t(this, w) || (Z(this, w, !0), W(this, Bt, fe).call(this), this.thickness || (this.thickness = At._defaultThickness), this.color || (this.color = At._defaultColor || P.AnnotationEditor._defaultLineColor), this.opacity ?? (this.opacity = At._defaultOpacity)), this.currentPath.push([$, vt]), Z(this, _, !1), W(this, V, hi).call(this), Z(this, c, () => {
-                                W(this, n, zi).call(this), t(this, c) && window.requestAnimationFrame(t(this, c));
-                            }), window.requestAnimationFrame(t(this, c));
+                            this.canvas.addEventListener("contextmenu", X.noContextMenu), this.canvas.addEventListener("pointerleave", t(this, O)), this.canvas.addEventListener("pointermove", t(this, L)), this.canvas.addEventListener("pointerup", t(this, T)), this.canvas.removeEventListener("pointerdown", t(this, v)), this.isEditing = !0, t(this, E) || (Z(this, E, !0), W(this, Bt, fe).call(this), this.thickness || (this.thickness = At._defaultThickness), this.color || (this.color = At._defaultColor || P.AnnotationEditor._defaultLineColor), this.opacity ?? (this.opacity = At._defaultOpacity)), this.currentPath.push([$, vt]), Z(this, b, !1), W(this, V, hi).call(this), Z(this, l, () => {
+                                W(this, n, zi).call(this), t(this, l) && window.requestAnimationFrame(t(this, l));
+                            }), window.requestAnimationFrame(t(this, l));
                         }, lt = new WeakSet(), di = function($, vt) {
                             const [Lt, Tt] = this.currentPath.at(-1);
                             if (this.currentPath.length > 1 && $ === Lt && vt === Tt)
                                 return;
                             const Ot = this.currentPath;
                             let Nt = t(this, A);
-                            if (Ot.push([$, vt]), Z(this, _, !0), Ot.length <= 2) {
+                            if (Ot.push([$, vt]), Z(this, b, !0), Ot.length <= 2) {
                                 Nt.moveTo(...Ot[0]), Nt.lineTo($, vt);
                                 return;
                             }
                             Ot.length === 3 && (Z(this, A, Nt = new Path2D()), Nt.moveTo(...Ot[0])), W(this, o, Xi).call(this, Nt, ...Ot.at(-3), ...Ot.at(-2), $, vt);
                         }, wt = new WeakSet(), Wi = function() {
                             if (this.currentPath.length === 0)
                                 return;
                             const $ = this.currentPath.at(-1);
                             t(this, A).lineTo(...$);
                         }, S = new WeakSet(), Gi = function($, vt) {
-                            Z(this, c, null), $ = Math.min(Math.max($, 0), this.canvas.width), vt = Math.min(Math.max(vt, 0), this.canvas.height), W(this, lt, di).call(this, $, vt), W(this, wt, Wi).call(this);
+                            Z(this, l, null), $ = Math.min(Math.max($, 0), this.canvas.width), vt = Math.min(Math.max(vt, 0), this.canvas.height), W(this, lt, di).call(this, $, vt), W(this, wt, Wi).call(this);
                             let Lt;
                             if (this.currentPath.length !== 1)
-                                Lt = W(this, b, Vi).call(this);
+                                Lt = W(this, _, Vi).call(this);
                             else {
                                 const _t = [$, vt];
                                 Lt = [
                                     [_t, _t.slice(), _t.slice(), _t]
                                 ];
                             }
                             const Tt = t(this, A),
@@ -12393,17 +12387,17 @@
                                 };
                             this.addCommands({
                                 cmd: Nt,
                                 undo: Jt,
                                 mustExec: !0
                             });
                         }, n = new WeakSet(), zi = function() {
-                            if (!t(this, _))
+                            if (!t(this, b))
                                 return;
-                            Z(this, _, !1);
+                            Z(this, b, !1);
                             const $ = Math.ceil(this.thickness * this.parentScale),
                                 vt = this.currentPath.slice(-3),
                                 Lt = vt.map((Nt) => Nt[0]),
                                 Tt = vt.map((Nt) => Nt[1]);
                             Math.min(...Lt) - $, Math.max(...Lt) + $, Math.min(...Tt) - $, Math.max(...Tt) + $;
                             const {
                                 ctx: Ot
@@ -12414,15 +12408,15 @@
                             Ot.stroke(t(this, A)), Ot.restore();
                         }, o = new WeakSet(), Xi = function($, vt, Lt, Tt, Ot, Nt, Jt) {
                             const _t = (vt + Tt) / 2,
                                 Yt = (Lt + Ot) / 2,
                                 It = (Tt + Nt) / 2,
                                 R = (Ot + Jt) / 2;
                             $.bezierCurveTo(_t + 2 * (Tt - _t) / 3, Yt + 2 * (Ot - Yt) / 3, It + 2 * (Tt - It) / 3, R + 2 * (Ot - R) / 3, It, R);
-                        }, b = new WeakSet(), Vi = function() {
+                        }, _ = new WeakSet(), Vi = function() {
                             const $ = this.currentPath;
                             if ($.length <= 2)
                                 return [
                                     [$[0], $[0], $.at(-1), $.at(-1)]
                                 ];
                             const vt = [];
                             let Lt, [Tt, Ot] = $[0];
@@ -12446,29 +12440,29 @@
                                 canvas: $,
                                 ctx: vt
                             } = this;
                             vt.setTransform(1, 0, 0, 1, 0, 0), vt.clearRect(0, 0, $.width, $.height), W(this, K, De).call(this);
                             for (const Lt of this.bezierPath2D)
                                 vt.stroke(Lt);
                         }, Q = new WeakSet(), ui = function($) {
-                            this.canvas.removeEventListener("pointerleave", t(this, I)), this.canvas.removeEventListener("pointermove", t(this, O)), this.canvas.removeEventListener("pointerup", t(this, x)), this.canvas.addEventListener("pointerdown", t(this, v)), setTimeout(() => {
+                            this.canvas.removeEventListener("pointerleave", t(this, O)), this.canvas.removeEventListener("pointermove", t(this, L)), this.canvas.removeEventListener("pointerup", t(this, T)), this.canvas.addEventListener("pointerdown", t(this, v)), setTimeout(() => {
                                 this.canvas.removeEventListener("contextmenu", X.noContextMenu);
                             }, 10), W(this, S, Gi).call(this, $.offsetX, $.offsetY), this.addToAnnotationStorage(), this.setInBackground();
                         }, ct = new WeakSet(), Me = function() {
                             this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", P.AnnotationEditor._l10nPromise.get("editor_ink_canvas_aria_label").then(($) => {
                                 var vt;
                                 return (vt = this.canvas) == null ? void 0 : vt.setAttribute("aria-label", $);
                             }), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
                         }, ut = new WeakSet(), Re = function() {
-                            Z(this, C, new ResizeObserver(($) => {
+                            Z(this, w, new ResizeObserver(($) => {
                                 const vt = $[0].contentRect;
                                 vt.width && vt.height && this.setDimensions(vt.width, vt.height);
-                            })), t(this, C).observe(this.div);
+                            })), t(this, w).observe(this.div);
                         }, Bt = new WeakSet(), fe = function() {
-                            if (!t(this, w))
+                            if (!t(this, E))
                                 return;
                             const [$, vt] = this.parentDimensions;
                             this.canvas.width = Math.ceil(this.width * $), this.canvas.height = Math.ceil(this.height * vt), W(this, K, De).call(this);
                         }, Dt = new WeakSet(), fi = function($, vt) {
                             const Lt = W(this, ot, Ie).call(this),
                                 Tt = ($ - Lt) / t(this, g),
                                 Ot = (vt - Lt) / t(this, F);
@@ -12543,31 +12537,31 @@
                                 Nt = this.thickness / 2,
                                 Jt = $ * vt + Nt,
                                 _t = $ * Lt + Nt;
                             for (const R of this.paths) {
                                 const e = [],
                                     f = [];
                                 for (let D = 0, j = R.length; D < j; D++) {
-                                    const [q, it, mt, kt] = R[D], Pt = $ * q[0] + Jt, zt = $ * q[1] + _t, Mt = $ * it[0] + Jt, Rt = $ * it[1] + _t, jt = $ * mt[0] + Jt, qt = $ * mt[1] + _t, Kt = $ * kt[0] + Jt, Qt = $ * kt[1] + _t;
-                                    D === 0 && (e.push(Pt, zt), f.push(Pt, zt)), e.push(Mt, Rt, jt, qt, Kt, Qt), f.push(Mt, Rt), D === j - 1 && f.push(Kt, Qt);
+                                    const [q, it, mt, kt] = R[D], xt = $ * q[0] + Jt, zt = $ * q[1] + _t, Mt = $ * it[0] + Jt, Rt = $ * it[1] + _t, jt = $ * mt[0] + Jt, qt = $ * mt[1] + _t, Kt = $ * kt[0] + Jt, Qt = $ * kt[1] + _t;
+                                    D === 0 && (e.push(xt, zt), f.push(xt, zt)), e.push(Mt, Rt, jt, qt, Kt, Qt), f.push(Mt, Rt), D === j - 1 && f.push(Kt, Qt);
                                 }
                                 Ot.push({
                                     bezier: W(Yt = At, Ct, pi).call(Yt, e, Tt, this.rotation),
                                     points: W(It = At, Ct, pi).call(It, f, Tt, this.rotation)
                                 });
                             }
                             return Ot;
                         }, Wt = new WeakSet(), gi = function() {
                             let $ = 1 / 0,
                                 vt = -1 / 0,
                                 Lt = 1 / 0,
                                 Tt = -1 / 0;
                             for (const Ot of this.paths)
                                 for (const [Nt, Jt, _t, Yt] of Ot) {
-                                    const It = l.Util.bezierBoundingBox(...Nt, ...Jt, ..._t, ...Yt);
+                                    const It = c.Util.bezierBoundingBox(...Nt, ...Jt, ..._t, ...Yt);
                                     $ = Math.min($, It[0]), Lt = Math.min(Lt, It[1]), vt = Math.max(vt, It[2]), Tt = Math.max(Tt, It[3]);
                                 }
                             return [$, Lt, vt, Tt];
                         }, ot = new WeakSet(), Ie = function() {
                             return t(this, u) ? Math.ceil(this.thickness * this.parentScale) : 0;
                         }, G = new WeakSet(), pe = function($ = !1) {
                             if (this.isEmpty())
@@ -12584,124 +12578,124 @@
                                 [Nt, Jt] = this.parentDimensions;
                             this.width = Tt / Nt, this.height = Ot / Jt, this.setAspectRatio(Tt, Ot);
                             const _t = this.translationX,
                                 Yt = this.translationY;
                             this.translationX = -vt[0], this.translationY = -vt[1], W(this, Bt, fe).call(this), W(this, N, ae).call(this), Z(this, y, Tt), Z(this, a, Ot), this.setDims(Tt, Ot);
                             const It = $ ? Lt / this.scaleFactor / 2 : 0;
                             this.translate(_t - this.translationX - It, Yt - this.translationY - It);
-                        }, L(At, ht), L(At, Ct), L(At, Gt), ee(At, "_defaultColor", null), ee(At, "_defaultOpacity", 1), ee(At, "_defaultThickness", 1), ee(At, "_type", "ink");
+                        }, I(At, ht), I(At, Ct), I(At, Gt), ee(At, "_defaultColor", null), ee(At, "_defaultOpacity", 1), ee(At, "_defaultThickness", 1), ee(At, "_type", "ink");
                         let B = At;
                         d.InkEditor = B;
                     },
                     /* 34 */
                     /***/
                     (dt, d, et) => {
-                        var B, F, g, O, I, x, v, A, u, _, w, ve, y, Se, c, Le, p, mi, T, Ki, U, Ji, E, bi, st, Oe, H, Qi;
+                        var B, F, g, L, O, T, v, A, u, b, E, ve, y, Se, l, Le, p, mi, x, Ki, U, Ji, C, bi, st, Oe, H, Qi;
                         Object.defineProperty(d, "__esModule", {
                             value: !0
                         }), d.StampEditor = void 0;
-                        var l = et(1),
+                        var c = et(1),
                             P = et(4),
                             rt = et(6),
                             X = et(29);
                         const gt = class gt extends P.AnnotationEditor {
                             constructor(S) {
                                 super({
                                     ...S,
                                     name: "stampEditor"
                                 });
-                                L(this, w);
-                                L(this, y);
-                                L(this, c);
-                                L(this, p);
-                                L(this, T);
-                                L(this, U);
-                                L(this, E);
-                                L(this, st);
-                                L(this, H);
-                                L(this, B, null);
-                                L(this, F, null);
-                                L(this, g, null);
-                                L(this, O, null);
-                                L(this, I, null);
-                                L(this, x, null);
-                                L(this, v, null);
-                                L(this, A, null);
-                                L(this, u, !1);
-                                L(this, _, !1);
-                                Z(this, O, S.bitmapUrl), Z(this, I, S.bitmapFile);
+                                I(this, E);
+                                I(this, y);
+                                I(this, l);
+                                I(this, p);
+                                I(this, x);
+                                I(this, U);
+                                I(this, C);
+                                I(this, st);
+                                I(this, H);
+                                I(this, B, null);
+                                I(this, F, null);
+                                I(this, g, null);
+                                I(this, L, null);
+                                I(this, O, null);
+                                I(this, T, null);
+                                I(this, v, null);
+                                I(this, A, null);
+                                I(this, u, !1);
+                                I(this, b, !1);
+                                Z(this, L, S.bitmapUrl), Z(this, O, S.bitmapFile);
                             }
                             static initialize(S) {
                                 P.AnnotationEditor.initialize(S);
                             }
                             static get supportedTypes() {
                                 const S = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"];
-                                return (0, l.shadow)(this, "supportedTypes", S.map((i) => `image/${i}`));
+                                return (0, c.shadow)(this, "supportedTypes", S.map((i) => `image/${i}`));
                             }
                             static get supportedTypesStr() {
-                                return (0, l.shadow)(this, "supportedTypesStr", this.supportedTypes.join(","));
+                                return (0, c.shadow)(this, "supportedTypesStr", this.supportedTypes.join(","));
                             }
                             static isHandlingMimeForPasting(S) {
                                 return this.supportedTypes.includes(S);
                             }
                             static paste(S, i) {
-                                i.pasteEditor(l.AnnotationEditorType.STAMP, {
+                                i.pasteEditor(c.AnnotationEditorType.STAMP, {
                                     bitmapFile: S.getAsFile()
                                 });
                             }
                             remove() {
                                 var S, i;
-                                t(this, F) && (Z(this, B, null), this._uiManager.imageManager.deleteId(t(this, F)), (S = t(this, x)) == null || S.remove(), Z(this, x, null), (i = t(this, v)) == null || i.disconnect(), Z(this, v, null)), super.remove();
+                                t(this, F) && (Z(this, B, null), this._uiManager.imageManager.deleteId(t(this, F)), (S = t(this, T)) == null || S.remove(), Z(this, T, null), (i = t(this, v)) == null || i.disconnect(), Z(this, v, null)), super.remove();
                             }
                             rebuild() {
                                 if (!this.parent) {
-                                    t(this, F) && W(this, c, Le).call(this);
+                                    t(this, F) && W(this, l, Le).call(this);
                                     return;
                                 }
-                                super.rebuild(), this.div !== null && (t(this, F) && W(this, c, Le).call(this), this.isAttachedToDOM || this.parent.add(this));
+                                super.rebuild(), this.div !== null && (t(this, F) && W(this, l, Le).call(this), this.isAttachedToDOM || this.parent.add(this));
                             }
                             onceAdded() {
                                 this._isDraggable = !0, this.div.focus();
                             }
                             isEmpty() {
-                                return !(t(this, g) || t(this, B) || t(this, O) || t(this, I));
+                                return !(t(this, g) || t(this, B) || t(this, L) || t(this, O));
                             }
                             get isResizable() {
                                 return !0;
                             }
                             render() {
                                 if (this.div)
                                     return this.div;
                                 let S, i;
-                                if (this.width && (S = this.x, i = this.y), super.render(), this.div.hidden = !0, t(this, B) ? W(this, p, mi).call(this) : W(this, c, Le).call(this), this.width) {
+                                if (this.width && (S = this.x, i = this.y), super.render(), this.div.hidden = !0, t(this, B) ? W(this, p, mi).call(this) : W(this, l, Le).call(this), this.width) {
                                     const [n, s] = this.parentDimensions;
                                     this.setAt(S * n, i * s, this.width * n, this.height * s);
                                 }
                                 return this.div;
                             }
                             static deserialize(S, i, n) {
                                 if (S instanceof X.StampAnnotationElement)
                                     return null;
                                 const s = super.deserialize(S, i, n),
                                     {
                                         rect: o,
                                         bitmapUrl: h,
-                                        bitmapId: b,
+                                        bitmapId: _,
                                         isSvg: M,
                                         accessibilityData: N
                                     } = S;
-                                b && n.imageManager.isValidId(b) ? Z(s, F, b) : Z(s, O, h), Z(s, u, M);
+                                _ && n.imageManager.isValidId(_) ? Z(s, F, _) : Z(s, L, h), Z(s, u, M);
                                 const [tt, Q] = s.pageDimensions;
                                 return s.width = (o[2] - o[0]) / tt, s.height = (o[3] - o[1]) / Q, N && (s.altTextData = N), s;
                             }
                             serialize(S = !1, i = null) {
                                 if (this.isEmpty())
                                     return null;
                                 const n = {
-                                    annotationType: l.AnnotationEditorType.STAMP,
+                                    annotationType: c.AnnotationEditorType.STAMP,
                                     bitmapId: t(this, F),
                                     pageIndex: this.pageIndex,
                                     rect: this.getRect(0, 0),
                                     rotation: this.rotation,
                                     isSvg: t(this, u),
                                     structTreeParentId: this._structTreeParentId
                                 };
@@ -12720,52 +12714,52 @@
                                 const h = t(this, u) ? (n.rect[2] - n.rect[0]) * (n.rect[3] - n.rect[1]) : null;
                                 if (!i.stamps.has(t(this, F)))
                                     i.stamps.set(t(this, F), {
                                         area: h,
                                         serialized: n
                                     }), n.bitmap = W(this, st, Oe).call(this, !1);
                                 else if (t(this, u)) {
-                                    const b = i.stamps.get(t(this, F));
-                                    h > b.area && (b.area = h, b.serialized.bitmap.close(), b.serialized.bitmap = W(this, st, Oe).call(this, !1));
+                                    const _ = i.stamps.get(t(this, F));
+                                    h > _.area && (_.area = h, _.serialized.bitmap.close(), _.serialized.bitmap = W(this, st, Oe).call(this, !1));
                                 }
                                 return n;
                             }
                         };
-                        B = new WeakMap(), F = new WeakMap(), g = new WeakMap(), O = new WeakMap(), I = new WeakMap(), x = new WeakMap(), v = new WeakMap(), A = new WeakMap(), u = new WeakMap(), _ = new WeakMap(), w = new WeakSet(), ve = function(S, i = !1) {
+                        B = new WeakMap(), F = new WeakMap(), g = new WeakMap(), L = new WeakMap(), O = new WeakMap(), T = new WeakMap(), v = new WeakMap(), A = new WeakMap(), u = new WeakMap(), b = new WeakMap(), E = new WeakSet(), ve = function(S, i = !1) {
                             if (!S) {
                                 this.remove();
                                 return;
                             }
                             Z(this, B, S.bitmap), i || (Z(this, F, S.id), Z(this, u, S.isSvg)), W(this, p, mi).call(this);
                         }, y = new WeakSet(), Se = function() {
-                            Z(this, g, null), this._uiManager.enableWaiting(!1), t(this, x) && this.div.focus();
-                        }, c = new WeakSet(), Le = function() {
+                            Z(this, g, null), this._uiManager.enableWaiting(!1), t(this, T) && this.div.focus();
+                        }, l = new WeakSet(), Le = function() {
                             if (t(this, F)) {
-                                this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(t(this, F)).then((i) => W(this, w, ve).call(this, i, !0)).finally(() => W(this, y, Se).call(this));
+                                this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(t(this, F)).then((i) => W(this, E, ve).call(this, i, !0)).finally(() => W(this, y, Se).call(this));
                                 return;
                             }
-                            if (t(this, O)) {
-                                const i = t(this, O);
-                                Z(this, O, null), this._uiManager.enableWaiting(!0), Z(this, g, this._uiManager.imageManager.getFromUrl(i).then((n) => W(this, w, ve).call(this, n)).finally(() => W(this, y, Se).call(this)));
+                            if (t(this, L)) {
+                                const i = t(this, L);
+                                Z(this, L, null), this._uiManager.enableWaiting(!0), Z(this, g, this._uiManager.imageManager.getFromUrl(i).then((n) => W(this, E, ve).call(this, n)).finally(() => W(this, y, Se).call(this)));
                                 return;
                             }
-                            if (t(this, I)) {
-                                const i = t(this, I);
-                                Z(this, I, null), this._uiManager.enableWaiting(!0), Z(this, g, this._uiManager.imageManager.getFromFile(i).then((n) => W(this, w, ve).call(this, n)).finally(() => W(this, y, Se).call(this)));
+                            if (t(this, O)) {
+                                const i = t(this, O);
+                                Z(this, O, null), this._uiManager.enableWaiting(!0), Z(this, g, this._uiManager.imageManager.getFromFile(i).then((n) => W(this, E, ve).call(this, n)).finally(() => W(this, y, Se).call(this)));
                                 return;
                             }
                             const S = document.createElement("input");
                             S.type = "file", S.accept = gt.supportedTypesStr, Z(this, g, new Promise((i) => {
                                 S.addEventListener("change", async () => {
                                     if (!S.files || S.files.length === 0)
                                         this.remove();
                                     else {
                                         this._uiManager.enableWaiting(!0);
                                         const n = await this._uiManager.imageManager.getFromFile(S.files[0]);
-                                        W(this, w, ve).call(this, n);
+                                        W(this, E, ve).call(this, n);
                                     }
                                     i();
                                 }), S.addEventListener("cancel", () => {
                                     this.remove(), i();
                                 });
                             }).finally(() => W(this, y, Se).call(this))), S.click();
                         }, p = new WeakSet(), mi = function() {
@@ -12779,52 +12773,52 @@
                             const [s, o] = this.pageDimensions, h = 0.75;
                             if (this.width)
                                 i = this.width * s, n = this.height * o;
                             else if (i > h * s || n > h * o) {
                                 const tt = Math.min(h * s / i, h * o / n);
                                 i *= tt, n *= tt;
                             }
-                            const [b, M] = this.parentDimensions;
-                            this.setDims(i * b / s, n * M / o), this._uiManager.enableWaiting(!1);
-                            const N = Z(this, x, document.createElement("canvas"));
-                            S.append(N), S.hidden = !1, W(this, E, bi).call(this, i, n), W(this, H, Qi).call(this), t(this, _) || (this.parent.addUndoableEditor(this), Z(this, _, !0)), this._uiManager._eventBus.dispatch("reporttelemetry", {
+                            const [_, M] = this.parentDimensions;
+                            this.setDims(i * _ / s, n * M / o), this._uiManager.enableWaiting(!1);
+                            const N = Z(this, T, document.createElement("canvas"));
+                            S.append(N), S.hidden = !1, W(this, C, bi).call(this, i, n), W(this, H, Qi).call(this), t(this, b) || (this.parent.addUndoableEditor(this), Z(this, b, !0)), this._uiManager._eventBus.dispatch("reporttelemetry", {
                                 source: this,
                                 details: {
                                     type: "editing",
                                     subtype: this.editorType,
                                     data: {
                                         action: "inserted_image"
                                     }
                                 }
                             }), this.addAltTextButton();
-                        }, T = new WeakSet(), Ki = function(S, i) {
+                        }, x = new WeakSet(), Ki = function(S, i) {
                             var h;
                             const [n, s] = this.parentDimensions;
                             this.width = S / n, this.height = i / s, this.setDims(S, i), (h = this._initialOptions) != null && h.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, t(this, A) !== null && clearTimeout(t(this, A)), Z(this, A, setTimeout(() => {
-                                Z(this, A, null), W(this, E, bi).call(this, S, i);
+                                Z(this, A, null), W(this, C, bi).call(this, S, i);
                             }, 200));
                         }, U = new WeakSet(), Ji = function(S, i) {
                             const {
                                 width: n,
                                 height: s
                             } = t(this, B);
                             let o = n,
                                 h = s,
-                                b = t(this, B);
+                                _ = t(this, B);
                             for (; o > 2 * S || h > 2 * i;) {
                                 const M = o,
                                     N = h;
                                 o > 2 * S && (o = o >= 16384 ? Math.floor(o / 2) - 1 : Math.ceil(o / 2)), h > 2 * i && (h = h >= 16384 ? Math.floor(h / 2) - 1 : Math.ceil(h / 2));
                                 const tt = new OffscreenCanvas(o, h);
-                                tt.getContext("2d").drawImage(b, 0, 0, M, N, 0, 0, o, h), b = tt.transferToImageBitmap();
+                                tt.getContext("2d").drawImage(_, 0, 0, M, N, 0, 0, o, h), _ = tt.transferToImageBitmap();
                             }
-                            return b;
-                        }, E = new WeakSet(), bi = function(S, i) {
+                            return _;
+                        }, C = new WeakSet(), bi = function(S, i) {
                             S = Math.ceil(S), i = Math.ceil(i);
-                            const n = t(this, x);
+                            const n = t(this, T);
                             if (!n || n.width === S && n.height === i)
                                 return;
                             n.width = S, n.height = i;
                             const s = t(this, u) ? t(this, B) : W(this, U, Ji).call(this, S, i),
                                 o = n.getContext("2d");
                             o.filter = this._uiManager.hcmFilter, o.drawImage(s, 0, 0, s.width, s.height, 0, 0, S, i);
                         }, st = new WeakSet(), Oe = function(S) {
@@ -12844,15 +12838,15 @@
                                 const [i, n] = this.pageDimensions, s = Math.round(this.width * i * rt.PixelsPerInch.PDF_TO_CSS_UNITS), o = Math.round(this.height * n * rt.PixelsPerInch.PDF_TO_CSS_UNITS), h = new OffscreenCanvas(s, o);
                                 return h.getContext("2d").drawImage(t(this, B), 0, 0, t(this, B).width, t(this, B).height, 0, 0, s, o), h.transferToImageBitmap();
                             }
                             return structuredClone(t(this, B));
                         }, H = new WeakSet(), Qi = function() {
                             Z(this, v, new ResizeObserver((S) => {
                                 const i = S[0].contentRect;
-                                i.width && i.height && W(this, T, Ki).call(this, i.width, i.height);
+                                i.width && i.height && W(this, x, Ki).call(this, i.width, i.height);
                             })), t(this, v).observe(this.div);
                         }, ee(gt, "_type", "stamp");
                         let pt = gt;
                         d.StampEditor = pt;
                     }
                     /******/
                 ],
@@ -12917,15 +12911,15 @@
                     enumerable: !0,
                     get: function() {
                         return d.CMapCompressionType;
                     }
                 }), Object.defineProperty(dt, "DOMSVGFactory", {
                     enumerable: !0,
                     get: function() {
-                        return l.DOMSVGFactory;
+                        return c.DOMSVGFactory;
                     }
                 }), Object.defineProperty(dt, "FeatureTest", {
                     enumerable: !0,
                     get: function() {
                         return d.FeatureTest;
                     }
                 }), Object.defineProperty(dt, "GlobalWorkerOptions", {
@@ -12957,15 +12951,15 @@
                     enumerable: !0,
                     get: function() {
                         return et.PDFDataRangeTransport;
                     }
                 }), Object.defineProperty(dt, "PDFDateString", {
                     enumerable: !0,
                     get: function() {
-                        return l.PDFDateString;
+                        return c.PDFDateString;
                     }
                 }), Object.defineProperty(dt, "PDFWorker", {
                     enumerable: !0,
                     get: function() {
                         return et.PDFWorker;
                     }
                 }), Object.defineProperty(dt, "PasswordResponses", {
@@ -12977,25 +12971,25 @@
                     enumerable: !0,
                     get: function() {
                         return d.PermissionFlag;
                     }
                 }), Object.defineProperty(dt, "PixelsPerInch", {
                     enumerable: !0,
                     get: function() {
-                        return l.PixelsPerInch;
+                        return c.PixelsPerInch;
                     }
                 }), Object.defineProperty(dt, "PromiseCapability", {
                     enumerable: !0,
                     get: function() {
                         return d.PromiseCapability;
                     }
                 }), Object.defineProperty(dt, "RenderingCancelledException", {
                     enumerable: !0,
                     get: function() {
-                        return l.RenderingCancelledException;
+                        return c.RenderingCancelledException;
                     }
                 }), Object.defineProperty(dt, "SVGGraphics", {
                     enumerable: !0,
                     get: function() {
                         return et.SVGGraphics;
                     }
                 }), Object.defineProperty(dt, "UnexpectedResponseException", {
@@ -13032,60 +13026,60 @@
                     enumerable: !0,
                     get: function() {
                         return et.getDocument;
                     }
                 }), Object.defineProperty(dt, "getFilenameFromUrl", {
                     enumerable: !0,
                     get: function() {
-                        return l.getFilenameFromUrl;
+                        return c.getFilenameFromUrl;
                     }
                 }), Object.defineProperty(dt, "getPdfFilenameFromUrl", {
                     enumerable: !0,
                     get: function() {
-                        return l.getPdfFilenameFromUrl;
+                        return c.getPdfFilenameFromUrl;
                     }
                 }), Object.defineProperty(dt, "getXfaPageViewport", {
                     enumerable: !0,
                     get: function() {
-                        return l.getXfaPageViewport;
+                        return c.getXfaPageViewport;
                     }
                 }), Object.defineProperty(dt, "isDataScheme", {
                     enumerable: !0,
                     get: function() {
-                        return l.isDataScheme;
+                        return c.isDataScheme;
                     }
                 }), Object.defineProperty(dt, "isPdfFile", {
                     enumerable: !0,
                     get: function() {
-                        return l.isPdfFile;
+                        return c.isPdfFile;
                     }
                 }), Object.defineProperty(dt, "loadScript", {
                     enumerable: !0,
                     get: function() {
-                        return l.loadScript;
+                        return c.loadScript;
                     }
                 }), Object.defineProperty(dt, "noContextMenu", {
                     enumerable: !0,
                     get: function() {
-                        return l.noContextMenu;
+                        return c.noContextMenu;
                     }
                 }), Object.defineProperty(dt, "normalizeUnicode", {
                     enumerable: !0,
                     get: function() {
                         return d.normalizeUnicode;
                     }
                 }), Object.defineProperty(dt, "renderTextLayer", {
                     enumerable: !0,
                     get: function() {
                         return P.renderTextLayer;
                     }
                 }), Object.defineProperty(dt, "setLayerDimensions", {
                     enumerable: !0,
                     get: function() {
-                        return l.setLayerDimensions;
+                        return c.setLayerDimensions;
                     }
                 }), Object.defineProperty(dt, "shadow", {
                     enumerable: !0,
                     get: function() {
                         return d.shadow;
                     }
                 }), Object.defineProperty(dt, "updateTextLayer", {
@@ -13097,28 +13091,27 @@
                     enumerable: !0,
                     get: function() {
                         return et.version;
                     }
                 });
                 var d = __w_pdfjs_require__(1),
                     et = __w_pdfjs_require__(2),
-                    l = __w_pdfjs_require__(6),
+                    c = __w_pdfjs_require__(6),
                     P = __w_pdfjs_require__(26),
                     rt = __w_pdfjs_require__(27),
                     X = __w_pdfjs_require__(5),
                     pt = __w_pdfjs_require__(29),
                     B = __w_pdfjs_require__(14),
                     F = __w_pdfjs_require__(32);
             })(), __webpack_exports__;
         })()
     ));
 })(pdf);
 var pdfExports = pdf.exports;
 const pdfjsLib = /* @__PURE__ */ getDefaultExportFromCjs(pdfExports),
-    Example_svelte_svelte_type_style_lang = "",
     {
         SvelteComponent,
         append,
         attr,
         binding_callbacks,
         detach,
         element,
@@ -13147,88 +13140,120 @@
             ), toggle_class(
                 d,
                 "selected",
                 /*selected*/
                 dt[1]
             );
         },
-        m(l, P) {
-            insert(l, d, P), append(d, et), dt[5](et);
+        m(c, P) {
+            insert(c, d, P), append(d, et), dt[5](et);
         },
-        p(l, [P]) {
+        p(c, [P]) {
             P & /*type*/
                 1 && toggle_class(
                     d,
                     "table",
                     /*type*/
-                    l[0] === "table"
+                    c[0] === "table"
                 ), P & /*type*/
                 1 && toggle_class(
                     d,
                     "gallery",
                     /*type*/
-                    l[0] === "gallery"
+                    c[0] === "gallery"
                 ), P & /*selected*/
                 2 && toggle_class(
                     d,
                     "selected",
                     /*selected*/
-                    l[1]
+                    c[1]
                 );
         },
         i: noop,
         o: noop,
-        d(l) {
-            l && detach(d), dt[5](null);
+        d(c) {
+            c && detach(d), dt[5](null);
         }
     };
 }
 
 function instance(dt, d, et) {
+    var c = this && this.__awaiter || function(T, v, A, u) {
+        function b(E) {
+            return E instanceof A ? E : new A(function(w) {
+                w(E);
+            });
+        }
+        return new(A || (A = Promise))(function(E, w) {
+            function y(k) {
+                try {
+                    l(u.next(k));
+                } catch (p) {
+                    w(p);
+                }
+            }
+
+            function a(k) {
+                try {
+                    l(u.throw(k));
+                } catch (p) {
+                    w(p);
+                }
+            }
+
+            function l(k) {
+                k.done ? E(k.value) : b(k.value).then(y, a);
+            }
+            l((u = u.apply(T, v || [])).next());
+        });
+    };
     let {
-        value: l
+        value: P
     } = d, {
-        samples_dir: P
+        samples_dir: rt
     } = d, {
-        type: rt
+        type: X
     } = d, {
-        selected: X = !1
+        selected: pt = !1
     } = d;
     pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdn.bootcss.com/pdf.js/3.11.174/pdf.worker.js";
-    let pt, B;
-    async function F(I) {
-        pt = await pdfjsLib.getDocument(I).promise, g();
+    let B, F;
+
+    function g(T) {
+        return c(this, void 0, void 0, function*() {
+            B = yield pdfjsLib.getDocument(T).promise, L();
+        });
     }
 
-    function g() {
-        pt.getPage(1).then((I) => {
-            const x = B.getContext("2d");
-            x.clearRect(0, 0, B.width, B.height);
-            const v = I.getViewport({
+    function L() {
+        B.getPage(1).then((T) => {
+            const v = F.getContext("2d");
+            v.clearRect(0, 0, F.width, F.height);
+            const A = T.getViewport({
                     scale: 0.2
                 }),
-                A = {
-                    canvasContext: x,
-                    viewport: v
+                u = {
+                    canvasContext: v,
+                    viewport: A
                 };
-            et(2, B.width = v.width, B), et(2, B.height = v.height, B), I.render(A);
+            et(2, F.width = A.width, F), et(2, F.height = A.height, F), T.render(u);
         });
     }
 
-    function O(I) {
-        binding_callbacks[I ? "unshift" : "push"](() => {
-            B = I, et(2, B);
+    function O(T) {
+        binding_callbacks[T ? "unshift" : "push"](() => {
+            F = T, et(2, F);
         });
     }
-    return dt.$$set = (I) => {
-        "value" in I && et(3, l = I.value), "samples_dir" in I && et(4, P = I.samples_dir), "type" in I && et(0, rt = I.type), "selected" in I && et(1, X = I.selected);
+    return dt.$$set = (T) => {
+        "value" in T && et(3, P = T.value), "samples_dir" in T && et(4, rt = T.samples_dir), "type" in T && et(0, X = T.type), "selected" in T && et(1, pt = T.selected);
     }, dt.$$.update = () => {
         dt.$$.dirty & /*samples_dir, value*/
-            24 && F(P + l);
-    }, [rt, X, B, l, P, O];
+            24 && g(rt + P);
+    }, [X, pt, F, P, rt, O];
 }
 class Example extends SvelteComponent {
     constructor(d) {
         super(), init(this, d, instance, create_fragment, safe_not_equal, {
             value: 3,
             samples_dir: 4,
             type: 0,
```

### Comparing `gradio_pdf-0.0.7/demo/app.py` & `gradio_pdf-0.0.8/demo/_app.py`

 * *Files identical despite different names*

### Comparing `gradio_pdf-0.0.7/demo/contract.pdf` & `gradio_pdf-0.0.8/demo/contract.pdf`

 * *Files identical despite different names*

### Comparing `gradio_pdf-0.0.7/demo/css.css` & `gradio_pdf-0.0.8/demo/css.css`

 * *Files identical despite different names*

### Comparing `gradio_pdf-0.0.7/demo/invoice_2.pdf` & `gradio_pdf-0.0.8/demo/invoice_2.pdf`

 * *Files identical despite different names*

### Comparing `gradio_pdf-0.0.7/demo/sample_invoice.pdf` & `gradio_pdf-0.0.8/demo/sample_invoice.pdf`

 * *Files identical despite different names*

### Comparing `gradio_pdf-0.0.7/demo/space.py` & `gradio_pdf-0.0.8/demo/app.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 
 import gradio as gr
-from app import demo as app
+from _app import demo as app
 import os
 
-_docs = {'PDF': {'description': 'A base class for defining methods that all input/output components should have.', 'members': {'__init__': {'value': {'type': 'typing.Any', 'default': 'None', 'description': None}, 'height': {'type': 'int | None', 'default': 'None', 'description': None}, 'label': {'type': 'str | None', 'default': 'None', 'description': None}, 'info': {'type': 'str | None', 'default': 'None', 'description': None}, 'show_label': {'type': 'bool | None', 'default': 'None', 'description': None}, 'container': {'type': 'bool', 'default': 'True', 'description': None}, 'scale': {'type': 'int | None', 'default': 'None', 'description': None}, 'min_width': {'type': 'int | None', 'default': 'None', 'description': None}, 'interactive': {'type': 'bool | None', 'default': 'None', 'description': None}, 'visible': {'type': 'bool', 'default': 'True', 'description': None}, 'elem_id': {'type': 'str | None', 'default': 'None', 'description': None}, 'elem_classes': {'type': 'list[str] | str | None', 'default': 'None', 'description': None}, 'render': {'type': 'bool', 'default': 'True', 'description': None}, 'load_fn': {'type': 'Callable[Ellipsis, typing.Any] | None', 'default': 'None', 'description': None}, 'every': {'type': 'float | None', 'default': 'None', 'description': None}}, 'postprocess': {'value': {'type': 'str | None', 'description': "The output data received by the component from the user's function in the backend."}}, 'preprocess': {'return': {'type': 'str', 'description': "The preprocessed input data sent to the user's function in the backend."}, 'value': None}}, 'events': {'change': {'type': None, 'default': None, 'description': ''}, 'upload': {'type': None, 'default': None, 'description': ''}}}, '__meta__': {'additional_interfaces': {}, 'user_fn_refs': {'PDF': []}}}
-
+_docs = {'PDF': {'description': 'A base class for defining methods that all input/output components should have.', 'members': {'__init__': {'value': {'type': 'Any', 'default': 'None', 'description': None}, 'height': {'type': 'int | None', 'default': 'None', 'description': None}, 'label': {'type': 'str | None', 'default': 'None', 'description': None}, 'info': {'type': 'str | None', 'default': 'None', 'description': None}, 'show_label': {'type': 'bool | None', 'default': 'None', 'description': None}, 'container': {'type': 'bool', 'default': 'True', 'description': None}, 'scale': {'type': 'int | None', 'default': 'None', 'description': None}, 'min_width': {'type': 'int | None', 'default': 'None', 'description': None}, 'interactive': {'type': 'bool | None', 'default': 'None', 'description': None}, 'visible': {'type': 'bool', 'default': 'True', 'description': None}, 'elem_id': {'type': 'str | None', 'default': 'None', 'description': None}, 'elem_classes': {'type': 'list[str] | str | None', 'default': 'None', 'description': None}, 'render': {'type': 'bool', 'default': 'True', 'description': None}, 'load_fn': {'type': 'Callable[..., Any] | None', 'default': 'None', 'description': None}, 'every': {'type': 'float | None', 'default': 'None', 'description': None}}, 'postprocess': {'value': {'type': 'str | None', 'description': None}}, 'preprocess': {'return': {'type': 'str', 'description': None}, 'value': None}}, 'events': {'change': {'type': None, 'default': None, 'description': ''}, 'upload': {'type': None, 'default': None, 'description': ''}}}, '__meta__': {'additional_interfaces': {}, 'user_fn_refs': {'PDF': []}}}
+    
 abs_path = os.path.join(os.path.dirname(__file__), "css.css")
 
 with gr.Blocks(
     css=abs_path,
     theme=gr.themes.Default(
         font_mono=[
             gr.themes.GoogleFont("Inconsolata"),
@@ -17,15 +17,15 @@
     ),
 ) as demo:
     gr.Markdown(
 """
 # `gradio_pdf`
 
 <div style="display: flex; gap: 7px;">
-<a href="https://pypi.org/project/gradio_pdf/" target="_blank"><img alt="PyPI - Version" src="https://img.shields.io/pypi/v/gradio_pdf"></a>  
+<a href="https://pypi.org/project/gradio_pdf/" target="_blank"><img alt="PyPI - Version" src="https://img.shields.io/pypi/v/gradio_pdf"></a> <a href="https://github.com/freddyaboulton/gradio-pdf/issues" target="_blank"><img alt="Static Badge" src="https://img.shields.io/badge/Issues-white?logo=github&logoColor=black"></a> <a href="https://huggingface.co/spaces/freddyaboulton/gradio_pdf/discussions" target="_blank"><img alt="Static Badge" src="https://img.shields.io/badge/%F0%9F%A4%97%20Discuss-%23097EFF?style=flat&logoColor=black"></a>
 </div>
 
 Easily display PDFs in Gradio
 """, elem_classes=["md-custom"], header_links=True)
     app.render()
     gr.Markdown(
 """
@@ -90,21 +90,20 @@
 
     gr.Markdown("""
 
 ### User function
 
 The impact on the users predict function varies depending on whether the component is used as an input or output for an event (or both).
 
-- When used as an Input, the component only impacts the input signature of the user function.
-- When used as an output, the component only impacts the return signature of the user function.
+- When used as an Input, the component only impacts the input signature of the user function. 
+- When used as an output, the component only impacts the return signature of the user function. 
 
 The code snippet below is accurate in cases where the component is used as both an input and an output.
 
-- **As input:** Is passed, the preprocessed input data sent to the user's function in the backend.
-- **As output:** Should return, the output data received by the component from the user's function in the backend.
+
 
  ```python
 def predict(
     value: str
 ) -> str | None:
     return value
 ```
@@ -127,15 +126,15 @@
                     el.innerHTML = el.innerHTML.replace(
                         new RegExp("\\b"+ref+"\\b", "g"),
                         `<a href="#h-${ref.toLowerCase()}">${ref}</a>`
                     );
                 })
             }
         })
-
+        
         Object.entries(refs).forEach(([key, refs]) => {
             if (refs.length > 0) {
                 const el = document.querySelector(`.${key}`);
                 if (!el) return;
                 refs.forEach(ref => {
                     el.innerHTML = el.innerHTML.replace(
                         new RegExp("\\b"+ref+"\\b", "g"),
```

### Comparing `gradio_pdf-0.0.7/frontend/Example.svelte` & `gradio_pdf-0.0.8/frontend/Example.svelte`

 * *Files identical despite different names*

### Comparing `gradio_pdf-0.0.7/frontend/Index.svelte` & `gradio_pdf-0.0.8/frontend/Index.svelte`

 * *Files 14% similar despite different names*

```diff
@@ -6,24 +6,25 @@
 		import { BaseButton } from "@gradio/button";
 		import { File } from "@gradio/icons";
 		import { StatusTracker } from "@gradio/statustracker";
 		import type { LoadingStatus } from "@gradio/statustracker";
 		import type { FileData } from "@gradio/client";
 		import { normalise_file } from "@gradio/client";
 		import { Upload, ModifyUpload } from "@gradio/upload";
-		import pdfjsLib from "pdfjs-dist";
+		import * as pdfjsLib from 'pdfjs-dist';
 
 		export let elem_id = "";
 		export let elem_classes: string[] = [];
 		export let visible = true;
 		export let value: FileData | null = null;
 		export let container = true;
 		export let scale: number | null = null;
 		export let root: string;
 		export let height: number | null = 500;
+        export let starting_page: number;
 		export let label: string;
 		export let proxy_url: string;
 		export let min_width: number | undefined = undefined;
 		export let loading_status: LoadingStatus;
 		export let gradio: Gradio<{
 			change: never;
 			upload: never;
@@ -31,30 +32,29 @@
 
 		pdfjsLib.GlobalWorkerOptions.workerSrc =  "https://cdn.bootcss.com/pdf.js/3.11.174/pdf.worker.js";
 
 		let _value = value;
 		let old_value = _value;
 		let pdfDoc;
 		let numPages = 1;
-		let currentPage = 1;
 		let canvasRef;
 
+		$: currentPage = Math.min(Math.max(starting_page, 1), numPages);
+
 		async function handle_clear() {
 			_value = null;
 			await tick();
 			gradio.dispatch("change");
-			currentPage = 1;
 		}
 
 		async function handle_upload({detail}: CustomEvent<FileData>): Promise<void> {
 			value = detail;
 			await tick();
 			gradio.dispatch("change");
 			gradio.dispatch("upload");
-			currentPage = 1;
 		}
 
 
 		async function get_doc(value: FileData) {
 			const loadingTask = pdfjsLib.getDocument(value.url);
 			pdfDoc = await loadingTask.promise;
 			numPages = pdfDoc.numPages;
```

### Comparing `gradio_pdf-0.0.7/frontend/PdfUploadText.svelte` & `gradio_pdf-0.0.8/frontend/PdfUploadText.svelte`

 * *Files identical despite different names*

### Comparing `gradio_pdf-0.0.7/frontend/package.json` & `gradio_pdf-0.0.8/frontend/package.json`

 * *Files 15% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9772727272727273%*

 * *Differences: {"'devDependencies'": "{'@gradio/preview': '0.9.0'}"}*

```diff
@@ -8,14 +8,15 @@
         "@gradio/statustracker": "0.3.0",
         "@gradio/upload": "0.3.2",
         "@gradio/utils": "0.2.0",
         "pdfjs-dist": "3.11.174"
     },
     "description": "Gradio UI packages",
     "devDependencies": {
+        "@gradio/preview": "0.9.0",
         "pdfjs-dist": "3.11.174"
     },
     "exports": {
         ".": "./Index.svelte",
         "./example": "./Example.svelte",
         "./package.json": "./package.json"
     },
```

